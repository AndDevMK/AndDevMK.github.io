<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>解读Flutter源码之setState - AndDevMK&#39;s android blog site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AndDevMK" /><meta name="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之StatefulWidget&amp;amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。 因此，本文将会深入分析se" /><meta name="keywords" content="Android, Java, Kotlin, C&#43;&#43;, C, Flutter, Dart, NDK" />


<meta name="baidu-site-verification" content="codeva-wQ7uOo4V09" />
<meta name="google-site-verification" content="yHzWB9BxTR74LiaUhuL5ncr89fnDYXiplTaPY565zqo" />


<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://anddevmk.github.io/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c11aaf02bef1025d6b0813ba5e1a8a8551aee15fa8f2bcea906d41b20bdf5c69.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">
<link rel="stylesheet" href="/css/codecopy.css">


<meta property="og:title" content="解读Flutter源码之setState" />
<meta property="og:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之StatefulWidget&amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。 因此，本文将会深入分析se" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anddevmk.github.io/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-21T11:28:31+08:00" />
<meta property="article:modified_time" content="2023-10-21T11:28:31+08:00" />
<meta itemprop="name" content="解读Flutter源码之setState">
<meta itemprop="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之StatefulWidget&amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。 因此，本文将会深入分析se"><meta itemprop="datePublished" content="2023-10-21T11:28:31+08:00" />
<meta itemprop="dateModified" content="2023-10-21T11:28:31+08:00" />
<meta itemprop="wordCount" content="10007">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解读Flutter源码之setState"/>
<meta name="twitter:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之StatefulWidget&amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。 因此，本文将会深入分析se"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AndDevMK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>

    
    <li class="mobile-menu-item-search">
      <div id="mobile_open_search" class="mobile_open_search">
        搜索
      </div>
    </li>

    
    <li class="mobile-menu-item-dark-mode">
      <div id="mobile_dark_mode_toggle" class="mobile_light_mode">
       
      </div>
    </li>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AndDevMK</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
    
    <div id="open_search" class="open_search">
      搜索
    </div>

    
    <div id="dark_mode_toggle" class="light_mode">

    </div>
  
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">解读Flutter源码之setState</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-10-21 </span>
        <div class="post-category">
            <a href="/categories/flutter/"> Flutter </a>
            </div>
          <span class="more-meta"> 约 10007 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一前言">一、前言</a></li>
    <li><a href="#二setstate方法的特性">二、<em>setState</em>方法的特性</a></li>
    <li><a href="#三分析setstate方法的源码">三、分析<em>setState</em>方法的源码</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><em>注：本文代码基于Flutter SDK 3.13.5</em></p>
</blockquote>
<h1 id="一前言">一、前言</h1>
<p>在上一文<a href="https://anddevmk.github.io/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><em>解读Flutter源码之StatefulWidget&amp;State的生命周期</em></a>中，笔者分析了<em>State</em>生命周期的相关方法，但碍于篇幅有限，对于<em>setState</em>方法只是进行了简单描述，还未进行深入分析。</p>
<p>因此，本文将会深入分析<em>setState</em>方法的源码。</p>
<h1 id="二setstate方法的特性">二、<em>setState</em>方法的特性</h1>
<p>在分析<em>setState</em>源码之前，一起再回顾下<em>setState</em>方法的一些特性：</p>
<p>1、<em>setState</em>方法用于通知框架该对象的内部状态已更改</p>
<p>2、<em>setState</em>方法提供的回调是同步调用，它不能返回<em>future</em>（也就是不能用<em>async</em>），因为如果是异步调用的话，就会不清楚状态何时实际被设置</p>
<p>3、通常，建议<em>setState</em>方法仅用于包装对状态的实际更改，而不是与更改相关的任何计算。例如，这里<em>build</em>方法使用的<code>_counter</code>被递增，然后更改被写入磁盘，但只有<code>_counter++</code>被包装在<em>setState</em>方法中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">_incrementCounter</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">Directory</span> <span class="n">directory</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">getApplicationDocumentsDirectory</span><span class="p">();</span> <span class="c1">// from path_provider package
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="kt">String</span> <span class="n">dirName</span> <span class="o">=</span> <span class="n">directory</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">await</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">dirName</span><span class="s1">/counter.txt&#39;</span><span class="p">).</span><span class="n">writeAsString</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">_counter</span><span class="s1">&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>4、在框架调用<em>dispose</em>之后调用<em>setState</em>方法是错误的，可以通过检查<em>mounted</em>属性是否为<em>true</em>来判断调用该方法是否合法。</p>
<h1 id="三分析setstate方法的源码">三、分析<em>setState</em>方法的源码</h1>
<p><em>setState</em>方法在<em>Flutter</em>中属于用得比较频繁的一个方法，当页面<em>UI</em>状态需要发生改变时，调用<em>setState</em>方法就可以触发页面<em>UI</em>状态的更新，那么<em>setState</em>方法是如何做到的，一起看下它的源码：</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/1.png" alt="" width="535">
<p>可以看到，在<em>setState</em>方法中，调用了外部传入的回调实例<em>fn</em>，类型为<em>VoidCallback</em>。疑问：为什么要将<em>fn</em>的返回值强转为<em>Object</em>？因为需要在断言中判断<em>fn</em>的返回值类型是否是<em>Future</em>，如果是则抛出异常。</p>
<p>然后执行了<code>_element</code>的<em>markNeedsBuild</em>方法，这里的<code>_element</code>指的是当前<em>State</em>实例所持有的<em>StatefulElement</em>引用。当然了，<em>StatefulElement</em>与<em>ComponentElement</em>内部都没有<em>markNeedsBuild</em>方法，所以执行的是<em>Element</em>的<em>markNeedsBuild</em>方法。</p>
<p>先看下<em>markNeedsBuild</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 将element标记为脏并将其添加到widgets的全局列表中以在下一帧中重建
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Marks the element as dirty and adds it to the global list of widgets to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuild in the next frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 由于在一帧中两次构建一个element是低效的，应用程序和widgets应该被构造为仅在帧开始之前的事件处理程序期间而不是在构建本身期间将widgets标记为脏。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Since it is inefficient to build an element twice in one frame,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// applications and widgets should be structured so as to only mark
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widgets dirty during event handlers before the frame begins, not during
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the build itself.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再看下<em>markNeedsBuild</em>方法的源码。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/2.png" alt="" width="535">
<p>在<em>markNeedsBuild</em>方法中，可以注意到有一个成员变量<em>dirty</em>，如果<em>dirty</em>为<em>true</em>则会<em>return</em>返回，之后的逻辑就不走了，先看下成员变量<em>dirty</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 如果element已被标记为需要重建，则返回true。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Returns true if the element has been marked as needing rebuilding.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当element首次创建且调用markNeedsBuild之后，该标志为true。该标志在performRebuild实现中重置为false。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The flag is true when the element is first created and after
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [markNeedsBuild] has been called. The flag is reset to false in the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [performRebuild] implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="kd">get</span> <span class="n">dirty</span> <span class="o">=&gt;</span> <span class="n">_dirty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">_dirty</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从成员变量<em>dirty</em>的注释中可以知道，如果一个<em>element</em>已被标记为需要重建，<code>_dirty</code>就会在<em>markNeedsBuild</em>方法中被标记为<em>true</em>，当执行<em>Element</em>的<em>performRebuild</em>方法时，<code>_dirty</code>会重置为<em>false</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 导致widget自行更新。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Cause the widget to update itself.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 进行适当的检查后由 [rebuild] 调用
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called by [rebuild] after the appropriate checks have been made.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 基本实现仅清除dirty标志。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The base implementation only clears the [dirty] flag.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">performRebuild</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_dirty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们知道，如果执行到了<em>performRebuild</em>方法，意味着即将执行<em>State</em>的<em>build</em>方法。因此，在执行<em>performRebuild</em>方法之前，连续调用多次<em>setState</em>方法，第二次之后其实都是多余的，因为此时<em>dirty</em>为<em>true</em>，<em>return</em>返回会忽略掉之后的逻辑，只有<em>dirty</em>为<em>false</em>时，调用<em>setState</em>方法才能触发页面<em>UI</em>状态的更新。</p>
<p><em>OK</em>，继续看下<code>owner!.scheduleBuildFor(this)</code>这行代码，执行的是<em>BuildOwner</em>的<em>scheduleBuildFor</em>方法，传入<em>this</em>，表示当前需要重建的<em>element</em>引用，那么这里的<em>owner</em>是在哪里创建的呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 管理该element生命周期的对象
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The object that manages the lifecycle of this element.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">BuildOwner</span><span class="o">?</span> <span class="kd">get</span> <span class="n">owner</span> <span class="o">=&gt;</span> <span class="n">_owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">BuildOwner</span><span class="o">?</span> <span class="n">_owner</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>BuildOwner</em>的由来，在之前文章讲<em>runApp</em>分析中有提到，它是在七大<em>binding</em>之一<em>WidgetsBinding</em>的<em>initInstances</em>方法中进行<em>BuildOwner</em>初始化，执行的是<em>BuildOwner</em>构造方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/3.png" alt="" width="535">
<p>然后在<em>WidgetsBinding</em>的<em>attachRootWidget</em>方法中，将<em>BuildOwner</em>实例作为参数传入了刚创建的<em>RenderObjectToWidgetAdapter</em>实例的<em>attachToRenderTree</em>方法中。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/4.png" alt="" width="535">
<p>然后在<em>RenderObjectToWidgetAdapter</em>的<em>attachToRenderTree</em>方法中执行了<em>createElement</em>方法，创建了<em>RenderObjectToWidgetElement</em>实例，接着执行了该<em>Element</em>实例的<em>assignOwner</em>方法，传入了<em>BuildOwner</em>引用。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/5.png" alt="" width="535">
<p>因为<em>RenderObjectToWidgetElement</em>没有<em>assignOwner</em>方法，所以执行的是混入的<em>RootElementMixin</em>的<em>assignOwner</em>方法，然后将传入的<em>BuildOwner</em>引用赋值给<em>RootElementMixin</em>的父类<em>Element</em>的成员变量<code>_owner</code>，那么<em>Element</em>就持有了最初创建的<em>BuildOwner</em>引用。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/6.png" alt="" width="535">
<p>那么为什么<em>Element</em>的子类可以获取到<em>BuildOwner</em>引用？那是因为在<em>Element</em>的<em>mount</em>方法中，对成员变量<code>_owner</code>进行了重新赋值，实际上就是将最初创建的<em>BuildOwner</em>引用一层一层往下传递给<em>Element</em>的子类了，所以<em>Element</em>的子类可以获取到<em>BuildOwner</em>引用。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/7.png" alt="" width="535">
<p><em>OK</em>，关于<em>BuildOwner</em>的由来已经知晓了，我们回到<code>owner!.scheduleBuildFor(this)</code>这行代码，这里执行了<em>BuildOwner</em>的<em>scheduleBuildFor</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/8.png" alt="" width="535">
<p>在<em>scheduleBuildFor</em>方法中，涉及了四个变量：<em>Element</em>的成员变量<code>_inDirtyList</code>、<em>BuildOwner</em>的成员变量<code>_dirtyElementsNeedsResorting</code>、<em>BuildOwner</em>的成员变量<code>_scheduledFlushDirtyElements</code>、<em>BuildOwner</em>的成员变量<code>_dirtyElements</code>以及<em>BuildOwner</em>的成员变量<em>onBuildScheduled</em>，下面一一分析这五个变量。</p>
<ul>
<li><em>Element</em>的成员变量<code>_inDirtyList</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">// 这是否在owner._dirtyElements中。这用于知道当element重新激活时我们是否应该将其添加回列表中。
</span></span></span><span class="line"><span class="cl"><span class="c1">// Whether this is in owner._dirtyElements. This is used to know whether we
</span></span></span><span class="line"><span class="cl"><span class="c1">// should be adding the element back into the list when it&#39;s reactivated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">_inDirtyList</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>scheduleBuildFor</em>方法中，如果该<em>Element</em>已经在<code>_dirtyElements</code>列表中，那么直接<em>return</em>返回，后续的逻辑不再执行；</p>
<p>在<em>scheduleBuildFor</em>方法中，如果该<em>Element</em>不在<code>_dirtyElements</code>列表中，那么将该<em>Element</em>放入到<code>_dirtyElements</code>列表中，然后将<code>_inDirtyList</code>赋值为<em>true</em>；</p>
<p>在<em>BuildOwner</em>的<em>buildScope</em>方法中，当处理完<code>_dirtyElements</code>列表中所有的<em>Element</em>后（所有<em>Element</em>均完成重建后），重新将所有<em>Element</em>的<code>_inDirtyList</code>赋值为false。</p>
<ul>
<li><em>BuildOwner</em>的成员变量<code>_dirtyElementsNeedsResorting</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 由于在构建过程中更多elements变脏，_dirtyElements是否需要再次排序
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Whether [_dirtyElements] need to be sorted again as a result of more
</span></span></span><span class="line"><span class="cl"><span class="c1">/// elements becoming dirty during the build.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这对于保留Element._sort定义的排序顺序是必要的
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This is necessary to preserve the sort order defined by [Element._sort].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当buildScope未主动重建widget树时，该字段设置为null。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This field is set to null when [buildScope] is not actively rebuilding
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the widget tree.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span><span class="o">?</span> <span class="n">_dirtyElementsNeedsResorting</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>scheduleBuildFor</em>方法中，如果该<em>Element</em>已经在<code>_dirtyElements</code>列表中，那么<code>_dirtyElementsNeedsResorting</code>赋值为<em>true</em>，表明<code>_dirtyElements</code>中的<em>Element</em>需要再次排序；</p>
<p>其它情况<code>_dirtyElementsNeedsResorting</code>为<em>false</em>，也就是不需要再次排序；</p>
<p>在<em>BuildOwner</em>的<em>buildScope</em>方法中，当处理完<code>_dirtyElements</code>列表中所有的<em>Element</em>后（所有<em>Element</em>均完成重建后），<code>_dirtyElementsNeedsResorting</code>会赋值为<em>null</em>。</p>
<ul>
<li><em>BuildOwner</em>的成员变量<code>_scheduledFlushDirtyElements</code></li>
</ul>
<p><code>_scheduledFlushDirtyElements</code>用来控制是否触发<code>onBuildScheduled</code>回调，相当于控制了是否执行<code>_dirtyElements</code>列表中所有<em>Element</em>的重建。</p>
<p>在<em>BuildOwner</em>的<em>buildScope</em>方法中，当处理完<code>_dirtyElements</code>列表中所有的<em>Element</em>后（所有<em>Element</em>均完成重建后），<code>_scheduledFlushDirtyElements</code>会赋值为<em>false</em>。</p>
<ul>
<li><em>BuildOwner</em>的成员变量<code>_dirtyElements</code></li>
</ul>
<p><code>_dirtyElements</code>列表用来添加需要重建的<em>Element</em>，后续会循环遍历该列表，执行所有<em>Element</em>的<em>rebuild</em>方法进行重建。</p>
<p>一般情况下，在你的<em>State</em>中点击按钮调用<em>setState</em>方法时，就会把当前<em>State</em>所持有的<em>Element</em>添加进该列表。但是，按钮<em>Widget</em>点击事件后面可能还有它自身的<em>setState</em>，这样就会产生多个需要重建的<em>Element</em>，它们也会被添加进该列表，所以就需要对<code>_dirtyElements</code>进行<em>depth</em>深度排序。</p>
<ul>
<li><em>BuildOwner</em>的成员变量<em>onBuildScheduled</em></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 当第一个可构建element被标记为脏时，在每个构建过程中调用
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called on each build pass when the first buildable element is marked
</span></span></span><span class="line"><span class="cl"><span class="c1">/// dirty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">VoidCallback</span><span class="o">?</span> <span class="n">onBuildScheduled</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>onBuildScheduled</code>回调的赋值是在<em>WidgetsBinding</em>的<em>initInstances</em>方法中，执行了<em>WidgetsBinding</em>的<code>_handleBuildScheduled</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/9.png" alt="" width="535">
<p>在<em>WidgetsBinding</em>的<code>_handleBuildScheduled</code>方法中，执行了<em>SchedulerBinding</em>的<em>ensureVisualUpdate</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/10.png" alt="" width="535">
<p>在<em>SchedulerBinding</em>的<em>ensureVisualUpdate</em>方法中，一开始<em>schedulerPhase</em>的状态为<em>SchedulerPhase.idle</em>，所以会执行<em>scheduleFrame</em>方法安排新帧，从注释可以知道，<em><strong>调用此方法可确保最终调用handleDrawFrame方法</strong></em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 如果该对象当前未生成帧，则使用 [scheduleFrame] 安排新帧。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Schedules a new frame using [scheduleFrame] if this object is not
</span></span></span><span class="line"><span class="cl"><span class="c1">/// currently producing a frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 调用此方法可确保最终调用 [handleDrawFrame]，除非它已经在进行中。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Calling this method ensures that [handleDrawFrame] will eventually be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// called, unless it&#39;s already in progress.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [schedulerPhase] 是 [SchedulerPhase.transientCallbacks] 或 [SchedulerPhase.midFrameMicrotasks]（因为在这种情况下已经准备好帧）
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 或 [SchedulerPhase.persistentCallbacks]（因为在这种情况下正在主动渲染帧），则这不起作用）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [schedulerPhase] 是 [SchedulerPhase.idle]（在帧之间）或 [SchedulerPhase.postFrameCallbacks]（在帧之后），它将调度一个帧。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This has no effect if [schedulerPhase] is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [SchedulerPhase.transientCallbacks] or [SchedulerPhase.midFrameMicrotasks]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// (because a frame is already being prepared in that case), or
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [SchedulerPhase.persistentCallbacks] (because a frame is actively being
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rendered in that case). It will schedule a frame if the [schedulerPhase]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// is [SchedulerPhase.idle] (in between frames) or
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [SchedulerPhase.postFrameCallbacks] (after a frame).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">ensureVisualUpdate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">schedulerPhase</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">SchedulerPhase</span><span class="p">.</span><span class="nl">idle:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">SchedulerPhase</span><span class="p">.</span><span class="nl">postFrameCallbacks:</span>
</span></span><span class="line"><span class="cl">      <span class="n">scheduleFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">SchedulerPhase</span><span class="p">.</span><span class="nl">transientCallbacks:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">SchedulerPhase</span><span class="p">.</span><span class="nl">midFrameMicrotasks:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">SchedulerPhase</span><span class="p">.</span><span class="nl">persistentCallbacks:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>SchedulerPhase</em>的几种状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// SchedulerBinding在SchedulerBinding.handleBeginFrame期间经历的各个阶段。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The various phases that a [SchedulerBinding] goes through during
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [SchedulerBinding.handleBeginFrame].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这是由SchedulerBinding.schedulerPhase公开的
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This is exposed by [SchedulerBinding.schedulerPhase].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该枚举的值按照与阶段发生的顺序相同的顺序排序，因此可以将它们的相对索引值相互比较
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The values of this enum are ordered in the same order as the phases occur,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// so their relative index values can be compared to each other.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">enum</span> <span class="n">SchedulerPhase</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// 没有正在处理的帧。任务（由SchedulerBinding.scheduleTask调度）、微任务（由scheduleMicrotask调度）、 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Timer回调、事件处理程序（例如，来自用户输入）和其它回调（例如，来自Future、 Stream等）可能正在执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// No frame is being processed. Tasks (scheduled by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [SchedulerBinding.scheduleTask]), microtasks (scheduled by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [scheduleMicrotask]), [Timer] callbacks, event handlers (e.g. from user
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// input), and other callbacks (e.g. from [Future]s, [Stream]s, and the like)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// may be executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">idle</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 瞬态回调（由SchedulerBinding.scheduleFrameCallback调度）当前正在执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The transient callbacks (scheduled by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [SchedulerBinding.scheduleFrameCallback]) are currently executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 通常，这些回调处理将对象更新为新的动画状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Typically, these callbacks handle updating objects to new animation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// states.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// See [SchedulerBinding.handleBeginFrame].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">transientCallbacks</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 当前正在执行处理瞬态回调期间安排的微任务。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Microtasks scheduled during the processing of transient callbacks are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// current executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 例如，这可能包括来自在transientCallbacks阶段解析的future的回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// This may include, for instance, callbacks from futures resolved during the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [transientCallbacks] phase.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">midFrameMicrotasks</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 持久回调（由SchedulerBinding.addPersistentFrameCallback调度）当前正在执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The persistent callbacks (scheduled by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [SchedulerBinding.addPersistentFrameCallback]) are currently executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 通常，这是构建/布局/绘制管道。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Typically, this is the build/layout/paint pipeline. See
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [WidgetsBinding.drawFrame] and [SchedulerBinding.handleDrawFrame].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">persistentCallbacks</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 帧后回调（由SchedulerBinding.addPostFrameCallback调度）当前正在执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The post-frame callbacks (scheduled by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [SchedulerBinding.addPostFrameCallback]) are currently executing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 通常，这些回调处理下一帧的清理和工作安排
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Typically, these callbacks handle cleanup and scheduling of work for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// next frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// See [SchedulerBinding.handleDrawFrame].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">postFrameCallbacks</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>继续看下<em>SchedulerBinding</em>的<em>scheduleFrame</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 如有必要，通过调用dart:ui.PlatformDispatcher.scheduleFrame来安排新帧。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// If necessary, schedules a new frame by calling
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [dart:ui.PlatformDispatcher.scheduleFrame].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 调用此函数后，引擎将（最终）调用handleBeginFrame 。 （此调用可能会延迟，例如，如果设备的屏幕关闭，则通常会延迟，直到屏幕打开并且应用程序可见。）
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在一个帧期间调用此函数会强制调度另一个帧，即使当前帧已尚未完成。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// After this is called, the engine will (eventually) call
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [handleBeginFrame]. (This call might be delayed, e.g. if the device&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1">/// screen is turned off it will typically be delayed until the screen is on
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and the application is visible.) Calling this during a frame forces
</span></span></span><span class="line"><span class="cl"><span class="c1">/// another frame to be scheduled, even if the current frame has not yet
</span></span></span><span class="line"><span class="cl"><span class="c1">/// completed.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当操作系统提供的“Vsync”信号触发时，调度帧就会得到服务。 “Vsync”信号或垂直同步信号在历史上与显示器刷新相关，当时硬件在显示器更新之间物理地垂直移动电子束。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 现代硬件的操作在某种程度上更加微妙和复杂，但概念性的“Vsync”刷新信号继续用于指示应用程序何时应更新其渲染
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Scheduled frames are serviced when triggered by a &#34;Vsync&#34; signal provided
</span></span></span><span class="line"><span class="cl"><span class="c1">/// by the operating system. The &#34;Vsync&#34; signal, or vertical synchronization
</span></span></span><span class="line"><span class="cl"><span class="c1">/// signal, was historically related to the display refresh, at a time when
</span></span></span><span class="line"><span class="cl"><span class="c1">/// hardware physically moved a beam of electrons vertically between updates
</span></span></span><span class="line"><span class="cl"><span class="c1">/// of the display. The operation of contemporary hardware is somewhat more
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subtle and complicated, but the conceptual &#34;Vsync&#34; refresh signal continue
</span></span></span><span class="line"><span class="cl"><span class="c1">/// to be used to indicate when applications should update their rendering.
</span></span></span></code></pre></td></tr></table>
</div>
</div><img title="" src="/img/flutter/解读Flutter源码之setState/11.png" alt="" width="535">
<p>在<em>SchedulerBinding</em>的<em>scheduleFrame</em>方法中，做了两件事情：</p>
<ul>
<li>调用<em>SchedulerBinding</em>的<em>ensureFrameCallbacksRegistered</em>方法</li>
</ul>
<p>注册了<em>PlatformDispatcher.onBeginFrame</em>与<em>PlatformDispatcher.onDrawFrame</em>两个回调。</p>
<p>当<em>Vsync</em>信号到来时，<em>onBeginFrame</em>与<em>onDrawFrame</em>都会从<em>Engine</em>层回调，其中<em>onBeginFrame</em>主要用来处理动画相关，<em>onDrawFrame</em>主要用来处理页面构建、布局、绘制相关。</p>
<p>本文只讲<em>onDrawFrame</em>回调后的逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 确保PlatformDispatcher.onBeginFrame和PlatformDispatcher.onDrawFrame的回调已注册。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Ensures callbacks for [PlatformDispatcher.onBeginFrame] and
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [PlatformDispatcher.onDrawFrame] are registered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ensureFrameCallbacksRegistered</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">platformDispatcher</span><span class="p">.</span><span class="n">onBeginFrame</span> <span class="o">??=</span> <span class="n">_handleBeginFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">platformDispatcher</span><span class="p">.</span><span class="n">onDrawFrame</span> <span class="o">??=</span> <span class="n">_handleDrawFrame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>执行<em>platformDispatcher.scheduleFrame()</em></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Requests that, at the next appropriate opportunity, the [onBeginFrame] and
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [onDrawFrame] callbacks be invoked.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">scheduleFrame</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_scheduleFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">Native</span><span class="o">&lt;</span><span class="n">Void</span> <span class="n">Function</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="nl">symbol:</span> <span class="s1">&#39;PlatformConfigurationNativeApi::ScheduleFrame&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">external</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">_scheduleFrame</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<em>platformDispatcher.scheduleFrame()</em> 调用的是<code>_scheduleFrame</code>方法，它已经是底层方法了，这里就不深入底层实现了，不过可以猜测，在<em>Android</em>中应该是调用了<em>Choreographer</em>注册了Vysnc信号监听，然后再回调给<em>Flutter</em>，具体留给你们去验证了。</p>
<p>等到<em>Engine</em>层处理完成，将会回调<em>Framework</em>层的<code>_drawFrame</code>方法，在<code>_drawFrame</code>方法中执行了<em>PlatformDispatcher</em>的<code>_drawFrame</code>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">// /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">pragma</span><span class="p">(</span><span class="s1">&#39;vm:entry-point&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_drawFrame</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">PlatformDispatcher</span><span class="p">.</span><span class="n">instance</span><span class="p">.</span><span class="n">_drawFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>PlatformDispatcher</em>的<code>_drawFrame</code>方法中，执行了<code>_invoke</code>方法，第一个参数传入的是<em>onDrawFrame</em>回调，这个就是之前讲过的<em>SchedulerBinding</em>的<em>ensureFrameCallbacksRegistered</em>方法中注册的回调。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">// Called from the engine, via hooks.dart
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">_drawFrame</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_invoke</span><span class="p">(</span><span class="n">onDrawFrame</span><span class="p">,</span> <span class="n">_onDrawFrameZone</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>来看下<code>_invoke</code>方法，执行了<em>callback()</em>，也就是调用了<em>onDrawFrame</em>的回调引用，那么就会触发<em>SchedulerBinding</em>的<code>_handleDrawFrame</code>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">// /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Invokes [callback] inside the given [zone].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">_invoke</span><span class="p">(</span><span class="kt">void</span> <span class="n">Function</span><span class="p">()</span><span class="o">?</span> <span class="n">callback</span><span class="p">,</span> <span class="n">Zone</span> <span class="n">zone</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">callback</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">identical</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">Zone</span><span class="p">.</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">callback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">zone</span><span class="p">.</span><span class="n">runGuarded</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>继续看<em>SchedulerBinding</em>的<code>_handleDrawFrame</code>方法，执行了<em>handleDrawFrame</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/12.png" alt="" width="535">
<p>先看下<em>handleDrawFrame</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 由引擎调用以产生新的帧
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called by the engine to produce a new frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法在handleBeginFrame之后立即调用。它调用addPersistentFrameCallback注册的所有回调（通常驱动渲染管道），然后调用addPostFrameCallback注册的回调
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This method is called immediately after [handleBeginFrame]. It calls all
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the callbacks registered by [addPersistentFrameCallback], which typically
</span></span></span><span class="line"><span class="cl"><span class="c1">/// drive the rendering pipeline, and then calls the callbacks registered by 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [addPostFrameCallback].
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>再看下<em>handleDrawFrame</em>方法的源码，它会遍历<code>_persistentCallbacks</code>这个<em>List</em>，然后执行<code>_invokeFrameCallback</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/13.png" alt="" width="535">
<p>在<code>_invokeFrameCallback</code>方法中，实际上是直接调用<em>callback</em>，也就是<code>_persistentCallbacks</code>中的<em>FrameCallback</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/14.png" alt="" width="535">
<p>那么这些<em>FrameCallback</em>是在哪里被添加进<code>_persistentCallbacks</code>这个<em>List</em>？</p>
<p>实际上是在<em>RendererBinding</em>的<em>initInstances</em>方法中执行了<em>addPersistentFrameCallback</em>方法添加进来，具体实现是<code>_handlePersistentFrameCallback</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/15.png" alt="" width="535">
<p>在<em>RendererBinding</em>的<code>_handlePersistentFrameCallback</code>方法中，执行了<em>drawFrame</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_handlePersistentFrameCallback</span><span class="p">(</span><span class="n">Duration</span> <span class="n">timeStamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">drawFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_scheduleMouseTrackerUpdate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>RendererBinding</em>的<em>drawFrame</em>方法被子类<em>WidgetsBinding</em>实现，在<em>WidgetsBinding</em>的<em>drawFrame</em>方法中，执行了<code>buildOwner!.buildScope(rootElement!);</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/16.png" alt="" width="535">
<p>在<em>BuildOwner</em>的<em>buildScope</em>方法中，对<code>_dirtyElements</code>进行了<em>depth</em>深度排序，遍历过程中从<em>depth</em>深度值为最小的<em>Element</em>开始处理，也就是优先处理越接近根布局的<em>Element</em>，然后执行<em>Element</em>的<em>rebuild</em>方法完成<em>Element</em>的重建。</p>
<img title="" src="/img/flutter/解读Flutter源码之setState/17.png" alt="" width="535">
<p>在<em>Element</em>的<em>rebuild</em>方法中，后续执行了<em>performRebuild</em>方法，这个方法我们太熟悉了，之后的过程就不讲解了，最终会触发<em>build</em>方法的执行，完成相关<em>Widget</em>的重建。</p>
<p>在<em>WidgetsBinding</em>的<em>drawFrame</em>方法中，执行了<code>buildOwner!.buildScope(rootElement!)</code>之后，就会执行<em>super.drawFrame()</em>，也就是调用父类<em>RendererBinding</em>的<em>drawFrame</em>方法。<em><strong>该方法意味着在重新构建渲染树之后就是真正的渲染开始了。</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 泵送渲染管道以生成帧
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Pump the rendering pipeline to generate a frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法由handleDrawFrame调用，当需要布局和绘制框架时，该方法本身由引擎自动调用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This method is called by [handleDrawFrame], which itself is called
</span></span></span><span class="line"><span class="cl"><span class="c1">/// automatically by the engine when it is time to lay out and paint a frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 每个帧由以下阶段组成：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Each frame consists of the following phases:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 1.动画阶段：在PlatformDispatcher.onBeginFrame中注册的handleBeginFrame方法按注册顺序调用在scheduleFrameCallback中注册的所有瞬态帧回调。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这包括驱动AnimationController对象的所有Ticker实例，这意味着所有活动的Animation对象此时都会勾选。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 1. The animation phase: The [handleBeginFrame] method, which is registered
</span></span></span><span class="line"><span class="cl"><span class="c1">/// with [PlatformDispatcher.onBeginFrame], invokes all the transient frame
</span></span></span><span class="line"><span class="cl"><span class="c1">/// callbacks registered with [scheduleFrameCallback], in registration order.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This includes all the [Ticker] instances that are driving
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [AnimationController] objects, which means all of the active [Animation]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// objects tick at this point.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 2. 微任务：[handleBeginFrame] 返回后，由瞬态帧回调调度的任何微任务都会开始运行。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这通常包括来自完成此帧的 [Ticker] 和 [AnimationController] 的 future 回调。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 2. Microtasks: After [handleBeginFrame] returns, any microtasks that got
</span></span></span><span class="line"><span class="cl"><span class="c1">/// scheduled by transient frame callbacks get to run. This typically includes
</span></span></span><span class="line"><span class="cl"><span class="c1">/// callbacks for futures from [Ticker]s and [AnimationController]s that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// completed this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在 [handleBeginFrame] 之后，调用在 [dart:ui.PlatformDispatcher.onDrawFrame] 中注册的 [handleDrawFrame]，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 它会调用所有持久帧回调，其中最值得注意的是这个方法 [drawFrame]，其执行过程如下如下：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// After [handleBeginFrame], [handleDrawFrame], which is registered with
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [dart:ui.PlatformDispatcher.onDrawFrame], is called, which invokes all the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// persistent frame callbacks, of which the most notable is this method,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [drawFrame], which proceeds as follows:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 3. 布局阶段：系统中所有脏的[RenderObject]都被布局
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 3. The layout phase: All the dirty [RenderObject]s in the system are laid
</span></span></span><span class="line"><span class="cl"><span class="c1">/// out (see [RenderObject.performLayout]). See [RenderObject.markNeedsLayout]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// for further details on marking an object dirty for layout.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 4. 合成位阶段：更新任何脏 [RenderObject] 对象上的合成位。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 4. The compositing bits phase: The compositing bits on any dirty
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [RenderObject] objects are updated. See
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [RenderObject.markNeedsCompositingBitsUpdate].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 5. 绘制阶段：系统中所有脏的[RenderObject]都被重新绘制（参见[RenderObject.paint]）。这会生成[图层]树。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 5. The paint phase: All the dirty [RenderObject]s in the system are
</span></span></span><span class="line"><span class="cl"><span class="c1">/// repainted (see [RenderObject.paint]). This generates the [Layer] tree. See
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [RenderObject.markNeedsPaint] for further details on marking an object
</span></span></span><span class="line"><span class="cl"><span class="c1">/// dirty for paint.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 6. 合成阶段：将图层树变成【场景】并发送到GPU。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 6. The compositing phase: The layer tree is turned into a [Scene] and
</span></span></span><span class="line"><span class="cl"><span class="c1">/// sent to the GPU.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 7. 语义阶段：系统中所有脏的[RenderObject]都更新了它们的语义。这会生成 [SemanticsNode] 树。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 7. The semantics phase: All the dirty [RenderObject]s in the system have
</span></span></span><span class="line"><span class="cl"><span class="c1">/// their semantics updated. This generates the [SemanticsNode] tree. See
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [RenderObject.markNeedsSemanticsUpdate] for further details on marking an
</span></span></span><span class="line"><span class="cl"><span class="c1">/// object dirty for semantics.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// For more details on steps 3-7, see [PipelineOwner].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 8. 最终确定阶段：[drawFrame] 返回后，[handleDrawFrame] 调用帧后回调（在 [addPostFrameCallback] 中注册）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 8. The finalization phase: After [drawFrame] returns, [handleDrawFrame]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// then invokes post-frame callbacks (registered with [addPostFrameCallback]).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 某些绑定（例如，[WidgetsBinding]）会向此列表添加额外的步骤（例如，请参阅[WidgetsBinding.drawFrame]）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Some bindings (for example, the [WidgetsBinding]) add extra steps to this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// list (for example, see [WidgetsBinding.drawFrame]).
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// When editing the above, also update widgets/binding.dart&#39;s copy.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">drawFrame</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushLayout</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushCompositingBits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushPaint</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">sendFramesToEngine</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">renderView</span><span class="p">.</span><span class="n">compositeFrame</span><span class="p">();</span> <span class="c1">// this sends the bits to the GPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushSemantics</span><span class="p">();</span> <span class="c1">// this also sends the semantics to the OS.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_firstFrameSent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">AndDevMK</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-10-21
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-qr-code.JPG">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay-qr-code.JPG">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bkey/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">解读Flutter源码之Key</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
            <span class="next-text nav-default">解读Flutter源码之StatefulWidget&amp;State的生命周期</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="AndDevMK/blog-utterances"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    
    <div id="search_mask" class="search_mask">
    <div class="search_modal">
        <div id="close_search" class="close_search">关闭</div>
        <div class="search_divider"></div>
        <input id="input_search_key" class="input_search_key" placeholder="请输入你要搜索的内容" tabindex="0">
        <ul id="search_list">
        </ul>
    </div>
</div>

<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>

    <footer id="footer" class="footer">
      

<div class="copyright">
  <span class="power-by">
    由 <a id="hexo-link" class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    
    <span id="run-time" class="run-time"></span> 
    <span class="heart"><i class="iconfont icon-heart"></i></span>
    &copy; 
    2023 - 
    2024&nbsp;
    <span>AndDevMK</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.11a4ba15caf2d921d57eaf6568c4ad21eafd5d2c001cbcb31693586c63f93005.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?6db179fb88e600cf326b0515a8aa1de3";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>




<script src="/js/codecopy.js"></script>



<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css"></link>
<script src="/js/dark.js"></script>


<script src="/js/site_runtime.js"></script>




</body>
</html>
