<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>解读Flutter源码之绘制Paint过程 - AndDevMK&#39;s android blog site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AndDevMK" /><meta name="description" content="注：本文代码基于Flutter SDK 3.13.5 一、与绘制相关的对象 Flutter中与绘制相关的对象有三个，分别是Canvas、Layer和Scene。 Canvas：封装了Flutter Skia各种绘制指令，比如画线drawLine、画圆drawCircle、画矩形drawRect等指令。 La" /><meta name="keywords" content="Android, Java, Kotlin, C&#43;&#43;, C, Flutter, Dart, NDK" />


<meta name="baidu-site-verification" content="codeva-wQ7uOo4V09" />
<meta name="google-site-verification" content="yHzWB9BxTR74LiaUhuL5ncr89fnDYXiplTaPY565zqo" />


<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BB%98%E5%88%B6paint%E8%BF%87%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c11aaf02bef1025d6b0813ba5e1a8a8551aee15fa8f2bcea906d41b20bdf5c69.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">
<link rel="stylesheet" href="/css/codecopy.css">


<meta property="og:title" content="解读Flutter源码之绘制Paint过程" />
<meta property="og:description" content="注：本文代码基于Flutter SDK 3.13.5 一、与绘制相关的对象 Flutter中与绘制相关的对象有三个，分别是Canvas、Layer和Scene。 Canvas：封装了Flutter Skia各种绘制指令，比如画线drawLine、画圆drawCircle、画矩形drawRect等指令。 La" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BB%98%E5%88%B6paint%E8%BF%87%E7%A8%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-12-05T08:00:00+08:00" />
<meta property="article:modified_time" content="2023-12-05T08:00:00+08:00" />
<meta itemprop="name" content="解读Flutter源码之绘制Paint过程">
<meta itemprop="description" content="注：本文代码基于Flutter SDK 3.13.5 一、与绘制相关的对象 Flutter中与绘制相关的对象有三个，分别是Canvas、Layer和Scene。 Canvas：封装了Flutter Skia各种绘制指令，比如画线drawLine、画圆drawCircle、画矩形drawRect等指令。 La"><meta itemprop="datePublished" content="2023-12-05T08:00:00+08:00" />
<meta itemprop="dateModified" content="2023-12-05T08:00:00+08:00" />
<meta itemprop="wordCount" content="11833">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解读Flutter源码之绘制Paint过程"/>
<meta name="twitter:description" content="注：本文代码基于Flutter SDK 3.13.5 一、与绘制相关的对象 Flutter中与绘制相关的对象有三个，分别是Canvas、Layer和Scene。 Canvas：封装了Flutter Skia各种绘制指令，比如画线drawLine、画圆drawCircle、画矩形drawRect等指令。 La"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AndDevMK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>

    
    <li class="mobile-menu-item-search">
      <div id="mobile_open_search" class="mobile_open_search">
        搜索
      </div>
    </li>

    
    <li class="mobile-menu-item-dark-mode">
      <div id="mobile_dark_mode_toggle" class="mobile_light_mode">
       
      </div>
    </li>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AndDevMK</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
    
    <div id="open_search" class="open_search">
      搜索
    </div>

    
    <div id="dark_mode_toggle" class="light_mode">

    </div>
  
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">解读Flutter源码之绘制Paint过程</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-12-05 </span>
        <div class="post-category">
            <a href="/categories/flutter/"> Flutter </a>
            </div>
          <span class="more-meta"> 约 11833 字 </span>
          <span class="more-meta"> 预计阅读 24 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一与绘制相关的对象">一、与绘制相关的对象</a>
      <ul>
        <li><a href="#11绘制产物picture">1.1、绘制产物<em>Picture</em></a></li>
        <li><a href="#12绘制产物的导出">1.2、绘制产物的导出</a></li>
        <li><a href="#13layer">1.3、<em>Layer</em></a>
          <ul>
            <li><a href="#131容器类layer">1.3.1、容器类<em>Layer</em></a></li>
            <li><a href="#132绘制类layer">1.3.2、绘制类<em>Layer</em></a></li>
            <li><a href="#133变换效果的实现方式">1.3.3、变换效果的实现方式</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#二示例演示">二、示例演示</a>
      <ul>
        <li><a href="#21绘制过程示例">2.1、绘制过程示例</a></li>
        <li><a href="#22总结绘制paint过程">2.2、总结绘制<em>Paint</em>过程</a></li>
      </ul>
    </li>
    <li><a href="#三源码分析">三、源码分析</a>
      <ul>
        <li><a href="#31组件树绘制流程">3.1、组件树绘制流程</a></li>
        <li><a href="#32创建新的picturelayer">3.2、创建新的<em>PictureLayer</em></a></li>
        <li><a href="#33pipelineowner的flushpaint方法">3.3、<em>PipelineOwner</em>的<em>flushPaint</em>方法</a></li>
        <li><a href="#34renderview的markneedsrepaint方法">3.4、<em>RenderView</em>的<em>markNeedsRepaint</em>方法</a></li>
        <li><a href="#35renderview的compositeframe方法">3.5、<em>RenderView</em>的<em>compositeFrame</em>方法</a></li>
      </ul>
    </li>
    <li><a href="#四参考文献">四、参考文献</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><em>注：本文代码基于Flutter SDK 3.13.5</em></p>
</blockquote>
<h1 id="一与绘制相关的对象">一、与绘制相关的对象</h1>
<p><em>Flutter</em>中与绘制相关的对象有三个，分别是<em>Canvas</em>、<em>Layer</em>和<em>Scene</em>。</p>
<ul>
<li>
<p><em><strong>Canvas</strong></em>：封装了<em>Flutter Skia</em>各种绘制指令，比如画线<em>drawLine</em>、画圆<em>drawCircle</em>、画矩形<em>drawRect</em>等指令。</p>
</li>
<li>
<p><em><strong>Layer</strong></em>：分为容器类<em>Layer</em>和绘制类<em>Layer</em>两种；暂时可以理解为是<em>绘制产物的载体</em>，比如调用<em>Canvas API</em>绘制后，相应的绘制产物<em>Picture</em>被保存在<em>PictureLayer.picture</em>对象中。</p>
</li>
<li>
<p><em><strong>Scene</strong></em>：屏幕上将要要显示的元素。在上屏前需要将<em>Layer</em>中保存的绘制产物<em>Picture</em>关联到<em>Scene</em>上。</p>
</li>
</ul>
<p>接下来重点分析绘制产物<em>Picture</em>以及<em>Layer</em>。</p>
<h2 id="11绘制产物picture">1.1、绘制产物<em>Picture</em></h2>
<p><em>PictureLayer</em>的绘制产物是<em>Picture</em>，关于<em>Picture</em>有两点需要阐明：</p>
<p>1、<em>Picture</em>实际上是一系列的图形绘制操作指令，这一点可以参考<em>Picture</em>类源码的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 表示一系列记录的图形操作的对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An object representing a sequence of recorded graphical operations.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 要创建Picture ，请使用PictureRecorder 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// To create a [Picture], use a [PictureRecorder].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 可以使用SceneBuilder通过SceneBuilder.addPicture方法将Picture放置在Scene中。也可以使用Canvas.drawPicture方法将Picture绘制到Canvas中。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the [SceneBuilder.addPicture] method. A [Picture] can also be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// drawn into a [Canvas], using the [Canvas.drawPicture] method.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Picture</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、<em>Picture</em>要显示在屏幕上，必然会经过光栅化（<em>光栅化是将图形数据转换为像素的过程，即将顶点数据转换为片元，每个片元对应帧缓冲区中的一像素</em>），随后<em>Flutter</em>会将光栅化后的位图信息缓存起来，也就是说同一个<em>Picture</em>对象，其绘制指令只会执行一次，执行完成后绘制的位图就会被缓存起来。</p>
<p>综合以上两点，可以看到<em>PictureLayer</em>的“绘制产物”一开始是一些“绘图指令”，当第一次绘制完成后，位图信息就会被缓存，绘制指令也就不会再被执行了，所以这时“绘制产物”就是位图了。</p>
<h2 id="12绘制产物的导出">1.2、绘制产物的导出</h2>
<p>既然<em>Picture</em>中保存的是绘制产物，那么它也应该能提供一个方法能将绘制产物导出，实际上，<em>Picture</em>有一个<em>toImage</em>方法，可以根据指定的大小导出<em>Image</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 将绘制产物导出为图片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">pictureToImage</span><span class="p">(</span><span class="n">PictureLayer</span> <span class="n">pictureLayer</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">Image</span> <span class="n">image</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">pictureLayer</span><span class="p">.</span><span class="n">picture</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="n">toImage</span><span class="p">(</span><span class="n">pictureLayer</span><span class="p">.</span><span class="n">canvasBounds</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">toInt</span><span class="p">(),</span> <span class="n">pictureLayer</span><span class="p">.</span><span class="n">canvasBounds</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">toInt</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">ByteData</span><span class="o">?</span> <span class="n">byteData</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">image</span><span class="p">.</span><span class="n">toByteData</span><span class="p">(</span><span class="nl">format:</span> <span class="n">ImageByteFormat</span><span class="p">.</span><span class="n">png</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 转化为Uint8List
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="n">Uint8List</span> <span class="n">uint8list</span> <span class="o">=</span> <span class="n">byteData</span><span class="o">!</span><span class="p">.</span><span class="n">buffer</span><span class="p">.</span><span class="n">asUint8List</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 需要导入库path_provider: ^2.1.1，以Android为例，这里存储到Context.getCacheDir目录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="kt">String</span> <span class="n">fileDir</span> <span class="o">=</span> <span class="p">(</span><span class="kd">await</span> <span class="n">getTemporaryDirectory</span><span class="p">()).</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">await</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">fileDir</span><span class="s1">/pictureToImage.png&#39;</span><span class="p">).</span><span class="n">writeAsBytes</span><span class="p">(</span><span class="n">uint8list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="13layer">1.3、<em>Layer</em></h2>
<p><em>Layer</em>作为绘制产物<em>Picture</em>的持有者，它的作用如下。</p>
<p>1、如果没有发生变化，可以在不同的<em>frame</em>之间复用绘制产物<em>Picture</em></p>
<p>2、划分绘制边界，缩小重绘范围</p>
<p><em>Layer</em>可以分为两类：容器类<em>Layer</em>与绘制类<em>Layer</em>，如图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/Layer继承关系.png" alt="" width="535">
<h3 id="131容器类layer">1.3.1、容器类<em>Layer</em></h3>
<p>例如<em>OffsetLayer</em>，它是根<em>Layer</em>，并且继承自<em>ContainerLayer</em>，而<em>ContainerLayer</em>继承自<em>Layer</em>类，可以将直接继承自<em>ContainerLayer</em>类的<em>Layer</em>称为容器类<em>Layer</em>，容器类<em>Layer</em>可以添加任意多个子<em>Layer</em>。</p>
<p>关于容器类<em>Layer</em>，它的作用以及具体的使用场景如下。</p>
<p>1、将组件树的绘制结构组成一棵树</p>
<blockquote>
<p><em>因为Flutter中的Widget是树状结构，那么相应的RenderObject对应的绘制结构也应该是树状结构，Flutter会根据一些“特定的规则”（后面解释）为组件树生成一棵Layer树，而容器类Layer就可以组成树状结构（父Layer可以包含任意多个子Layer，子Layer又可以包含任意多个子Layer）。</em></p>
</blockquote>
<p>2、可以对多个<em>Layer</em>整体应用一些变换效果</p>
<blockquote>
<p><em>容器类Layer可以对其子Layer整体做一些变换效果，比如剪裁效果（ClipRectLayer、ClipRRectLayer、ClipPathLayer）、过滤效果（ColorFilterLayer、ImageFilterLayer）、矩阵变换（TransformLayer）、透明变换（OpacityLayer）等。</em></p>
</blockquote>
<p>注意：虽然<em>ContainerLayer</em>并非抽象类，开发者可以直接创建<em>ContainerLayer</em>类的实例，但实际上很少会这么做。与此相反，在需要使用使用<em>ContainerLayer</em>时直接使用其子类即可。如果您确实不需要任何变换效果，那么就使用<em>OffsetLayer</em>，不用担心会有额外性能开销，它的底层实现（<em>Skia</em>）是非常高效的。</p>
<h3 id="132绘制类layer">1.3.2、绘制类<em>Layer</em></h3>
<p>下面重点介绍一下<em>PictureLayer</em>类，它是<em>Flutter</em>中最常用的一种绘制类<em>Layer</em>。</p>
<p>一般而言，最终显示在屏幕上的是位图信息，而位图信息正是由<em>Canvas API</em>绘制的。前面讲过，<em>Canvas API</em>的绘制产物是<em>Picture</em>对象，而当前版本的<em>Flutter</em>中只有<em>PictureLayer</em>才拥有<em>Picture</em>对象，换句话说，<em>Flutter</em>中通过<em>Canvas API</em>绘制自身及其子节点的组件的绘制结果最终会落在<em>PictureLayer</em>中。</p>
<h3 id="133变换效果的实现方式">1.3.3、变换效果的实现方式</h3>
<p>上面说过<em>ContainerLayer</em>可以对其子<em>Layer</em>整体进行一些变换，实际上，在大多数<em>UI</em>系统的<em>Canvas API</em>中也都有一些变换相关的方法，那么也就意味着一些变换效果既可以通过 <em>ContainerLayer</em>来实现，也可以通过<em>Canvas API</em>来实现。例如要实现平移变换，既可以使用 <em>OffsetLayer</em>，也可以直接使用<em>Canva.translate API</em>。既然如此，那选择实现方式的原则是什么呢？</p>
<p>容器类<em>Layer</em>的变换在底层是通过<em>Skia</em>来实现的，不需要<em>Canvas</em>来处理。具体的原理是，有变换功能的容器类<em>Layer</em>会对应一个<em>Skia</em>引擎中的<em>Layer</em>（有变换功能的容器类<em>Layer</em>在添加到<em>Scene</em>之前就会构建一个<em>Engine Layer</em>），为了和<em>Flutter Framework</em>中<em>Layer</em>区分，<em>Flutter</em>中将<em>Skia</em>的<em>Layer</em>称为<em>Engine Layer</em>。这里以<em>OffsetLayer</em>为例，看看它的<em>addToScene</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 存储为此层创建的引擎层，以便跨框架重用引擎资源以获得更好的应用程序性能。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该值可以传递给ui.SceneBuilder.addRetained以向引擎传达该层或其任何后代中没有任何变化。例如，本机引擎可以重用前一帧中渲染的纹理。例如，Web引擎可以重用为前一帧创建的HTML DOM节点。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该值可以作为oldLayer参数传递给“push”方法，以向引擎传达图层正在更新先前渲染的图层的信息。例如，Web引擎可以更新先前渲染的HTML DOM节点的属性，而不是创建新节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">visibleForTesting</span>
</span></span><span class="line"><span class="cl"><span class="n">ui</span><span class="p">.</span><span class="n">EngineLayer</span><span class="o">?</span> <span class="kd">get</span> <span class="n">engineLayer</span> <span class="o">=&gt;</span> <span class="n">_engineLayer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 重写此方法以将此层上传到引擎
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">addToScene</span><span class="p">(</span><span class="n">ui</span><span class="p">.</span><span class="n">SceneBuilder</span> <span class="n">builder</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Skia has a fast path for concatenating scale/translation only matrices.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Hence pushing a translation-only transform layer should be fast. For
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// retained rendering, we don&#39;t want to push the offset down to each leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// node. Otherwise, changing an offset layer on the very high level could
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// cascade the change to too many leaves.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 创建Engine Layer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">engineLayer</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">pushOffset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">offset</span><span class="p">.</span><span class="n">dx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">offset</span><span class="p">.</span><span class="n">dy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nl">oldLayer:</span> <span class="n">_engineLayer</span> <span class="o">as</span> <span class="n">ui</span><span class="p">.</span><span class="n">OffsetEngineLayer</span><span class="o">?</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">addChildrenToScene</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">builder</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>OffsetLayer</em>对其子节点整体做偏移变换的功能是<em>Skia</em>中实现支持的。<em>Skia</em>可以支持多层渲染，但并不是层越多越好，<em>Engine Layer</em>是会占用一定的资源，<em>Flutter</em>自带组件库中涉及到变换效果的都是优先使用<em>Canvas API</em>来实现，如果<em>Canvas API</em>实现起来非常困难或实现不了时才会用 <em>ContainerLayer</em>来实现。</p>
<p>那么有什么场景下变换效果通过<em>Canvas API</em>实现起来会非常困难，需要用<em>ContainerLayer</em>来实现？一个典型的场景是需要对组件树中的某个子树整体做变换，且子树中有多个<em>PictureLayer</em>时。这是因为一个<em>Canvas</em>往往对应一个<em>PictureLayer</em>，不同<em>Canvas</em>之间相互隔离的，只有子树中所有组件都通过同一个<em>Canvas</em>绘制时才能通过该<em>Canvas</em>对所有子节点进行整体变换，否则就只能通过<em>ContainerLayer</em>。</p>
<p>注意：<em>Canvas API</em>中也有名字包含<em>Layer</em>的相关方法，如<em>Canvas.saveLayer</em>，它和上面分析的<em>Layer</em>含义不同。<em>Canvas</em>对象中的<em>Layer</em>相关方法主要是提供一种在绘制过程中缓存中间绘制结果的手段，为了在绘制复杂对象时方便多个绘制元素之间分离绘制而设计的，您可以简单认为不管<em>Canvas</em>中创建多少个<em>Layer</em>，这些<em>Layer</em>都是在同一个<em>PictureLayer</em>上。</p>
<h1 id="二示例演示">二、示例演示</h1>
<h2 id="21绘制过程示例">2.1、绘制过程示例</h2>
<p>无论是通过<em>CustomPaint</em>还是自定义<em>RenderObject</em>，都是在<em>Flutter</em>的<em>Widget</em>框架模型下进行的绘制，实际上<em>Flutter</em>底层最终都会通过调用文章开头讲的与绘制相关的对象它们的<em>API</em>去完成绘制。既然如此，那么您也可以直接在<em>main</em>方法中调用这些与绘制相关的对象它们的<em>API</em>来完成绘制，下面演示一下直接在<em>main</em>方法中绘制一个椭圆形。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pictureToImage方法中使用了跨平台交互，所以需要先初始化ServicesBinding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建绘制记录器与Canvas
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PictureRecorder</span> <span class="n">recorder</span> <span class="o">=</span> <span class="n">PictureRecorder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Canvas</span> <span class="n">canvas</span> <span class="o">=</span> <span class="n">Canvas</span><span class="p">(</span><span class="n">recorder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 绘制背景
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">canvas</span><span class="p">.</span><span class="n">drawColor</span><span class="p">(</span><span class="n">Colors</span><span class="p">.</span><span class="n">white</span><span class="p">,</span> <span class="n">BlendMode</span><span class="p">.</span><span class="n">lighten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 绘制椭圆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">canvas</span><span class="p">.</span><span class="n">drawOval</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置椭圆的左上角原点以及宽高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">const</span> <span class="n">Rect</span><span class="p">.</span><span class="n">fromLTWH</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="m">300</span><span class="p">,</span> <span class="m">400</span><span class="p">),</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Paint</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">..</span><span class="n">color</span> <span class="o">=</span> <span class="n">Colors</span><span class="p">.</span><span class="n">blueAccent</span>
</span></span><span class="line"><span class="cl">      <span class="p">..</span><span class="n">isAntiAlias</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="p">..</span><span class="n">style</span> <span class="o">=</span> <span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
</span></span><span class="line"><span class="cl">      <span class="p">..</span><span class="n">strokeWidth</span> <span class="o">=</span> <span class="m">8</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 在指定位置区域绘制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 创建layer，将绘制的产物保存在layer中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="n">pictureLayer</span> <span class="o">=</span> <span class="n">PictureLayer</span><span class="p">(</span><span class="kd">const</span> <span class="n">Rect</span><span class="p">.</span><span class="n">fromLTWH</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">500</span><span class="p">,</span> <span class="m">600</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// recorder.endRecording()获取绘制产物
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pictureLayer</span><span class="p">.</span><span class="n">picture</span> <span class="o">=</span> <span class="n">recorder</span><span class="p">.</span><span class="n">endRecording</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 将给定Layer添加到该Layer的子列表的末尾，也就是将pictureLayer添加到OffsetLayer中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">var</span> <span class="n">rootLayer</span> <span class="o">=</span> <span class="n">OffsetLayer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">rootLayer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pictureLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 上屏，将绘制的内容显示在屏幕上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="n">SceneBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">SceneBuilder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">Scene</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">rootLayer</span><span class="p">.</span><span class="n">buildScene</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// PlatformDispatcher.instance.implicitView相当于window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PlatformDispatcher</span><span class="p">.</span><span class="n">instance</span><span class="p">.</span><span class="n">implicitView</span><span class="o">!</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 将绘制产物导出为图片，与最前面例子对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pictureToImage</span><span class="p">(</span><span class="n">pictureLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/Layer绘制演示.png" alt="" width="235">
<p>将绘制产物导出为图片，与最前面例子对应，如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/pictureToImage.png" alt="" width="235">
<h2 id="22总结绘制paint过程">2.2、总结绘制<em>Paint</em>过程</h2>
<p>1、构建一个<em>Canvas</em>用于绘制；同时还要创建一个绘制指令记录器<em>PictureRecorder</em>，因为绘制指令最终是要传递给<em>Skia</em>的，而<em>Canvas</em>可能会连续发起多条绘制指令，指令记录器用于收集<em>Canvas</em>在一段时间内所有的绘制指令，因此<em>Canvas</em>构造函数第一个参数必须传递一个<em>PictureRecorder</em>实例。</p>
<p>2、<em>Canvas</em>绘制完成后，通过<em>PictureRecorder</em>获取绘制产物，然后将其保存在<em>PictureLayer.picture</em>中。</p>
<p>3、构建<em>Scene</em>对象，将<em>Layer</em>的绘制产物和<em>Scene</em>关联起来。</p>
<p>4、最后上屏。调用<em>implicitView</em>的<em>render</em>方法将<em>Scene</em>上的绘制产物发送给<em>GPU</em>。</p>
<h1 id="三源码分析">三、源码分析</h1>
<p>为了便于描述，这里先定义一下“绘制边界节点”的概念：<em><strong>将isRepaintBoundary属性值为true的RenderObject节点称为绘制边界节点。</strong></em></p>
<p><em>Flutter</em>中自带了一个<em>RepaintBoundary</em>组件，它的功能其实就是向组件树中插入一个绘制边界节点。</p>
<h2 id="31组件树绘制流程">3.1、组件树绘制流程</h2>
<p><em>Flutter</em>绘制组件树的大致流程如下（不包括子树中需要层合成<em>Compositing</em>的情况）：</p>
<p><em>Flutter</em>第一次绘制时，会从上到下开始递归地绘制子节点，每当遇到一个边界节点，就会判断该边界节点的<em>Layer</em>属性（类型为<em>ContainerLayer</em>），如果<em>Layer</em>为空就会创建一个新的<em>OffsetLayer</em>并赋值给它；如果不为空就会直接使用它。然后再将该边界节点的<em>Layer</em>传递给子节点，接下来有两种情况：</p>
<ul>
<li>子节点是非边界节点并且需要绘制</li>
</ul>
<p>如果是第一次绘制，就会创建一个<em>Canvas</em>对象和一个<em>PictureLayer</em>，然后将它们绑定，后续调用<em>Canvas</em>绘制都会落到和其绑定的<em>PictureLayer</em>上，然后将这个<em>PictureLayer</em>加入到边界节点的<em>Layer</em>中。</p>
<p>如果不是第一次绘制，就会复用已有的<em>PictureLayer</em>和<em>Canvas</em>对象。</p>
<ul>
<li>子节点是边界节点</li>
</ul>
<p>如果子节点是边界节点，则对子节点递归上述过程。当子树的递归完成后，就要将子节点的<em>Layer</em>添加到父级<em>Layer</em>中。</p>
<p>最终整个流程执行完后就生成了一棵<em>Layer</em>树，下面通过一个例子来理解整个过程。下图左边是<em>Widget</em>树，右边是最终生成的<em>Layer</em>树，一起看一下生成过程。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/组件树绘制演示1.png" alt="" width="535">
<p>上图对应的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_runApp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kd">const</span> <span class="n">Row</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">crossAxisAlignment:</span> <span class="n">CrossAxisAlignment</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">mainAxisSize:</span> <span class="n">MainAxisSize</span><span class="p">.</span><span class="n">min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;Text1&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">blueAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;Text2&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">redAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">RepaintBoundary</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">child:</span> <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nl">mainAxisSize:</span> <span class="n">MainAxisSize</span><span class="p">.</span><span class="n">min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">              <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;Text3&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">greenAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;Text4&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">yellowAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">],</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_runApp</span><span class="p">(</span><span class="n">Widget</span> <span class="n">app</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">WidgetsBinding</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span><span class="p">.</span><span class="n">run</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binding</span><span class="p">.</span><span class="n">attachRootWidget</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">binding</span><span class="p">.</span><span class="n">scheduleWarmUpFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>1、<em>RenderView</em>是<em>Flutter</em>应用的根节点，绘制会从它开始，因为它是一个绘制边界节点，在第一次绘制时，会为它创建一个<em>OffsetLayer</em>，这里记为<em>OffsetLayer1</em>，接下<em>OffsetLayer1</em>会传递给<em>Row</em>。</p>
<p>2、由于<em>Row</em>是一个容器类组件且不需要绘制自身，那么接下来它会绘制自己的孩子，它有两个孩子，先绘制第一个孩子<em>Column1</em>，将<em>OffsetLayer1</em>传给<em>Column1</em>，而<em>Column1</em>也不需要绘制自身，那么它又会将<em>OffsetLayer1</em>传递给第一个子节点<em>Text1</em>。</p>
<p>3、<em>Text1</em>需要绘制文本，它会使用<em>OffsetLayer1</em>进行绘制，由于<em>OffsetLayer1</em>是第一次绘制，所以会新建一个<em>PictureLayer1</em>和一个<em>Canvas1</em>，然后将<em>Canvas1</em>和<em>PictureLayer1</em>绑定，接下来文本内容通过<em>Canvas1</em>对象绘制，<em>Text1</em>绘制完成后，<em>Column1</em>又会将 <em>OffsetLayer1</em>传给<em>Text2</em>。</p>
<p>4、<em>Text2</em>也需要使用<em>OffsetLayer1</em>绘制文本，但是此时<em>OffsetLayer1</em>已经不是第一次绘制，所以会复用之前的<em>Canvas1</em>和<em>PictureLayer1</em>，调用<em>Canvas1</em>来绘制文本。</p>
<p>5、<em>Column1</em>的子节点绘制完成后，<em>PictureLayer1</em>上承载的是<em>Text1</em>和<em>Text2</em>的绘制产物。</p>
<p>6、接下来<em>Row</em>完成了<em>Column1</em>的绘制后，开始绘制第二个子节点<em>RepaintBoundary</em>，<em>Row</em>会将<em>OffsetLayer1</em>传递给<em>RepaintBoundary</em>，由于它是一个绘制边界节点并且是第一次绘制，则会为它创建一个<em>OffsetLayer2</em>。接下来<em>RepaintBoundary</em>会将<em>OffsetLayer2</em>传递给<em>Column2</em>，和<em>Column1</em>不同的是，<em>Column2</em>会使用<em>OffsetLayer2</em>去绘制<em>Text3</em>和<em>Text4</em>，绘制过程同<em>Column1</em>，在此不再赘述。</p>
<p>7、当<em>RepaintBoundary</em>的子节点绘制完时，要将<em>RepaintBoundary</em>的<em>Layer</em>（ <em>OffsetLayer2</em>）添加到父级<em>Layer</em>（<em>OffsetLayer1</em>）中。</p>
<p>至此，整棵组件树绘制完成，生成了一棵右图所示的<em>Layer</em>树。需要说明的是<em>PictureLayer1</em>和 <em>OffsetLayer2</em>是兄弟关系，它们都是<em>OffsetLayer1</em>的孩子。</p>
<p>通过上面的例子至少可以发现一点：<em><strong>同一个Layer是可以多个组件共享的，比如Text1和Text2共享PictureLayer1</strong></em>。</p>
<p>但是<em>Layer</em>共享也会带来一个潜在的问题：比如<em>Text1</em>文本发生变化需要重绘时，也会连带着<em>Text2</em>重绘。也许您会有疑惑：不能每一个组件都绘制在一个单独的<em>Layer</em>上吗？这样还能避免相互干扰。</p>
<p>不可否认，您的疑惑是对的，但是究其原因还是为了节省资源，<em>Layer</em>太多时<em>Skia</em>会比较耗资源，所以这是一个权衡问题。</p>
<p><em>OK</em>，上面只是绘制的一般流程。一般情况下<em>Layer</em>树中的<em>ContainerLayer</em>和<em>PictureLayer</em>的数量与结构是和<em>Widget</em>树中的边界节点一一对应的。但是，如果<em>Widget</em>树中有子组件在绘制过程中添加了新的<em>Layer</em>，那么<em>Layer</em>会比边界节点数量多一些，这时就不是一一对应了。</p>
<p>另外，<em>Flutter</em>中很多拥有变换、剪裁、透明等效果的组件，它们的实现都会往<em>Layer</em>树中添加新的<em>Layer</em>，这个有机会再讲。</p>
<h2 id="32创建新的picturelayer">3.2、创建新的<em>PictureLayer</em></h2>
<p>现在接着上面例子，给<em>Row</em>添加第三个子节点<em>Text5</em>，如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/组件树绘制演示2.png" alt="" width="535">
<p>上图对应的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_runApp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kd">const</span> <span class="n">Row</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">crossAxisAlignment:</span> <span class="n">CrossAxisAlignment</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">mainAxisSize:</span> <span class="n">MainAxisSize</span><span class="p">.</span><span class="n">min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;Text1&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">blueAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;Text2&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">redAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">RepaintBoundary</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">child:</span> <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nl">mainAxisSize:</span> <span class="n">MainAxisSize</span><span class="p">.</span><span class="n">min</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">              <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;Text3&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">greenAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="s1">&#39;Text4&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">yellowAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">],</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;Text5&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="p">.</span><span class="n">ltr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">style:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">38</span><span class="p">,</span> <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">purpleAccent</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_runApp</span><span class="p">(</span><span class="n">Widget</span> <span class="n">app</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">WidgetsBinding</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span><span class="p">.</span><span class="n">run</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binding</span><span class="p">.</span><span class="n">attachRootWidget</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">binding</span><span class="p">.</span><span class="n">scheduleWarmUpFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么它的<em>Layer</em>树会变成什么样呢？首先<em>Row</em>会遍历子组件，执行<em>PaintingContext</em>的<em>paintChild</em>方法绘制子组件，下面看绘制<em>RepaintBoundary</em>的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">paintChild</span><span class="p">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 因为RepaintBoundary是绘制边界节点，所以isRepaintBoundary为true，执行这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">isRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将Canvas1绘制产物保存在PictureLayer1中，置空Layer以及Canvas
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stopRecordingIfNeeded</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 递归绘制RepaintBoundary的所有子组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_compositeChild</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If a render object was a repaint boundary but no longer is one, this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// is where the framework managed layer is automatically disposed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_wasRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="k">is</span> <span class="n">OffsetLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>PaintingContext</em>的 <em>_compositeChild</em> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_compositeChild</span><span class="p">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Create a layer for our child, and paint the child into it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_needsPaint</span> <span class="o">||</span> <span class="o">!</span><span class="n">child</span><span class="p">.</span><span class="n">_wasRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 递归绘制RepaintBoundary的所有子组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">repaintCompositedChild</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nl">debugAlsoPaintedParent:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_needsCompositedLayerUpdate</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">updateLayerProperties</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="k">is</span> <span class="n">OffsetLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将RepaintBoundary的Layer（OffsetLayer2）添加到父级Layer（OffsetLayer1）中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="n">OffsetLayer</span> <span class="n">childOffsetLayer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span><span class="o">!</span> <span class="o">as</span> <span class="n">OffsetLayer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">childOffsetLayer</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">appendLayer</span><span class="p">(</span><span class="n">childOffsetLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>继续看<em>PaintingContext</em>的<em>repaintCompositedChild</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="n">repaintCompositedChild</span><span class="p">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="p">{</span> <span class="kt">bool</span> <span class="n">debugAlsoPaintedParent</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_needsPaint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">_repaintCompositedChild</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nl">debugAlsoPaintedParent:</span> <span class="n">debugAlsoPaintedParent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="n">_repaintCompositedChild</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">debugAlsoPaintedParent</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">PaintingContext</span><span class="o">?</span> <span class="n">childContext</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">OffsetLayer</span><span class="o">?</span> <span class="n">childLayer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">as</span> <span class="n">OffsetLayer</span><span class="o">?</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 此处childLayer为null，由于RepaintBoundary是一个绘制边界节点，且是第一次绘制，则会为它创建一个OffsetLayer2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">childLayer</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">debugAlsoPaintedParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Not using the `layer` setter because the setter asserts that we not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// replace the layer for repaint boundaries. That assertion does not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// apply here because this is exactly the place designed to create a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// layer for repaint boundaries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">final</span> <span class="n">OffsetLayer</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">updateCompositedLayer</span><span class="p">(</span><span class="nl">oldLayer:</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">childLayer</span> <span class="o">=</span> <span class="n">layer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">childLayer</span><span class="p">.</span><span class="n">removeAllChildren</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">OffsetLayer</span> <span class="n">updatedLayer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">updateCompositedLayer</span><span class="p">(</span><span class="nl">oldLayer:</span> <span class="n">childLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">child</span><span class="p">.</span><span class="n">_needsCompositedLayerUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">childContext</span> <span class="o">??=</span> <span class="n">PaintingContext</span><span class="p">(</span><span class="n">childLayer</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">paintBounds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 递归绘制RepaintBoundary的所有子组件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="n">childContext</span><span class="p">,</span> <span class="n">Offset</span><span class="p">.</span><span class="n">zero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Double-check that the paint method did not replace the layer (the first
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// check is done in the [layer] setter itself).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">assert</span><span class="p">(</span><span class="n">identical</span><span class="p">(</span><span class="n">childLayer</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将Canvas2的绘制产物保存在PictureLayer2中，置空Layer以及Canvas
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">childContext</span><span class="p">.</span><span class="n">stopRecordingIfNeeded</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>Text5</em>是在<em>RepaintBoundary</em>绘制完成后才会绘制，因为<em>Row</em>循环第三次时才会遍历到它。</p>
<p>接下来在绘制<em>Text5</em>时，要先通过<em>context.canvas</em>来绘制，看下它的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">Canvas</span> <span class="kd">get</span> <span class="n">canvas</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 前面_canvas已经被置空，所以执行_startRecording方法，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">_canvas</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_startRecording</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_currentLayer</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">_canvas</span><span class="o">!</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_startRecording</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">_isRecording</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 新创建一个PictureLayer3与Canvas3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_currentLayer</span> <span class="o">=</span> <span class="n">PictureLayer</span><span class="p">(</span><span class="n">estimatedBounds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">_recorder</span> <span class="o">=</span> <span class="n">ui</span><span class="p">.</span><span class="n">PictureRecorder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_canvas</span> <span class="o">=</span> <span class="n">Canvas</span><span class="p">(</span><span class="n">_recorder</span><span class="o">!</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 添加到OffsetLayer1中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_containerLayer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">_currentLayer</span><span class="o">!</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，<em>Text5</em>的绘制会落在<em>PictureLayer3</em>上，所以最终的 <em>Layer</em>树如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/组件树绘制演示3.png" alt="" width="535">
<p>总结：<em><strong>父节点在绘制子节点时，如果子节点是绘制边界节点，则在绘制完该子节点后会生成一个新的PictureLayer，后续其它子节点会在新的PictureLayer上绘制。</strong></em></p>
<p>对于上面的例子，为什么不能复用之前的<em>PictureLayer1</em>？如果这样做，在层叠布局（例如<em>Stack</em>）的场景中就会有问题。下面看一个例子，如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/组件树绘制演示4.png" alt="" width="535">
<p>左边是一个<em>Stack</em>布局，右边是对应的<em>Layer</em>树结构；大家都知道<em>Stack</em>布局中会根据其子组件的加入顺序进行层叠绘制，最先加入的孩子在最底层，最后加入的孩子在最上层。可以设想一下如果绘制 <em>Child3</em>时复用了<em>PictureLayer1</em>，则会导致<em>Child3</em>被<em>Child2</em>遮住，这显然不符合预期，但如果新建一个<em>PictureLayer</em>在添加到<em>OffsetLayer</em>最后面，则可以获得正确的结果。</p>
<p>还有一种可能，如果<em>Child2</em>的父节点不是<em>RepaintBoundary</em>，那么<em>Child3</em>和<em>Child1</em>还是不可以共享同一个<em>PictureLayer</em>，原因如下：</p>
<p>如果<em>Child2</em>的父组件改为一个自定义的组件，在这个自定义的组件中您希望对子节点在渲染时进行一些矩阵变化，为了实现这个功能，您创建一个新的<em>TransformLayer</em>并指定变换规则，然后把它传递给 <em>Child2</em>，<em>Child2</em>会绘制完成后需要将<em>TransformLayer</em>添加到<em>Layer</em>树中（不添加到<em>Layer</em>树中是不会显示的），则组件树和最终的<em>Layer</em>树结构如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之绘制Paint过程/组件树绘制演示5.png" alt="" width="535">
<p>可以发现这种情况本质上和上面使用<em>RepaintBoudary</em>的情况是一样的，<em>Child3</em>仍然不应该复用 <em>PictureLayer1</em>，那么现在可以总结一个一般规律了：<em><strong>只要一个组件需要往Layer树中添加新的 Layer，那么就必须也要结束掉当前PictureLayer的绘制。</strong></em></p>
<h2 id="33pipelineowner的flushpaint方法">3.3、<em>PipelineOwner</em>的<em>flushPaint</em>方法</h2>
<p>不管是<em>runApp</em>方法或者<em>setState</em>方法，都会执行<em>RendererBinding</em>的<em>drawFrame</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">drawFrame</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushLayout</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushCompositingBits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 触发绘制流程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushPaint</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">sendFramesToEngine</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发送二进制数据给GPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">renderView</span><span class="p">.</span><span class="n">compositeFrame</span><span class="p">();</span> <span class="c1">// this sends the bits to the GPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pipelineOwner</span><span class="p">.</span><span class="n">flushSemantics</span><span class="p">();</span> <span class="c1">// this also sends the semantics to the OS.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_firstFrameSent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>PipelineOwner</em>的<em>flushPaint</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">// nodesNeedingPaint中的节点的isRepaintBoundary必然为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">RenderObject</span><span class="o">&gt;</span> <span class="n">_nodesNeedingPaint</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">RenderObject</span><span class="o">&gt;</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">flushPaint</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">RenderObject</span><span class="o">&gt;</span> <span class="n">dirtyNodes</span> <span class="o">=</span> <span class="n">_nodesNeedingPaint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_nodesNeedingPaint</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">RenderObject</span><span class="o">&gt;</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 对脏节点进行深度优先排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Sort the dirty nodes in reverse order (deepest first).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kd">final</span> <span class="n">RenderObject</span> <span class="n">node</span> <span class="k">in</span> <span class="n">dirtyNodes</span><span class="p">..</span><span class="n">sort</span><span class="p">((</span><span class="n">RenderObject</span> <span class="n">a</span><span class="p">,</span> <span class="n">RenderObject</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">depth</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">assert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">((</span><span class="n">node</span><span class="p">.</span><span class="n">_needsPaint</span> <span class="o">||</span> <span class="n">node</span><span class="p">.</span><span class="n">_needsCompositedLayerUpdate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span><span class="o">!</span><span class="p">.</span><span class="n">attached</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">assert</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">isRepaintBoundary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">_needsPaint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 重新绘制给定的渲染对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 渲染对象必须附加到PipelineOwner，必须具有合成层，并且必须需要绘制。渲染对象的图层（如果有）以及子树中不需要重新绘制的任何图层都会被重新使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">PaintingContext</span><span class="p">.</span><span class="n">repaintCompositedChild</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 更新child的合成层而不重新绘制其子级。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 渲染对象必须附加到PipelineOwner，必须具有合成层，并且必须需要合成层更新但不需要绘制。渲染对象的图层被重新使用，并且其子对象的图层都不会被重新绘制或更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">PaintingContext</span><span class="p">.</span><span class="n">updateLayerProperties</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 当flushPaint()试图让我们绘制但我们的图层被分离时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// 为了确保我们的子树在最终重新连接时被重新绘制，即使在某些祖先层本身从未被标记为脏的情况下，我们也必须将整个分离的子树标记为脏并需要重新绘制。这样，我们最终将被重新绘制。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">node</span><span class="p">.</span><span class="n">_skippedPaintingOnLayer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>PaintingContext</em>的<em>repaintCompositedChild</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="n">repaintCompositedChild</span><span class="p">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="p">{</span> <span class="kt">bool</span> <span class="n">debugAlsoPaintedParent</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_needsPaint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">_repaintCompositedChild</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nl">debugAlsoPaintedParent:</span> <span class="n">debugAlsoPaintedParent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>PaintingContext</em>的 <em>_repaintCompositedChild</em> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kt">void</span> <span class="n">_repaintCompositedChild</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">debugAlsoPaintedParent</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 此处childContext参数没有传入，所以为null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PaintingContext</span><span class="o">?</span> <span class="n">childContext</span><span class="p">,</span>    
</span></span><span class="line"><span class="cl"><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">OffsetLayer</span><span class="o">?</span> <span class="n">childLayer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">as</span> <span class="n">OffsetLayer</span><span class="o">?</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果边界节点没有Layer，则为其创建一个OffsetLayer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">childLayer</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Not using the `layer` setter because the setter asserts that we not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// replace the layer for repaint boundaries. That assertion does not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// apply here because this is exactly the place designed to create a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// layer for repaint boundaries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">final</span> <span class="n">OffsetLayer</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">updateCompositedLayer</span><span class="p">(</span><span class="nl">oldLayer:</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">childLayer</span> <span class="o">=</span> <span class="n">layer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果边界节点已经有Layer了（之前绘制时已经为其创建过Layer了），则清空其子节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">childLayer</span><span class="p">.</span><span class="n">removeAllChildren</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">OffsetLayer</span> <span class="n">updatedLayer</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">updateCompositedLayer</span><span class="p">(</span><span class="nl">oldLayer:</span> <span class="n">childLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">child</span><span class="p">.</span><span class="n">_needsCompositedLayerUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 通过其Layer构建一个paintingContext，之后Layer便和childContext绑定，这意味着通过同一个paintingContext的canvas绘制的产物属于同一个Layer。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">childContext</span> <span class="o">??=</span> <span class="n">PaintingContext</span><span class="p">(</span><span class="n">childLayer</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">paintBounds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 调用节点的paint方法，绘制子节点树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="n">childContext</span><span class="p">,</span> <span class="n">Offset</span><span class="p">.</span><span class="n">zero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Double-check that the paint method did not replace the layer (the first
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// check is done in the [layer] setter itself).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">assert</span><span class="p">(</span><span class="n">identical</span><span class="p">(</span><span class="n">childLayer</span><span class="p">,</span> <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将Canvas的绘制产物保存在PictureLayer中，置空Layer以及Canvas
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">childContext</span><span class="p">.</span><span class="n">stopRecordingIfNeeded</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>RenderObject</em>的 <em>_paintWithContext</em> 方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_paintWithContext</span><span class="p">(</span><span class="n">PaintingContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果我们仍然需要布局，那么这意味着我们在布局阶段被跳过，因此不需要绘制。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 我们可能还不知道（也就是说，我们的层可能还没有分离），因为在布局中跳过我们的同一个节点在树中位于我们之上（显然），因此可能还没有机会绘制（因为树以相反的顺序绘制）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 特别是如果它们具有不同的层，就会发生这种情况，因为我们之间存在重绘边界。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If we still need layout, then that means that we were skipped in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// layout phase and therefore don&#39;t need painting. We might not know that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// yet (that is, our layer might not have been detached yet), because the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// same node that skipped us in layout is above us in the tree (obviously)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and therefore may not have had a chance to paint yet (since the tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// paints in reverse order). In particular this will happen if they have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a different layer, because there&#39;s a repaint boundary between us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">_needsLayout</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">_needsPaint</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_needsCompositedLayerUpdate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_wasRepaintBoundary</span> <span class="o">=</span> <span class="n">isRepaintBoundary</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">paint</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">_needsLayout</span><span class="p">);</span> <span class="c1">// check that the paint() method didn&#39;t mark us dirty again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">_needsPaint</span><span class="p">);</span> <span class="c1">// check that the paint() method didn&#39;t mark us dirty again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_reportException</span><span class="p">(</span><span class="s1">&#39;paint&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">stack</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>RenderObject</em>的<em>paint</em>方法，这个方法由子类实现。如果是容器组件，要绘制孩子和自身（当然，容器自身也可能没有绘制逻辑，这种情况只绘制孩子即可，比如<em>Center</em>组件），如果不是容器类组件，则绘制自身，比如<em>Image</em>组件。下面以<em>Center</em>组件为例，看下它<em>RenderShiftedBox</em>的<em>paint</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">paint</span><span class="p">(</span><span class="n">PaintingContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">RenderBox</span><span class="o">?</span> <span class="n">child</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="n">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">BoxParentData</span> <span class="n">childParentData</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">parentData</span><span class="o">!</span> <span class="o">as</span> <span class="n">BoxParentData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 绘制子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">context</span><span class="p">.</span><span class="n">paintChild</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">childParentData</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>PaintingContext</em>的<em>paintChild</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">paintChild</span><span class="p">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="p">,</span> <span class="n">Offset</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果该节点是边界节点，则执行_compositeChild方法，内部会递归绘制子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">isRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stopRecordingIfNeeded</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_compositeChild</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果渲染对象是重绘边界但不再是重绘边界，则框架管理层会自动处理该边界。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If a render object was a repaint boundary but no longer is one, this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// is where the framework managed layer is automatically disposed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_wasRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="k">is</span> <span class="n">OffsetLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果不是边界节点直接绘制自己
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">child</span><span class="p">.</span><span class="n">_paintWithContext</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照上面的流程执行完毕后，最终所有边界节点的<em>Layer</em>就会相连起来组成一棵<em>Layer</em>树。</p>
<h2 id="34renderview的markneedsrepaint方法">3.4、<em>RenderView</em>的<em>markNeedsRepaint</em>方法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">markNeedsPaint</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">_debugDisposed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">owner</span><span class="o">!</span><span class="p">.</span><span class="n">debugDoingPaint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">_needsPaint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">_needsPaint</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果这之前不是重绘边界，那么它将没有我们可以从中绘制的图层。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// If this was not previously a repaint boundary it will not have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a layer we can paint from.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">isRepaintBoundary</span> <span class="o">&amp;&amp;</span> <span class="n">_wasRepaintBoundary</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果我们总是有自己的Layer，那么我们可以重新绘制自己，而不涉及任何其它节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we always have our own layer, then we can just repaint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ourselves without involving any other nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">assert</span><span class="p">(</span><span class="n">_layerHandle</span><span class="p">.</span><span class="n">layer</span> <span class="k">is</span> <span class="n">OffsetLayer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 将当前节点添加到需要重新绘制的列表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">owner</span><span class="o">!</span><span class="p">.</span><span class="n">_nodesNeedingPaint</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 请求新的frame，该方法最终会调用scheduleFrame()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">owner</span><span class="o">!</span><span class="p">.</span><span class="n">requestVisualUpdate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="k">is</span> <span class="n">RenderObject</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 若不是边界节点且存在父节点，递归调用父节点的markNeedsPaint
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">parent</span><span class="o">!</span><span class="p">.</span><span class="n">markNeedsPaint</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果我们是渲染树的根而不是重绘边界，那么我们必须绘制自己，因为没有其它人可以绘制我们。在这种情况下，我们不会将自己添加到 _nodesNeedingPaint 中，因为无论如何，根总是被告知要绘制。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 以RenderView为根的树不会经过此代码路径，因为RenderView是重绘边界。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// If we are the root of the render tree and not a repaint boundary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// then we have to paint ourselves, since nobody else can paint us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We don&#39;t add ourselves to _nodesNeedingPaint in this case,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because the root is always told to paint regardless.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Trees rooted at a RenderView do not go through this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// code path because RenderViews are repaint boundaries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是根节点，直接请求新的frame即可
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">owner</span><span class="o">!</span><span class="p">.</span><span class="n">requestVisualUpdate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>markNeedsRepaint</em>方法的执行过程如下：</p>
<p>1、会从当前节点一直往父级查找，直到找到一个绘制边界节点时终止查找，然后会将该绘制边界节点添加到其<em>PiplineOwner</em>的 <em>_nodesNeedingPaint</em>列表中（保存需要重绘的绘制边界节点）。</p>
<p>2、在查找的过程中，会将自己到绘制边界节点路径上所有节点的 <em>_needsPaint</em> 属性置为<em>true</em>，表示需要重新绘制。</p>
<p>3、请求新的<em>frame</em>，执行重绘重绘流程。</p>
<h2 id="35renderview的compositeframe方法">3.5、<em>RenderView</em>的<em>compositeFrame</em>方法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="n">ui</span><span class="p">.</span><span class="n">FlutterView</span> <span class="kd">get</span> <span class="n">flutterView</span> <span class="o">=&gt;</span> <span class="n">_view</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">ui</span><span class="p">.</span><span class="n">FlutterView</span> <span class="n">_view</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">compositeFrame</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">ui</span><span class="p">.</span><span class="n">SceneBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">ui</span><span class="p">.</span><span class="n">SceneBuilder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过Layer构建Scene
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">final</span> <span class="n">ui</span><span class="p">.</span><span class="n">Scene</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">layer</span><span class="o">!</span><span class="p">.</span><span class="n">buildScene</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">automaticSystemUiAdjustment</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_updateSystemChrome</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">_view</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">scene</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">scene</span><span class="p">.</span><span class="n">dispose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>看下<em>ContainerLayer</em>的<em>buildScene</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="n">ui</span><span class="p">.</span><span class="n">Scene</span> <span class="n">buildScene</span><span class="p">(</span><span class="n">ui</span><span class="p">.</span><span class="n">SceneBuilder</span> <span class="n">builder</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">updateSubtreeNeedsAddToScene</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将Layer树中每一个Layer传给Skia，最终会调用Native API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">addToScene</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">subtreeHasCompositionCallbacks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_fireCompositionCallbacks</span><span class="p">(</span><span class="nl">includeChildren:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Clearing the flag _after_ calling `addToScene`, not _before_. This is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// because `addToScene` calls children&#39;s `addToScene` methods, which may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// mark this layer as dirty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_needsAddToScene</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">ui</span><span class="p">.</span><span class="n">Scene</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">build</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">scene</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="四参考文献">四、参考文献</h1>
<blockquote>
<ul>
<li><a href="https://juejin.cn/post/7230615859575242808"><em>Flutter -绘制原理及Layer</em></a></li>
<li><a href="https://juejin.cn/post/7230769010907594789"><em>Flutter 组件树绘制流程</em></a></li>
</ul>
</blockquote>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">AndDevMK</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-12-05
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-qr-code.JPG">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay-qr-code.JPG">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8B%E5%B8%83%E5%B1%80layout%E8%BF%87%E7%A8%8B/">
            <span class="next-text nav-default">解读Flutter源码之布局Layout过程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="AndDevMK/blog-utterances"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    
    <div id="search_mask" class="search_mask">
    <div class="search_modal">
        <div id="close_search" class="close_search">关闭</div>
        <div class="search_divider"></div>
        <input id="input_search_key" class="input_search_key" placeholder="请输入你要搜索的内容" tabindex="0">
        <ul id="search_list">
        </ul>
    </div>
</div>

<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>

    <footer id="footer" class="footer">
      

<div class="copyright">
  <span class="power-by">
    由 <a id="hexo-link" class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    
    <span id="run-time" class="run-time"></span> 
    <span class="heart"><i class="iconfont icon-heart"></i></span>
    &copy; 
    2023&nbsp;
    <span>AndDevMK</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.11a4ba15caf2d921d57eaf6568c4ad21eafd5d2c001cbcb31693586c63f93005.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?6db179fb88e600cf326b0515a8aa1de3";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>




<script src="/js/codecopy.js"></script>



<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css"></link>
<script src="/js/dark.js"></script>


<script src="/js/site_runtime.js"></script>




</body>
</html>
