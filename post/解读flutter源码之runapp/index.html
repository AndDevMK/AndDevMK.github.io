<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>解读Flutter源码之runApp - AndDevMK&#39;s android blog site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AndDevMK" /><meta name="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWi" /><meta name="keywords" content="Android, Java, Kotlin, C&#43;&#43;, C, Flutter, Dart, NDK" />


<meta name="baidu-site-verification" content="codeva-wQ7uOo4V09" />
<meta name="google-site-verification" content="yHzWB9BxTR74LiaUhuL5ncr89fnDYXiplTaPY565zqo" />


<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://anddevmk.github.io/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c11aaf02bef1025d6b0813ba5e1a8a8551aee15fa8f2bcea906d41b20bdf5c69.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">
<link rel="stylesheet" href="/css/codecopy.css">


<meta property="og:title" content="解读Flutter源码之runApp" />
<meta property="og:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anddevmk.github.io/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-14T11:28:31+08:00" />
<meta property="article:modified_time" content="2023-10-14T11:28:31+08:00" />
<meta itemprop="name" content="解读Flutter源码之runApp">
<meta itemprop="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWi"><meta itemprop="datePublished" content="2023-10-14T11:28:31+08:00" />
<meta itemprop="dateModified" content="2023-10-14T11:28:31+08:00" />
<meta itemprop="wordCount" content="9327">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解读Flutter源码之runApp"/>
<meta name="twitter:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWi"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AndDevMK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>

    
    <li class="mobile-menu-item-search">
      <div id="mobile_open_search" class="mobile_open_search">
        搜索
      </div>
    </li>

    
    <li class="mobile-menu-item-dark-mode">
      <div id="mobile_dark_mode_toggle" class="mobile_light_mode">
       
      </div>
    </li>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AndDevMK</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
    
    <div id="open_search" class="open_search">
      搜索
    </div>

    
    <div id="dark_mode_toggle" class="light_mode">

    </div>
  
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">解读Flutter源码之runApp</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-10-14 </span>
        <div class="post-category">
            <a href="/categories/flutter/"> Flutter </a>
            </div>
          <span class="more-meta"> 约 9327 字 </span>
          <span class="more-meta"> 预计阅读 19 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一前言">一、前言</a></li>
    <li><a href="#二小案例之设计问题">二、小案例之设计问题</a></li>
    <li><a href="#三root分析">三、<em>Root</em>分析</a>
      <ul>
        <li><a href="#21widgetsflutterbindingensureinitialized">2.1、<em>WidgetsFlutterBinding.ensureInitialized()</em></a></li>
        <li><a href="#22attachrootwidget方法">2.2、<em>attachRootWidget</em>方法</a></li>
        <li><a href="#23renderobjecttowidgetadapter构造方法">2.3、<em>RenderObjectToWidgetAdapter</em>构造方法</a></li>
        <li><a href="#24attachtorendertree方法">2.4、<em>attachToRenderTree</em>方法</a></li>
      </ul>
    </li>
    <li><a href="#四statelesswidget分析">四、<em>StatelessWidget</em>分析</a></li>
    <li><a href="#五statefulwidget分析">五、<em>StatefulWidget</em>分析</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><em>注：本文代码基于Flutter SDK 3.13.5</em></p>
</blockquote>
<h1 id="一前言">一、前言</h1>
<p>在上一文<a href="https://anddevmk.github.io/post/flutter%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89%E9%A2%97%E6%A0%91%E5%88%86%E7%B1%BB/"><em>Flutter源码之三颗树分类</em></a>中，我们对<em>Flutter</em>的三颗树<em>Widget</em>、<em>Element</em>、<em>RenderObject</em>进行了简单的分类，知道了<em>Widget</em>可分为<em>RenderObjectWidget</em>一类和非<em>RenderObjectWidget</em>另一类，并且<em>XXXWidget</em>基本上都有与之对应的<em>XXXElement</em>。</p>
<p>在本文中，将会通过一个小案例以及<em>Debug</em>调试源码的方式深入分析<em>runApp</em>方法的执行过程。</p>
<h1 id="二小案例之设计问题">二、小案例之设计问题</h1>
<p>笔者在最初设计小案例时，预期想要的<em>Widget</em>层次结构是下图这样的。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/1.png" alt="" width="535">
<p>对应的代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyApp</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">const</span> <span class="n">MyPage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyPage</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyPage</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyPageState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyPageState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">const</span> <span class="n">ColoredBox</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">pinkAccent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序运行起来后，可以看到如下效果。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/2.png" alt="" width="235">
<p>但是当笔者通过<em>Flutter Inspector</em>查看<em>Widget</em>层次结构时，发现事与愿违，它的结构变为如下所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/3.png" alt="" width="535">
<p>可以发现，此时的<em>Widget</em>层次结构多出了一个<em>View</em>结构，这无疑会给后面的分析带来不必要的干扰，因此需要看下有无办法去掉<em>View</em>结构部分。</p>
<p>看了下<em>runApp</em>的源码，发现<em>View</em>结构这一部分是在<em>WidgetsBinding</em>的<em>wrapWithDefaultView</em>方法中被添加进来的。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/4.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/5.png" alt="" width="535" style="margin-top:10px;">
<p><em>再看下wrapWithDefaultView方法的注释：
由runApp用于将提供的rootWidget包装在默认View中。
View决定应用程序渲染到哪个FlutterView中。目前这是来自platformDispatcher的PlatformDispatcher.implicitView 。提供给此方法的rootWidget必须尚未包装在View中。</em></p>
<p><em>OK</em>，这<em>wrapWithDefaultView</em>方法的注释看得一头雾水，没关系，再看下<em>View</em>的红框部分注释。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/6.png" alt="" width="535">
<p><em>翻译：提供的child包装在根据给定view构造的MediaQuery中。</em>
查看了<em>View</em>的部分源码发现的确如此。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/7.png" alt="" width="535">
<p>这里的<em>child</em>指我们传入的<em>Widget</em>，<em>view</em>指<em>FlutterView</em>，结合之前的分析，笔者大胆猜测<em>wrapWithDefaultView</em>方法的用意：<em>用View对FlutterView进行一个指定渲染的优化管理，在View中先让MediaQuery初始化，为的是让后续的子Widget能够通过MediaQuery获取相关媒体查询数据。也就是说，如果不想调用wrapWithDefaultView方法，只要保证后续子Widget没用到MediaQuery就OK。</em></p>
<p>前面所给出的<em>MyApp</em>代码中是完全没有用到<em>MediaQuery</em>的，所以这点不用担心，我们可以大大方方的不调用<em>wrapWithDefaultView</em>方法，改造后<em>runApp</em>方法如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_runApp</span><span class="p">(</span><span class="n">Widget</span> <span class="n">app</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">WidgetsBinding</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">binding</span>
</span></span><span class="line"><span class="cl">    <span class="p">..</span><span class="n">scheduleAttachRootWidget</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">..</span><span class="n">scheduleWarmUpFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是这样还不行，因为<em>scheduleAttachRootWidget</em>方法是一个@<em>protected</em>方法，外部调用该方法的话会有警告，所以直接把方法体的代码摘抄出来就好了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_runApp</span><span class="p">(</span><span class="n">Widget</span> <span class="n">app</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">WidgetsBinding</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span><span class="p">.</span><span class="n">run</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binding</span><span class="p">.</span><span class="n">attachRootWidget</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">binding</span><span class="p">.</span><span class="n">scheduleWarmUpFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次运行程序，然后通过<em>Flutter Inspector</em>查看<em>Widget</em>层次结构，发现与预期的<em>Widget</em>层次结构一致。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/小案例之设计问题/8.png" alt="" width="535">
<p><em><strong>温馨提示：此处runApp方法的改动是为了在Debug调试源码过程中减少其它Widget的干扰，而在实际项目中不能这样做。</strong></em></p>
<h1 id="三root分析">三、<em>Root</em>分析</h1>
<p><em>OK</em>，现在从程序入口<code>_runApp</code>方法开始分析。该方法接收一个<em>Widget</em>参数，接下来执行<em>WidgetsFlutterBinding</em>的<em>ensureInitialized</em>方法，返回一个<em>WidgetsBinding</em>实例。</p>
<h2 id="21widgetsflutterbindingensureinitialized">2.1、<em>WidgetsFlutterBinding.ensureInitialized()</em></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">WidgetsFlutterBinding</span> <span class="kd">extends</span> <span class="n">BindingBase</span> <span class="kd">with</span> <span class="n">GestureBinding</span><span class="p">,</span> <span class="n">SchedulerBinding</span><span class="p">,</span> <span class="n">ServicesBinding</span><span class="p">,</span> <span class="n">PaintingBinding</span><span class="p">,</span> <span class="n">SemanticsBinding</span><span class="p">,</span> <span class="n">RendererBinding</span><span class="p">,</span> <span class="n">WidgetsBinding</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">static</span> <span class="n">WidgetsBinding</span> <span class="n">ensureInitialized</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">WidgetsBinding</span><span class="p">.</span><span class="n">_instance</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">WidgetsFlutterBinding</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">WidgetsBinding</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由上面源码可知，在<em>ensureInitialized</em>方法中，首先会判断<code>WidgetsBinding._instance == null</code>，如果满足条件，则调用<em>WidgetsFlutterBinding</em>的构造方法进行初始化，最后返回<code>WidgetsBinding.instance</code>实例。</p>
<p>当然了，第一次调用<em>ensureInitialized</em>方法时<em>WidgetsBinding._instance</em>肯定为<em>null</em>，这里可以打个断点<em>Debug</em>看下。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/1.png" alt="" width="535">
<p>此时会有个意外的发现，<em>WidgetsFlutterBinding</em>中根本就没有构造方法，毫无疑问会执行其父类<em>BindingBase</em>的构造方法。</p>
<p><em>OK</em>，我们继续跟踪其父类<em>BindingBase</em>的源码。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/2.png" alt="" width="535">
<p>发现父类<em>BindingBase</em>构造方法中有一个<em>initInstances</em>方法，这里打个断点<em>Debug</em>调试一下，进入<em>initInstances</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/3.png" alt="" width="535">
<p>然后进入了<em>WidgetsBinding</em>的<em>initInstances</em>方法，继续<em>Debug</em>下一步，来到<code>super.initInstances()</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/4.png" alt="" width="535">
<p>继续<em>Debug</em>进入<code>super.initInstances()</code>，然后进入了<em>RendererBinding</em>的<em>initInstances</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/5.png" alt="" width="535">
<p>以此类推，当断点<em>Debug</em>调试走到<em>BindingBase</em>的<em>initInstances</em>方法时，它的调用堆栈如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/6.png" alt="" width="535">
<p>对于出现这样栈帧顺序的方法调用栈，其实并不感到意外，回顾之前<em>WidgetsFlutterBinding</em>的声明处源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">WidgetsFlutterBinding</span> <span class="kd">extends</span> <span class="n">BindingBase</span> <span class="kd">with</span> <span class="n">GestureBinding</span><span class="p">,</span> <span class="n">SchedulerBinding</span><span class="p">,</span> <span class="n">ServicesBinding</span><span class="p">,</span> <span class="n">PaintingBinding</span><span class="p">,</span> <span class="n">SemanticsBinding</span><span class="p">,</span> <span class="n">RendererBinding</span><span class="p">,</span> <span class="n">WidgetsBinding</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现，<em>WidgetsFlutterBinding</em>混入了<em>GestureBinding、SchedulerBinding、ServicesBinding、PaintingBinding、SemanticsBinding、RendererBinding、WidgetsBinding</em>这七个<em>Binding</em>，并且这些<em>Binding</em>都是<em>BindingBase</em>的子类，每个<em>Binding</em>都重写了父类<em>BindingBase</em>的<em>initInstances</em>方法，也在各自重写的<em>initInstances</em>方法体中调用了<code>super.initInstances()</code>以及执行了实例变量引用的赋值<code>_instance = this</code>。</p>
<p>因此，<em>initInstances</em>方法的调用顺序为：<em>WidgetsBinding -&gt; RendererBinding -&gt; SemanticsBinding -&gt; PaintingBinding -&gt; ServicesBinding -&gt; SchedulerBinding -&gt; GestureBinding</em>，最后才调用父类<em>BindingBase</em>中的<em>initInstances</em>方法，这点从上图的方法调用栈也可以看出。</p>
<p>也许你会有疑问：为什么<em>initInstances</em>方法的调用顺序是这样的？</p>
<p>这其实是Dart语言中<em>with</em>关键字的一个语法特性了，如果一个类<em>with</em>混入的多个类中都有相同的方法（例如上面的<em>initInstances</em>方法），那么当调用该方法时，只会调用距离<em>with</em>关键字最远类中的方法，也就是上面<em>WidgetsBinding</em>中的<em>initInstances</em>方法。</p>
<p>但是由于<em>WidgetsBinding</em>在<em>initInstances</em>方法中又调用了<code>super.initInstances()</code>，所以才会一级一级地往父类方向调用，直到调用父类<em>BindingBase</em>中的<em>initInstances</em>方法。</p>
<p>因为调用的是<em>WidgetsFlutterBinding</em>的构造方法来进行初始化，所以<em>ensureInitialized</em>方法实例化的是<em>WidgetsFlutterBinding</em>对象了，只不过把实例引用赋值给了<em>WidgetsBinding</em>，如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/7.png" alt="" width="535">
<h2 id="22attachrootwidget方法">2.2、<em>attachRootWidget</em>方法</h2>
<p>在<code>WidgetsFlutterBinding.ensureInitialized()</code>实例化<em>WidgetsFlutterBinding</em>后，接下来会继续执行<em>WidgetsBinding</em>的<em>attachRootWidget</em>方法，这个方法接收了一个<em>Widget</em>参数。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/8.png" alt="" width="535">
<p>那么<em>attachRootWidget</em>方法做了什么事情？看下它的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"> <span class="c1">/// Takes a widget and attaches it to the [rootElement], creating it if
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="c1">/// necessary.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><em>翻译：获取一个Widget并将其附加到rootElement ，并在必要时创建它。</em>
<em>attachRootWidget</em>方法的源码如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/9.png" alt="" width="535">
<p>由上面源码可知，<em>attachRootWidget</em>方法体中先是执行了<em>RenderObjectToWidgetAdapter</em>构造方法，然后再执行该实例对象的<em>attachToRenderTree</em>方法。</p>
<h2 id="23renderobjecttowidgetadapter构造方法">2.3、<em>RenderObjectToWidgetAdapter</em>构造方法</h2>
<p>先打个断点<em>Debug</em>看下<em>RenderObjectToWidgetAdapter</em>构造方法传入的参数。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/10.png" alt="" width="535">
<p>可以看到，<em>RenderObjectToWidgetAdapter</em>构造方法传入了3个参数，其中参数<em>child</em>就是我们自己的<em>MyApp</em>；参数<em>container</em>传入了<em>renderView</em>，它的类型为<em>RenderView</em>；最后一个参数<em>debugShortDescription</em>从名字上看是调试用的，这个不用管。</p>
<p>关于参数<em>container</em>传入了<em>renderView</em>，那么这个<em>renderView</em>是怎么来的呢？</p>
<p>回顾下之前所讲的那七个混入<em>Binding</em>之一的<em>RendererBinding</em>，其实<em>renderView</em>是在<em>RendererBinding</em>的<em>initInstances</em>方法中初始化的。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/11.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/12.png" alt="" width="535" style="margin-top: 10px;">
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/13.png" alt="" width="535" style="margin-top: 10px;">
<p><em>OK</em>，<em>RenderObjectToWidgetAdapter</em>构造方法的参数分析完毕，接下来继续看<em>attachToRenderTree</em>方法。</p>
<h2 id="24attachtorendertree方法">2.4、<em>attachToRenderTree</em>方法</h2>
<p>先打个断点<em>Debug</em>看下<em>attachToRenderTree</em>方法传入的参数。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/14.png" alt="" width="535">
<p>可以看到，<em>attachToRenderTree</em>方法接收2个参数，一个是<em>BuildOwner</em>，另一个是可选的位置参数<em>RenderObjectToWidgetElement</em>。</p>
<p>关于传入的参数<em>buildOwner</em>，那么这个<em>buildOwner</em>是怎么来的呢？它是在那七个混入<em>Binding</em>之一的<em>WidgetsBinding</em>的<em>initInstances</em>方法中初始化的。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/15.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/16.png" alt="" width="535" style="margin-top: 10px;">
<p><em>OK</em>，开始分析<em>attachToRenderTree</em>方法源码，因为<em>element</em>为<em>null</em>，所以重点分析下红框部分。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/17.png" alt="" width="535">
<p><em><code>owner.lockState()</code><em>接收一个</em>VoidCallback</em>回调，<em>lockState</em>方法体中只是进行一些断言操作，然后在<em>try-finally</em>中执行<em>callback</em>方法，<em>lockState</em>方法的源码如下。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/18.png" alt="" width="535">
<p><em>lockState</em>方法体中没做什么操作，所以<em>lockState</em>方法回调中先调用了<em>createElement</em>方法，创建<em>Element</em>实例后，再调用<em>Element</em>实例的<em>assignOwner</em>方法，因为<em>assignOwner</em>方法不是主线的重点，所以这部分不做讲解。</p>
<p>继续看主线的重点：<em>createElement</em>方法，它调用的是<em>RenderObjectToWidgetAdapter</em>这个<em>Widget</em>的<em>createElement</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/19.png" alt="" width="535">
<p>可以发现，调用了<em>RenderObjectToWidgetElement</em>构造方法，方法参数传入的是<em>this</em>，表示<em>RenderObjectToWidgetAdapter</em>本身。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/20.png" alt="" width="535">
<p><em>RenderObjectToWidgetElement</em>构造方法参数执行<code>super.widget</code>，就会把<em>widget</em>一级一级往上传递，先是执行了 <em>RenderObjectElement</em>的构造方法，最后执行了<em>Element</em>的构造方法。并且在<em>Element</em>的构造方法中，把一路传递过来的this，也就是<em>RenderObjectToWidgetAdapter</em>本身赋值给了<em>Element</em>的成员变量<code>_widget</code>，那么<em>Element</em>就持有了这个<em>Widget</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/21.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/22.png" alt="" width="535" style="margin-top: 10px;">
<p><em>OK</em>，<em><code>owner.lockState()</code><em>已经分析完成，继续看</em><code>owner.buildScope()</code></em>，<em>buildScope</em>方法体的实现与前面的<em>lockState</em>方法较为相似，也只是进行一些断言判断，最后在<em>try-finally</em>中执行<em>callback</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/23.png" alt="" width="535">
<p><em>buildScope</em>方法体中没做什么操作，所以在<em>buildScope</em>方法回调中就会执行<em>element</em>的<em>mount</em>方法，也就是<em>RenderObjectToWidgetElement</em>的<em>mount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/24.png" alt="" width="535">
<p>分析下<em>RenderObjectToWidgetElement</em>的<em>mount</em>方法，这里分两步走，一步是执行<em>super.mount</em>，也就是执行父类的<em>mount</em>方法；另一步是执行<code>_rebuild</code>方法，这个后面会讲。</p>
<p>看下第一步，也就是执行父类的<em>mount</em>方法，它会一级一级往上执行，先是执行<em>RenderObjectElement</em>的<em>mount</em>方法，最后执行<em>Element</em>的<em>mount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/25.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/26.png" alt="" width="535" style="margin-top: 10px;">
<p>可以看到，在<em>Element</em>的<em>mount</em>方法中主要是对一些属性进行赋值操作，如<code>_parent</code>等。当<em>Element</em>的<em>mount</em>方法执行完成后就会出栈，然后回来执行<em>RenderObjectElement</em>的<em>mount</em>方法。</p>
<p>在<em>RenderObjectElement</em>的<em>mount</em>方法中会执行<em>widget</em>的<em>createRenderObject</em>方法，想必该<em>Widget</em>是谁应该知道吧，它就是之前在构造方法中将参数一级一级往上传递的<em>this</em>，也就是<em>RenderObjectToWidgetAdapter</em>，它是<code>Root</code><em>Widget</em>，如果不确定，可以<em>Debug</em>断点调试看下。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/27.png" alt="" width="535">
<p>继续执行<em>RenderObjectToWidgetAdapter</em>的 <em>createRenderObject</em>方法，会返回一个<em>container</em>，也就是之前讲的<em>RenderView</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/28.png" alt="" width="535">
<p>然后将<em>createRenderObject</em>方法返回值赋值给<em>RenderObjectElement</em>的成员变量<code>_renderObject</code>，于是得出一个结论：<em>RenderObjectElement</em>会持有一个<em>RenderObject</em>实例。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/29.png" alt="" width="535">
<p>接着，继续执行<em>RenderObjectElement</em>中的<em>attachRenderObject</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/30.png" alt="" width="535">
<p>在<em>RenderObjectElement</em>中的<em>attachRenderObject</em>方法中，它一共做了三件事情。</p>
<p>1、执行<code>_findAncestorRenderObjectElement</code>方法，沿着父类往上查找最远处<em>RenderObjectElement</em>类型的<em>Element</em>，并且赋值给 <code>_ancestorRenderObjectElement</code>；其中<code>_parent</code>是在<em>Element</em>的<em>mount</em>方法中赋值，一开始<code>_parent</code>为<em>null</em>，所以<code>_findAncestorRenderObjectElement</code>方法返回为<em>null</em>，相当于该方法没执行。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/31.png" alt="" width="535">
<p>2、执行上一步返回的<code>_ancestorRenderObjectElement</code>的<em>insertRenderObjectChild</em>方法将<em>renderObject</em>插入渲染树中；
但是由于<code>_ancestorRenderObjectElement</code>为<em>null</em>，所以<em>insertRenderObjectChild</em>方法并没有触发。</p>
<p>3、执行<code>_findAncestorParentDataElement</code>方法，沿着父类往上查找最近处<em>ParentDataElement<ParentData><em>类型的</em>Element</em>，但是由于<code>_parent</code>为<em>null</em>，所以该方法执行了个寂寞。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/32.png" alt="" width="535">
<p>因此，整体上<em>RenderObjectElement</em>中的<em>attachRenderObject</em>方法相当于没执行到。</p>
<p><em>OK</em>，<em>RenderObjectElement</em>的<em>mount</em>方法分析完了，此时会继续出栈，然后继续执行<em>RenderObjectToWidgetElement</em>的<em>mount</em>方法中<code>super.mount()</code>之后的逻辑。</p>
<p>也就是执行<em>RenderObjectToWidgetElement</em>的<code>_rebuild</code>方法，在 <code>_rebuild</code>方法中，执行了<em>updateChild</em>方法，参数一<code>_child</code>为<em>null</em>，参数二就是我们自己的<em>MyApp</em>，参数三为<em>Object</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/33.png" alt="" width="535">
<p>继续执行<em>Element</em>的<em>updateChild</em>方法，因为此时<em>child</em>为<em>null</em>，所以会执行红框部分，也就是执行<em>inflateWidget</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/34.png" alt="" width="535">
<p>继续执行<em>Element</em>的<em>inflateWidget</em>方法，之前已经知道传入的<em>newWidget</em>为<em>MyApp</em>，看下它的源码。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/35.png" alt="" width="535">
<p>在<em>Element</em>中的<em>inflateWidget</em>方法中，它一共做了3件事情。</p>
<p>1、校验<em>key</em>是否为<em>GlobalKey</em>，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。</p>
<p>2、执行<em>newWidget</em>的<em>createElement</em>方法，也就是执行<em>MyApp</em>的<em>createElement</em>方法，返回一个<em>Element</em>实例。</p>
<p>3、执行上一步返回<em>Element</em>实例的<em>mount</em>方法。</p>
<p>看到这里，相信你会觉得<em>createElement</em>、<em>mount</em>方法似曾相识，因为之前分析过了。</p>
<p>总结下<em>Root</em>分析的执行流程，如下图所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/36.png" alt="" width="535">
<h1 id="四statelesswidget分析">四、<em>StatelessWidget</em>分析</h1>
<p>接着<em>Root</em>分析，继续执行<em>MyApp</em>的<em>createElement</em>方法，因为<em>MyApp</em>的类型是<em>StatelessWidget</em>，所以执行了<em>StatelessWidget</em>的<em>createElement</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/1.png" alt="" width="535">
<p>然后创建了<em>StatelessElement</em>实例，并将this传入<em>StatelessElement</em>的构造方法中，<em>this</em>也就是<em>MyApp</em>本身，而<em>StatelessElement</em>构造方法的参数执行了<code>super.widget</code>，会一级一级地向父类传递<em>this</em>，先是执行了<em>ComponentElement</em>的构造方法，最后再执行<em>Element</em>的构造方法，将传递的<em>this</em>赋值给<em>Element</em>的成员变量<code>_widget</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/2.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/3.png" alt="" width="535" style="margin-top: 10px;">
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/4.png" alt="" width="535" style="margin-top: 10px;">
<p>这种子类<em>Element</em>向父类一级一级传递<em>this</em>的行为我们之前讲过的，也是似曾相识了。</p>
<p>接着<em>Root</em>分析，继续执行<em>Element</em>的<em>mount</em>方法。因为<em>StatelessElement</em>没有<em>mount</em>方法，所以执行的是<em>ComponentElement</em>的<em>mount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/5.png" alt="" width="535">
<p>可以看到，先是执行了<code>super.mount</code>，也就是执行<em>Element</em>的<em>mount</em>方法，这个之前看过，只是一些成员变量的赋值操作。</p>
<p>然后执行了<code>_firstBuild</code>方法，在该方法中又执行了<em>Element</em>的<em>rebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/6.png" alt="" width="535">
<p>在<em>Element</em>的<em>rebuild</em>方法中，<em>try-finally</em>处执行了<em>performRebuild</em>方法，然后又回到了<em>ComponentElement</em>的<em>performRebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/7.png" alt="" width="535">
<p>在<em>ComponentElement</em>的<em>performRebuild</em>方法中，做了两件事情。</p>
<p>1、执行<em>build</em>方法。这里执行了<em>StatelessElement</em>的<em>build</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/8.png" alt="" width="535">
<p>这里的<em>widget</em>就是我们自己的<em>MyApp</em>，所以执行了<em>MyApp</em>的<em>build</em>方法，创建了<em>MyPage</em>实例。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/9.png" alt="" width="535">
<p>2、执行了<em>Element</em>的<em>updateChild</em>方法，看到该方法是否又似曾相识，<em>OK</em>，继续分析。</p>
<p>因为此时<em>child</em>为<em>null</em>，所以会执行红框部分，也就是执行<em>inflateWidget</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/10.png" alt="" width="535">
<p>继续执行<em>Element</em>的<em>inflateWidget</em>方法，之前已经知道传入的<em>newWidget</em>为<em>MyPage</em>，看下它的源码。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/Root分析/35.png" alt="" width="535">
<p>在<em>Element</em>中的<em>inflateWidget</em>方法中，它一共做了三件事情，这个前面讲过。</p>
<p>1、校验<em>key</em>是否为<em>GlobalKey</em>，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。</p>
<p>2、执行<em>newWidget</em>的<em>createElement</em>方法，也就是执行<em>MyPage</em>的<em>createElement</em>方法，返回一个<em>Element</em>实例。</p>
<p>3、执行上一步返回<em>Element</em>实例的<em>mount</em>方法。</p>
<p>看到这里，相信你会觉得再熟悉不过，因为之前多次分析过<em>createElement</em>、<em>mount</em>方法了。</p>
<h1 id="五statefulwidget分析">五、<em>StatefulWidget</em>分析</h1>
<p>接着<em>StatelessWidget</em>分析，继续执行<em>MyPage</em>的<em>createElement</em>方法，因为<em>MyPage</em>的类型是<em>StatefulWidget</em>，所以执行了<em>StatefulWidget</em>的<em>createElement</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatefulWidget分析/1.png" alt="" width="535">
<p>然后创建了<em>StatefulElement</em>实例，并将<em>this</em>传入<em>StatefulElement</em>的构造方法中，<em>this</em>也就是<em>MyPage</em>本身。</p>
<p>在<em>StatefulElement</em>的构造方法中，执行了<code>widget.createState()</code>，widget就是我们的<em>MyPage</em>，也就是执行了<em>MyPage</em>的<em>createState</em>方法。</p>
<p>将创建好的<code>_MyPageState</code>实例赋值给<em>StatefulElement</em>的成员变量<code>_state</code>，也就是说<em>StatefulElement</em>持有了<em>State</em>实例。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatefulWidget分析/2.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatefulWidget分析/3.png" alt="" width="535" style="margin-top: 10px;">
<p>与此同时，<em>StatefulElement</em>构造方法中还执行了<code>super(widget)</code>，会一级一级地向父类传递<em>this</em>，先是执行了<em>ComponentElement</em>的构造方法，最后再执行<em>Element</em>的构造方法，将传递的<em>this</em>赋值给<em>Element</em>的成员变量<code>_widget</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/3.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/4.png" alt="" width="535" style="margin-top: 10px;">
<p>这种子类<em>Element</em>向父类一级一级传递<em>this</em>的行为我们之前讲过的，也是老相识了。</p>
<p>接着<em>StatelessWidget</em>分析，继续执行<em>Element</em>的<em>mount</em>方法。因为<em>StatefulElement</em>没有<em>mount</em>方法，所以执行的是<em>ComponentElement</em>的<em>mount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/5.png" alt="" width="535">
<p>可以看到，先是执行了<code>super.mount</code>，也就是执行<em>Element</em>的<em>mount</em>方法，这个之前看过，只是一些成员变量的赋值操作。</p>
<p>然后执行了<code>_firstBuild</code>方法，在该方法中又执行了<em>Element</em>的<em>rebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/6.png" alt="" width="535">
<p>在<em>Element</em>的<em>rebuild</em>方法中，<em>try-finally</em>处执行了<em>performRebuild</em>方法，然后又回到了<em>ComponentElement</em>的<em>performRebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatelessWidget分析/7.png" alt="" width="535">
<p>在<em>ComponentElement</em>的<em>performRebuild</em>方法中，做了两件事情。</p>
<p>1、执行<em>build</em>方法。这里执行了<em>StatefulElement</em>的<em>build</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatefulWidget分析/4.png" alt="" width="535">
<p>这里执行了<code>state.build()</code>，也就是执行了<code>_MyPageState</code>的<em>build</em>方法，创建了<em>ColoredBox</em>实例。</p>
<img title="" src="/img/flutter/解读Flutter源码之runApp/StatefulWidget分析/5.png" alt="" width="535">
<p>2、执行了<em>Element</em>的<em>updateChild</em>方法，该方法是老朋友了。</p>
<p>再后面就是<em>ColoredBox</em>的分析，因为<em>ColoredBox</em>最终父类的类型与根布局<em>RenderObjectToWidgetAdapter</em>的类型都是<em>RenderObjectWidget</em>，因此分析都是差不多的，后面就留给你们发挥了。</p>
<p>当然了，<em>runApp</em>方法的分析肯定不止上面这些内容，后续有机会再补上。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">AndDevMK</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-10-14
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-qr-code.JPG">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay-qr-code.JPG">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">解读Flutter源码之StatefulWidget&amp;State的生命周期</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/flutter%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89%E9%A2%97%E6%A0%91%E5%88%86%E7%B1%BB/">
            <span class="next-text nav-default">Flutter源码之三颗树分类</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="AndDevMK/blog-utterances"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    
    <div id="search_mask" class="search_mask">
    <div class="search_modal">
        <div id="close_search" class="close_search">关闭</div>
        <div class="search_divider"></div>
        <input id="input_search_key" class="input_search_key" placeholder="请输入你要搜索的内容" tabindex="0">
        <ul id="search_list">
        </ul>
    </div>
</div>

<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>

    <footer id="footer" class="footer">
      

<div class="copyright">
  <span class="power-by">
    由 <a id="hexo-link" class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    
    <span id="run-time" class="run-time"></span> 
    <span class="heart"><i class="iconfont icon-heart"></i></span>
    &copy; 
    2023 - 
    2024&nbsp;
    <span>AndDevMK</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.11a4ba15caf2d921d57eaf6568c4ad21eafd5d2c001cbcb31693586c63f93005.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?6db179fb88e600cf326b0515a8aa1de3";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>




<script src="/js/codecopy.js"></script>



<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css"></link>
<script src="/js/dark.js"></script>


<script src="/js/site_runtime.js"></script>




</body>
</html>
