<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>解读Flutter源码之InheritedWidget - AndDevMK&#39;s android blog site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AndDevMK" /><meta name="description" content="注：本文代码基于Flutter SDK 3.13.5 一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widge" /><meta name="keywords" content="Android, Java, Kotlin, C&#43;&#43;, C, Flutter, Dart, NDK" />


<meta name="baidu-site-verification" content="codeva-wQ7uOo4V09" />
<meta name="google-site-verification" content="yHzWB9BxTR74LiaUhuL5ncr89fnDYXiplTaPY565zqo" />


<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Binheritedwidget/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c11aaf02bef1025d6b0813ba5e1a8a8551aee15fa8f2bcea906d41b20bdf5c69.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">
<link rel="stylesheet" href="/css/codecopy.css">


<meta property="og:title" content="解读Flutter源码之InheritedWidget" />
<meta property="og:description" content="注：本文代码基于Flutter SDK 3.13.5 一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widge" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Binheritedwidget/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-31T11:28:31+08:00" />
<meta property="article:modified_time" content="2023-10-31T11:28:31+08:00" />
<meta itemprop="name" content="解读Flutter源码之InheritedWidget">
<meta itemprop="description" content="注：本文代码基于Flutter SDK 3.13.5 一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widge"><meta itemprop="datePublished" content="2023-10-31T11:28:31+08:00" />
<meta itemprop="dateModified" content="2023-10-31T11:28:31+08:00" />
<meta itemprop="wordCount" content="14895">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解读Flutter源码之InheritedWidget"/>
<meta name="twitter:description" content="注：本文代码基于Flutter SDK 3.13.5 一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widge"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AndDevMK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>

    
    <li class="mobile-menu-item-search">
      <div id="mobile_open_search" class="mobile_open_search">
        搜索
      </div>
    </li>

    
    <li class="mobile-menu-item-dark-mode">
      <div id="mobile_dark_mode_toggle" class="mobile_light_mode">
       
      </div>
    </li>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AndDevMK</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
    
    <div id="open_search" class="open_search">
      搜索
    </div>

    
    <div id="dark_mode_toggle" class="light_mode">

    </div>
  
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">解读Flutter源码之InheritedWidget</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-10-31 </span>
        <div class="post-category">
            <a href="/categories/flutter/"> Flutter </a>
            </div>
          <span class="more-meta"> 约 14895 字 </span>
          <span class="more-meta"> 预计阅读 30 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一子widget多层嵌套之状态管理问题">一、子<em>Widget</em>多层嵌套之状态管理问题</a></li>
    <li><a href="#二什么是inheritedwidget">二、什么是<em>InheritedWidget</em>？</a></li>
    <li><a href="#三inheritedwidget示例演示">三、<em>InheritedWidget</em>示例演示</a></li>
    <li><a href="#四分析inheritedwidget源码">四、分析<em>InheritedWidget</em>源码</a>
      <ul>
        <li><a href="#41inheritedelement注册阶段">4.1、<em>InheritedElement</em>注册阶段</a></li>
        <li><a href="#42inheritedelement通知更新阶段">4.2、<em>InheritedElement</em>通知更新阶段</a></li>
        <li><a href="#43inheritedelement取消注册阶段">4.3、<em>InheritedElement</em>取消注册阶段</a></li>
      </ul>
    </li>
    <li><a href="#五inheritedwidget扩展">五、<em>InheritedWidget</em>扩展</a>
      <ul>
        <li><a href="#51inheritedmodel介绍">5.1、<em>InheritedModel</em>介绍</a></li>
        <li><a href="#52inheritednotifier介绍">5.2、<em>InheritedNotifier</em>介绍</a></li>
        <li><a href="#53inheritedtheme介绍">5.3、<em>InheritedTheme</em>介绍</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><em>注：本文代码基于Flutter SDK 3.13.5</em></p>
</blockquote>
<h1 id="一子widget多层嵌套之状态管理问题">一、子<em>Widget</em>多层嵌套之状态管理问题</h1>
<p>在<em>Flutter</em>开发中，如果父<em>Widget</em>想要控制子<em>Widget</em>的状态，最常见的办法是把子<em>Widget</em>的状态提升到父<em>Widget</em>中，当父<em>Widget</em>修改该状态并且执行了<em>setState</em>方法之后，子<em>Widget</em>就会发生重建，而子<em>Widget</em>可通过构造方法传入父<em>Widget</em>的状态，然后在<em>build</em>方法中使用该状态即可。</p>
<p>例如下面这个计数器示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyApp</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">title:</span> <span class="s1">&#39;Flutter Demo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">theme:</span> <span class="n">ThemeData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">colorScheme:</span> <span class="n">ColorScheme</span><span class="p">.</span><span class="n">fromSeed</span><span class="p">(</span><span class="nl">seedColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">deepPurple</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nl">useMaterial3:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">home:</span> <span class="kd">const</span> <span class="n">MyPage</span><span class="p">(</span><span class="nl">title:</span> <span class="s1">&#39;计数器&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyPage</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyPage</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">title</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">String</span> <span class="n">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyPageState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyPageState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">backgroundColor:</span> <span class="n">Theme</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">inversePrimary</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="n">widget</span><span class="p">.</span><span class="n">title</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">body:</span> <span class="n">MyChild</span><span class="p">(</span><span class="nl">counter:</span> <span class="n">_counter</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">floatingActionButton:</span> <span class="n">FloatingActionButton</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">onPressed:</span> <span class="n">_increment</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">tooltip:</span> <span class="s1">&#39;increment&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">add</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyChild</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyChild</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">counter</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;build&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Center</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">child:</span> <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;</span><span class="si">$</span><span class="n">counter</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">style:</span> <span class="kd">const</span> <span class="n">TextStyle</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">fontSize:</span> <span class="m">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">black</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序运行<em>UI</em>效果为：</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/计数器.gif" alt="" width="235">
<p>点击<em>FloatingActionButton</em>时日志打印如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7101): build
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果考虑到父<em>Widget</em>与子<em>Widget</em>之间嵌套很深的情况时，上面的方案其实就不是那么好使了，因为状态的传递需要通过子<em>Widget</em>的构造方法一层一层地传入，这样维护起来非常麻烦且不够优雅，那么<em>Flutter</em>官方有提供什么解决办法呢？是有的，它就是<em>InheritedWidget</em>。</p>
<h1 id="二什么是inheritedwidget">二、什么是<em>InheritedWidget</em>？</h1>
<p>遇事不决，先看<em>InheritedWidget</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 有效地沿树传播信息的widgets的基类。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Base class for widgets that efficiently propagate information down the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 要从构建上下文获取特定类型的inherited widget的最近实例，请使用BuildContext.dependOnInheritedWidgetOfExactType。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// To obtain the nearest instance of a particular type of inherited widget from
</span></span></span><span class="line"><span class="cl"><span class="c1">/// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当以这种方式引用Inherited widgets时，当Inherited widgets本身更改状态时，将导致使用者重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Inherited widgets, when referenced in this way, will cause the consumer to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuild when the inherited widget itself changes state.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 以下是名为FrogColor的inherited widget的骨架
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The following is a skeleton of an inherited widget called `FrogColor`:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class FrogColor extends InheritedWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const FrogColor({
</span></span></span><span class="line"><span class="cl"><span class="c1">///     super.key,
</span></span></span><span class="line"><span class="cl"><span class="c1">///     required this.color,
</span></span></span><span class="line"><span class="cl"><span class="c1">///     required super.child,
</span></span></span><span class="line"><span class="cl"><span class="c1">///   });
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final Color color;
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   static FrogColor? maybeOf(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return context.dependOnInheritedWidgetOfExactType&lt;FrogColor&gt;();
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   static FrogColor of(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     final FrogColor? result = maybeOf(context);
</span></span></span><span class="line"><span class="cl"><span class="c1">///     assert(result != null, &#39;No FrogColor found in context&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return result!;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   bool updateShouldNotify(FrogColor oldWidget) =&gt; color != oldWidget.color;
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## 实现“of”和“maybeOf”方法
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## Implementing the `of` and `maybeOf` methods
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 约定是在InheritedWidget上提供两个静态方法of和maybeOf ，它们调用BuildContext.dependOnInheritedWidgetOfExactType。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这允许类定义自己的后备逻辑，以防范围内没有widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The convention is to provide two static methods, `of` and `maybeOf`, on the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedWidget] which call
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [BuildContext.dependOnInheritedWidgetOfExactType]. This allows the class to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// define its own fallback logic in case there isn&#39;t a widget in scope.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `of` 方法通常返回一个不可为 null 的实例，并在未找到 [InheritedWidget] 时断言，而 `maybeOf` 方法则返回一个可为 null 的实例，并在未找到 [InheritedWidget] 时返回 null。 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// “of”方法通常通过内部调用“maybeOf”来实现。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The `of` method typically returns a non-nullable instance and asserts if the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedWidget] isn&#39;t found, and the `maybeOf` method returns a nullable
</span></span></span><span class="line"><span class="cl"><span class="c1">/// instance, and returns null if the [InheritedWidget] isn&#39;t found. The `of`
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method is typically implemented by calling `maybeOf` internally.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 有时，“of”和“maybeOf”方法返回一些数据，而不是inherited widget本身；例如，在这种情况下，它可能返回一个 [Color] 而不是“FrogColor”小部件。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Sometimes, the `of` and `maybeOf` methods return some data rather than the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// inherited widget itself; for example, in this case it could have returned a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [Color] instead of the `FrogColor` widget.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 有时，inherited widget是另一个类的实现细节，因此是私有的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在这种情况下，“of”和“maybeOf”方法通常在公共类上实现。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，[Theme]被实现为[StatelessWidget]，它构建了一个私有inherited widget； [Theme.of] 使用 [BuildContext.dependOnInheritedWidgetOfExactType] 查找inherited widget，然后返回其中的 [ThemeData]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Occasionally, the inherited widget is an implementation detail of another
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class, and is therefore private. The `of` and `maybeOf` methods in that case
</span></span></span><span class="line"><span class="cl"><span class="c1">/// are typically implemented on the public class instead. For example, [Theme]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// is implemented as a [StatelessWidget] that builds a private inherited
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget; [Theme.of] looks for that private inherited widget using
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [BuildContext.dependOnInheritedWidgetOfExactType] and then returns the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [ThemeData] inside it.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## 调用“of”或“maybeOf”方法
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## Calling the `of` or `maybeOf` methods
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 使用“of”或“maybeOf”方法时，“context”必须是 [InheritedWidget] 的后代，这意味着它必须位于树中 [InheritedWidget]“下方”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// When using the `of` or `maybeOf` methods, the `context` must be a descendant
</span></span></span><span class="line"><span class="cl"><span class="c1">/// of the [InheritedWidget], meaning it must be &#34;below&#34; the [InheritedWidget]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在此示例中，使用的“context”是来自 [Builder] 的context，它是“FrogColor” widget的子级，因此这是可行的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In this example, the `context` used is the one from the [Builder], which is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// a child of the `FrogColor` widget, so this works.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// // continuing from previous example...
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyPage extends StatelessWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const MyPage({super.key});
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return Scaffold(
</span></span></span><span class="line"><span class="cl"><span class="c1">///       body: FrogColor(
</span></span></span><span class="line"><span class="cl"><span class="c1">///         color: Colors.green,
</span></span></span><span class="line"><span class="cl"><span class="c1">///         child: Builder(
</span></span></span><span class="line"><span class="cl"><span class="c1">///           builder: (BuildContext innerContext) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///             return Text(
</span></span></span><span class="line"><span class="cl"><span class="c1">///               &#39;Hello Frog&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1">///               style: TextStyle(color: FrogColor.of(innerContext).color),
</span></span></span><span class="line"><span class="cl"><span class="c1">///             );
</span></span></span><span class="line"><span class="cl"><span class="c1">///           },
</span></span></span><span class="line"><span class="cl"><span class="c1">///         ),
</span></span></span><span class="line"><span class="cl"><span class="c1">///       ),
</span></span></span><span class="line"><span class="cl"><span class="c1">///     );
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在此示例中，使用的“context”是来自“MyOtherPage” widget的上下文，该widget是“FrogColor”widget的父级，因此这不起作用，并且会在调用“FrogColor.of”时断言。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In this example, the `context` used is the one from the `MyOtherPage`
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget, which is a parent of the `FrogColor` widget, so this does not work,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and will assert when `FrogColor.of` is called.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// // continuing from previous example...
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyOtherPage extends StatelessWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const MyOtherPage({super.key});
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return Scaffold(
</span></span></span><span class="line"><span class="cl"><span class="c1">///       body: FrogColor(
</span></span></span><span class="line"><span class="cl"><span class="c1">///         color: Colors.green,
</span></span></span><span class="line"><span class="cl"><span class="c1">///         child: Text(
</span></span></span><span class="line"><span class="cl"><span class="c1">///           &#39;Hello Frog&#39;,
</span></span></span><span class="line"><span class="cl"><span class="c1">///           style: TextStyle(color: FrogColor.of(context).color),
</span></span></span><span class="line"><span class="cl"><span class="c1">///         ),
</span></span></span><span class="line"><span class="cl"><span class="c1">///       ),
</span></span></span><span class="line"><span class="cl"><span class="c1">///     );
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，注释详细地描述了<em>InheritedWidget</em>的特性以及贴心地给出了相应的示例，根据<em>InheritedWidget</em>的注释，可以总结下它的特性：</p>
<p>1、<em>InheritedWidget</em>是沿着<em>Widget</em>树传播信息的基类。</p>
<p>2、可以使用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>获取特定类型的<em>InheritedWidget</em>的最近实例。</p>
<p>3、当<em>InheritedWidget</em>本身更改状态时，将导致使用者重建。</p>
<p>4、使用<em>of</em>或<em>maybeOf</em>方法时，<em>context</em>必须是<em>InheritedWidget</em>的后代，这意味着它必须位于树中<em>InheritedWidget</em>下方。</p>
<p>5、&hellip;</p>
<p>这里给出了<em>InheritedWidget</em>的部分特性，主要是想让大家对<em>InheritedWidget</em>有一个初级认知。</p>
<p>继续看下<em>InheritedWidget</em>的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InheritedWidget</span> <span class="kd">extends</span> <span class="n">ProxyWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">InheritedWidget</span><span class="p">({</span> <span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">super</span><span class="p">.</span><span class="n">child</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">InheritedElement</span> <span class="n">createElement</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">InheritedElement</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 框架是否应该通知继承自此widget的widgets
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Whether the framework should notify widgets that inherit from this widget.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 当这个widget被重建时，有时我们需要重建从这个widget继承的widgets，但有时我们不需要。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 例如，如果这个widget保存的数据与“oldWidget”保存的数据相同，那么我们不需要重建继承“oldWidget”保存数据的widgets。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// When this widget is rebuilt, sometimes we need to rebuild the widgets that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// inherit from this widget but sometimes we do not. For example, if the data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// held by this widget is the same as the data held by `oldWidget`, then we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// do not need to rebuild the widgets that inherited the data held by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// `oldWidget`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 框架通过使用先前占据树中此位置的widget作为参数来调用此函数来区分这些情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 保证给定的widget与该对象具有相同的 [runtimeType]。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The framework distinguishes these cases by calling this function with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// widget that previously occupied this location in the tree as an argument.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The given widget is guaranteed to have the same [runtimeType] as this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">updateShouldNotify</span><span class="p">(</span><span class="n">covariant</span> <span class="n">InheritedWidget</span> <span class="n">oldWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现，<em>InheritedWidget</em>继承自<em>ProxyWidget</em>，<em>InheritedWidget</em>的构造方法需要传入一个<em>child</em>，<em>createElement</em>方法返回了一个<em>InheritedElement</em>实例，并且在父类<em>ProxyWidget</em>的基础上新增了一个<em>updateShouldNotify</em>方法，从该方法的注释也可以了解到，它用于判断是否应该通知继承<em>InheritedWidget</em>的<em>Widget</em>。</p>
<h1 id="三inheritedwidget示例演示">三、<em>InheritedWidget</em>示例演示</h1>
<p>使用<em>InheritedWidget</em>改造之前的计数器示例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyApp</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">title:</span> <span class="s1">&#39;Flutter Demo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">theme:</span> <span class="n">ThemeData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">colorScheme:</span> <span class="n">ColorScheme</span><span class="p">.</span><span class="n">fromSeed</span><span class="p">(</span><span class="nl">seedColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">deepPurple</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nl">useMaterial3:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">home:</span> <span class="kd">const</span> <span class="n">MyPage</span><span class="p">(</span><span class="nl">title:</span> <span class="s1">&#39;计数器&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyPage</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyPage</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">title</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">String</span> <span class="n">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyPageState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyPageState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_increment</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">backgroundColor:</span> <span class="n">Theme</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">inversePrimary</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="n">widget</span><span class="p">.</span><span class="n">title</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">body:</span> <span class="n">MyParent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">counter:</span> <span class="n">_counter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">child:</span> <span class="kd">const</span> <span class="n">MyChild</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">floatingActionButton:</span> <span class="n">FloatingActionButton</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">onPressed:</span> <span class="n">_increment</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">tooltip:</span> <span class="s1">&#39;increment&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">add</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyParent</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyParent</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">counter</span><span class="p">,</span> <span class="kd">required</span> <span class="k">super</span><span class="p">.</span><span class="n">child</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">static</span> <span class="n">MyParent</span><span class="o">?</span> <span class="n">maybeOf</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">context</span><span class="p">.</span><span class="n">dependOnInheritedWidgetOfExactType</span><span class="o">&lt;</span><span class="n">MyParent</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">static</span> <span class="n">MyParent</span> <span class="n">of</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">MyParent</span><span class="o">?</span> <span class="n">result</span> <span class="o">=</span> <span class="n">maybeOf</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;No MyParent found in context&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="o">!</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">updateShouldNotify</span><span class="p">(</span><span class="n">covariant</span> <span class="n">MyParent</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">counter</span> <span class="o">!=</span> <span class="n">oldWidget</span><span class="p">.</span><span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyChild</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyChild</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyChild</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyChildState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyChildState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyChild</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">didChangeDependencies</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;didChangeDependencies&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;build&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Center</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">child:</span> <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;</span><span class="si">${</span><span class="n">MyParent</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">counter</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">style:</span> <span class="kd">const</span> <span class="n">TextStyle</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="nl">fontSize:</span> <span class="m">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">black</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序运行<em>UI</em>效果和之前的计数器示例一样，可以参考上面<em>gif</em>图。</p>
<p>在<em>InheritedWidget</em>示例中，点击<em>FloatingActionButton</em>时日志打印如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7101): didChangeDependencies
</span></span><span class="line"><span class="cl">I/flutter ( 7101): build
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的<em>InheritedWidget</em>示例中，可以发现存在3个疑点：</p>
<p>1、对于之前的计数器示例，每次点击<em>FloatingActionButton</em>时仅会触发<em>build</em>方法，而对于<em>InheritedWidget</em>示例，如果目标子<em>Widget</em>是<em>StatefulWidget</em>，那么还会触发<em>State</em>的<em>didChangeDependencies</em>方法，这是为什么呢？</p>
<p>2、如果把<em>InheritedWidget</em>示例中<code>const MyChild()</code>的const修饰去掉，会发生什么？</p>
<p>3、我们知道，子<em>Widget</em>通过<code>MyParent.of</code>方法获取<em>InheritedWidget</em>的实例，使用的是<em>context</em>的<em>dependOnInheritedWidgetOfExactType</em>方法，除此之外还有一个<em>getInheritedWidgetOfExactType</em>方法也可以获取<em>InheritedWidget</em>的实例，那这两个方法之间有什么区别？</p>
<p>关于这3个疑点，等下分析源码时再进行讲解。</p>
<h1 id="四分析inheritedwidget源码">四、分析<em>InheritedWidget</em>源码</h1>
<h2 id="41inheritedelement注册阶段">4.1、<em>InheritedElement</em>注册阶段</h2>
<p>程序启动后，当执行到<em>MyChild</em>关联的<em>State</em>的<em>build</em>方法时，就会调用<em>MyParent.of</em>方法，而<em>InheritedElement</em>注册阶段在于<em>context</em>的<em>dependOnInheritedWidgetOfExactType</em>方法，具体实现在<em>Element</em>，点击进去看下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">?</span> <span class="n">dependOnInheritedWidgetOfExactType</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span><span class="o">&gt;</span><span class="p">({</span><span class="kt">Object</span><span class="o">?</span> <span class="n">aspect</span><span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_debugCheckStateIsActiveForAncestorLookup</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分析1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="n">InheritedElement</span><span class="o">?</span> <span class="n">ancestor</span> <span class="o">=</span> <span class="n">_inheritedElements</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">_inheritedElements</span><span class="o">!</span><span class="p">[</span><span class="n">T</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分析2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dependOnInheritedElement</span><span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="nl">aspect:</span> <span class="n">aspect</span><span class="p">)</span> <span class="o">as</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分析3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_hadUnsatisfiedDependencies</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析1：这里涉及<em>Element</em>的成员变量<code>_inheritedElements</code>，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="n">PersistentHashMap</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">InheritedElement</span><span class="o">&gt;?</span> <span class="n">_inheritedElements</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到<code>_inheritedElements</code>的类型是<em>PersistentHashMap</em>，它是一个键值对的集合，其中<em>Key</em>为<em>Type</em>，这里的<em>Type</em>为<em>InheritedWidget</em>或<em>InheritedWidget</em>的子类，<em>Value</em>为<em>InheritedElement</em>。</p>
<p>在分析1中，首先判断<code>_inheritedElements == null</code>，如果不为null，那么以<em>InheritedWidget</em>类型为<em>Key</em>获取<em>InheritedElement</em>。</p>
<p>那么<code>_inheritedElements</code>是在哪里赋值的？对于非<em>InheritedElement</em>来说，它是在<em>Element</em>的<code>_updateInheritance()</code>方法中赋值，看下它的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_updateInheritance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_lifecycleState</span> <span class="o">==</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">active</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">_inheritedElements</span> <span class="o">=</span> <span class="n">_parent</span><span class="o">?</span><span class="p">.</span><span class="n">_inheritedElements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而对于<em>InheritedElement</em>来说，它是在<em>InheritedElement</em>的<code>_updateInheritance()</code>方法中赋值，看下它的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_updateInheritance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_lifecycleState</span> <span class="o">==</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">active</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">PersistentHashMap</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">InheritedElement</span><span class="o">&gt;</span> <span class="n">incomingWidgets</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">_parent</span><span class="o">?</span><span class="p">.</span><span class="n">_inheritedElements</span> <span class="o">??</span> <span class="kd">const</span> <span class="n">PersistentHashMap</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">InheritedElement</span><span class="o">&gt;</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_inheritedElements</span> <span class="o">=</span> <span class="n">incomingWidgets</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">widget</span><span class="p">.</span><span class="n">runtimeType</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，如果父类的<code>_inheritedElements</code>为<em>null</em>，那么就会创建一个空的<em>PersistentHashMap</em>实例，赋值给局部变量<em>incomingWidgets</em>，然后以<em>InheritedWidget</em>的<em>runtimeType</em>为<em>Key</em>，把当前的<em>InheritedElement</em>作为<em>Value</em>存入该<em>HashMap</em>中。</p>
<p>那么<code>_updateInheritance()</code>方法是在哪里触发的？它是在<em>Element</em>的<em>mount</em>方法中触发的，也就是当<em>InheritedElement</em>添加到<em>Element</em>树时，就会将<em>InheritedElement</em>存入到这个<code>_inheritedElements</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/1.png" alt="" width="535">
<p>以及在<em>Element</em>的<em>activate</em>方法中触发的，也就是当<em>InheritedElement</em>重新合并到<em>Element</em>树时，就会将<em>InheritedElement</em>存入到这个<code>_inheritedElements</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/2.png" alt="" width="535">
<p>现在知道了为什么通过<em>dependOnInheritedWidgetOfExactType</em>方法能够获取距离目标子<em>Widget</em>最近的一个<em>InheritedWidget</em>子类的实例了？</p>
<p>因为<em>InheritedWidget</em>子类的<em>runtimeType</em>作为<em>Key</em>是唯一的，对于相同类型的<em>Key</em>，每次添加<em>InheritedElement</em>进<code>_inheritedElements</code>这个<em>HashMap</em>时会覆盖掉之前的<em>InheritedElement</em>。</p>
<p>分析2：如果以<em>InheritedWidget</em>类型为<em>Key</em>从<em>HashMap</em>中获取的<em>InheritedElement</em>不为<em>null</em>，那么就会执行<em>dependOnInheritedElement</em>方法，看下它的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">InheritedWidget</span> <span class="n">dependOnInheritedElement</span><span class="p">(</span><span class="n">InheritedElement</span> <span class="n">ancestor</span><span class="p">,</span> <span class="p">{</span> <span class="kt">Object</span><span class="o">?</span> <span class="n">aspect</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_dependencies</span> <span class="o">??=</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">InheritedElement</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_dependencies</span><span class="o">!</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">ancestor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ancestor</span><span class="p">.</span><span class="n">updateDependencies</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">aspect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ancestor</span><span class="p">.</span><span class="n">widget</span> <span class="o">as</span> <span class="n">InheritedWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里涉及<em>Element</em>的成员变量<code>_dependencies</code>，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="n">Set</span><span class="o">&lt;</span><span class="n">InheritedElement</span><span class="o">&gt;?</span> <span class="n">_dependencies</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到<code>_dependencies</code>的类型是<em>HashSet</em>，用来存放<em>InheritedElement</em>，为什么用一个<em>Set</em>集合来存放这些<em>InheritedElement</em>呢？</p>
<p>因为当前<em>Element</em>（比如<em>MyChild</em>所关联的<em>StatefulElement</em>）所依赖的<em>InheritedWidget</em>可能不值一个，并且比如多次调用<em>MyParent.of</em>时，<em>Set</em>确保同一个<em>InheritedElement</em>只能添加一次。</p>
<p>在<em>dependOnInheritedElement</em>方法中，如果<code>_dependencies</code>为<em>null</em>，就会创建一个空的<em>HashSet</em>，然后把从<code>_inheritedElements![T]</code>获取的<em>ancestor</em>存入该<em>HashSet</em>。</p>
<p>紧接着执行<em>ancestor</em>（也就是<em>InheritedElement</em>）的<em>updateDependencies</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">updateDependencies</span><span class="p">(</span><span class="n">Element</span> <span class="n">dependent</span><span class="p">,</span> <span class="kt">Object</span><span class="o">?</span> <span class="n">aspect</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">setDependencies</span><span class="p">(</span><span class="n">dependent</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>InheritedElement</em>的<em>updateDependencies</em>方法中，执行了<em>setDependencies</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">setDependencies</span><span class="p">(</span><span class="n">Element</span> <span class="n">dependent</span><span class="p">,</span> <span class="kt">Object</span><span class="o">?</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_dependents</span><span class="p">[</span><span class="n">dependent</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里涉及<em>InheritedElement</em>的成员变量<code>_dependents</code>，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">,</span> <span class="kt">Object</span><span class="o">?&gt;</span> <span class="n">_dependents</span> <span class="o">=</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">,</span> <span class="kt">Object</span><span class="o">?&gt;</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到<code>_dependents</code>的类型是<em>HashMap</em>，也就是一个键值对的集合，其中<em>Key</em>为<em>Element</em>，<em>Value</em>为<em>Object</em>。</p>
<p>将当前<em>Element</em>（此处是<em>MyChild</em>所关联的<em>StatefulElement</em>）作为<em>Key</em>，此时<em>value</em>为null，存入了该<em>HashMap</em>。</p>
<p>目前所讲源码中涉及了3个集合<code>_inheritedElements</code>、<code>_dependencies</code>、<code>_dependents</code>，它们之间的关系如下图。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/三个集合的作用.png" alt="" width="535">
<p>分析3：回到<em>dependOnInheritedWidgetOfExactType</em>方法，如果<code>_inheritedElements == null</code>成立，那么该方法返回<em>null</em>，表示查找不到指定类型的<em>InheritedWidget</em>。</p>
<p>到这里先解释下之前的疑点3：</p>
<blockquote>
<p><em>我们知道，子Widget通过MyParent.of方法获取InheritedWidget的实例，使用的是context的dependOnInheritedWidgetOfExactType方法，除此之外还有一个getInheritedWidgetOfExactType方法也可以获取InheritedWidget的实例，那这两个方法之间有什么区别？</em></p>
</blockquote>
<p>看下<em>getInheritedWidgetOfExactType</em>方法源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">?</span> <span class="n">getInheritedWidgetOfExactType</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">getElementForInheritedWidgetOfExactType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="n">widget</span> <span class="o">as</span> <span class="n">T</span><span class="o">?</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="n">InheritedElement</span><span class="o">?</span> <span class="n">getElementForInheritedWidgetOfExactType</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_debugCheckStateIsActiveForAncestorLookup</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">InheritedElement</span><span class="o">?</span> <span class="n">ancestor</span> <span class="o">=</span> <span class="n">_inheritedElements</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">_inheritedElements</span><span class="o">!</span><span class="p">[</span><span class="n">T</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ancestor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，相比于<em>dependOnInheritedWidgetOfExactType</em>方法，是少了<em>InheritedElement</em>注册部分，所以如果<em>InheritedWidget</em>的状态发生改变，是无法通知子<em>Widget</em>进行重建的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">ancestor</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">dependOnInheritedElement</span><span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="nl">aspect:</span> <span class="n">aspect</span><span class="p">)</span> <span class="o">as</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="42inheritedelement通知更新阶段">4.2、<em>InheritedElement</em>通知更新阶段</h2>
<p>当点击<em>FloatingActionButton</em>时，就会执行<em>setState</em>方法，那么示例中<code>_MyPageState</code>的<em>build</em>方法就会执行。</p>
<p>关于<em>setState</em>方法的分析请参考<a href="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/"><em>解读Flutter源码之setState</em></a>一文，<em>InheritedElement</em>通知更新阶段从<em>BuildOwner</em>的<em>buildScope</em>方法开始讲起。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/3.png" alt="" width="535">
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/4.png" alt="" width="535" style="margin-top: 10px;">
<p>在<em>BuildOwner</em>的<em>buildScope</em>方法的<em>While</em>循环中，当前正在执行<code>element.rebuild()</code>方法，此处<em>element</em>正是<em>MyPage</em>所关联的<em>StatefulElement</em>，注意<em>BuildOwner</em>中的一个布尔值成员变量<code>_scheduledFlushDirtyElements</code>，因为<em>While</em>循环还没执行完，所以不会执行到<em>finally</em>语句（它在<em>finally</em>语句中修改为<em>false</em>），所以布尔值为<em>true</em>，<em>OK</em>，知道这些信息就行。</p>
<p>从<em>MyPage</em>的重建一直到<em>MyParent</em>的重建，中间嵌套太多层了，这部分不会进行讲解，而是从<em>MyParent</em>的重建开始讲起。</p>
<p>当执行到<em>MyParent</em>的重建时，就会执行<em>Element</em>的<em>updateChild</em>方法，因为<em>MyParent</em>不是<em>const</em>修饰，所以每次都会创建一个<em>MyParent</em>新实例，那么<code> if (hasSameSuperclass &amp;&amp; child.widget == newWidget)</code>是不成立的，就会执行下面的<code>else if (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget))</code>，这里<em>MyParent</em>是没有传入<em>Key</em>的，所以满足<em>else if</em>条件。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/5.png" alt="" width="535">
<p>接着执行<code>child.update(newWidget)</code>，也就是执行<em>Element</em>的<em>update</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/6.png" alt="" width="535">
<p>又因为<em>MyParent</em>所关联的<em>Element</em>为<em>InheritedElement</em>，而<em>InheritedElement</em>的父类为<em>ProxyElement</em>，所以执行了<em>ProxyElement</em>的<em>update</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">ProxyWidget</span> <span class="n">newWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">ProxyWidget</span> <span class="n">oldWidget</span> <span class="o">=</span> <span class="n">widget</span> <span class="o">as</span> <span class="n">ProxyWidget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">widget</span> <span class="o">!=</span> <span class="n">newWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">newWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">widget</span> <span class="o">==</span> <span class="n">newWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">updated</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rebuild</span><span class="p">(</span><span class="nl">force:</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>ProxyElement</em>的<em>update</em>方法中，一共做了3件事情：</p>
<p>1、执行<code>super.update(newWidget)</code>，更新<em>InheritedElement</em>所关联的<em>Widget</em>，也就是<em>MyParent</em>。</p>
<p>2、执行<code>updated(oldWidget)</code>方法，这里是执行了<em>InheritedElement</em>的<em>updated</em>方法，看下它的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">updated</span><span class="p">(</span><span class="n">InheritedWidget</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">widget</span> <span class="o">as</span> <span class="n">InheritedWidget</span><span class="p">).</span><span class="n">updateShouldNotify</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">updated</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>InheritedElement</em>的<em>updated</em>方法中，先执行<em>updateShouldNotify</em>方法，也就是我们在<em>MyParent</em>中实现的方法，用于判断是否应该通知继承<em>InheritedWidget</em>的<em>Widget</em>。</p>
<p>如果<em>updateShouldNotify</em>方法返回<em>true</em>，那么执行<code>super.updated(oldWidget)</code>，也就是执行父类<em>ProxyElement</em>的<em>updated</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">updated</span><span class="p">(</span><span class="n">covariant</span> <span class="n">ProxyWidget</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">notifyClients</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>ProxyElement</em>的<em>updated</em>方法中，执行了<em>notifyClients</em>方法，这个方法由子类实现，这里看<em>InheritedElement</em>的<em>notifyClients</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">notifyClients</span><span class="p">(</span><span class="n">InheritedWidget</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_debugCheckOwnerBuildTargetExists</span><span class="p">(</span><span class="s1">&#39;notifyClients&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">final</span> <span class="n">Element</span> <span class="n">dependent</span> <span class="k">in</span> <span class="n">_dependents</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// check that it really is our descendant
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Element</span><span class="o">?</span> <span class="n">ancestor</span> <span class="o">=</span> <span class="n">dependent</span><span class="p">.</span><span class="n">_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="n">ancestor</span> <span class="o">!=</span> <span class="k">this</span> <span class="o">&amp;&amp;</span> <span class="n">ancestor</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ancestor</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">.</span><span class="n">_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">ancestor</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// check that it really depends on us
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">assert</span><span class="p">(</span><span class="n">dependent</span><span class="p">.</span><span class="n">_dependencies</span><span class="o">!</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">notifyDependent</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">,</span> <span class="n">dependent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>InheritedElement</em>的<em>notifyClients</em>方法中，<em>for</em>循环遍历了<code>_dependents</code>的<em>keys</em>，然后在<em>for</em>循环中执行了<em>notifyDependent</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">notifyDependent</span><span class="p">(</span><span class="n">covariant</span> <span class="n">InheritedWidget</span> <span class="n">oldWidget</span><span class="p">,</span> <span class="n">Element</span> <span class="n">dependent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">dependent</span><span class="p">.</span><span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>InheritedElement</em>的<em>notifyDependent</em>方法中，执行了<em>Element</em>的<em>didChangeDependencies</em>方法。因为之前注册的就是我们自己的<em>MyChild</em>所关联的<em>StatefulElement</em>，所以执行的<em>StatefulElement</em>的<em>didChangeDependencies</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">didChangeDependencies</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">super</span><span class="p">.</span><span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_didChangeDependencies</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>StatefulElement</em>的<em>didChangeDependencies</em>方法中，执行了<code>super.didChangeDependencies()</code>，也就是执行了父类<em>Element</em>的<em>didChangeDependencies</em>方法，然后把<code>_didChangeDependencies</code>赋值为<em>true</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">didChangeDependencies</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_lifecycleState</span> <span class="o">==</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">active</span><span class="p">);</span> <span class="c1">// otherwise markNeedsBuild is a no-op
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">assert</span><span class="p">(</span><span class="n">_debugCheckOwnerBuildTargetExists</span><span class="p">(</span><span class="s1">&#39;didChangeDependencies&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">markNeedsBuild</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<em>Element</em>的<em>didChangeDependencies</em>方法中，执行了<em>Element</em>的<em>markNeedsBuild</em>方法，<em>markNeedsBuild</em>方法是老朋友了，它会将<em>Element</em>标记为脏并将其添加到<em>Widget</em>的全局列表中以在下一帧中重建，这里的<em>Element</em>指<em>MyChild</em>所关联的<em>StatefulElement</em>。</p>
<p>在<em>Element</em>的<em>markNeedsBuild</em>方法中，执行了<em>BuildOwner</em>的<em>scheduleBuildFor</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/7.png" alt="" width="535">
<p>在<em>BuildOwner</em>的<em>scheduleBuildFor</em>方法中，执行<code>if (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != null)</code>，还记得之前讲的成员变量<code>_scheduledFlushDirtyElements</code>的值为<em>true</em>吗，这是因为<em>MyParent</em>及其子<em>Widget</em>还没重建完成。</p>
<p>所以<em>if</em>条件不成立，<code>onBuildScheduled!()</code>不会执行，这里只是把<em>MyChild</em>所关联的<em>StatefulElement</em>添加进<code>_dirtyElements</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/8.png" alt="" width="535">
<p>整体上看<em>MyPage</em>的重建已经包括了<em>MyChild</em>的重建，所以这里<em>MyChild</em>的重建是不需要单独放在下一帧去处理了，还是放在<code>_MyPageState</code>最初执行<em>setState</em>时的那一帧进行重建。</p>
<p>此时需要<em>While</em>循环处理的<code>_dirtyElements</code>如下。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/9.png" alt="" width="535">
<p>3、回到<em>ProxyElement</em>的<em>update</em>方法中，接着执行<code>rebuild(force: true)</code>，也就是执行<em>Element</em>的<em>rebuild</em>方法，这个方法是老朋友了，在它的内部会执行<em>performRebuild</em>方法。</p>
<p>因为<em>ComponentElement</em>为<em>ProxyElement</em>的父类，所以这里执行了<em>ComponentElement</em>的<em>performRebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/10.png" alt="" width="535">
<p>在<em>ComponentElement</em>的<em>performRebuild</em>方法中，执行了<em>MyParent</em>所关联的<em>Element</em>的<em>build</em>方法，也就是<em>ProxyElement</em>的<em>build</em>方法，这个<em>build</em>方法就是用来构建<em>MyChild</em>这个<em>Widget</em>的。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/11.png" alt="" width="535">
<p>在<em>ComponentElement</em>的<em>performRebuild</em>方法中，接着执行了<em>Element</em>的<em>updateChild</em>方法。因为<em>MyChild</em>使用<em>const</em>修饰，它相当于一个常量，所以满足<code>if (hasSameSuperclass &amp;&amp; child.widget == newWidget)</code>，然后直接返回之前的<em>Element</em>，也就是<em>MyParent</em>所关联的<em>Element</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/12.png" alt="" width="535">
<p>到这里就解释了之前的疑点2：</p>
<blockquote>
<p><em>如果把InheritedWidget示例中const MyChild()的const修饰去掉，会发生什么？</em></p>
</blockquote>
<p><em>OK</em>，回到最初在<code>_MyPageState</code>中执行<em>setState</em>方法时，它会触发<em>BuildOwner</em>的<em>buildScope</em>方法，在第一轮<em>While</em>循环中，任务是重建<em>MyPage</em>，现在已经循环完了，然后<em>index</em>+1。</p>
<p>下面进入第二轮<em>While</em>循环来重建<em>MyChild</em>，执行了<em>Element</em>的<em>rebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/13.png" alt="" width="535">
<p>之前讲过，在<em>Element</em>的<em>rebuild</em>方法中会执行<em>performRebuild</em>方法，此时执行的就是<em>StatefulElement</em>的<em>performRebuild</em>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">performRebuild</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">_didChangeDependencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_didChangeDependencies</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">super</span><span class="p">.</span><span class="n">performRebuild</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为之前<code>_didChangeDependencies</code>已经赋值为<em>true</em>，所以这里执行了<code>state.didChangeDependencies()</code>，触发了<em>State</em>的<em>didChangeDependencies</em>方法。</p>
<p>到这里就解释了之前的疑点1：</p>
<blockquote>
<p><em>对于之前的计数器示例，每次点击FloatingActionButton时仅会触发build方法，而对于InheritedWidget示例，如果目标子Widget是StatefulWidget，那么还会触发State的didChangeDependencies方法，这是为什么呢？</em></p>
</blockquote>
<p>接着执行<code>super.performRebuild()</code>，调用父类<em>ComponentElement</em>的<em>performRebuild</em>方法，这个方法也是老朋友了，最终会触发<em>MyChild</em>的<em>build</em>方法。</p>
<h2 id="43inheritedelement取消注册阶段">4.3、<em>InheritedElement</em>取消注册阶段</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_lifecycleState</span> <span class="o">==</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">active</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_widget</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span> <span class="c1">// Use the private property to avoid a CastError during hot reload.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">_dependencies</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">_dependencies</span><span class="o">!</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">final</span> <span class="n">InheritedElement</span> <span class="n">dependency</span> <span class="k">in</span> <span class="n">_dependencies</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">dependency</span><span class="p">.</span><span class="n">_dependents</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 为了方便起见，我们实际上并没有清除此处的列表，尽管它不再代表我们注册的内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果我们永远不会被重用，那也没关系。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果这样做，那么我们将在 activate() 中清除该列表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这样做的好处是，它允许 Element 的 activate() 实现根据我们这里是否有依赖关系来决定是否重建。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// For expediency, we don&#39;t actually clear the list here, even though it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// no longer representative of what we are registered with. If we never
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// get re-used, it doesn&#39;t matter. If we do, then we&#39;ll clear the list in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// activate(). The benefit of this is that it allows Element&#39;s activate()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// implementation to decide whether to rebuild based on whether we had
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// dependencies here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">_inheritedElements</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_lifecycleState</span> <span class="o">=</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">inactive</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>InheritedElement</em>取消注册是在<em>Element</em>的<em>deactivate</em>方法，比如当<em>MyChild</em>所关联的<em>Element</em>（也就是<em>StatefulElement</em>）执行了<em>deactivate</em>方法，如果<code>_dependencies</code>不为<em>null</em>且不为空，那么将当前<em>Element</em>从<em>InheritedElement</em>的<code>_dependents</code>中移除。</p>
<p>下次在<em>InheritedElement</em>的<em>notifyClients</em>方法中<em>for</em>循环遍历<code>_dependents</code>的<em>keys</em>时，就无法再通知<em>MyChild</em>所关联的<em>Element</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">notifyClients</span><span class="p">(</span><span class="n">InheritedWidget</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kd">final</span> <span class="n">Element</span> <span class="n">dependent</span> <span class="k">in</span> <span class="n">_dependents</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">notifyDependent</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">,</span> <span class="n">dependent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后执行<code>_inheritedElements = null</code>，把<code>_inheritedElements</code>也置为<em>null</em>。</p>
<p>但是，<code>_dependencies</code>在<em>deactivate</em>方法中是没有被清除的，通过<em>deactivate</em>方法中的注释可以知道，如果<em>Element</em>永远不会被重用，那也没关系。</p>
<p>可以之后在<em>activate</em>方法中清除该列表，这样做的好处是，它允许<em>Element</em>的<em>activate</em>方法实现根据我们这里是否有依赖关系来决定是否重建。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_lifecycleState</span> <span class="o">==</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">inactive</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 是否有依赖关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kd">final</span> <span class="kt">bool</span> <span class="n">hadDependencies</span> <span class="o">=</span> <span class="p">(</span><span class="n">_dependencies</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">_dependencies</span><span class="o">!</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span> <span class="o">||</span> <span class="n">_hadUnsatisfiedDependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_lifecycleState</span> <span class="o">=</span> <span class="n">_ElementLifecycle</span><span class="p">.</span><span class="n">active</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 我们在 deactivate 中注销了我们的依赖项，但从未清除过列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// We unregistered our dependencies in deactivate, but never cleared the list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 由于我们将被重用，所以现在让我们清除我们的列表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Since we&#39;re going to be reused, let&#39;s clear our list now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_dependencies</span><span class="o">?</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">_hadUnsatisfiedDependencies</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_updateInheritance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">attachNotificationTree</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">_dirty</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">owner</span><span class="o">!</span><span class="p">.</span><span class="n">scheduleBuildFor</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果有有依赖关系，执行didChangeDependencies进行重建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">hadDependencies</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="五inheritedwidget扩展">五、<em>InheritedWidget</em>扩展</h1>
<p>除了上面讲的<em>InheritedWidget</em>，其实<em>InheritedWidget</em>还存在一些特定的子类，如下图。</p>
<img title="" src="/img/flutter/解读Flutter源码之InheritedWidget/InheritedWidget扩展.png" alt="" width="335">
<h2 id="51inheritedmodel介绍">5.1、<em>InheritedModel</em>介绍</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 一种 [InheritedWidget]，旨在用作模型的基类，其依赖项可能仅依赖于整个模型的一部分或“方面”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An [InheritedWidget] that&#39;s intended to be used as the base class for models
</span></span></span><span class="line"><span class="cl"><span class="c1">/// whose dependents may only depend on one part or &#34;aspect&#34; of the overall
</span></span></span><span class="line"><span class="cl"><span class="c1">/// model.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当inherited widget根据 [InheritedWidget.updateShouldNotify] 发生更改时，inherited widget的依赖项将无条件重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此widget类似，只是依赖项不会无条件重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An inherited widget&#39;s dependents are unconditionally rebuilt when the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// inherited widget changes per [InheritedWidget.updateShouldNotify]. This
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget is similar except that dependents aren&#39;t rebuilt unconditionally.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 依赖于 [InheritedModel] 的Widgets用一个值来限定其依赖关系，该值指示它们所依赖的模型的“方面”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当重建模型时，依赖项也将被重建，但前提是模型中存在与它们提供的方面相对应的更改。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Widgets that depend on an [InheritedModel] qualify their dependence with a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// value that indicates what &#34;aspect&#34; of the model they depend on. When the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// model is rebuilt, dependents will also be rebuilt, but only if there was a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// change in the model that corresponds to the aspect they provided.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 类型参数“T”是模型方面对象的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The type parameter `T` is the type of the model aspect objects.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Widgets使用静态方法创建对 [InheritedModel] 的依赖：[InheritedModel.inheritFrom]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此方法的“context”参数定义模型更改时将重建的子树。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 通常，“inheritFrom”方法是从特定于模型的静态“maybeOf”或“of”方法调用的，这是许多查找事物的 Flutter 框架类中存在的约定。例如：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Widgets create a dependency on an [InheritedModel] with a static method:
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedModel.inheritFrom]. This method&#39;s `context` parameter defines the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subtree that will be rebuilt when the model changes. Typically the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `inheritFrom` method is called from a model-specific static `maybeOf` or
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `of` methods, a convention that is present in many Flutter framework classes
</span></span></span><span class="line"><span class="cl"><span class="c1">/// which look things up. For example:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyModel extends InheritedModel&lt;String&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const MyModel({super.key, required super.child});
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   // ...
</span></span></span><span class="line"><span class="cl"><span class="c1">///   static MyModel? maybeOf(BuildContext context, [String? aspect]) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return InheritedModel.inheritFrom&lt;MyModel&gt;(context, aspect: aspect);
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   // ...
</span></span></span><span class="line"><span class="cl"><span class="c1">///   static MyModel of(BuildContext context, [String? aspect]) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     final MyModel? result = maybeOf(context, aspect);
</span></span></span><span class="line"><span class="cl"><span class="c1">///     assert(result != null, &#39;Unable to find an instance of MyModel...&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return result!;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 调用 `MyModel.of(context, &#39;foo&#39;)` 或 `MyModel.maybeOf(context, &#39;foo&#39;)` 意味着仅当 `MyModel` 的 `foo` aspect发生更改时才应该重建 `context`。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果“aspect”为空，则模型支持所有aspects。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Calling `MyModel.of(context, &#39;foo&#39;)` or `MyModel.maybeOf(context,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// &#39;foo&#39;)` means that `context` should only be rebuilt when the `foo` aspect of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `MyModel` changes. If the `aspect` is null, then the model supports all
</span></span></span><span class="line"><span class="cl"><span class="c1">/// aspects.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool snippet}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 重建inherited model时， [updateShouldNotify] 和 [updateShouldNotifyDependent] 方法用于决定应该重建什么。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [updateShouldNotify] 返回 true，则针对每个依赖项及其依赖的aspect对象集测试inherited model的 [updateShouldNotifyDependent] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [updateShouldNotify Dependent] 方法必须将aspectj依赖项集与模型本身的更改进行比较。例如：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// When the inherited model is rebuilt the [updateShouldNotify] and
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [updateShouldNotifyDependent] methods are used to decide what should be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuilt. If [updateShouldNotify] returns true, then the inherited model&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [updateShouldNotifyDependent] method is tested for each dependent and the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// set of aspect objects it depends on. The [updateShouldNotifyDependent]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method must compare the set of aspect dependencies with the changes in the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// model itself. For example:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class ABModel extends InheritedModel&lt;String&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const ABModel({
</span></span></span><span class="line"><span class="cl"><span class="c1">///    super.key,
</span></span></span><span class="line"><span class="cl"><span class="c1">///    this.a,
</span></span></span><span class="line"><span class="cl"><span class="c1">///    this.b,
</span></span></span><span class="line"><span class="cl"><span class="c1">///    required super.child,
</span></span></span><span class="line"><span class="cl"><span class="c1">///   });
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final int? a;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final int? b;
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   bool updateShouldNotify(ABModel oldWidget) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return a != oldWidget.a || b != oldWidget.b;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   bool updateShouldNotifyDependent(ABModel oldWidget, Set&lt;String&gt; dependencies) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return (a != oldWidget.a &amp;&amp; dependencies.contains(&#39;a&#39;))
</span></span></span><span class="line"><span class="cl"><span class="c1">///       || (b != oldWidget.b &amp;&amp; dependencies.contains(&#39;b&#39;));
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   // ...
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在前面的示例中，[updateShouldNotify Dependent] 检查的依赖项只是传递给“dependOnInheritedWidgetOfExactType”的aspect字符串。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 它们被表示为一个 [Set]，因为一个 Widget 可以依赖于模型的多个aspect。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果一个widget依赖于模型但没有指定某个aspect，那么模型中的更改将导致widget无条件地重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In the previous example the dependencies checked by
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [updateShouldNotifyDependent] are just the aspect strings passed to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `dependOnInheritedWidgetOfExactType`. They&#39;re represented as a [Set] because
</span></span></span><span class="line"><span class="cl"><span class="c1">/// one Widget can depend on more than one aspect of the model. If a widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// depends on the model but doesn&#39;t specify an aspect, then changes in the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// model will cause the widget to be rebuilt unconditionally.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool dartpad}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此示例演示如何实现 [InheritedModel] 以基于合格的依赖关系重建widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当点击“调整logo”按钮时，仅重建logo widget，而背景widget不受影响。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This example shows how to implement [InheritedModel] to rebuild a widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// based on a qualified dependence. When tapped on the &#34;Resize Logo&#34; button
</span></span></span><span class="line"><span class="cl"><span class="c1">/// only the logo widget is rebuilt while the background widget remains
</span></span></span><span class="line"><span class="cl"><span class="c1">/// unaffected.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ** See code in examples/api/lib/widgets/inherited_model/inherited_model.0.dart **
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InheritedModel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<em>InheritedModel</em>的注释可以知道，<em>InheritedModel</em>相比于<em>InheritedWidget</em>可以更细粒度地控制依赖于<em>InheritedModel</em>的子<em>Widget</em>的重建。</p>
<p>还有一点，我们经常用的媒体查询<em>MediaQuery</em>也是继承自<em>InheritedModel</em>。</p>
<h2 id="52inheritednotifier介绍">5.2、<em>InheritedNotifier</em>介绍</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// [Listenable] [notifier] 的inherited widget，当触发 [notifier] 时更新其依赖项。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An inherited widget for a [Listenable] [notifier], which updates its
</span></span></span><span class="line"><span class="cl"><span class="c1">/// dependencies when the [notifier] is triggered.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这是 [InheritedWidget] 的变体，专门用于 [Listenable] 的子类，例如 [ChangeNotifier] 或 [ValueNotifier]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This is a variant of [InheritedWidget], specialized for subclasses of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [Listenable], such as [ChangeNotifier] or [ValueNotifier].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 每当[notifier]发送通知或每当[notifier]的身份发生变化时，依赖项都会收到通知。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Dependents are notified whenever the [notifier] sends notifications, or
</span></span></span><span class="line"><span class="cl"><span class="c1">/// whenever the identity of the [notifier] changes.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 多个通知被合并，因此即使 [notifier] 在两帧之间触发多次，依赖项也仅重建一次。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Multiple notifications are coalesced, so that dependents only rebuild once
</span></span></span><span class="line"><span class="cl"><span class="c1">/// even if the [notifier] fires multiple times between two frames.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 通常，该类是一个类的子类，该类提供一个“of”静态方法，该方法使用该类调用 [BuildContext.dependOnInheritedWidgetOfExactType]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Typically this class is subclassed with a class that provides an `of` static
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method that calls [BuildContext.dependOnInheritedWidgetOfExactType] with that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [updateShouldNotify] 方法也可以被重写，以在 [notifier] 本身发生更改的情况下更改逻辑。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [notifier] 发生更改，则使用旧的 [notifier] 调用 [updateShouldNotify] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当它返回 true 时，依赖项被标记为需要在该框架中重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The [updateShouldNotify] method may also be overridden, to change the logic
</span></span></span><span class="line"><span class="cl"><span class="c1">/// in the cases where [notifier] itself is changed. The [updateShouldNotify]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method is called with the old [notifier] in the case of the [notifier] being
</span></span></span><span class="line"><span class="cl"><span class="c1">/// changed. When it returns true, the dependents are marked as needing to be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuilt this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool dartpad}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此示例显示了三个旋转方块，它们使用祖先 [InheritedNotifier] (`SpinModel`) 上的notifier的值来进行旋转。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedNotifier] 不需要了解子级，并且 `notifier` 参数不需要是动画控制器，它可以是任何实现 [Listenable] 的东西（如 [ChangeNotifier]）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This example shows three spinning squares that use the value of the notifier
</span></span></span><span class="line"><span class="cl"><span class="c1">/// on an ancestor [InheritedNotifier] (`SpinModel`) to give them their
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rotation. The [InheritedNotifier] doesn&#39;t need to know about the children,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and the `notifier` argument doesn&#39;t need to be an animation controller, it
</span></span></span><span class="line"><span class="cl"><span class="c1">/// can be anything that implements [Listenable] (like a [ChangeNotifier]).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `SpinModel` 类可以轻松地侦听另一个 [Listenable] 对象（例如，保留输入或数据模型值的值的单独对象），并从中获取值。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 后代也不需要拥有 [InheritedNotifier] 的实例即可使用它，他们只需要知道他们的祖先中有一个实例即可。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这有助于将widgets与其模型解耦。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The `SpinModel` class could just as easily listen to another object (say, a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// separate object that keeps the value of an input or data model value) that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// is a [Listenable], and get the value from that. The descendants also don&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1">/// need to have an instance of the [InheritedNotifier] in order to use it, they
</span></span></span><span class="line"><span class="cl"><span class="c1">/// just need to know that there is one in their ancestry. This can help with
</span></span></span><span class="line"><span class="cl"><span class="c1">/// decoupling widgets from their models.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ** See code in examples/api/lib/widgets/inherited_notifier/inherited_notifier.0.dart **
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InheritedNotifier</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Listenable</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<em>InheritedNotifier</em>的注释可以知道，它需要和<em>Listenable</em>一起使用，当触发 <em>notifier</em>时会更新其依赖项。</p>
<h2 id="53inheritedtheme介绍">5.3、<em>InheritedTheme</em>介绍</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 一个 [InheritedWidget]，定义 [child] 子树所依赖的视觉属性，例如颜色和文本样式。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An [InheritedWidget] that defines visual properties like colors
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and text styles, which the [child]&#39;s subtree depends on.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [captureAll] 和 [CapturedThemes.wrap] 使用 [wrap] 方法来构造一个widget，该widget将把子项包装在widget树的指定部分中存在的所有inherited themes中。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The [wrap] method is used by [captureAll] and [CapturedThemes.wrap] to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// construct a widget that will wrap a child in all of the inherited themes
</span></span></span><span class="line"><span class="cl"><span class="c1">/// which are present in a specified part of the widget tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在与其内置环境不同的上下文中显示的widget，就像新路由或overlay的内容一样，将能够看到它所构建的上下文的祖先inherited themes。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// A widget that&#39;s shown in a different context from the one it&#39;s built in,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// like the contents of a new route or an overlay, will be able to see the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ancestor inherited themes of the context it was built in.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool dartpad}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此示例演示了如何使用 InheritedTheme.capture() 来使用inherited themes来包装新route的内容，这些主题在构建route时存在，但在实际显示route时不存在。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This example demonstrates how `InheritedTheme.capture()` can be used
</span></span></span><span class="line"><span class="cl"><span class="c1">/// to wrap the contents of a new route with the inherited themes that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// are present when the route was built - but are not present when route
</span></span></span><span class="line"><span class="cl"><span class="c1">/// is actually shown.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果相同的代码在没有 `InheritedTheme.capture() 的情况下运行，则新route的 Text widget将继承“omething must be wrong”反馈文本样式，而不是 MyApp 中定义的默认文本样式。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// If the same code is run without `InheritedTheme.capture(), the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// new route&#39;s Text widget will inherit the &#34;something must be wrong&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">/// fallback text style, rather than the default text style defined in MyApp.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ** See code in examples/api/lib/widgets/inherited_theme/inherited_theme.0.dart **
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">InheritedTheme</span> <span class="kd">extends</span> <span class="n">InheritedWidget</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过<em>InheritedTheme</em>的注释可以知道，它和主题相关联，比如经常用的<em>Theme.of()</em>，它底层会通过<em>dependOnInheritedWidgetOfExactType</em>方法查询<code>_InheritedTheme</code>实例，而<code>_InheritedTheme</code>继承自<em>InheritedTheme</em>。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">AndDevMK</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-10-31
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-qr-code.JPG">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay-qr-code.JPG">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Banimation/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">解读Flutter源码之Animation</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bkey/">
            <span class="next-text nav-default">解读Flutter源码之Key</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="AndDevMK/blog-utterances"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    
    <div id="search_mask" class="search_mask">
    <div class="search_modal">
        <div id="close_search" class="close_search">关闭</div>
        <div class="search_divider"></div>
        <input id="input_search_key" class="input_search_key" placeholder="请输入你要搜索的内容" tabindex="0">
        <ul id="search_list">
        </ul>
    </div>
</div>

<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>

    <footer id="footer" class="footer">
      

<div class="copyright">
  <span class="power-by">
    由 <a id="hexo-link" class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    
    <span id="run-time" class="run-time"></span> 
    <span class="heart"><i class="iconfont icon-heart"></i></span>
    &copy; 
    2023&nbsp;
    <span>AndDevMK</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.11a4ba15caf2d921d57eaf6568c4ad21eafd5d2c001cbcb31693586c63f93005.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?6db179fb88e600cf326b0515a8aa1de3";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>




<script src="/js/codecopy.js"></script>



<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css"></link>
<script src="/js/dark.js"></script>


<script src="/js/site_runtime.js"></script>




</body>
</html>
