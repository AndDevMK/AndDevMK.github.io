<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>解读Flutter源码之StatefulWidget&amp;State的生命周期 - AndDevMK&#39;s android blog site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AndDevMK" /><meta name="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。 因此，本文将会深入分析StatefulWidget的源码&amp;am" /><meta name="keywords" content="Android, Java, Kotlin, C&#43;&#43;, C, Flutter, Dart, NDK" />


<meta name="baidu-site-verification" content="codeva-wQ7uOo4V09" />
<meta name="google-site-verification" content="yHzWB9BxTR74LiaUhuL5ncr89fnDYXiplTaPY565zqo" />


<meta name="generator" content="Hugo 0.111.3 with theme even" />


<link rel="canonical" href="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c11aaf02bef1025d6b0813ba5e1a8a8551aee15fa8f2bcea906d41b20bdf5c69.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">
<link rel="stylesheet" href="/css/codecopy.css">


<meta property="og:title" content="解读Flutter源码之StatefulWidget&amp;State的生命周期" />
<meta property="og:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。 因此，本文将会深入分析StatefulWidget的源码&am" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-10-18T11:28:31+08:00" />
<meta property="article:modified_time" content="2023-10-18T11:28:31+08:00" />
<meta itemprop="name" content="解读Flutter源码之StatefulWidget&amp;State的生命周期">
<meta itemprop="description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。 因此，本文将会深入分析StatefulWidget的源码&am"><meta itemprop="datePublished" content="2023-10-18T11:28:31+08:00" />
<meta itemprop="dateModified" content="2023-10-18T11:28:31+08:00" />
<meta itemprop="wordCount" content="22249">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="解读Flutter源码之StatefulWidget&amp;State的生命周期"/>
<meta name="twitter:description" content="注：本文代码基于Flutter SDK 3.13.5 一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。 因此，本文将会深入分析StatefulWidget的源码&am"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AndDevMK</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>

    
    <li class="mobile-menu-item-search">
      <div id="mobile_open_search" class="mobile_open_search">
        搜索
      </div>
    </li>

    
    <li class="mobile-menu-item-dark-mode">
      <div id="mobile_dark_mode_toggle" class="mobile_light_mode">
       
      </div>
    </li>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AndDevMK</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
    
    <div id="open_search" class="open_search">
      搜索
    </div>

    
    <div id="dark_mode_toggle" class="light_mode">

    </div>
  
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">解读Flutter源码之StatefulWidget&amp;State的生命周期</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-10-18 </span>
        <div class="post-category">
            <a href="/categories/flutter/"> Flutter </a>
            </div>
          <span class="more-meta"> 约 22249 字 </span>
          <span class="more-meta"> 预计阅读 45 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一前言">一、前言</a></li>
    <li><a href="#二分析statefulwidget源码">二、分析<em>StatefulWidget</em>源码</a></li>
    <li><a href="#三分析statefulelement源码">三、分析<em>StatefulElement</em>源码</a></li>
    <li><a href="#四分析state源码">四、分析<em>State</em>源码</a>
      <ul>
        <li><a href="#41initstate方法">4.1、<em>initState</em>方法</a></li>
        <li><a href="#42didchangedependencies方法">4.2、<em>didChangeDependencies</em>方法</a></li>
        <li><a href="#43build方法">4.3、<em>build</em>方法</a></li>
        <li><a href="#44didupdatewidget方法">4.4、<em>didUpdateWidget</em>方法</a></li>
        <li><a href="#45deactivate方法">4.5、<em>deactivate</em>方法</a></li>
        <li><a href="#46dispose方法">4.6、<em>dispose</em>方法</a></li>
        <li><a href="#47setstate方法">4.7、<em>setState</em>方法</a></li>
        <li><a href="#48reassemble方法">4.8、<em>reassemble</em>方法</a></li>
      </ul>
    </li>
    <li><a href="#五state生命周期示例">五、<em>State</em>生命周期示例</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><em>注：本文代码基于Flutter SDK 3.13.5</em></p>
</blockquote>
<h1 id="一前言">一、前言</h1>
<p>在上一文<a href="https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/"><em>解读Flutter源码之runApp</em></a>中，笔者对于<em>StatefulWidget</em>与<em>StatefulElement</em>源码的分析并未足够深入，而且<em>State</em>相关的分析也并未涉及。</p>
<p>因此，本文将会深入分析<em>StatefulWidget</em>的源码&amp;<em>State</em>的生命周期。</p>
<h1 id="二分析statefulwidget源码">二、分析<em>StatefulWidget</em>源码</h1>
<p>看一个类的源码，最先入手方向应该是它的注释，因为官方<em>document</em>也是通过代码注释生成的，所以先看下<em>StatefulWidget</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 一个具有可变状态的widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// A widget that has mutable state.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// State is information that (1) can be read synchronously when the widget is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// built and (2) might change during the lifetime of the widget. It is the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// responsibility of the widget implementer to ensure that the [State] is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// promptly notified when such state changes, using [State.setState].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 一个stateful widget是“通过构建更具体地描述用户界面的其它widgets的一个星座”来描述用户界面的一部分的一个widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 构建过程递归地继续，直到用户界面的描述完全具体（例如，完全由 [RenderObjectWidget]s 组成，它描述具体的 [RenderObject]s）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// A stateful widget is a widget that describes part of the user interface by
</span></span></span><span class="line"><span class="cl"><span class="c1">/// building a constellation of other widgets that describe the user interface
</span></span></span><span class="line"><span class="cl"><span class="c1">/// more concretely. The building process continues recursively until the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// description of the user interface is fully concrete (e.g., consists
</span></span></span><span class="line"><span class="cl"><span class="c1">/// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当您描述的用户界面部分可以动态更改时，Stateful widgets非常有用，例如由于具有内部时钟驱动状态，或取决于某些系统状态。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 对于仅依赖于对象本身的配置信息和widget在其中填充的 [BuildContext] 的组合，请考虑使用 [StatelessWidget]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Stateful widgets are useful when the part of the user interface you are
</span></span></span><span class="line"><span class="cl"><span class="c1">/// describing can change dynamically, e.g. due to having an internal
</span></span></span><span class="line"><span class="cl"><span class="c1">/// clock-driven state, or depending on some system state. For compositions that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// depend only on the configuration information in the object itself and the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [BuildContext] in which the widget is inflated, consider using
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatelessWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@youtube 560 315 https://www.youtube.com/watch?v=AqCMFXEmf3w}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] 实例本身是不可变的，并将其可变状态存储在由 [createState] 方法创建的单独 [State] 对象中，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 或者存储在 [State] 订阅的对象中，例如 [Stream] 或 [ChangeNotifier] 对象，其引用存储在 [StatefulWidget] 本身的final字段中。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] instances themselves are immutable and store their mutable
</span></span></span><span class="line"><span class="cl"><span class="c1">/// state either in separate [State] objects that are created by the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [createState] method, or in objects to which that [State] subscribes, for
</span></span></span><span class="line"><span class="cl"><span class="c1">/// example [Stream] or [ChangeNotifier] objects, to which references are stored
</span></span></span><span class="line"><span class="cl"><span class="c1">/// in final fields on the [StatefulWidget] itself.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 每当框架填充 [StatefulWidget] 时，框架都会调用 [createState]，这意味着如果该widget已插入树中的多个位置，则多个 [State] 对象可能与同一个 [StatefulWidget] 关联。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [createState] 来创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework calls [createState] whenever it inflates a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget], which means that multiple [State] objects might be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// associated with the same [StatefulWidget] if that widget has been inserted
</span></span></span><span class="line"><span class="cl"><span class="c1">/// into the tree in multiple places. Similarly, if a [StatefulWidget] is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// removed from the tree and later inserted in to the tree again, the framework
</span></span></span><span class="line"><span class="cl"><span class="c1">/// will call [createState] again to create a fresh [State] object, simplifying
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the lifecycle of [State] objects.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [StatefulWidget] 的创建者使用 [GlobalKey] 作为其 [key]，那么当它从树中的一个位置移动到另一个位置时，[StatefulWidget] 会保留相同的 [State] 对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 由于具有 [GlobalKey] 的widget最多可在树中的一个位置使用，因此使用 [GlobalKey] 的widget最多具有一个关联element。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当将具有全局键的widget从树中的一个位置移动到另一个位置时，框架利用此属性，将与该widget相关联的（唯一）子树从旧位置移植到新位置（而不是在新位置重新创建子树）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 与 [StatefulWidget] 关联的 [State] 对象与子树的其余部分一起嫁接，这意味着 [State] 对象在新位置重用（而不是重新创建）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 但是，为了符合嫁接的条件，必须将widget插入到从旧位置删除的同一动画帧中的新位置。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// A [StatefulWidget] keeps the same [State] object when moving from one
</span></span></span><span class="line"><span class="cl"><span class="c1">/// location in the tree to another if its creator used a [GlobalKey] for its
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [key]. Because a widget with a [GlobalKey] can be used in at most one
</span></span></span><span class="line"><span class="cl"><span class="c1">/// location in the tree, a widget that uses a [GlobalKey] has at most one
</span></span></span><span class="line"><span class="cl"><span class="c1">/// associated element. The framework takes advantage of this property when
</span></span></span><span class="line"><span class="cl"><span class="c1">/// moving a widget with a global key from one location in the tree to another
</span></span></span><span class="line"><span class="cl"><span class="c1">/// by grafting the (unique) subtree associated with that widget from the old
</span></span></span><span class="line"><span class="cl"><span class="c1">/// location to the new location (instead of recreating the subtree at the new
</span></span></span><span class="line"><span class="cl"><span class="c1">/// location). The [State] objects associated with [StatefulWidget] are grafted
</span></span></span><span class="line"><span class="cl"><span class="c1">/// along with the rest of the subtree, which means the [State] object is reused
</span></span></span><span class="line"><span class="cl"><span class="c1">/// (instead of being recreated) in the new location. However, in order to be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// eligible for grafting, the widget must be inserted into the new location in
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the same animation frame in which it was removed from the old location.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 性能考虑
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## Performance considerations
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget]s 有两个主要类别。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// There are two primary categories of [StatefulWidget]s.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 第一类是在[State.initState]中分配资源并在[State.dispose]中处理资源，但不依赖于[InheritedWidget]s或调用[State.setState]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此类widgets通常在应用程序或页面的根部使用，并通过 [ChangeNotifier]、[Stream] 或其它此类对象与子widget进行通信。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 遵循这种模式的Stateful widgets相对便宜（就 CPU 和 GPU 周期而言），因为它们构建一次就不再更新。因此，他们可以有一些复杂和深入的构建方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The first is one which allocates resources in [State.initState] and disposes
</span></span></span><span class="line"><span class="cl"><span class="c1">/// of them in [State.dispose], but which does not depend on [InheritedWidget]s
</span></span></span><span class="line"><span class="cl"><span class="c1">/// or call [State.setState]. Such widgets are commonly used at the root of an
</span></span></span><span class="line"><span class="cl"><span class="c1">/// application or page, and communicate with subwidgets via [ChangeNotifier]s,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [Stream]s, or other such objects. Stateful widgets following such a pattern
</span></span></span><span class="line"><span class="cl"><span class="c1">/// are relatively cheap (in terms of CPU and GPU cycles), because they are
</span></span></span><span class="line"><span class="cl"><span class="c1">/// built once then never update. They can, therefore, have somewhat complicated
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and deep build methods.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 第二类是使用 [State.setState] 或依赖于 [InheritedWidget]s 的widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 这些通常会在应用程序的生命周期内重建多次，因此最小化重建此类widget的影响非常重要。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// （它们也可以使用 [State.initState] 或 [State.didChangeDependency] 并分配资源，但重要的部分是它们重建。）
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The second category is widgets that use [State.setState] or depend on
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedWidget]s. These will typically rebuild many times during the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// application&#39;s lifetime, and it is therefore important to minimize the impact
</span></span></span><span class="line"><span class="cl"><span class="c1">/// of rebuilding such a widget. (They may also use [State.initState] or
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State.didChangeDependencies] and allocate resources, but the important part
</span></span></span><span class="line"><span class="cl"><span class="c1">/// is that they rebuild.)
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 有几种技术可以用来最小化重建stateful widget的影响：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// There are several techniques one can use to minimize the impact of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuilding a stateful widget:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 将状态推送到叶子。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    例如，如果您的页面有一个滴答作响的时钟，则不要将状态放在页面顶部并在每次时钟滴答时重建整个页面，而是创建一个仅更新自身的专用时钟widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * Push the state to the leaves. For example, if your page has a ticking
</span></span></span><span class="line"><span class="cl"><span class="c1">///    clock, rather than putting the state at the top of the page and
</span></span></span><span class="line"><span class="cl"><span class="c1">///    rebuilding the entire page each time the clock ticks, create a dedicated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="c1">///    clock widget that only updates itself.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 最小化由build方法及其创建的任何widgets传递创建的节点数量。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    理想情况下，stateful widget只会创建一个小部件，并且该widget将是一个 [RenderObjectWidget]。 （显然这并不总是实用，但是widget越接近这个理想，它的效率就越高。）
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * Minimize the number of nodes transitively created by the build method and
</span></span></span><span class="line"><span class="cl"><span class="c1">///    any widgets it creates. Ideally, a stateful widget would only create a
</span></span></span><span class="line"><span class="cl"><span class="c1">///    single widget, and that widget would be a [RenderObjectWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///    (Obviously this isn&#39;t always practical, but the closer a widget gets to
</span></span></span><span class="line"><span class="cl"><span class="c1">///    this ideal, the more efficient it will be.)
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果子树没有更改，则缓存代表该子树的widget，并在每次可以使用时重新使用它。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    为此，请将widget分配给“final”状态变量并在构建方法中重新使用它。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    重用widget比创建新的（但配置相同的）widget要高效得多。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    另一种缓存策略是将widget的可变部分提取到接受子参数的 [StatefulWidget] 中。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If a subtree does not change, cache the widget that represents that
</span></span></span><span class="line"><span class="cl"><span class="c1">///    subtree and re-use it each time it can be used. To do this, assign
</span></span></span><span class="line"><span class="cl"><span class="c1">///    a widget to a `final` state variable and re-use it in the build method. It
</span></span></span><span class="line"><span class="cl"><span class="c1">///    is massively more efficient for a widget to be re-used than for a new (but
</span></span></span><span class="line"><span class="cl"><span class="c1">///    identically-configured) widget to be created. Another caching strategy
</span></span></span><span class="line"><span class="cl"><span class="c1">///    consists in extracting the mutable part of the widget into a [StatefulWidget]
</span></span></span><span class="line"><span class="cl"><span class="c1">///    which accepts a child parameter.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 尽可能使用“const” widget。 （这相当于缓存一个widget并重新使用它。）
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * Use `const` widgets where possible. (This is equivalent to caching a
</span></span></span><span class="line"><span class="cl"><span class="c1">///    widget and re-using it.)
</span></span></span><span class="line"><span class="cl"><span class="c1">///  
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 避免更改任何创建的子树的深度或更改子树中任何widget的类型。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    例如，不要返回子控件或包装在[IgnorePointer]中的子控件，而是始终将子控件包装在[IgnorePointer]中并控制[IgnorePointer.ignoring]属性。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    这是因为更改子树的深度需要重新构建、布局和绘制整个子树，而仅更改属性将需要对渲染树进行最小可能的更改（例如，在[IgnorePointer]的情况下，根本不需要布局或重新绘制）。   
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * Avoid changing the depth of any created subtrees or changing the type of
</span></span></span><span class="line"><span class="cl"><span class="c1">///    any widgets in the subtree. For example, rather than returning either the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    child or the child wrapped in an [IgnorePointer], always wrap the child
</span></span></span><span class="line"><span class="cl"><span class="c1">///    widget in an [IgnorePointer] and control the [IgnorePointer.ignoring]
</span></span></span><span class="line"><span class="cl"><span class="c1">///    property. This is because changing the depth of the subtree requires
</span></span></span><span class="line"><span class="cl"><span class="c1">///    rebuilding, laying out, and painting the entire subtree, whereas just
</span></span></span><span class="line"><span class="cl"><span class="c1">///    changing the property will require the least possible change to the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    render tree (in the case of [IgnorePointer], for example, no layout or
</span></span></span><span class="line"><span class="cl"><span class="c1">///    repaint is necessary at all).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果由于某种原因必须更改深度，请考虑将子树的公共部分包装在具有 [GlobalKey] 的小部件中，该 [GlobalKey] 在stateful widget的生命周期中保持一致。
</span></span></span><span class="line"><span class="cl"><span class="c1">///   （如果没有其它widget可以方便地分配key，则 [KeyedSubtree] widget可能对此很有用。）
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If the depth must be changed for some reason, consider wrapping the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    common parts of the subtrees in widgets that have a [GlobalKey] that
</span></span></span><span class="line"><span class="cl"><span class="c1">///    remains consistent for the life of the stateful widget. (The
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [KeyedSubtree] widget may be useful for this purpose if no other widget
</span></span></span><span class="line"><span class="cl"><span class="c1">///    can conveniently be assigned the key.)
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@macro flutter.flutter.widgets.framework.prefer_const_over_helper}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This video gives more explanations on why `const` constructors are important
</span></span></span><span class="line"><span class="cl"><span class="c1">/// and why a [Widget] is better than a helper method.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// For more details on the mechanics of rebuilding a widget, see
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the discussion at [Element.rebuild].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool snippet}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This is a skeleton of a stateful widget subclass called `YellowBird`.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In this example, the [State] has no actual state. State is normally
</span></span></span><span class="line"><span class="cl"><span class="c1">/// represented as private member fields. Also, normally widgets have more
</span></span></span><span class="line"><span class="cl"><span class="c1">/// constructor arguments, each of which corresponds to a `final` property.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class YellowBird extends StatefulWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const YellowBird({ super.key });
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   State&lt;YellowBird&gt; createState() =&gt; _YellowBirdState();
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class _YellowBirdState extends State&lt;YellowBird&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return Container(color: const Color(0xFFFFE306));
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@tool snippet}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This example shows the more generic widget `Bird` which can be given a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// color and a child, and which has some internal state with a method that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// can be called to mutate it:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class Bird extends StatefulWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const Bird({
</span></span></span><span class="line"><span class="cl"><span class="c1">///     super.key,
</span></span></span><span class="line"><span class="cl"><span class="c1">///     this.color = const Color(0xFFFFE306),
</span></span></span><span class="line"><span class="cl"><span class="c1">///     this.child,
</span></span></span><span class="line"><span class="cl"><span class="c1">///   });
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final Color color;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final Widget? child;
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   State&lt;Bird&gt; createState() =&gt; _BirdState();
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class _BirdState extends State&lt;Bird&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   double _size = 1.0;
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   void grow() {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     setState(() { _size += 0.1; });
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return Container(
</span></span></span><span class="line"><span class="cl"><span class="c1">///       color: widget.color,
</span></span></span><span class="line"><span class="cl"><span class="c1">///       transform: Matrix4.diagonal3Values(_size, _size, 1.0),
</span></span></span><span class="line"><span class="cl"><span class="c1">///       child: widget.child,
</span></span></span><span class="line"><span class="cl"><span class="c1">///     );
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@end-tool}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 按照惯例，widget构造函数仅使用命名参数。同样按照约定，第一个参数是 [key]，最后一个参数是 `child`、`children` 或等效参数。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// By convention, widget constructors only use named arguments. Also by
</span></span></span><span class="line"><span class="cl"><span class="c1">/// convention, the first argument is [key], and the last argument is `child`,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `children`, or the equivalent.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<em>StatefulWidget</em>的注释还是比较多的，这也恰恰反映了它的一个重要性，毕竟平时用它比较多。在<em>StatefulWidget</em>注释当中，它想尽可能地为<em>API</em>使用者讲明白<em>StatefulWidget</em>是什么，因此这不仅有常规的介绍，而且也有出于性能优化的一个考虑（目前来说，性能优化这块并不是本文的重点），以及最后还贴心地给出了使用示例，下面总结下<em>StatefulWidget</em>的特性：</p>
<p>1、<em>StatefulWidget</em>实例本身是不可变的，它是将其可变状态存储在由<em>createState</em>方法创建的单独 <em>State</em>对象中。</p>
<p>2、将<em>StatefulWidget</em>插入到树中的多个位置时，会创建多个单独的<em>State</em>实例；如果 <em>StatefulWidget</em>从树中删除，然后再次插入到树中，框架将再次调用<em>createState</em>来创建一个新的 <em>State</em>对象。</p>
<p>3、<em>StatefulWidget</em>的实现者在状态更改时可以使用<em>State.setState</em>及时通知<em>State</em>。</p>
<p>4、如果<em>StatefulWidget</em>的创建者使用<em>GlobalKey</em>作为其<em>key</em>，那么当它从树中的一个位置移动到另一个位置时，<em>StatefulWidget</em>会保留相同的<em>State</em>对象。</p>
<p>5、&hellip;</p>
<p>这里给出了<em>StatefulWidget</em>的部分特性，主要是想让大家对<em>StatefulWidget</em>有一个初级认知，至于更多的特性需要从<em>Flutter</em>框架源码中去挖掘，这个任务留给个人自行去探索了。</p>
<p><em>OK</em>，我们继续看<em>StatefulWidget</em>的源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">StatefulWidget</span> <span class="kd">extends</span> <span class="n">Widget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">StatefulWidget</span><span class="p">({</span> <span class="k">super</span><span class="p">.</span><span class="n">key</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 创建一个StatefulElement来管理此widget在树中的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Creates a [StatefulElement] to manage this widget&#39;s location in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 子类重写此方法的情况并不常见。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// It is uncommon for subclasses to override this method.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">StatefulElement</span> <span class="n">createElement</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">StatefulElement</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// 在树中的给定位置为此widget创建可变状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Creates the mutable state for this widget at a given location in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 子类应该重写此方法以返回其关联State子类的新创建的实例：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// Subclasses should override this method to return a newly created
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// instance of their associated [State] subclass:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// @override
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// State&lt;SomeWidget&gt; createState() =&gt; _SomeWidgetState();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 框架可以在StatefulWidget的生命周期内多次调用此方法。例如，如果widget被插入树中的多个位置，框架将为每个位置创建一个单独的State对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// 类似地，如果widget从树中删除，然后再次插入到树中，框架将再次调用createState来创建一个新的State对象，从而简化State对象的生命周期
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// The framework can call this method multiple times over the lifetime of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// a [StatefulWidget]. For example, if the widget is inserted into the tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// in multiple locations, the framework will create a separate [State] object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// for each location. Similarly, if the widget is removed from the tree and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// later inserted into the tree again, the framework will call [createState]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// again to create a fresh [State] object, simplifying the lifecycle of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [State] objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="kd">factory</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span> <span class="n">createState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从<em>StatefulWidget</em>的源码可以知道，它继承自抽象类<em>Widget</em>，重写了<em>createElement</em>方法，返回一个<em>StatefulElement</em>实例，并且在<em>Widget</em>的基础上新增了一个<em>createState</em>抽象方法，用于返回一个State实例。</p>
<p>这两个方法的功能从注释中也可以看的明明白白，关于<em>StatefulWidget</em>的分析先讲到这里。</p>
<h1 id="三分析statefulelement源码">三、分析<em>StatefulElement</em>源码</h1>
<p>先看下<em>StatefulElement</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 使用 [StatefulWidget] 作为其配置的 [Element]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An [Element] that uses a [StatefulWidget] as its configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">class</span> <span class="nc">StatefulElement</span> <span class="kd">extends</span> <span class="n">ComponentElement</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<em>StatefulElement</em>的注释非常简要，从注释中并不能看出该<em>Element</em>的特性所在，不过可以知道的是<em>StatefulElement</em>继承自<em>ComponentElement</em>，那么来看下<em>ComponentElement</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 组成其它[Element]s的一个[Element].
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An [Element] that composes other [Element]s.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ComponentElement不是直接创建RenderObject ，而是通过创建其它Element来间接创建RenderObject 
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Rather than creating a [RenderObject] directly, a [ComponentElement] creates
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [RenderObject]s indirectly by creating other [Element]s.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 与RenderObjectElement对比
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Contrast with [RenderObjectElement].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ComponentElement</span> <span class="kd">extends</span> <span class="n">Element</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<em>ComponentElement</em>属于组合型<em>Element</em>，它不是直接创建<em>RenderObject</em>，而是通过创建其它<em>Element</em>来间接创建<em>RenderObject</em>，并且<em>ComponentElement</em>继承自<em>Element</em>，那么来看下<em>Element</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 树中特定位置的 [Widget] 实例。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An instantiation of a [Widget] at a particular location in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Widgets描述了如何配置子树，但同一个widget可用于同时配置多个子树，因为widgets是不可变的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [Element]表示使用widget来配置树中的特定位置。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 随着时间的推移，与给定Element关联的widget可能会发生变化，例如，如果父widget重建并为此位置创建新的widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Widgets describe how to configure a subtree but the same widget can be used
</span></span></span><span class="line"><span class="cl"><span class="c1">/// to configure multiple subtrees simultaneously because widgets are immutable.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// An [Element] represents the use of a widget to configure a specific location
</span></span></span><span class="line"><span class="cl"><span class="c1">/// in the tree. Over time, the widget associated with a given element can
</span></span></span><span class="line"><span class="cl"><span class="c1">/// change, for example, if the parent widget rebuilds and creates a new widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// for this location.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Elements形成一棵树。大多数elements都有一个唯一的子元素，但某些widgets（例如 [RenderObjectElement] 的子类）可以有多个子元素。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Elements form a tree. Most elements have a unique child, but some widgets
</span></span></span><span class="line"><span class="cl"><span class="c1">/// (e.g., subclasses of [RenderObjectElement]) can have multiple children.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Elements具有以下生命周期：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Elements have the following lifecycle:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 框架通过在将用作element初始配置的widget上调用 [Widget.createElement] 来创建一个element。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The framework creates an element by calling [Widget.createElement] on the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    widget that will be used as the element&#39;s initial configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 框架调用 [mount] 将新创建的element添加到给定父级中给定槽处的树中。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [mount] 方法负责填充任何子widgets，并根据需要调用 [attachRenderObject] 将任何关联的渲染对象附加到渲染树。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The framework calls [mount] to add the newly created element to the tree
</span></span></span><span class="line"><span class="cl"><span class="c1">///    at a given slot in a given parent. The [mount] method is responsible for
</span></span></span><span class="line"><span class="cl"><span class="c1">///    inflating any child widgets and calling [attachRenderObject] as
</span></span></span><span class="line"><span class="cl"><span class="c1">///    necessary to attach any associated render objects to the render tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///  
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此时，该element被认为是“active”并且可能出现在屏幕上。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At this point, the element is considered &#34;active&#34; and might appear on
</span></span></span><span class="line"><span class="cl"><span class="c1">///    screen.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在某些时候，父级可能决定更改用于配置此element的widget，例如因为父级使用新状态进行了重建。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    发生这种情况时，框架将使用新的widget调用 [update]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    新的widget将始终具有与旧widget相同的 [runtimeType] 和键。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    如果父级希望更改树中此位置的widget的 [runtimeType] 或键，则可以通过卸载此element并在此位置填充新widget来实现。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At some point, the parent might decide to change the widget used to
</span></span></span><span class="line"><span class="cl"><span class="c1">///    configure this element, for example because the parent rebuilt with new
</span></span></span><span class="line"><span class="cl"><span class="c1">///    state. When this happens, the framework will call [update] with the new
</span></span></span><span class="line"><span class="cl"><span class="c1">///    widget. The new widget will always have the same [runtimeType] and key as
</span></span></span><span class="line"><span class="cl"><span class="c1">///    old widget. If the parent wishes to change the [runtimeType] or key of
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the widget at this location in the tree, it can do so by unmounting this
</span></span></span><span class="line"><span class="cl"><span class="c1">///    element and inflating the new widget at this location.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在某些时候，祖先可能决定从树中删除此element（或中间祖先），祖先通过调用 [deactivateChild] 本身来完成此操作。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    停用中间祖先将从渲染树中删除该element的渲染对象，并将该element添加到 [owner] 的非活动element列表中，从而导致框架对此element调用 [deactivate]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At some point, an ancestor might decide to remove this element (or an
</span></span></span><span class="line"><span class="cl"><span class="c1">///    intermediate ancestor) from the tree, which the ancestor does by calling
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [deactivateChild] on itself. Deactivating the intermediate ancestor will
</span></span></span><span class="line"><span class="cl"><span class="c1">///    remove that element&#39;s render object from the render tree and add this
</span></span></span><span class="line"><span class="cl"><span class="c1">///    element to the [owner]&#39;s list of inactive elements, causing the framework
</span></span></span><span class="line"><span class="cl"><span class="c1">///    to call [deactivate] on this element.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此时，该元素被视为“inactive”并且不会出现在屏幕上。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    element只能保持inactive状态直到当前动画帧结束。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    在动画帧结束时，任何仍处于非活动状态的elements都将被卸载。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At this point, the element is considered &#34;inactive&#34; and will not appear
</span></span></span><span class="line"><span class="cl"><span class="c1">///    on screen. An element can remain in the inactive state only until
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the end of the current animation frame. At the end of the animation
</span></span></span><span class="line"><span class="cl"><span class="c1">///    frame, any elements that are still inactive will be unmounted.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果该element被重新合并到树中（例如，因为它或其祖先之一具有可重用的global key），
</span></span></span><span class="line"><span class="cl"><span class="c1">///    框架将从 [owner] 的非活动element列表中删除该element，对该element调用 [activate]，并将该element的渲染对象重新附加到渲染树。
</span></span></span><span class="line"><span class="cl"><span class="c1">///   （此时，该element再次被视为“active”并且可能出现在屏幕上。）
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If the element gets reincorporated into the tree (e.g., because it or one
</span></span></span><span class="line"><span class="cl"><span class="c1">///    of its ancestors has a global key that is reused), the framework will
</span></span></span><span class="line"><span class="cl"><span class="c1">///    remove the element from the [owner]&#39;s list of inactive elements, call
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [activate] on the element, and reattach the element&#39;s render object to
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the render tree. (At this point, the element is again considered &#34;active&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1">///    and might appear on screen.)
</span></span></span><span class="line"><span class="cl"><span class="c1">///  
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果在当前动画帧结束时该element没有重新合并到树中，框架将对该element调用 [unmount]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If the element does not get reincorporated into the tree by the end of
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the current animation frame, the framework will call [unmount] on the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    element.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此时，该element被视为“defunct”，并且将来不会合并到树中。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At this point, the element is considered &#34;defunct&#34; and will not be
</span></span></span><span class="line"><span class="cl"><span class="c1">///    incorporated into the tree in the future.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，<em>Element</em>的注释还是挺多的，大部分是描述了它的生命周期。</p>
<p><em>OK</em>，结合<em>StatefulElement</em>、<em>ComponentElement</em>以及<em>Element</em>三者的注释，总结一下<em>StatefulElement</em>的特性：</p>
<p>1、<em>StatefulWidget</em>为<em>StatefulElement</em>提供配置，而<em>StatefulElement</em>则是树中特定位置的<em>StatefulWidget</em>实例。</p>
<p>2、<em>StatefulElement</em>用来组成其它<em>Element</em>，是一种组合型的<em>Element</em>，<em>StatefulElement</em>不是直接创建<em>RenderObject</em>，而是通过创建其它<em>Element</em>来间接创建<em>RenderObject</em>。</p>
<p>3、&hellip;</p>
<p>这里给出了<em>StatefulElement</em>的部分特性，余下的留给个人去探索。<em>OK</em>，继续看下<em>StatefulElement</em>的部分源码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">StatefulElement</span> <span class="kd">extends</span> <span class="n">ComponentElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">/// Creates an element that uses the given widget as its configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">StatefulElement</span><span class="p">(</span><span class="n">StatefulWidget</span> <span class="n">widget</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">_state</span> <span class="o">=</span> <span class="n">widget</span><span class="p">.</span><span class="n">createState</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="k">super</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">.</span><span class="n">_debugTypesAreRight</span><span class="p">(</span><span class="n">widget</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">FlutterError</span><span class="p">.</span><span class="n">fromParts</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DiagnosticsNode</span><span class="o">&gt;</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">          <span class="n">ErrorSummary</span><span class="p">(</span><span class="s1">&#39;StatefulWidget.createState must return a subtype of State&lt;</span><span class="si">${</span><span class="n">widget</span><span class="p">.</span><span class="n">runtimeType</span><span class="si">}</span><span class="s1">&gt;&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="n">ErrorDescription</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;The createState function for </span><span class="si">${</span><span class="n">widget</span><span class="p">.</span><span class="n">runtimeType</span><span class="si">}</span><span class="s1"> returned a state &#39;</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;of type </span><span class="si">${</span><span class="n">state</span><span class="p">.</span><span class="n">runtimeType</span><span class="si">}</span><span class="s1">, which is not a subtype of &#39;</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;State&lt;</span><span class="si">${</span><span class="n">widget</span><span class="p">.</span><span class="n">runtimeType</span><span class="si">}</span><span class="s1">&gt;, violating the contract for createState.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}());</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">_element</span> <span class="o">==</span> <span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">_element</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="p">.</span><span class="n">_widget</span> <span class="o">==</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;The createState function for </span><span class="si">$</span><span class="n">widget</span><span class="s1"> returned an old or invalid state &#39;</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;instance: </span><span class="si">${</span><span class="n">state</span><span class="p">.</span><span class="n">_widget</span><span class="si">}</span><span class="s1">, which is not null, violating the contract &#39;</span>
</span></span><span class="line"><span class="cl">      <span class="s1">&#39;for createState.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">_widget</span> <span class="o">=</span> <span class="n">widget</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">_debugLifecycleState</span> <span class="o">==</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">created</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">state</span><span class="p">.</span><span class="n">build</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">/// The [State] instance associated with this location in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// There is a one-to-one relationship between [State] objects and the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// [StatefulElement] objects that hold them. The [State] objects are created
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">/// by [StatefulElement] in [mount].
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">State</span><span class="o">&lt;</span><span class="n">StatefulWidget</span><span class="o">&gt;</span> <span class="kd">get</span> <span class="n">state</span> <span class="o">=&gt;</span> <span class="n">_state</span><span class="o">!</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">StatefulWidget</span><span class="o">&gt;?</span> <span class="n">_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，在<em>StatefulElement</em>的构造方法中，它做了四件事情。</p>
<ul>
<li>执行<code>_state = widget.createState()</code>创建了<em>State</em>实例，并赋值给<em>StatefulElement</em>的成员变量<code>_state</code>，也就是说<em>StatefulElement</em>持有了<em>State</em>实例引用。</li>
<li>执行<code>super(widget)</code>调用父类<em>ComponentElement</em>的构造方法，然后一级一级往上传递<em>this</em>，也就是<em>StatefulWidget</em>本身引用，最后在<em>Element</em>的构造方法中赋值给它的成员变量<code>_widget</code>，说明<em>Element</em>会持有<em>Widget</em>的引用。</li>
<li>执行<code>state._element = this;</code>，将<em>StatefulElement</em>赋值给<em>State</em>的成员变量<code>_element</code>，说明<em>State</em>也持有了<em>StatefulElement</em>引用。</li>
<li>执行<code>state._widget = widget;</code>，将<em>StatefulWidget</em>赋值给<em>State</em>的成员变量<code>_widget</code>，说明<em>State</em>也持有了<em>StatefulWidget</em>引用。</li>
</ul>
<p><em>OK</em>，现在应该理清了<em>StatefulWidget</em>、<em>StatefulElement</em>以及<em>State</em>之间的关系。因此，可以得出以下结论：</p>
<ul>
<li><em>StatefulElement</em>持有了<em>State</em>实例引用</li>
<li><em>StatefulElement</em>持有了<em>StatefulWidget</em>实例引用</li>
<li><em>State</em>又会反过来持有了<em>StatefulWidget</em>与<em>StatefulElement</em>的引用</li>
<li><em>StatefulWidget</em>只是负责创建<em>StatefulElement</em>与<em>State</em>实例，并不持有它们</li>
</ul>
<p>关于<em>State</em>的分析后面会讲到，在此之前，我们看下之前的一个<em>runApp</em>示例，补充之前没给出的<em>StatefulWidget</em>加载的一个执行流程图。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">_runApp</span><span class="p">(</span><span class="n">Widget</span> <span class="n">app</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">WidgetsBinding</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">WidgetsFlutterBinding</span><span class="p">.</span><span class="n">ensureInitialized</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timer</span><span class="p">.</span><span class="n">run</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binding</span><span class="p">.</span><span class="n">attachRootWidget</span><span class="p">(</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="n">binding</span><span class="p">.</span><span class="n">scheduleWarmUpFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyApp</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">const</span> <span class="n">MyPage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyPage</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyPage</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyPageState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyPageState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyPage</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kd">const</span> <span class="n">ColoredBox</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">pinkAccent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>StatefulWidget</em>加载的一个执行流程图如下所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/StatefulWidget加载的一个执行流程.png" alt="" width="535">
<h1 id="四分析state源码">四、分析<em>State</em>源码</h1>
<p>遇事不决，直接找<em>State</em>的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] 的逻辑和内部状态
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The logic and internal state for a [StatefulWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// State is information that (1) can be read synchronously when the widget is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// built and (2) might change during the lifetime of the widget. It is the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// responsibility of the widget implementer to ensure that the [State] is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// promptly notified when such state changes, using [State.setState].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] 对象是由框架在填充 [StatefulWidget] 并将其插入到树中时调用 [StatefulWidget.createState] 方法创建的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 因为给定的 [StatefulWidget] 实例可以多次填充（例如，该widget一次在多个位置合并到树中），可能有多个 [State] 对象与给定的 [StatefulWidget] 实例关联。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [StatefulWidget.createState] 以创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] objects are created by the framework by calling the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget.createState] method when inflating a [StatefulWidget] to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// insert it into the tree. Because a given [StatefulWidget] instance can be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// inflated multiple times (e.g., the widget is incorporated into the tree in
</span></span></span><span class="line"><span class="cl"><span class="c1">/// multiple places at once), there might be more than one [State] object
</span></span></span><span class="line"><span class="cl"><span class="c1">/// associated with a given [StatefulWidget] instance. Similarly, if a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] is removed from the tree and later inserted in to the tree
</span></span></span><span class="line"><span class="cl"><span class="c1">/// again, the framework will call [StatefulWidget.createState] again to create
</span></span></span><span class="line"><span class="cl"><span class="c1">/// a fresh [State] object, simplifying the lifecycle of [State] objects.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] 对象具有以下生命周期：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] objects have the following lifecycle:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 框架通过调用 [StatefulWidget.createState] 创建一个 [State] 对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The framework creates a [State] object by calling
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [StatefulWidget.createState].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 新创建的 [State] 对象与 [BuildContext] 关联。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    这种关联是永久的：[State] 对象永远不会更改其 [BuildContext]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    但是，[BuildContext] 本身可以与其子树一起在树中移动。此时，[State]对象就被认为是[mounted]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The newly created [State] object is associated with a [BuildContext].
</span></span></span><span class="line"><span class="cl"><span class="c1">///    This association is permanent: the [State] object will never change its
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [BuildContext]. However, the [BuildContext] itself can be moved around
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the tree along with its subtree. At this point, the [State] object is
</span></span></span><span class="line"><span class="cl"><span class="c1">///    considered [mounted].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  *  框架调用[initState]。[State]的子类应覆盖 [initState]去执行依赖于[BuildContext]或widget的一次性初始化，当调用[initState]方法时，它们分别作为[context]和[widget]属性可用。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The framework calls [initState]. Subclasses of [State] should override
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [initState] to perform one-time initialization that depends on the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [BuildContext] or the widget, which are available as the [context] and
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [widget] properties, respectively, when the [initState] method is
</span></span></span><span class="line"><span class="cl"><span class="c1">///    called.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  *  框架调用[didChangeDependency]。
</span></span></span><span class="line"><span class="cl"><span class="c1">///     [State] 的子类应重写 [didChangeDependency] 以执行涉及 [InheritedWidget] 的初始化。
</span></span></span><span class="line"><span class="cl"><span class="c1">///     如果调用 [BuildContext.dependOnInheritedWidgetOfExactType]，则如果inherited widgets随后发生更改或者widget在树中移动，则将再次调用 [didChangeDependency] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * The framework calls [didChangeDependencies]. Subclasses of [State] should
</span></span></span><span class="line"><span class="cl"><span class="c1">///    override [didChangeDependencies] to perform initialization involving
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [InheritedWidget]s. If [BuildContext.dependOnInheritedWidgetOfExactType] is
</span></span></span><span class="line"><span class="cl"><span class="c1">///    called, the [didChangeDependencies] method will be called again if the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    inherited widgets subsequently change or if the widget moves in the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此时，[State] 对象已完全初始化，框架可能会多次调用其 [build] 方法来获取此子树的用户界面的描述。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [State] 对象可以通过调用其 [setState] 方法自发请求重建其子树，这表明它们的某些内部状态已发生变化，可能会影响该子树中的用户界面。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At this point, the [State] object is fully initialized and the framework
</span></span></span><span class="line"><span class="cl"><span class="c1">///    might call its [build] method any number of times to obtain a
</span></span></span><span class="line"><span class="cl"><span class="c1">///    description of the user interface for this subtree. [State] objects can
</span></span></span><span class="line"><span class="cl"><span class="c1">///    spontaneously request to rebuild their subtree by calling their
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [setState] method, which indicates that some of their internal state
</span></span></span><span class="line"><span class="cl"><span class="c1">///    has changed in a way that might impact the user interface in this
</span></span></span><span class="line"><span class="cl"><span class="c1">///    subtree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在此期间，父widget可能会重建并请求更新树中的此位置以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    发生这种情况时，框架将更新 [widget] 属性以引用新的widget，然后使用先前的widget作为参数调用 [didUpdateWidget] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [State] 对象应覆盖 [didUpdateWidget] 以响应其关联widget中的更改（例如，启动隐式动画）。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * During this time, a parent widget might rebuild and request that this
</span></span></span><span class="line"><span class="cl"><span class="c1">///    location in the tree update to display a new widget with the same
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [runtimeType] and [Widget.key]. When this happens, the framework will
</span></span></span><span class="line"><span class="cl"><span class="c1">///    update the [widget] property to refer to the new widget and then call the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [didUpdateWidget] method with the previous widget as an argument. [State]
</span></span></span><span class="line"><span class="cl"><span class="c1">///    objects should override [didUpdateWidget] to respond to changes in their
</span></span></span><span class="line"><span class="cl"><span class="c1">///    associated widget (e.g., to start implicit animations). The framework
</span></span></span><span class="line"><span class="cl"><span class="c1">///    always calls [build] after calling [didUpdateWidget], which means any
</span></span></span><span class="line"><span class="cl"><span class="c1">///    calls to [setState] in [didUpdateWidget] are redundant. (See alse the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    discussion at [Element.rebuild].)
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在开发过程中，如果发生热重载（无论是通过按“r”从命令行“flutter”工具启动，还是从 IDE 启动），都会调用 [reassemble] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    这提供了重新初始化在 [initState] 方法中准备的任何数据的机会。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * During development, if a hot reload occurs (whether initiated from the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    command line `flutter` tool by pressing `r`, or from an IDE), the
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [reassemble] method is called. This provides an opportunity to
</span></span></span><span class="line"><span class="cl"><span class="c1">///    reinitialize any data that was prepared in the [initState] method.
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果包含 [State] 对象的子树从树中删除（例如，因为父级使用不同的 [runtimeType] 或 [Widget.key] 构建了一个widget），则框架调用 [deactivate] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If the subtree containing the [State] object is removed from the tree
</span></span></span><span class="line"><span class="cl"><span class="c1">///    (e.g., because the parent built a widget with a different [runtimeType]
</span></span></span><span class="line"><span class="cl"><span class="c1">///    or [Widget.key]), the framework calls the [deactivate] method. Subclasses
</span></span></span><span class="line"><span class="cl"><span class="c1">///    should override this method to clean up any links between this object
</span></span></span><span class="line"><span class="cl"><span class="c1">///    and other elements in the tree (e.g. if you have provided an ancestor
</span></span></span><span class="line"><span class="cl"><span class="c1">///    with a pointer to a descendant&#39;s [RenderObject]).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此时，框架可能会将该子树重新插入到树的另一部分中。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    如果发生这种情况，框架将确保调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * At this point, the framework might reinsert this subtree into another
</span></span></span><span class="line"><span class="cl"><span class="c1">///    part of the tree. If that happens, the framework will ensure that it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="c1">///    calls [build] to give the [State] object a chance to adapt to its new
</span></span></span><span class="line"><span class="cl"><span class="c1">///    location in the tree. If the framework does reinsert this subtree, it
</span></span></span><span class="line"><span class="cl"><span class="c1">///    will do so before the end of the animation frame in which the subtree was
</span></span></span><span class="line"><span class="cl"><span class="c1">///    removed from the tree. For this reason, [State] objects can defer
</span></span></span><span class="line"><span class="cl"><span class="c1">///    releasing most resources until the framework calls their [dispose]
</span></span></span><span class="line"><span class="cl"><span class="c1">///    method.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 如果框架在当前动画帧结束时没有重新插入此子树，框架将调用 [dispose]，这表明此 [State] 对象将永远不会再次构建。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * If the framework does not reinsert this subtree by the end of the current
</span></span></span><span class="line"><span class="cl"><span class="c1">///    animation frame, the framework will call [dispose], which indicates that
</span></span></span><span class="line"><span class="cl"><span class="c1">///    this [State] object will never build again. Subclasses should override
</span></span></span><span class="line"><span class="cl"><span class="c1">///    this method to release any resources retained by this object (e.g.,
</span></span></span><span class="line"><span class="cl"><span class="c1">///    stop any active animations).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。
</span></span></span><span class="line"><span class="cl"><span class="c1">///    此时调用[setState]是错误的。生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。 
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After the framework calls [dispose], the [State] object is considered
</span></span></span><span class="line"><span class="cl"><span class="c1">///    unmounted and the [mounted] property is false. It is an error to call
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [setState] at this point. This stage of the lifecycle is terminal: there
</span></span></span><span class="line"><span class="cl"><span class="c1">///    is no way to remount a [State] object that has been disposed.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于<em>State</em>，要关注的重点是它的生命周期，这点从注释中对<em>State</em>生命周期的大量描述也可以看出，这里总结下<em>State</em>生命周期的特性：</p>
<p>1、框架通过调用<code>StatefulWidget.createState</code>创建一个<em>State</em>对象，新创建的<em>State</em>对象与<em>BuildContext</em>关联。</p>
<p>2、<em>State</em>的子类可以覆盖<em>initState</em>方法去执行一次性初始化，此时<em>context</em>和<em>widget</em>属性可用。</p>
<p>3、<em>State</em>的子类可以重写<em>didChangeDependency</em>以执行涉及<em>InheritedWidget</em>的初始化。</p>
<p>4、<em>State</em>对象完全初始化后，可以通过调用其<em>setState</em>方法自发请求重建其子树。</p>
<p>5、如果父<em>widget</em>重建并请求更新树中的此位置以显示具有相同<em>runtimeType</em>和<em>Widget.key</em>的新<em>widget</em>，框架将更新<em>widget</em>属性以引用新的widget，然后使用先前的<em>widget</em>作为参数调用<em>didUpdateWidget</em>方法，<em>State</em>的子类可以覆盖<em>didUpdateWidget</em>方法以响应其关联<em>widget</em>中的更改。</p>
<p>6、在开发过程中，如果发生热重载会调用<em>reassemble</em>方法。</p>
<p>7、如果包含<em>State</em>对象的子树从树中删除，那么会调用<em>deactivate</em>方法，<em>State</em>的子类可以覆盖<em>deactivate</em>方法做一些清除<em>Element</em>链接的操作。</p>
<p>8、如果框架在当前动画帧结束时没有重新插入此子树，框架将调用<em>dispose</em>，这表明此<em>State</em>对象将永远不会再次构建。</p>
<p>9、框架调用<em>dispose</em>后，<em>State</em>对象被视为已卸载，并且<em>mounted</em>属性为<em>false</em>。</p>
<p>10、&hellip;</p>
<p>这里给出了<em>State</em>生命周期的部分特性，余下的留给个人去探索。<em>OK</em>，继续看下<em>State</em>生命周期相关方法的源码。</p>
<h2 id="41initstate方法">4.1、<em>initState</em>方法</h2>
<p>看下<em>initState</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 当该对象插入到树中时调用。  
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called when this object is inserted into the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架将为它创建的每个 [State] 对象调用此方法一次。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework will call this method exactly once for each [State] object
</span></span></span><span class="line"><span class="cl"><span class="c1">/// it creates.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 重写此方法以执行初始化，该初始化取决于此对象插入树中的位置（即 [context]）或用于配置此对象的widget（即 [widget]）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Override this method to perform initialization that depends on the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// location at which this object was inserted into the tree (i.e., [context])
</span></span></span><span class="line"><span class="cl"><span class="c1">/// or on the widget used to configure this object (i.e., [widget]).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@template flutter.widgets.State.initState}
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [State] 的 [build] 方法依赖于一个本身可以更改状态的对象，例如 [ChangeNotifier] 或 [Stream]，或者可以订阅接收通知的其它对象，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 那么请务必订阅并在 [initState]、[didUpdateWidget] 和 [dispose] 中正确取消订阅：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// If a [State]&#39;s [build] method depends on an object that can itself
</span></span></span><span class="line"><span class="cl"><span class="c1">/// change state, for example a [ChangeNotifier] or [Stream], or some
</span></span></span><span class="line"><span class="cl"><span class="c1">/// other object to which one can subscribe to receive notifications, then
</span></span></span><span class="line"><span class="cl"><span class="c1">/// be sure to subscribe and unsubscribe properly in [initState],
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [didUpdateWidget], and [dispose]:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在[initState]中，订阅该对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * In [initState], subscribe to the object.
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在 [didUpdateWidget] 中，如果更新的小部件配置需要替换对象，则取消订阅旧对象并订阅新对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * In [didUpdateWidget] unsubscribe from the old object and subscribe
</span></span></span><span class="line"><span class="cl"><span class="c1">///    to the new one if the updated widget configuration requires
</span></span></span><span class="line"><span class="cl"><span class="c1">///    replacing the object.
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在[dispose]中，取消订阅该对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * In [dispose], unsubscribe from the object.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@endtemplate}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 您不能从此方法中使用 [BuildContext.dependOnInheritedWidgetOfExactType]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 但是，在此方法之后将立即调用 [didChangeDependency]，并且可以在此处使用 [BuildContext.dependOnInheritedWidgetOfExactType]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// You cannot use [BuildContext.dependOnInheritedWidgetOfExactType] from this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method. However, [didChangeDependencies] will be called immediately
</span></span></span><span class="line"><span class="cl"><span class="c1">/// following this method, and [BuildContext.dependOnInheritedWidgetOfExactType] can
</span></span></span><span class="line"><span class="cl"><span class="c1">/// be used there.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法的实现应该从调用继承的方法开始，如“super.initState()”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Implementations of this method should start with a call to the inherited
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method, as in `super.initState()`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">initState</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 启用断言时跟踪 [State] 对象的生命周期。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 该状态表明[State] 对象已创建。此时会调用[State.initState]。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">assert</span><span class="p">(</span><span class="n">_debugLifecycleState</span> <span class="o">==</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">created</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">kFlutterMemoryAllocationsEnabled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemoryAllocations</span><span class="p">.</span><span class="n">instance</span><span class="p">.</span><span class="n">dispatchObjectCreated</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">library</span><span class="o">:</span> <span class="n">_flutterWidgetsLibrary</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">className:</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">State</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">object:</span> <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>initState</em>方法的说明都在注释中了，那框架在什么地方触发的<em>initState</em>方法呢？</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/initState方法/1.png" alt="" width="535">
<p>调用了<em>ComponentElement</em>的<em>mount</em>方法，在<em>mount</em>方法中又调用了<code>_firstBuild</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/initState方法/2.png" alt="" width="535">
<p><code>_firstBuild</code>方法被子类<em>StatefulElement</em>重写了，并且在该方法中调用了<em>initState</em>方法。</p>
<p>最后附上<em>initState</em>方法的执行流程图。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/initState方法/initState方法.png" alt="" width="335">
<h2 id="42didchangedependencies方法">4.2、<em>didChangeDependencies</em>方法</h2>
<p>看下<em>didChangeDependencies</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 当此 [State] 对象的依赖项发生更改时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called when a dependency of this [State] object changes.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，如果先前对 [build] 的调用引用了后来更改的 [InheritedWidget]，则框架将调用此方法来通知此对象有关更改的信息。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// For example, if the previous call to [build] referenced an
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [InheritedWidget] that later changed, the framework would call this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method to notify this object about the change.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法也会在 [initState] 之后立即调用。从此方法调用 [BuildContext.dependOnInheritedWidgetOfExactType] 是安全的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This method is also called immediately after [initState]. It is safe to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// call [BuildContext.dependOnInheritedWidgetOfExactType] from this method.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 子类很少重写此方法，因为框架总是在依赖项更改后调用 [build]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 某些子类确实会重写此方法，因为当它们的依赖项发生变化时，它们需要执行一些昂贵的工作（例如，网络获取），而对于每个构建来说，这些工作都太昂贵了。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Subclasses rarely override this method because the framework always
</span></span></span><span class="line"><span class="cl"><span class="c1">/// calls [build] after a dependency changes. Some subclasses do override
</span></span></span><span class="line"><span class="cl"><span class="c1">/// this method because they need to do some expensive work (e.g., network
</span></span></span><span class="line"><span class="cl"><span class="c1">/// fetches) when their dependencies change, and that work would be too
</span></span></span><span class="line"><span class="cl"><span class="c1">/// expensive to do for every build.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">didChangeDependencies</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>didChangeDependencies</em>方法的说明都在注释中了，那框架在什么地方触发的<em>didChangeDependencies</em>方法呢？</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/initState方法/1.png" alt="" width="535">
<p>调用了<em>ComponentElement</em>的<em>mount</em>方法，在<em>mount</em>方法中又调用了<code>_firstBuild</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didChangeDependencies方法/1.png" alt="" width="535">
<p><code>_firstBuild</code>方法被子类<em>StatefulElement</em>重写了，并且在该方法中调用了<em>initState</em>方法，随后又调用了<em>didChangeDependencies</em>方法，最后执行<code>super._firstBuild()</code>，也就是调用<em>ComponentElement</em>的<code>_firstBuild</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didChangeDependencies方法/2.png" alt="" width="535">
<p>在<em>ComponentElement</em>的<code>_firstBuild</code>方法中，执行了<em>rebuild</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didChangeDependencies方法/3.png" alt="" width="535">
<p>在<em>rebuild</em>方法中又会调用<em>performRebuild</em>方法，该方法被子类<em>StatefulElement</em>和<em>ComponentElement</em>重写了，这里我们看<em>StatefulElement</em>重写的<em>performRebuild</em>方法，可以看到执行了<em>didChangeDependencies</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didChangeDependencies方法/4.png" alt="" width="535">
<p>最后附上<em>didChangeDependencies</em>方法的执行流程图。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didChangeDependencies方法/didChangeDependencies方法.png" alt="" width="535">
<h2 id="43build方法">4.3、<em>build</em>方法</h2>
<p>看下<em>build</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 描述此widget代表的用户界面部分。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Describes the part of the user interface represented by this widget.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架在许多不同的情况下调用此方法。例如：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework calls this method in a number of different situations. For
</span></span></span><span class="line"><span class="cl"><span class="c1">/// example:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在调用 [initState] 之后
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After calling [initState].
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在调用 [didUpdateWidget] 之后
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After calling [didUpdateWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 在收到对 [setState] 的调用之后。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After receiving a call to [setState].
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 此 [State] 对象的依赖项更改后（例如，先前 [build] 更改引用的 [InheritedWidget]）。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After a dependency of this [State] object changes (e.g., an
</span></span></span><span class="line"><span class="cl"><span class="c1">///    [InheritedWidget] referenced by the previous [build] changes).
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * 调用 [deactivate] 后，然后将 [State] 对象重新插入到树中的另一个位置。
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * After calling [deactivate] and then reinserting the [State] object into
</span></span></span><span class="line"><span class="cl"><span class="c1">///    the tree at another location.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法可以在每个帧中调用，并且除了构建widget之外不应该有任何副作用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// This method can potentially be called in every frame and should not have
</span></span></span><span class="line"><span class="cl"><span class="c1">/// any side effects beyond building a widget.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架将此widget下面的子树替换为此方法返回的widget，方法是更新现有子树或删除子树并填充新子树，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 具体取决于此方法返回的widget是否可以更新现有子树的根，通过调用 [Widget.canUpdate] 确定。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework replaces the subtree below this widget with the widget
</span></span></span><span class="line"><span class="cl"><span class="c1">/// returned by this method, either by updating the existing subtree or by
</span></span></span><span class="line"><span class="cl"><span class="c1">/// removing the subtree and inflating a new subtree, depending on whether the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widget returned by this method can update the root of the existing
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subtree, as determined by calling [Widget.canUpdate].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 通常，实现会返回新创建的widgets星座，这些widgets配置有来自该widget的构造函数、给定的 [BuildContext] 和此 [State] 对象的内部状态的信息。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Typically implementations return a newly created constellation of widgets
</span></span></span><span class="line"><span class="cl"><span class="c1">/// that are configured with information from this widget&#39;s constructor, the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// given [BuildContext], and the internal state of this [State] object.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 给定的 [BuildContext] 包含有关在树中构建此小部件的位置的信息。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，上下文为树中的该位置提供一组inherited widgets。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [BuildContext] 参数始终与此 [State] 对象的 [context] 属性相同，并且在此对象的生命周期内保持不变。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 此处冗余地提供了 [BuildContext] 参数，以便此方法与 [WidgetBuilder] 的签名匹配。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The given [BuildContext] contains information about the location in the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// tree at which this widget is being built. For example, the context
</span></span></span><span class="line"><span class="cl"><span class="c1">/// provides the set of inherited widgets for this location in the tree. The
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [BuildContext] argument is always the same as the [context] property of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// this [State] object and will remain the same for the lifetime of this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// object. The [BuildContext] argument is provided redundantly here so that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// this method matches the signature for a [WidgetBuilder].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 设计讨论
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ## Design discussion
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 为什么 [build] 方法在 [State] 上，而不是在 [StatefulWidget] 上？
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ### Why is the [build] method on [State], and not [StatefulWidget]?
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 将 `Widget build(BuildContext context)` 方法放在 [State] 上，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 而不是将 `Widget build(BuildContext context, State state)` 方法放在 [StatefulWidget] 上，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 可以为开发人员在子类化 [StatefulWidget] 时提供更大的灵活性。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Putting a `Widget build(BuildContext context)` method on [State] rather
</span></span></span><span class="line"><span class="cl"><span class="c1">/// than putting a `Widget build(BuildContext context, State state)` method
</span></span></span><span class="line"><span class="cl"><span class="c1">/// on [StatefulWidget] gives developers more flexibility when subclassing
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// For example, [AnimatedWidget] is a subclass of [StatefulWidget] that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// introduces an abstract `Widget build(BuildContext context)` method for its
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subclasses to implement. If [StatefulWidget] already had a [build] method
</span></span></span><span class="line"><span class="cl"><span class="c1">/// that took a [State] argument, [AnimatedWidget] would be forced to provide
</span></span></span><span class="line"><span class="cl"><span class="c1">/// its [State] object to subclasses even though its [State] object is an
</span></span></span><span class="line"><span class="cl"><span class="c1">/// internal implementation detail of [AnimatedWidget].
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 从概念上讲，[StatelessWidget] 也可以以类似的方式实现为 [StatefulWidget] 的子类。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果 [build] 方法位于 [StatefulWidget] 而不是 [State]，那么这将不再可能。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Conceptually, [StatelessWidget] could also be implemented as a subclass of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] in a similar manner. If the [build] method were on
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget] rather than [State], that would not be possible anymore.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 将 [build] 函数放在 [State] 而不是 [StatefulWidget] 上也有助于避免与隐式捕获 `this` 的闭包相关的一类错误。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果您在 [StatefulWidget] 上的 [build] 函数中定义了一个闭包，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 则该闭包将隐式捕获“this”，即当前的widget实例，并且在范围内具有该实例的（不可变）字段：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Putting the [build] function on [State] rather than [StatefulWidget] also
</span></span></span><span class="line"><span class="cl"><span class="c1">/// helps avoid a category of bugs related to closures implicitly capturing
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `this`. If you defined a closure in a [build] function on a
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [StatefulWidget], that closure would implicitly capture `this`, which is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the current widget instance, and would have the (immutable) fields of that
</span></span></span><span class="line"><span class="cl"><span class="c1">/// instance in scope:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// // (this is not valid Flutter code)
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyButton extends StatefulWidgetX {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   MyButton({super.key, required this.color});
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final Color color;
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context, State state) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return SpecialWidget(
</span></span></span><span class="line"><span class="cl"><span class="c1">///       handler: () { print(&#39;color: $color&#39;); },
</span></span></span><span class="line"><span class="cl"><span class="c1">///     );
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，假设父级构建“MyButton”时“color”为蓝色，则 print 函数中的“color”指的是蓝色，正如预期的那样。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 现在，假设父级用绿色重建“MyButton”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 第一次构建创建的闭包仍然隐式引用原始widget，并且“颜色”仍然打印蓝色，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 即使widget已更新为绿色；如果该闭包比它的widget寿命更长，它会打印过时的信息。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// For example, suppose the parent builds `MyButton` with `color` being blue,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the `$color` in the print function refers to blue, as expected. Now,
</span></span></span><span class="line"><span class="cl"><span class="c1">/// suppose the parent rebuilds `MyButton` with green. The closure created by
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the first build still implicitly refers to the original widget and the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// `$color` still prints blue even through the widget has been updated to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// green; should that closure outlive its widget, it would print outdated
</span></span></span><span class="line"><span class="cl"><span class="c1">/// information.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 相反，使用 [State] 对象上的 [build] 函数，在 [build] 期间创建的闭包隐式捕获 [State] 实例而不是 widget 实例：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In contrast, with the [build] function on the [State] object, closures
</span></span></span><span class="line"><span class="cl"><span class="c1">/// created during [build] implicitly capture the [State] instance instead of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the widget instance:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyButton extends StatefulWidget {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   const MyButton({super.key, this.color = Colors.teal});
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final Color color;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   // ...
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// class MyButtonState extends State&lt;MyButton&gt; {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   // ...
</span></span></span><span class="line"><span class="cl"><span class="c1">///   @override
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Widget build(BuildContext context) {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     return SpecialWidget(
</span></span></span><span class="line"><span class="cl"><span class="c1">///       handler: () { print(&#39;color: ${widget.color}&#39;); },
</span></span></span><span class="line"><span class="cl"><span class="c1">///     );
</span></span></span><span class="line"><span class="cl"><span class="c1">///   }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 现在，当父级用绿色重建“MyButton”时，第一个构建创建的闭包仍然引用 [State] 对象，该对象在重建过程中保留，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 但框架已更新 [State] 对象的 [widget] 属性以引用新的 `MyButton` 实例，并且 `{widget.color}` 按预期打印绿色。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Now when the parent rebuilds `MyButton` with green, the closure created by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="c1">/// the first build still refers to [State] object, which is preserved across
</span></span></span><span class="line"><span class="cl"><span class="c1">/// rebuilds, but the framework has updated that [State] object&#39;s [widget]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// property to refer to the new `MyButton` instance and `${widget.color}`
</span></span></span><span class="line"><span class="cl"><span class="c1">/// prints green, as expected.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// See also:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">///  * [StatefulWidget], which contains the discussion on performance considerations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>build</em>方法的说明都在注释中了，那框架在什么地方触发的<em>build</em>方法呢？</p>
<ul>
<li>在调用<em>initState</em>方法之后</li>
<li>在调用<em>didUpdateWidget</em>方法之后</li>
<li>在调用<em>setState</em>方法之后。</li>
<li>此<em>State</em>对象的依赖项更改后（例如，先前<em>build</em>更改引用的<em>InheritedWidget</em>）。</li>
<li>调用<em>deactivate</em>后，然后将<em>State</em>对象重新插入到树中的另一个位置。</li>
</ul>
<p>关于<em>build</em>方法的各个触发条件，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。</p>
<h2 id="44didupdatewidget方法">4.4、<em>didUpdateWidget</em>方法</h2>
<p>看下<em>didUpdateWidget</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 每当widget配置更改时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called whenever the widget configuration changes.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果父widget重建并请求树中的此位置更新以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget，
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架将更新此 [State] 对象的 [widget] 属性以引用新的widget，然后使用前一个widget作为参数调用此方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// If the parent widget rebuilds and requests that this location in the tree
</span></span></span><span class="line"><span class="cl"><span class="c1">/// update to display a new widget with the same [runtimeType] and
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [Widget.key], the framework will update the [widget] property of this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] object to refer to the new widget and then call this method
</span></span></span><span class="line"><span class="cl"><span class="c1">/// with the previous widget as an argument.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 重写此方法以在 [widget] 更改时做出响应（例如，启动隐式动画）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Override this method to respond when the [widget] changes (e.g., to start
</span></span></span><span class="line"><span class="cl"><span class="c1">/// implicit animations).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework always calls [build] after calling [didUpdateWidget], which
</span></span></span><span class="line"><span class="cl"><span class="c1">/// means any calls to [setState] in [didUpdateWidget] are redundant.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@macro flutter.widgets.State.initState}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法的实现应该从调用继承的方法开始，如“super.didUpdateWidget(oldWidget)”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Implementations of this method should start with a call to the inherited
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method, as in `super.didUpdateWidget(oldWidget)`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">didUpdateWidget</span><span class="p">(</span><span class="n">covariant</span> <span class="n">T</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>didUpdateWidget</em>方法的说明都在注释中了，那框架在什么地方触发的<em>didUpdateWidget</em>方法呢？</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didUpdateWidget方法/1.png" alt="" width="535">
<p>当Widget通过build方法构建后，就会执行<em>Element</em>的<em>updateChild</em>方法，然后将该<em>Widget</em>的引用作为第二个参数<em>newWidget</em>传入到<em>updateChild</em>方法中。</p>
<p>然后通过<em>Widget</em>的<em>canUpdate</em>方法判断<em>newWidget</em>是否可用于更新当前将<em>oldWidget</em>作为其配置的<em>Element</em>。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didUpdateWidget方法/2.png" alt="" width="535">
<p>如果<em>canUpdate</em>方法返回<em>true</em>，就会执行<code>child.update(newWidget)</code>，也就是执行<em>Element</em>的<em>update</em>方法。该方法被子类<em>StatefulElement</em>重写了，所以看下<em>StatefulElement</em>的<em>update</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/didUpdateWidget方法/3.png" alt="" width="535">
<p>可以看到，<em>StatefulElement</em>的<em>update</em>方法中执行了<em>State</em>的<em>didUpdateWidget</em>方法，这里就不附上<em>didUpdateWidget</em>方法的执行流程图了。</p>
<h2 id="45deactivate方法">4.5、<em>deactivate</em>方法</h2>
<p>看下<em>deactivate</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 当该对象从树中删除时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called when this object is removed from the tree.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 每当框架从树中删除此 [State] 对象时，框架都会调用此方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 在某些情况下，框架会将 [State] 对象重新插入树的另一部分（例如，如果由于使用 [GlobalKey]，包含此 [State] 对象的子树从树中的一个位置嫁接到另一个位置） ）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果发生这种情况，框架将调用 [activate] 以使 [State] 对象有机会重新获取它在 [deactivate] 中释放的任何资源。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 然后，它还将调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework calls this method whenever it removes this [State] object
</span></span></span><span class="line"><span class="cl"><span class="c1">/// from the tree. In some cases, the framework will reinsert the [State]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// object into another part of the tree (e.g., if the subtree containing this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [State] object is grafted from one location in the tree to another due to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the use of a [GlobalKey]). If that happens, the framework will call
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [activate] to give the [State] object a chance to reacquire any resources
</span></span></span><span class="line"><span class="cl"><span class="c1">/// that it released in [deactivate]. It will then also call [build] to give
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the [State] object a chance to adapt to its new location in the tree. If
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the framework does reinsert this subtree, it will do so before the end of
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the animation frame in which the subtree was removed from the tree. For
</span></span></span><span class="line"><span class="cl"><span class="c1">/// this reason, [State] objects can defer releasing most resources until the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// framework calls their [dispose] method.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Subclasses should override this method to clean up any links between
</span></span></span><span class="line"><span class="cl"><span class="c1">/// this object and other elements in the tree (e.g. if you have provided an
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ancestor with a pointer to a descendant&#39;s [RenderObject]).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法的实现应该以调用继承的方法结束，如“super.deactivate()”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Implementations of this method should end with a call to the inherited
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method, as in `super.deactivate()`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>deactivate</em>方法的说明都在注释中了，那框架在什么地方触发的<em>deactivate</em>方法呢？</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/deactivate方法/1.png" alt="" width="535">
<p>当Widget通过build方法构建后，就会执行<em>Element</em>的<em>updateChild</em>方法，然后将该<em>Widget</em>的引用作为第二个参数<em>newWidget</em>传入到<em>updateChild</em>方法中。</p>
<p>这里先解释下红框部分：</p>
<ul>
<li>上面红框：表示如果<em>newWidget</em>为<em>null</em>，并且<em>child</em>不为<em>null</em>，那么需要将<em>child</em>删除，因为它不再具有配置。</li>
<li>下面红框：表示如果<em>newWidget</em>、<em>child</em>两者都不为空，并且如果<code>Widget.canUpdate()</code>返回false，表明新的<em>Widget</em>与旧的<em>Widget</em>不相同了，就需要先将老的<em>child</em>从渲染树中去除，重新去挂载新<em>child</em>。</li>
</ul>
<p>这里多插一嘴，<em>updateChild</em>方法作用就是使用给定的新配置更新给定的<em>child</em>，它是<em>widgets</em>系统的核心，每次我们根据更新的配置添加、更新或删除<em>child</em>时都会调用它。</p>
<p>这里总结下<em>updateChild</em>方法的执行：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left"><em>newWidget == null</em></th>
<th style="text-align:left"><em>newWidget != null</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>child == null</em></td>
<td style="text-align:left">返回<em>null</em></td>
<td style="text-align:left">返回新的<em>Element</em></td>
</tr>
<tr>
<td style="text-align:center"><em>child != null</em></td>
<td style="text-align:left">旧的<em>child</em>被移除, 返回<em>null</em></td>
<td style="text-align:left">如果可能，更新旧<em>child</em>，返回<em>child</em>或新的<em>Element</em></td>
</tr>
</tbody>
</table>
<p>在红框部分，都会调用<em>deactivateChild</em>方法，然后在<em>deactivateChild</em>方法中执行<code>owner!._inactiveElements.add(child)</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/deactivate方法/2.png" alt="" width="535">
<p>在<code>_InactiveElements</code>的<em>add</em>方法中，执行了<code>_deactivateRecursively()</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/deactivate方法/3.png" alt="" width="535">
<p>在<code>_InactiveElements</code>的<code>_deactivateRecursively()</code>中，执行了<code>element.deactivate()</code>。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/deactivate方法/4.png" alt="" width="535">
<p><em>Element</em>的<em>deactivate</em>方法被子类<em>StatefulElement</em>重写了，所以看下<em>StatefulElement</em>的<em>deactivate</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/deactivate方法/5.png" alt="" width="535">
<p>可以看到，<em>StatefulElement</em>的<em>deactivate</em>方法中执行了<em>State</em>的<em>deactivate</em>方法，这里就不附上<em>deactivate</em>方法的执行流程图了。</p>
<h2 id="46dispose方法">4.6、<em>dispose</em>方法</h2>
<p>看下<em>dispose</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 当该对象从树中永久删除时调用。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Called when this object is removed from the tree permanently.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 当此 [State] 对象不再构建时，框架将调用此方法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。此时调用[setState]是错误的。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The framework calls this method when this [State] object will never
</span></span></span><span class="line"><span class="cl"><span class="c1">/// build again. After the framework calls [dispose], the [State] object is
</span></span></span><span class="line"><span class="cl"><span class="c1">/// considered unmounted and the [mounted] property is false. It is an error
</span></span></span><span class="line"><span class="cl"><span class="c1">/// to call [setState] at this point. This stage of the lifecycle is terminal:
</span></span></span><span class="line"><span class="cl"><span class="c1">/// there is no way to remount a [State] object that has been disposed.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Subclasses should override this method to release any resources retained
</span></span></span><span class="line"><span class="cl"><span class="c1">/// by this object (e.g., stop any active animations).
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// {@macro flutter.widgets.State.initState}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 该方法的实现应该以调用继承的方法结束，如“super.dispose()”。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Implementations of this method should end with a call to the inherited
</span></span></span><span class="line"><span class="cl"><span class="c1">/// method, as in `super.dispose()`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">dispose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(</span><span class="n">_debugLifecycleState</span> <span class="o">==</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">ready</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_debugLifecycleState</span> <span class="o">=</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">defunct</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">kFlutterMemoryAllocationsEnabled</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemoryAllocations</span><span class="p">.</span><span class="n">instance</span><span class="p">.</span><span class="n">dispatchObjectDisposed</span><span class="p">(</span><span class="nl">object:</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>关于<em>dispose</em>方法的说明都在注释中了，那框架在什么地方触发的<em>dispose</em>方法呢？</p>
<p>在<em>RendererBinding</em>的<em>initInstances</em>方法中，会调用<em>addPersistentFrameCallback</em>方法注册一个持久帧回调。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/1.png" alt="" width="535">
<p>在持久帧回调<code>_handlePersistentFrameCallback</code>中调用了<em>RendererBinding</em>的<em>drawFrame</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/2.png" alt="" width="535">
<p><em>RendererBinding</em>的<em>drawFrame</em>方法被子类<em>WidgetsBinding</em>重写了，所以看下<em>WidgetsBinding</em>的<em>drawFrame</em>方法。</p>
<p>在<em>WidgetsBinding</em>的<em>drawFrame</em>方法中执行了<em>BuildOwner</em>的<em>finalizeTree</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/3.png" alt="" width="535">
<p>在<em>BuildOwner</em>的<em>finalizeTree</em>方法中执行了<code>_InactiveElements</code>的<code>_unmountAll</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/4.png" alt="" width="535">
<p>在<code>_InactiveElements</code>的<code>_unmountAll</code>方法中执行了<code>_unmount</code>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/5.png" alt="" width="535">
<p>在<code>_InactiveElements</code>的<code>_unmount</code>方法中又调用了<em>Element</em>的<em>unmount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/6.png" alt="" width="535">
<p><em>Element</em>的<em>unmount</em>方法被子类<em>StatefulElement</em>重写了，所以看下<em>StatefulElement</em>的<em>unmount</em>方法。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/dispose方法/7.png" alt="" width="535">
<p>可以看到，<em>StatefulElement</em>的<em>unmount</em>方法中执行了<em>State</em>的<em>dispose</em>方法，这里就不附上<em>dispose</em>方法的执行流程图了。</p>
<h2 id="47setstate方法">4.7、<em>setState</em>方法</h2>
<p>看下<em>setState</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// 通知框架该对象的内部状态已更改。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Notify the framework that the internal state of this object has changed.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 每当您更改 [State] 对象的内部状态时，请在传递给 [setState] 的函数中进行更改：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Whenever you change the internal state of a [State] object, make the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// change in a function that you pass to [setState]:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// setState(() { _myState = newValue; });
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 提供的回调将立即同步调用。它不能返回 future（回调不能是“异步”），因为这样就不清楚状态何时实际被设置。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// The provided callback is immediately called synchronously. It must not
</span></span></span><span class="line"><span class="cl"><span class="c1">/// return a future (the callback cannot be `async`), since then it would be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// unclear when the state was actually being set.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 调用 [setState] 通知框架此对象的内部状态已更改，可能会影响此子树中的用户界面，这会导致框架为此 [State] 对象安排 [build]。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Calling [setState] notifies the framework that the internal state of this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// object has changed in a way that might impact the user interface in this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subtree, which causes the framework to schedule a [build] for this [State]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// object.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 如果您只是直接更改状态而不调用 [setState]，框架可能不会安排 [build]，并且此子树的用户界面可能不会更新以反映新状态。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// If you just change the state directly without calling [setState], the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// framework might not schedule a [build] and the user interface for this
</span></span></span><span class="line"><span class="cl"><span class="c1">/// subtree might not be updated to reflect the new state.
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 通常，建议 [setState] 方法仅用于包装对状态的实际更改，而不是可能与更改相关的任何计算。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 例如，这里将 [build] 函数使用的值递增，然后将更改写入磁盘，但只有递增被包装在 [setState] 中：
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Generally it is recommended that the [setState] method only be used to
</span></span></span><span class="line"><span class="cl"><span class="c1">/// wrap the actual changes to the state, not any computation that might be
</span></span></span><span class="line"><span class="cl"><span class="c1">/// associated with the change. For example, here a value used by the [build]
</span></span></span><span class="line"><span class="cl"><span class="c1">/// function is incremented, and then the change is written to disk, but only
</span></span></span><span class="line"><span class="cl"><span class="c1">/// the increment is wrapped in the [setState]:
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```dart
</span></span></span><span class="line"><span class="cl"><span class="c1">/// Future&lt;void&gt; _incrementCounter() async {
</span></span></span><span class="line"><span class="cl"><span class="c1">///   setState(() {
</span></span></span><span class="line"><span class="cl"><span class="c1">///     _counter++;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   });
</span></span></span><span class="line"><span class="cl"><span class="c1">///   Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package
</span></span></span><span class="line"><span class="cl"><span class="c1">///   final String dirName = directory.path;
</span></span></span><span class="line"><span class="cl"><span class="c1">///   await File(&#39;$dirName/counter.txt&#39;).writeAsString(&#39;$_counter&#39;);
</span></span></span><span class="line"><span class="cl"><span class="c1">/// }
</span></span></span><span class="line"><span class="cl"><span class="c1">/// ```
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 框架调用[dispose]后调用该方法是错误的。您可以通过检查[mounted]属性是否为true来判断调用该方法是否合法。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// It is an error to call this method after the framework calls [dispose].
</span></span></span><span class="line"><span class="cl"><span class="c1">/// You can determine whether it is legal to call this method by checking
</span></span></span><span class="line"><span class="cl"><span class="c1">/// whether the [mounted] property is true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">setState</span><span class="p">(</span><span class="n">VoidCallback</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_debugLifecycleState</span> <span class="o">==</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">defunct</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="n">FlutterError</span><span class="p">.</span><span class="n">fromParts</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DiagnosticsNode</span><span class="o">&gt;</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorSummary</span><span class="p">(</span><span class="s1">&#39;setState() called after dispose(): </span><span class="si">$</span><span class="n">this</span><span class="s1">&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorDescription</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;This error happens if you call setState() on a State object for a widget that &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;no longer appears in the widget tree (e.g., whose parent widget no longer &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;includes the widget in its build). This error can occur when code calls &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;setState() from a timer or an animation callback.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorHint</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;The preferred solution is &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;to cancel the timer or stop listening to the animation in the dispose() &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;callback. Another solution is to check the &#34;mounted&#34; property of this &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;object before calling setState() to ensure the object is still in the &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;tree.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorHint</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;This error might indicate a memory leak if setState() is being called &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;because another object is retaining a reference to this State object &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;after it has been removed from the tree. To avoid memory leaks, &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;consider breaking the reference to this object during dispose().&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_debugLifecycleState</span> <span class="o">==</span> <span class="n">_StateLifecycle</span><span class="p">.</span><span class="n">created</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mounted</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="n">FlutterError</span><span class="p">.</span><span class="n">fromParts</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DiagnosticsNode</span><span class="o">&gt;</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorSummary</span><span class="p">(</span><span class="s1">&#39;setState() called in constructor: </span><span class="si">$</span><span class="n">this</span><span class="s1">&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorHint</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;This happens when you call setState() on a State object for a widget that &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s2">&#34;hasn&#39;t been inserted into the widget tree yet. It is not necessary to call &#34;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;setState() in the constructor, since the state is already assumed to be dirty &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;when it is initially created.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}());</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">Object</span><span class="o">?</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">()</span> <span class="o">as</span> <span class="kt">dynamic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">assert</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="k">is</span> <span class="n">Future</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="n">FlutterError</span><span class="p">.</span><span class="n">fromParts</span><span class="p">(</span><span class="o">&lt;</span><span class="n">DiagnosticsNode</span><span class="o">&gt;</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorSummary</span><span class="p">(</span><span class="s1">&#39;setState() callback argument returned a Future.&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorDescription</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;The setState() method on </span><span class="si">$</span><span class="n">this</span><span class="s1"> was called with a closure or method that &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;returned a Future. Maybe it is marked as &#34;async&#34;.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">ErrorHint</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;Instead of performing asynchronous work inside a call to setState(), first &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;execute the work (without updating the widget state), and then synchronously &#39;</span>
</span></span><span class="line"><span class="cl">          <span class="s1">&#39;update the state inside a call to setState().&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// We ignore other types of return values so that you can do things like:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//   setState(() =&gt; x = 3);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}());</span>
</span></span><span class="line"><span class="cl">  <span class="n">_element</span><span class="o">!</span><span class="p">.</span><span class="n">markNeedsBuild</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>碍于篇幅有限，本文不会去分析<em>setState</em>方法的执行流程，后续可能会出一篇来专门分析<em>setState</em>方法。</p>
<h2 id="48reassemble方法">4.8、<em>reassemble</em>方法</h2>
<p>看下<em>reassemble</em>方法的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="c1">/// {@macro flutter.widgets.Element.reassemble}
</span></span></span><span class="line"><span class="cl"><span class="c1">///
</span></span></span><span class="line"><span class="cl"><span class="c1">/// 除了调用此方法之外，还保证在发出重组信号时调用 [build] 方法。因此，大多数widgets不需要在 [reassemble] 方法中执行任何操作。
</span></span></span><span class="line"><span class="cl"><span class="c1">/// In addition to this method being invoked, it is guaranteed that the
</span></span></span><span class="line"><span class="cl"><span class="c1">/// [build] method will be invoked when a reassemble is signaled. Most
</span></span></span><span class="line"><span class="cl"><span class="c1">/// widgets therefore do not need to do anything in the [reassemble] method.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">@</span><span class="n">protected</span>
</span></span><span class="line"><span class="cl"><span class="err">@</span><span class="n">mustCallSuper</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">reassemble</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>reassemble</em>方法是专门为开发调试提供的，通过点击<em>AS</em>的<code>Flutter Hot Reload</code>按钮来触发，并且在<em>Release</em>模式下永远不会被调用。所以关于<em>reassemble</em>方法的触发流程，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。</p>
<p>至此，<em>State</em>的生命周期方法分析完毕，最后给出<em>State</em>的生命周期流程图。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/State生命周期流程图.png" alt="" width="535">
<h1 id="五state生命周期示例">五、<em>State</em>生命周期示例</h1>
<p>现在要实现的需求：</p>
<p>1、点击“减一”按钮，由<em>MyChild</em>控制<em>setState</em>进行构建</p>
<p>2、点击“+”、“添加或移除<em>MyChild</em>控件”按钮，由<em>MyParent</em>控制<em>setState</em>进行构建</p>
<p>3、<em>MyParent</em>与<em>MyChild</em>中的计数器值要保持一致</p>
<p>4、不同操作场景下，观察<em>MyChild</em>的生命周期变化</p>
<p>那么，最终的实现代码如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dart" data-lang="dart"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">runApp</span><span class="p">(</span><span class="kd">const</span> <span class="n">MyApp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyApp</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">title:</span> <span class="s1">&#39;Flutter Demo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nl">theme:</span> <span class="n">ThemeData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">colorScheme:</span> <span class="n">ColorScheme</span><span class="p">.</span><span class="n">fromSeed</span><span class="p">(</span><span class="nl">seedColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">deepPurple</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nl">useMaterial3:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">home:</span> <span class="kd">const</span> <span class="n">MyParent</span><span class="p">(</span><span class="nl">title:</span> <span class="s1">&#39;State生命周期演示&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyParent</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyParent</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">title</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">String</span> <span class="n">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyParent</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyParentState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyParentState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyParent</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">_isShowCounter</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_incrementCounter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_toggleCounter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_isShowCounter</span> <span class="o">=</span> <span class="o">!</span><span class="n">_isShowCounter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_counterChanged</span><span class="p">(</span><span class="kt">int</span> <span class="n">counter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">_counter</span> <span class="o">=</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">backgroundColor:</span> <span class="n">Theme</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">inversePrimary</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="n">widget</span><span class="p">.</span><span class="n">title</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">body:</span> <span class="n">_isShowCounter</span>
</span></span><span class="line"><span class="cl">          <span class="o">?</span> <span class="n">MyChild</span><span class="p">(</span><span class="nl">counter:</span> <span class="n">_counter</span><span class="p">,</span> <span class="nl">counterChanged:</span> <span class="n">_counterChanged</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">:</span> <span class="n">Container</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="nl">floatingActionButton:</span> <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">mainAxisAlignment:</span> <span class="n">MainAxisAlignment</span><span class="p">.</span><span class="n">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">children:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">          <span class="n">FloatingActionButton</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nl">onPressed:</span> <span class="n">_incrementCounter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">tooltip:</span> <span class="s1">&#39;Increment&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">add</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="kd">const</span> <span class="n">SizedBox</span><span class="p">(</span><span class="nl">height:</span> <span class="m">10</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="n">FloatingActionButton</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nl">onPressed:</span> <span class="n">_toggleCounter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">tooltip:</span> <span class="s1">&#39;ToggleCounter&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">child:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">_isShowCounter</span> <span class="o">?</span> <span class="n">Icons</span><span class="p">.</span><span class="n">toggle_on</span> <span class="o">:</span> <span class="n">Icons</span><span class="p">.</span><span class="n">toggle_off</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span> 
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">MyChild</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">final</span> <span class="n">ValueChanged</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counterChanged</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">const</span> <span class="n">MyChild</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">counter</span><span class="p">,</span> <span class="kd">required</span> <span class="k">this</span><span class="p">.</span><span class="n">counterChanged</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">State</span><span class="o">&lt;</span><span class="n">MyChild</span><span class="o">&gt;</span> <span class="n">createState</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">_MyChildState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">_MyChildState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">MyChild</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">_decrementCounter</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">setState</span><span class="p">(()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;setState&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">_counter</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">widget</span><span class="p">.</span><span class="n">counterChanged</span><span class="p">(</span><span class="n">_counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">initState</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">initState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;initState&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">didChangeDependencies</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">didChangeDependencies</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_counter</span> <span class="o">=</span> <span class="n">widget</span><span class="p">.</span><span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;didChangeDependencies&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">didUpdateWidget</span><span class="p">(</span><span class="n">covariant</span> <span class="n">MyChild</span> <span class="n">oldWidget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">didUpdateWidget</span><span class="p">(</span><span class="n">oldWidget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_counter</span> <span class="o">=</span> <span class="n">widget</span><span class="p">.</span><span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;didUpdateWidget&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;build&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Center</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nl">child:</span> <span class="n">Column</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nl">mainAxisAlignment:</span> <span class="n">MainAxisAlignment</span><span class="p">.</span><span class="n">center</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">[</span>
</span></span><span class="line"><span class="cl">          <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;You have pushed the button this many times:&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="n">Text</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;</span><span class="si">$</span><span class="n">_counter</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">style:</span> <span class="n">Theme</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">textTheme</span><span class="p">.</span><span class="n">headlineMedium</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="n">ElevatedButton</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nl">onPressed:</span> <span class="n">_decrementCounter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;减一&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">reassemble</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">reassemble</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;reassemble&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">deactivate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;deactivate&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="err">@</span><span class="n">override</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">dispose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">super</span><span class="p">.</span><span class="n">dispose</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">debugPrint</span><span class="p">(</span><span class="s1">&#39;dispose&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>程序运行后，效果如图下所示。</p>
<img title="" src="/img/flutter/解读Flutter源码之StatefulWidget&State的生命周期/State生命周期演示.png" alt="" width="235">
<ul>
<li>程序刚运行起来，打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): initState
</span></span><span class="line"><span class="cl">I/flutter ( 7658): didChangeDependencies
</span></span><span class="line"><span class="cl">I/flutter ( 7658): build
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>点击“减一”按钮，打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): setState
</span></span><span class="line"><span class="cl">I/flutter ( 7658): build
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>点击“+”按钮，打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): didUpdateWidget
</span></span><span class="line"><span class="cl">I/flutter ( 7658): build
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>点击“<em>Flutter Hot Reload</em>”按钮，打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): reassemble
</span></span><span class="line"><span class="cl">I/flutter ( 7658): didUpdateWidget
</span></span><span class="line"><span class="cl">I/flutter ( 7658): build
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>点击“添加或移除<em>MyChild</em>控件”按钮，此时状态为移除，那么打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): deactivate
</span></span><span class="line"><span class="cl">I/flutter ( 7658): dispose
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>点击“添加或移除<em>MyChild</em>控件”按钮，此时状态为添加，那么打印日志为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">I/flutter ( 7658): initState
</span></span><span class="line"><span class="cl">I/flutter ( 7658): didChangeDependencies
</span></span><span class="line"><span class="cl">I/flutter ( 7658): build
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">AndDevMK</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2023-10-18
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-qr-code.JPG">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay-qr-code.JPG">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">解读Flutter源码之setState</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/">
            <span class="next-text nav-default">解读Flutter源码之runApp</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="AndDevMK/blog-utterances"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    
    <div id="search_mask" class="search_mask">
    <div class="search_modal">
        <div id="close_search" class="close_search">关闭</div>
        <div class="search_divider"></div>
        <input id="input_search_key" class="input_search_key" placeholder="请输入你要搜索的内容" tabindex="0">
        <ul id="search_list">
        </ul>
    </div>
</div>

<script src="/js/fuse.js"></script> 
<script src="/js/fastsearch.js"></script>

    <footer id="footer" class="footer">
      

<div class="copyright">
  <span class="power-by">
    由 <a id="hexo-link" class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    
    <span id="run-time" class="run-time"></span> 
    <span class="heart"><i class="iconfont icon-heart"></i></span>
    &copy; 
    2023&nbsp;
    <span>AndDevMK</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.11a4ba15caf2d921d57eaf6568c4ad21eafd5d2c001cbcb31693586c63f93005.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?6db179fb88e600cf326b0515a8aa1de3";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>




<script src="/js/codecopy.js"></script>



<link disabled id="dark-mode-theme" rel="stylesheet" href="/css/dark.css"></link>
<script src="/js/dark.js"></script>


<script src="/js/site_runtime.js"></script>




</body>
</html>
