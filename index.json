[{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 XML文件在Android中是一种非常常见的文件格式，例如你的主页面布局文件activity_main.xml、Android清单文件AndroidManifest.xml、XXX.xml的res资源文件等等，然而我们在日常开发中往往会忽略XML文件本身，因为AS太过智能化，根据AS智能提示很容易就能写出想要的XML文件，但是我们真的有了解过XML文件吗？还有为什么要去了解XML文件？阅读本文后，你应该可以找到问题的答案。\n因此，本文会把关注点放到XML文件本身，学习它的基础语法，然后循序渐进地讲解Android中怎么解析XML数据，这对之后在Framework层遇到XML解析流程时非常有帮助，比如Activity的setContentView源码里，它是如何将我们写的layout布局文件解析出来的。\n二、XML简单介绍 2.1、什么是XML？ XML的全称为Extensible Markup Language，翻译过来是可扩展标记语言，它是标准通用标记语言的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。\n2.2、XML的基本语法 2.2.1、必须有声明语句 XML声明是XML文档的第一句，代码如下：\n1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; 2.2.2、XML文档有且只有一个根元素 良好格式的XML文档必须有一个根元素，就是紧接着声明后面建立的第一个元素，其他元素都是这个根元素的子元素，根元素完全包括文档中其他所有的元素，根元素的起始标记要放在所有其他元素的起始标记之前；根元素的结束标记要放在所有其他元素的结束标记之后，代码如下：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 在上面代码中，root称为根元素。\n2.2.3、XML标签对大小写敏感 在XML文档中，大小写是有区别的，例如下面代码中“a”和“A”是不同的标记。注意在写元素时，前后标记的大小写要保持一致。最好养成一种习惯，或者全部大写，或者全部小写，或者大写第一个字母，这样可以减少因为大小写不匹配而产生的文档错误。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;A\u0026gt;\u0026lt;/A\u0026gt; \u0026lt;/root\u0026gt; 2.2.4、属性值必须加引号 XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误。\n如下代码为错误演示：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;element id=999\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 如下代码为正确演示：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element id=\u0026#34;999\u0026#34;\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 2.2.5、所有的标记必须有相应的结束标记 在XML中，所有标记必须成对出现，有一个开始标记，就必须有一个结束标记，否则将被视为错误。\n2.2.6、实体引用 在XML中，一些字符拥有特殊的意义，如果你把字符\u0026quot;\u0026lt;\u0026ldquo;放在XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;count\u0026gt;num \u0026lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 为了避免这个错误，需要用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符。\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;count\u0026gt;num \u0026lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 在XML中，有5个预定义的实体引用。\n2.2.7、命名空间 在XML中，因为元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。\n这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的table元素，就会发生命名冲突，XML解析器无法确定如何处理这类冲突。\n如果以Java的思维来描述，可以认为是在同一个包下，创建了两个类名都为Table的类，那么在使用时就会不知道要用的是哪个了。\n因此，需要用XML命名空间来解决该冲突问题。XML命名空间属性被放置于元素的开始标签之中，其语法为：\n1 xmlns:namespace-prefix=\u0026#34;namespaceURI\u0026#34; 当XML命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;root\u0026gt; \u0026lt;s:table xmlns:s=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 命名空间也可以在XML根元素中声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;root xmlns:s=\u0026#34;https://www.student.com/\u0026#34; xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;s:table\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作，其语法为：\n1 xmlns=\u0026#34;namespaceURI\u0026#34; 这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table xmlns=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table xmlns=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 三、Android解析XML数据 3.1、选择XML解释器 Android提供了三种类型的XML解析器，它们是DOM、SAX和XmlPullParser，但是官方建议使用XmlPullParser，这是一种在Android上解析XML的高效且可维护的方式，Android有此接口的两个实现如下：\nKXmlParser，使用XmlPullParserFactory.newPullParser() ExpatPullParser，使用Xml.newPullParser() 上面两种任一选择都可以，在本文的示例中使用的是ExpatPullParser和Xml.newPullParser()。\n3.1.1、XmlPullParser接口 这里仅列举XmlPullParser接口和后面示例有联系的变量和方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public interface XmlPullParser { // ***************next()报告的事件类型*************** // 表明解析器位于文档的最开头，尚未读取任何内容，这种事件类型只能通过在第一次调用next()、nextToken或nextTag()之前调用getEventType()来观察 int START_DOCUMENT = 0; // xml文档的逻辑结束，当到达输入文档的末尾时，从getEventType()、next()和nextToken()返回 int END_DOCUMENT = 1; // 读取开始标记时从getEventType()、next()、nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得（如果命名空间已启用） int START_TAG = 2; // 读取结束标记时从getEventType()、next()或nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得 int END_TAG = 3; // 已读取字符数据并将通过调用getText()获得 int TEXT = 4; // 该数组可用于将事件类型整型常量（如START_TAG或TEXT）转换为字符串。例如，TYPES[START_TAG]的值是字符串“START_TAG”。该数组仅用于诊断输出。依赖数组的内容可能是危险的，因为恶意应用程序可能会更改数组，尽管它是最终的，但由于Java语言的限制 String [] TYPES = { \u0026#34;START_DOCUMENT\u0026#34;, \u0026#34;END_DOCUMENT\u0026#34;, \u0026#34;START_TAG\u0026#34;, \u0026#34;END_TAG\u0026#34;, \u0026#34;TEXT\u0026#34;, \u0026#34;CDSECT\u0026#34;, \u0026#34;ENTITY_REF\u0026#34;, \u0026#34;IGNORABLE_WHITESPACE\u0026#34;, \u0026#34;PROCESSING_INSTRUCTION\u0026#34;, \u0026#34;COMMENT\u0026#34;, \u0026#34;DOCDECL\u0026#34; }; // ***************命名空间相关特性*************** // 这个特性决定了解析器是否处理命名空间。对于所有功能，默认值为false // 注意：该值在解析期间不能更改，必须在解析前设置 String FEATURE_PROCESS_NAMESPACES = \u0026#34;http://xmlpull.org/v1/doc/features.html#process-namespaces\u0026#34;; // 使用此调用来更改解析器的一般行为，例如命名空间处理或文档类型声明处理。必须在第一次调用next或nextToken之前调用此方法。否则，将抛出异常 void setFeature(String name, boolean state) throws XmlPullParserException; // 将解析器的输入源设置为给定的阅读器并重置解析器。事件类型设置为初始值 START_DOCUMENT。将读取器设置为null只会停止解析并重置解析器状态，从而允许解析器释放解析缓冲区等内部资源 void setInput(Reader in) throws XmlPullParserException; // 设置解析器将要处理的输入流。此调用重置解析器状态并将事件类型设置为初始值START_DOCUMENT // 注意：如果传递了输入编码字符串，则必须使用它。否则，如果inputEncoding为null，解析器应该尝试确定遵循XML 1.0规范的输入编码（见下文） void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException; // ***************TEXT相关方法*************** // 检查当前TEXT事件是否只包含空白字符。对于IGNORABLE_WHITESPACE，这始终为真。对于TEXT和CDSECT，当当前事件文本至少包含一个非空白字符时返回false。对于任何其他事件类型，都会抛出异常 boolean isWhitespace() throws XmlPullParserException; // 以String形式返回当前事件的文本内容。返回值取决于当前事件类型，例如对于TEXT事件，它是元素内容（这是使用next()时的典型情况） String getText (); // ***************START_TAG END_TAG共享方法*************** // 对于START_TAG或END_TAG事件，启用命名空间时返回当前元素的（本地）名称。当命名空间处理被禁用时，原始名称被返回。对于ENTITY_REF事件，返回实体名称。如果当前事件不是START_TAG、END_TAG或ENTITY_REF，则返回null String getName(); // ***************START_TAG属性检索方法*************** // 返回由命名空间URI和命名空间localName标识的属性值。如果命名空间被禁用，命名空间必须为空。如果当前事件类型不是START_TAG，则将抛出IndexOutOfBoundsException String getAttributeValue(String namespace, String name); // ***************实际解析方法*************** // 返回当前事件的类型（START_TAG、END_TAG、TEXT等） int getEventType() throws XmlPullParserException; // 获取下一个解析事件 - 元素内容将被合并，并且必须为整个元素内容只返回一个TEXT事件（将忽略注释和处理指令，并且必须扩展实体引用，或者如果实体引用无法扩展则必须抛出异常）。如果元素内容为空（内容为“”），则不会报告TEXT事件 int next() throws XmlPullParserException, IOException; // ***************使XML解析更容易的实用方法*************** // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配。null将匹配任何名称空间和任何名称。如果测试未通过，则抛出异常。异常文本表示解析器位置、预期事件和不符合要求的当前事件 void require(int type, String namespace, String name) throws XmlPullParserException, IOException; // 如果是START_TAG或END_TAG，则调用next()并返回事件，否则抛出异常。如果有的话，它将跳过实际标记之前的空白TEXT int nextTag() throws XmlPullParserException, IOException; } 接下来，只讲解一下重点的方法。\n3.1.1.1、next方法 从上面的注释可以知道，next方法用于获取下一个解析事件，但是它有一些现象需要知道下。\n现象一：如果元素内容为空，则不会报告TEXT事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // kotlin原始字符串 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) var eventType = parser.eventType while (eventType != XmlPullParser.END_DOCUMENT) { Log.e(\u0026#34;MinKin\u0026#34;, \u0026#34;eventType: ${XmlPullParser.TYPES[eventType]}; name: ${parser.name}; text: ${parser.text}\u0026#34;) eventType = parser.next() } 打印结果如下：\n1 2 3 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: END_TAG; name: school; text: null 从打印结果来看，school元素内容为空时，的确没有触发TEXT事件。\n不知到你们是否留意到，为什么也没有触发END_DOCUMENT事件？\n其实是有触发的，只是不满足条件没法打印出来。因为While循环的判断条件为eventType != XmlPullParser.END_DOCUMENT，当eventType == XmlPullParser.END_DOCUMENT时，此时早已退出循环了，所以没有打印出来。\n特性二：如果实体引用无法扩展则必须抛出异常。 将上面代码中的xml变量替换为如下代码：\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 此时因为school标签之间多了\u0026rdquo;\u0026lt;\u0026quot;，运行时会触发XmlPullParserException这样的一个崩溃。把字符\u0026quot;\u0026lt;\u0026ldquo;放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始，为了避免这个错误，用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符，这也是我们之前讲过的。\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 修改为实体引用后，打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: \u0026lt; E/MinKin: eventType: END_TAG; name: school; text: null 特性三：标签之间不是黏连一起的，比如之间有空格，或者出现了换行，或者存在子标签的情况下，都会报告TEXT事件。 将上面代码中的xml变量替换为如下代码：\n1 2 3 4 // 标签之间有空格 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 1 2 3 4 5 // 标签之间出现了换行 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里school标签之间多打印了一次TEXT事件。如果是存在子标签的情况下，代码如下：\n1 2 3 4 5 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;count\u0026gt;1000\u0026lt;/count\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 5 6 7 8 9 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: START_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: 1000 E/MinKin: eventType: END_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里count标签前后多打印了两次TEXT事件。\n3.1.1.2、nextTag方法 如果当前事件不是START_TAG或END_TAG，会抛出XmlPullParserException异常，例如下面代码就会崩溃。\n1 2 3 4 5 6 7 8 9 10 11 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;清华大学\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) parser.next() parser.nextTag() 分析原因：初始时，当前事件为START_DOCUMENT，调用parser的next方法后，事件变为START_TAG，然后再调用parser的nextTag方法时，它的事件状态应该不满足START_TAG或END_TAG，从而抛出了异常。\n为什么不满足？nextTag方法本质源码为：\n1 2 3 4 5 6 7 8 int eventType = next(); if(eventType == TEXT \u0026amp;\u0026amp; isWhitespace()) { // skip whitespace eventType = next(); } if (eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG) { throw new XmlPullParserException(\u0026#34;expected start or end tag\u0026#34;, this, null); } return eventType; 可以看到，会优先调用next方法，此时当前事件为TEXT，接着会去判断eventType == TEXT \u0026amp;\u0026amp; isWhitespace()，但是isWhitespace方法是不满足的，因为school标签中存在元素内容“清华大学”，所以isWhitespace方法返回false，也就无法进入if条件去进一步调用next，事件停留在TEXT，满足了后面的eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG，从而抛出了异常。\n注意：next方法和nextTag方法需要在合理的地方使用，使用不当就会抛出异常。\n3.2、分析animal 创建一个animal.xml文件，解析animal的第一步是确定感兴趣的字段，解析器会提取这些字段的数据，并忽略其余字段。本案例会演示如何忽略cat标签，仅提取需要的字段。\n要解析的XML内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;animal xmlns=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Rufus\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;labrador\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=labrador\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;拉布拉多猎犬（英文名：Labrador retriever）是起源于加拿大的纽芬兰岛，最早被训练在冰冷的海上将渔网收回和担任搬运工作的一种猎犬。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Marty\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;whippet\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=whippet\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;小灵狗是一种赛狗，性温顺。和蔼。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;cat\u0026gt; \u0026lt;name\u0026gt;大黄\u0026lt;/name\u0026gt; \u0026lt;/cat\u0026gt; \u0026lt;/animal\u0026gt; 习惯性，animal标签包含了命名空间xmlns，profile标签的元素内容标记为HTML，所以要把HTML内容当成整体的纯文本去提取，这里给HTML内容包裹一层\u0026lt;![CDATA[ HTML内容 ]]，否则HTML中的标签会被XML当成元素去解析。\n3.3、实例化XML解释器 解析animal的下一步就是实例化解析器和启动解析的过程，此代码段会初始化一个解析器，使其不处理命名空间并将提供的InputStream用作输入，它通过调用nextTag方法开始解析过程，并调用readAnimal方法，该方法将提取并处理应用感兴趣的数据，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimalXMLParser { // 不使用命名空间 private val ns: String? = null @Throws(XmlPullParserException::class, IOException::class) fun parse(inputStream: InputStream): List\u0026lt;Dog\u0026gt; { inputStream.use { val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(it, null) parser.nextTag() return readAnimal(parser) } } // ... } 3.4、读取animal readAnimal方法执行处理animal的实际工作，它会查找标记为“dog”的元素作为以递归方式处理animal的起点，如果某个标签不是dog标签，则会跳过它，以递归方式处理完整个animal后，readAnimal方法将返回结果集List，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Throws(XmlPullParserException::class, IOException::class) private fun readAnimal(parser: XmlPullParser): List\u0026lt;Dog\u0026gt; { val dogs = mutableListOf\u0026lt;Dog\u0026gt;() // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配 parser.require(XmlPullParser.START_TAG, ns, \u0026#34;animal\u0026#34;) while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } if (parser.name == \u0026#34;dog\u0026#34;) { dogs.add(readDog(parser)) } else { skip(parser) } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;animal\u0026#34;) return dogs } 其中Dog类为：\n1 2 3 4 5 6 data class Dog( val name: String?, val breed: String?, val link: String?, val profile: String? ) 3.5、解析XML 解析XML animal的步骤如下：\n按照分析animal中所述，确定希望包含在应用中的标签。此示例提取了dog标签及其嵌套标签name、breed、link和profile的数据。\n创建以下方法：\n要包含的每个标签的“read”方法，例如readDog方法。解析器会从输入流中读取标签。当遇到此示例中名为name、breed、link和profile的标签时，它会调用该标签的相应方法。否则，它会跳过该标签。 为每个不同类型的标签提取数据并推动解析器解析下一个标签的方法。在此示例中，相关方法如下所示： 对于name、breed和profile标签，解析器会调用 readText方法。此方法通过调用parser的getText方法提取这些标签的数据。 对于link标签，解析器首先会确定链接是否为其感兴趣的类型，再提取该链接的数据。然后使用parser的getAttributeValue方法提取该链接的值。 对于dog标签，解析器会调用readDog方法。此方法会解析条目的嵌套标签，并返回包含数据成员name、breed、link和profile的Dog对象。 一种递归的辅助skip方法。 以下代码段展示了解析器如何解析name、breed、link和profile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @Throws(XmlPullParserException::class, IOException::class) private fun readDog(parser: XmlPullParser): Dog { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;dog\u0026#34;) var name: String? = null var breed: String? = null var link: String? = null var profile: String? = null while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } when (parser.name) { \u0026#34;name\u0026#34; -\u0026gt; name = readName(parser) \u0026#34;breed\u0026#34; -\u0026gt; breed = readBreed(parser) \u0026#34;link\u0026#34; -\u0026gt; link = readLink(parser) \u0026#34;profile\u0026#34; -\u0026gt; profile = readProfile(parser) else -\u0026gt; skip(parser) } } return Dog(name, breed, link, profile) } @Throws(XmlPullParserException::class, IOException::class) private fun readProfile(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;profile\u0026#34;) val profile = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;profile\u0026#34;) return profile } @Throws(XmlPullParserException::class, IOException::class) private fun readLink(parser: XmlPullParser): String { var link = \u0026#34;\u0026#34; parser.require(XmlPullParser.START_TAG, ns, \u0026#34;link\u0026#34;) val tag = parser.name val relType = parser.getAttributeValue(null, \u0026#34;rel\u0026#34;) if (tag == \u0026#34;link\u0026#34;) { if (relType == \u0026#34;alternate\u0026#34;) { link = parser.getAttributeValue(null, \u0026#34;href\u0026#34;) parser.nextTag() } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;link\u0026#34;) return link } @Throws(XmlPullParserException::class, IOException::class) private fun readBreed(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;breed\u0026#34;) val breed = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;breed\u0026#34;) return breed } @Throws(XmlPullParserException::class, IOException::class) private fun readName(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;name\u0026#34;) val name = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;name\u0026#34;) return name } @Throws(XmlPullParserException::class, IOException::class) private fun readText(parser: XmlPullParser): String { var result = \u0026#34;\u0026#34; if (parser.next() == XmlPullParser.TEXT) { result = parser.text parser.nextTag() } return result } 3.6、跳过不感兴趣的标签 解析器需要跳过不感兴趣的标签，下面是解析器的skip方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Throws(XmlPullParserException::class, IOException::class) private fun skip(parser: XmlPullParser) { if (parser.eventType != XmlPullParser.START_TAG) { throw IllegalStateException() } var depth = 1 while (depth != 0) { when (parser.next()) { XmlPullParser.END_TAG -\u0026gt; depth-- XmlPullParser.START_TAG -\u0026gt; depth++ } } } 其工作原理如下：\n如果当前事件不是START_TAG，则会抛出异常。 它会使用START_TAG以及直到匹配的END_TAG（含）的所有事件。 为确保其在遇到正确的END_TAG时停止，而非在遇到原始 START_TAG之后的首个标签时停止，它会不断追踪嵌套深度。 因此，如果当前元素具有嵌套元素，在解析器使用了原始START_TAG及其匹配的END_TAG之间的所有事件之前，depth的值不会为0。例如，看看解析器如何跳过拥有name这个嵌套元素的 cat元素：\n第一次经历while循环时，解析器在\u0026lt;cat\u0026gt;之后遇到的下一个标签是\u0026lt;name\u0026gt;的START_TAG。depth的值递增到2。 第二次经历while循环时，解析器遇到的下一个标签是 END_TAG，也就是\u0026lt;/name\u0026gt;。depth的值递减为1。 第三次，也就是最后一次经历while循环时，解析器遇到的下一个标签是END_TAG，也就是。depth的值递减为0，这表明该方法已成功跳过\u0026lt;cat\u0026gt;元素。 3.7、使用XML数据 第一步：把animal.xml文件放到Assets目录下。\n第二步：本文使用Databinding，所以需要在app的build.gradle中添加依赖：\n1 2 3 4 5 android { dataBinding { enabled = true } } 第三步：改造activity_main.xml布局，这里只有一个点击按钮，给按钮绑定点击事件，点击按钮时触发XML的解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;presenter\u0026#34; type=\u0026#34;com.pengmj.androidparsexml.Presenter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{(view)-\u0026gt;presenter.onParseXML(view)}\u0026#34; android:text=\u0026#34;解析XML\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 第四步：实现点击事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Presenter { companion object { private val tag: String = Presenter::class.java.simpleName } fun onParseXML(view: View) { val inputStream = view.context.assets.open(\u0026#34;animal.xml\u0026#34;) val list = AnimalXMLParser().parse(inputStream) Log.e(tag, list.toString()) } } 第五步：在MainActivity中将Databinding绑定UI层，设置页面点击事件对象。\n1 2 3 4 5 6 7 8 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView\u0026lt;ActivityMainBinding\u0026gt;(this, R.layout.activity_main) binding.presenter = Presenter() } } 本文源码地址： AndroidParseXML\n","date":"2023-05-07T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E8%A7%A3%E6%9E%90xml%E6%95%B0%E6%8D%AE/","section":"post","tags":null,"title":"Android解析XML数据"},{"categories":["Java"],"contents":"一、概述 假设你对ArrayDeque的源码一无所知，那么仅凭ArrayDeque名字来看的话，大概可以猜到它的实现和Array数组有关。\nArrayDeque是Java Collections Framework的一个成员，它的底层是基于定长数组实现的一个双端队列，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据，并且维护了双端队列头部元素的索引head和尾部元素的索引tail，使得它成为了一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始。\n我们知道，数组非尾部的插入和删除效率是比较低的，然而，这在ArrayDeque上的表现却是效率高，这是怎么实现的呢？\n接下来，本文会叙述ArrayDeque是如何维护这样一个循环数组，它的扩容机制是怎么实现的，这些都是ArrayDeque的核心所在；除此之外，本文还会叙述ArrayDeque的基本操作是怎样实现的，以及其它的细节。\n好了，让我们一起逐步揭开它的神秘面纱。\n二、ArrayDeque源码解读 2.1、继承关系 从UML类图中可以看到，ArrayDeque直接或间接实现了Iterable、Collection、Deque、Queue、Cloneable、Serializable这6个接口；ArrayDeque继承了AbstractCollection这个抽象类。\nArrayDeque和LinkedList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，比如说Deque接口、Queue接口的解读，本文不再次叙述，想去了解的话，可参考之前的Java集合系列：一文解读LinkedList源码「JDK11」一文。\n2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 // 存储双端队列元素的数组。所有不包含双端队列元素的数组单元格始终为空。该数组始终至少有一个空槽（在尾部）。 transient Object[] elements; // 双端队列头部元素的索引（这是将被 remove() 或 pop() 删除的元素）；或者任意数字 0 \u0026lt;= head \u0026lt; elements.length 等于 tail 如果双端队列为空。 transient int head; // 将下一个元素添加到双端队列尾部的索引（通过 addLast(E)、add(E) 或 push(E)）； elements[tail] 始终为空。 transient int tail; // 要分配的数组的最大大小。一些 VM 在数组中保留一些标题字。尝试分配更大的数组可能会导致 OutOfMemoryError: Requested array size exceeds VM limit private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从成员变量head、tail的注释可以知道，数组的长度、头部元素、尾部元素都和这两个变量有关，那么当数组初始化后，这样的数组表现形式有4种情况：\n头部元素的索引head == 尾部元素的索引tail，那么数组为空，也就是数组内部没有元素，如下图所示： 头部元素的索引head \u0026lt; 尾部元素的索引tail，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到tail-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail == 0，那么头部元素为elements[head]，尾部元素为elements[elements.length-1]，元素索引从head到elements.length-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail != 0，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构造一个空数组双端队列，其初始容量足以容纳16个元素 public ArrayDeque() { elements = new Object[16]; } // 构造一个空数组双端队列，其初始容量足以容纳指定数量的元素 public ArrayDeque(int numElements) { elements = new Object[(numElements \u0026lt; 1) ? 1 : (numElements == Integer.MAX_VALUE) ? Integer.MAX_VALUE : numElements + 1]; } // 构造一个包含指定集合元素的双端队列，按照集合迭代器返回元素的顺序。（集合的迭代器返回的第一个元素成为第一个元素，或双端队列的前面。） public ArrayDeque(Collection\u0026lt;? extends E\u0026gt; c) { this(c.size()); copyElements(c); } // 将集合c的元素循环添加到队尾 private void copyElements(Collection\u0026lt;? extends E\u0026gt; c) { c.forEach(this::addLast); } 我们看下第二个构造方法，需要传入一个numElements，这里有3种情况确定数组大小：\n如果numElements \u0026lt; 1，那么数组大小为1；\n如果numElements == Integer.MAX_VALUE，那么数组大小为Integer.MAX_VALUE；\n如果numElements \u0026gt;= 1 \u0026amp;\u0026amp; numElements \u0026lt; Integer.MAX_VALUE，那么数组大小为numElements + 1;\n第三种情况：为什么要numElements + 1呢？\n因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置。\n2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ***********尾部插入*********** // 在此双端队列的末尾插入指定的元素 public boolean add(E e) { addLast(e); return true; } // 在此双端队列的末尾插入指定的元素 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 上面说了，tail索引对应的位置是一个空位，所以这里用来存放元素e es[tail] = e; // 计算tail的新索引位置，赋值给tail变量；如果(tail+1) \u0026gt;= es.length，那么tail = 0，否则就是tail+1 // 判断是否head == tail，如果是则表示数组存满了，需要进行扩容 if (head == (tail = inc(tail, es.length))) // 执行扩容 grow(1); } static final int inc(int i, int modulus) { if (++i \u0026gt;= modulus) i = 0; return i; } // 在此双端队列的末尾插入指定的元素 public boolean offer(E e) { return offerLast(e); } // 在此双端队列的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 将指定集合中的所有元素添加到此双端队列的末尾，就像对每个元素调用addLast一样，按照集合的迭代器返回它们的顺序。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // s：原数组的元素个数 // needed：所需的最低额外容量 final int s, needed; // needed = 原数组的元素个数 + 集合c的长度 + 1（tail索引占位）- 原数组长度 // 如果needed\u0026gt;0，说明数组元素个数 + 集合c的长度 + 1（tail索引占位) \u0026gt; 原数组长度，也就是原数组容量不够装集合c了，需要扩容 if ((needed = (s = size()) + c.size() + 1 - elements.length) \u0026gt; 0) // 执行扩容 grow(needed); // 扩容完成后，将集合c的元素循环添加到队尾 copyElements(c); // 如果此双端队列发生了更改，那么返回true return size() \u0026gt; s; } // ***********头部插入*********** // 在此双端队列的前面插入指定的元素 public void addFirst(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 计算head的新索引位置，赋值给head变量；如果(head-1) \u0026lt; 0，那么head = es.length-1，否则就是head-1 es[head = dec(head, es.length)] = e; // 判断是否head==tail，如果是则表示数组存满了，需要进行扩容 if (head == tail) // 执行扩容 grow(1); } static final int dec(int i, int modulus) { if (--i \u0026lt; 0) i = modulus - 1; return i; } // 在此双端队列的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素压入此双端队列所代表的堆栈。换句话说，将元素插入到这个双端队列的前面 public void push(E e) { addFirst(e); } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // ***********尾部删除*********** public E removeLast() { E e = pollLast(); if (e == null) throw new NoSuchElementException(); return e; } public E pollLast() { final Object[] es; // 记录tail的新索引位置 final int t; // 计算tail的新索引位置，赋值给临时变量t；如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出t索引对应的元素 E e = elementAt(es = elements, t = dec(tail, es.length)); if (e != null) // 将t赋值给tail，然后将tail索引位置的元素置为null es[tail = t] = null; return e; } // ***********头部删除*********** // 检索并删除由此双端队列表示的队列的头部。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E remove() { return removeFirst(); } // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。 public E poll() { return pollFirst(); } public E removeFirst() { E e = pollFirst(); if (e == null) throw new NoSuchElementException(); return e; } public E pollFirst() { final Object[] es; // 记录head索引位置 final int h; // 在数组中取出head索引对应的元素 E e = elementAt(es = elements, h = head); if (e != null) { // 将head索引位置的元素置为null es[h] = null; // 计算head的新索引位置，赋值给head；如果(head+1) \u0026gt;= es.length，那么head = 0，否则就是head+1 head = inc(h, es.length); } // 返回head索引对应的元素 return e; } // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。 public E pop() { return removeFirst(); } 2.4.3、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // ***********头部检索*********** // 检索但不删除由此双端队列表示的队列的头部。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E element() { return getFirst(); } // 检索但不删除由此双端队列表示的队列的头部，或者如果此双端队列为空则返回null 。 public E peek() { return peekFirst(); } public E getFirst() { // 在数组中取出head索引对应的元素 E e = elementAt(elements, head); if (e == null) throw new NoSuchElementException(); // 返回head索引对应的元素 return e; } // 返回数组索引 i 处的元素。这是对泛型的轻微滥用，被 javac 所接受 static final \u0026lt;E\u0026gt; E elementAt(Object[] es, int i) { return (E) es[i]; } public E peekFirst() { // 在数组中取出head索引对应的元素 return elementAt(elements, head); } // ***********尾部检索*********** public E getLast() { final Object[] es = elements; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 E e = elementAt(es, dec(tail, es.length)); if (e == null) throw new NoSuchElementException(); return e; } public E peekLast() { final Object[] es; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 return elementAt(es = elements, dec(tail, es.length)); } 2.4.4、扩容机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将此双端队列的容量至少增加给定的数量 // need：所需的最低额外容量 private void grow(int needed) { // overflow-conscious code // 获取旧容量大小 final int oldCapacity = elements.length; // 记录新容量大小 int newCapacity; // Double capacity if small; else grow by 50% // jump：可译为跳跃，是基于旧容量计算的一个值，姑且叫跳跃容量 // 如果oldCapacity \u0026lt; 64，那么jump = oldCapacity + 2，为什么这里是+2？+1不行吗？因为+2有两个含义，一个是给tail占位使用，另一个就是给新元素插入使用 // 如果oldCapacity \u0026gt;= 64，那么jump = oldCapacity \u0026gt;\u0026gt; 1，右移一位表示除2，相当于oldCapacity/2 int jump = (oldCapacity \u0026lt; 64) ? (oldCapacity + 2) : (oldCapacity \u0026gt;\u0026gt; 1); // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 如果（跳跃容量 + 旧容量）\u0026gt; MAX_ARRAY_SIZE，说明超过数组长度允许最大值了 // // newCapacity的值有两个情况： // 如果oldCapacity \u0026lt; 64，那newCapacity为oldCapacity * 2 + 2 // 如果oldCapacity \u0026gt;= 64，那newCapacity为oldCapacity * 1.5 if (jump \u0026lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE \u0026gt; 0) // 出现上面说的两种情况时，需要重新调整新容量大小 newCapacity = newCapacity(needed, jump); // 将原数组的元素全部拷贝到新数组中去 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated // 此时数组只是扩大了，但是tail==head，即依然指向同一位置，为避免歧义，需要调整head和tail的位置 if (tail \u0026lt; head || (tail == head \u0026amp;\u0026amp; es[head] != null)) { // wrap around; slide first leg forward to end of array // 计算扩容后数组的剩余空间 int newSpace = newCapacity - oldCapacity; // 将旧数据复制到新位置 System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); // 将旧位置的旧数据全部清空，head成为新位置⾸元素的位置 for (int i = head, to = (head += newSpace); i \u0026lt; to; i++) es[i] = null; } } // 边缘条件的容量计算，尤其是溢出 private int newCapacity(int needed, int jump) { final int oldCapacity = elements.length, minCapacity; // 边界处理：判断旧容量 + 所需的最低额外容量是否超过数组长度允许最大值 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE \u0026gt; 0) { if (minCapacity \u0026lt; 0) throw new IllegalStateException(\u0026#34;Sorry, deque too big\u0026#34;); return Integer.MAX_VALUE; } // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 返回minCapacity = oldCapacity + needed if (needed \u0026gt; jump) return minCapacity; // 如果最小容量minCapacity没有超过数组长度允许最大值，并且need \u0026lt;= jump // 边界处理：判断旧容量+跳跃容量是否超过数组长度允许最大值 return (oldCapacity + jump - MAX_ARRAY_SIZE \u0026lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; } 下面通过一个小例子去演示扩容机制的执行流程，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 初始时，数组⻓度是5，真实索引是0-4，head = tail = 0 ArrayDeque\u0026lt;Integer\u0026gt; arrayDeque = new ArrayDeque\u0026lt;\u0026gt;(4); // 执行完，head = 0, tail = 1；此时数组为：[1, null, null, null, null] arrayDeque.addLast(1); // 执行完，head = 4，tail = 1；此时数组为：[1, null, null, null, 2] arrayDeque.addFirst(2); // 执行完，head = 3，tail = 1；此时数组为：[1, null, null, 3, 2] arrayDeque.addFirst(3); // 执行完，head = 2，tail = 1；此时数组为：[1, null, 4, 3, 2] arrayDeque.addFirst(4); // 执行完，head = tail = 1，触发扩容；此时数组为：[1, 5, 4, 3, 2]，扩容容量为5*2+2 // 然后将旧数据复制到新位置，此时数组为：[1, 5, 4, 3, 2, null, null, null, 5, 4, 3, 2] // 接着清掉旧数据，这时head = 8，tail = 1；此时数组为：[1, null, null, null, null, null, null, null, 5, 4, 3, 2] arrayDeque.addFirst(5); // 执行完，head = 8, tail = 2；此时数组为：[1, 6, null, null, null, null, null, null, 5, 4, 3 ,2] arrayDeque.addLast(6); 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 返回此双端队列中的元素数 public int size() { // i = tail，j = head，modulus = elements.length // 那么i -= j为i = i-j，代入后是tail = tail - head，然后判断计算后的tail是否 \u0026lt; 0 // 如果 \u0026lt; 0，说明是head \u0026gt; tail的情况，对应于前面讲成员变量提到的数组情况3或4，这种情况下， tail会再次计算，tail = tail + elements.length，这样计算就可以求出数组的元素个数，不明白可以对照图来看 // 如果 \u0026gt;= 0，说明是head \u0026lt;= tail的情况，对应于前面讲成员变量提到的数组情况1或2，这种情况下，直接把tail返回即可，因为if条件判断时已经计算过了，这样计算就可以求出数组的元素个数，不明白可以对照图来看 return sub(tail, head, elements.length); } static final int sub(int i, int j, int modulus) { if ((i -= j) \u0026lt; 0) i += modulus; return i; } // 如果此双端队列包含指定元素，则返回true 。更正式地说，当且仅当此双端队列包含至少一个满足o.equals(e)的元素e时才返回true public boolean contains(Object o) { if (o != null) { final Object[] es = elements; // to = (i \u0026lt;= end) ? end : es.length; 代入为：to = （head \u0026lt;= tail）? tail : es.length; // 这里要判断head \u0026lt;= tail，如果是true，那么to==end，即to为tail，说明内层for循环只需要遍历区间[head,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false // 如果head \u0026gt; tail，如果为true，那么to = es.length，说明内层for循环要遍历区间[head,es.length)中是否存在和o元素相同的元素，如果存在，返回true // 否则，内存for循环执行完成，外层for循环此时执行 i = 0, to = end； // 接着内存for循环继续要遍历区间[0,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false for (int i = head, end = tail, to = (i \u0026lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i \u0026lt; to; i++) if (o.equals(es[i])) return true; if (to == end) break; } } return false; } 三、总结 在ArrayDeque的源码中，并没有与并发相关的代码，所以说ArrayDeque是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。\nArrayDeque没有索引位置的概念，不能根据索引位置进行操作，所以没有更改操作，如set方法。\n另外，ArrayDeque禁止添加空元素。最关键一点是：ArrayDeque用作堆栈时很可能比Stack快，用作队列时比LinkedList快。\n","date":"2023-04-24T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraydeque%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayDeque源码「JDK11」"},{"categories":["Java"],"contents":"一、概述 LinkedList是Java Collections Framework的一个成员，然后底层是基于双向链表来实现的。对于LinkedList来说，可能平常开发用的频率并没有ArrayList多，这并不是我们不去学习LinkedList原理的理由。我们知道，ArrayList的特点是随机访问效率很高，但是非尾部的插入和删除性能就比较低，因为要挪动元素位置。LinkedList和ArrayList一样实现了List接口，因为两者底层的实现不一样，造就了它的特点与ArrayList几乎正好相反。\n接下来，本文会叙述LinkedList是如何维护这样一个双向链表的，基本操作是怎样实现的，以及其它的细节。\n二、LinkedList源码解读 2.1、继承关系 从UML类图中可以看到，LinkedList直接或间接实现了Iterable、Collection、List、Deque、Queue、Cloneable、Serializable这7个接口；LinkedList直接或间接继承了AbstractSequentialList、AbstractList、AbstractCollection这3个抽象类。\n可能细心的同学会发现，为什么AbstractList实现了List接口，LinkedList还要去再实现一次List接口？\n关于这一点，在之前的Java集合系列：一文解读ArrayList源码「JDK11」一文中已有解答，除此之外，LinkedList和ArrayList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，本文不再次叙述，想去了解的话，可点击上文链接去了解。\n2.1.1、Queue接口 Queue接口是一个队列接口，它对Collection接口进行了扩展。所谓队列，就类似于日常生活中的各种排队，特点就是先进先出，在尾部添加元素，从头部删除元素，它的接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此队列，则在成功时返回true并在当前没有可用空间时抛出IllegalStateException boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，当使用容量受限的队列时，此方法通常优于add，后者可能仅通过抛出异常来插入元素失败 boolean offer(E e); // 检索并删除此队列的头部。此方法与poll()的不同之处仅在于，如果此队列为空，它会抛出异常 E remove(); // 检索并删除此队列的头部，如果此队列为空，则返回null E poll(); // 检索但不删除此队列的头部。此方法与peek不同之处仅在于，如果此队列为空，它会抛出异常 E element(); // 检索但不删除此队列的头部，如果此队列为空，则返回null E peek(); } Queue队列提供了插入、删除和检查操作。这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（null或false ，具体取决于操作），如下图所示：\n注意：Queue队列实现通常不允许插入null元素，尽管某些实现（例如 LinkedList）不禁止插入null。即使在允许它的实现中，也不应将null插入到Queue队列中，因为null也被poll方法用作特殊的返回值，以指示队列不包含任何元素。\n实践一下，我们把LinkedList当作Queue队列来使用，如下代码：\n1 2 3 4 5 6 7 Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(\u0026#34;Jerry\u0026#34;); queue.offer(\u0026#34;Tom\u0026#34;); queue.offer(\u0026#34;May\u0026#34;); while (queue.peek() != null) { System.out.println(queue.poll()); } 2.1.2、Deque接口 Deque接口对Queue接口进行了扩展，Deque是“double ended queue”的缩写，它定义了访问双端队列两端元素的方法，接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此双端队列的前面，如果当前没有可用空间则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerFirst void addFirst(E e); // 如果可以在不违反容量限制的情况下立即插入指定的元素，则在此双端队列的末尾插入指定的元素，如果当前没有可用空间，则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerLast。此方法等效于add void addLast(E e); // 将指定的元素插入此双端队列的前面，除非它违反容量限制。当使用容量受限的双端队列时，此方法通常优于addFirst方法，后者仅通过抛出异常才能插入元素失败。 boolean offerFirst(E e); // 除非违反容量限制，否则在此双端队列的末尾插入指定的元素。当使用容量受限的双端队列时，此方法通常优于addLast方法，后者仅通过抛出异常才能插入元素失败 boolean offerLast(E e); // 检索并删除此双端队列的第一个元素。此方法与pollFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeFirst(); // 检索并删除此双端队列的最后一个元素。此方法与pollLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeLast(); // 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null E pollFirst(); // 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null E pollLast(); // 检索但不删除此双端队列的第一个元素。此方法与peekFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getFirst(); // 检索但不删除此双端队列的最后一个元素。此方法与peekLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getLast(); // 检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回null E peekFirst(); // 检索但不删除此双端队列的最后一个元素，如果此双端队列为空则返回null E peekLast(); // *** Queue methods *** // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true并在当前没有可用空间时抛出IllegalStateException .使用容量受限的双端队列时，通常最好使用offer 。此方法等效于addLast boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true ，如果当前没有可用空间则返回false 。当使用容量受限的双端队列时，此方法通常优于add方法，后者仅通过抛出异常才能插入元素失败。此方法等效于offerLast boolean offer(E e); // 检索并删除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于removeFirst() E remove(); // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。此方法等效于pollFirst() E poll(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于getFirst() E element(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回null 。此方法等效于peekFirst() E peek(); // *** Stack methods *** // 如果可以在不违反容量限制的情况下立即将元素推入此双端队列表示的堆栈（换句话说，在此双端队列的头部），如果当前没有可用空间则抛出IllegalStateException void push(E e); // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。此方法等效于removeFirst() E pop(); } Deque接口提供了插入、删除和检查的方法，这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（ null或false ，具体取决于操作），如下图所示：\n当双端队列用作队列时，会产生FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。从Queue接口继承的方法与Deque接口方法完全等价，如下图所示：\n除此之外，双端队列也可以用作LIFO（后进先出）堆栈。应优先使用此接口而不是使用Stack类。当双端队列用作堆栈时，元素从双端队列的开头被压入和弹出。Stack方法等同于Deque方法，如下图所示：\n实践一下，我们把LinkedList当作Deque堆栈来使用，如下代码：\n1 2 3 4 5 6 7 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;Jerry\u0026#34;); deque.push(\u0026#34;Tom\u0026#34;); deque.push(\u0026#34;May\u0026#34;); while (deque.peek() != null) { System.out.println(deque.pop()); } 注意：当双端队列用作队列或堆栈时，peek方法同样有效；在任何一种情况下，元素都是从双端队列的开头提取的。\n虽然并未严格要求Deque队列实现禁止插入空元素，但强烈建议它们这样做。强烈建议任何确实允许null元素的Deque实现的用户不要利用插入null的能力。之所以如此，是因为null被各种方法用作特殊的返回值，以指示双端队列为空。\nDeque接口除了上面介绍的核心方法外，它还有一个迭代器方法，可以从后往前遍历，如下代码：\n1 2 3 4 5 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(new String[]{\u0026#34;Jerry\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;May\u0026#34;})); Iterator\u0026lt;String\u0026gt; iterator = deque.descendingIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2.2、成员变量 1 2 3 4 5 6 7 8 // LinkedList的大小（它包含的元素数） transient int size = 0; // 指向第一个节点的指针 transient Node\u0026lt;E\u0026gt; first; // 指向最后一个节点的指针 transient Node\u0026lt;E\u0026gt; last; LinkedList的成员变量不多，我们重点看下内部类Node节点的实现，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static class Node\u0026lt;E\u0026gt; { // 存储元素 E item; // 后继节点 Node\u0026lt;E\u0026gt; next; // 前驱节点 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 从上面Node节点的构造函数来看，Node节点的结构如下图所示：\nLinkedList就是由一个个的Node节点双向连接而成，如下图所示：\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 // 构造一个空列表 public LinkedList() { } // 构造一个包含指定集合元素的列表，按照集合迭代器返回元素的顺序 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { this(); // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 addAll(c); } 2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // ***********尾部插入*********** // 将指定的元素附加到此列表的末尾 public boolean add(E e) { linkLast(e); return true; } // 将指定的元素附加到此列表的末尾 public void addLast(E e) { linkLast(e); } // 添加指定元素作为此列表的尾部（最后一个元素） public boolean offer(E e) { return add(e); } // 在此列表的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return addAll(size, c); } // ***********头部插入*********** // 在此列表的开头插入指定的元素 public void addFirst(E e) { linkFirst(e); } // 在此列表的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素推入此列表表示的堆栈中。换句话说，将元素插入此列表的前面 public void push(E e) { addFirst(e); } // ***********中间插入*********** // 在此列表中的指定位置插入指定元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一） public void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 如果插入的索引位置为size，那说明是尾部插入 if (index == size) // 执行尾部插入 linkLast(element); else // 先找到当前链表上指定index位置的node节点，然后再插入新节点 linkBefore(element, node(index)); } // ***********插入核心实现*********** // 链接e作为最后一个元素 void linkLast(E e) { // 获取当前链表的last节点 final Node\u0026lt;E\u0026gt; l = last; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 让新节点成为last节点 last = newNode; // 如果last节点为null，说明这是第一次插入新节点，所以新节点也是first节点 if (l == null) first = newNode; else // 否则新节点是last节点的下一个节点 l.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 链接e作为第一个元素 private void linkFirst(E e) { // 获取当前链表的first节点 final Node\u0026lt;E\u0026gt; f = first; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 让新节点成为last节点 first = newNode; // 如果first节点为null，说明这是第一次插入新节点，所以新节点也是last节点 if (f == null) last = newNode; else // 否则新节点是first节点的上一个节点 f.prev = newNode; // 更新size：元素个数+1 size++; modCount++; } // 返回指定元素索引处的（非空）节点。 Node\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1 == size/2 // 如果index \u0026lt; size/2，那么就从first节点开始往后遍历查找 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 如果index \u0026gt;= size/2，那么就从last节点开始往前遍历查找 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } // 在非空节点 succ 之前插入元素 e void linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; // 获取当前链表的succ节点的前一个节点pred final Node\u0026lt;E\u0026gt; pred = succ.prev; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 让新节点成为succ节点的前一个节点 succ.prev = newNode; // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 将指定集合中的所有元素插入此列表，从指定位置开始。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的​​迭代器返回的顺序出现在列表中。 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 将集合c的元素按集合c的顺序转换为数组返回 Object[] a = c.toArray(); // 如果数组长度为0，那么返回false int numNew = a.length; if (numNew == 0) return false; // 定义当前链表index索引对应的succ节点，以及succ节点的前节点pred Node\u0026lt;E\u0026gt; pred, succ; // 如果index == size，说明是尾部插入 if (index == size) { // size位置的节点为null succ = null; // pred节点为插入位置的前节点last pred = last; } else { // 否则是中间插入，那么先找到当前链表上指定index位置的node节点，然后再插入新节点 succ = node(index); // pred为succ的前节点 pred = succ.prev; } // 遍历数组，让数组转换为链表 for (Object o : a) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新节点 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 每一轮循环结束，新节点就是pred节点 pred = newNode; } // 如果succ节点为null，说明是尾部插入，此时插入已经完成，那么pred节点为数组的最后一个节点，所以理所应当成为last节点 if (succ == null) { last = pred; } else { // 如果succ节点不为null，说明是中间插入，此时插入已经完成，那么数组的最后一个节点指向插入位置节点succ pred.next = succ; // 数组的最后一个节点pred，理所应当成为插入位置节点succ的上一个节点 succ.prev = pred; } // 更新size：元素个数+数组长度 size += numNew; modCount++; return true; } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 // ***********尾部删除*********** // 从此列表中移除并返回最后一个元素 public E removeLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 检索并删除此列表的最后一个元素，如果此列表为空，则返回null public E pollLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : unlinkLast(l); } // ***********头部删除*********** // 检索并删除此列表的头部（第一个元素） public E remove() { return removeFirst(); } // 检索并删除此列表的头部（第一个元素） public E poll() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表中移除并返回第一个元素。 public E removeFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 检索并删除此列表的第一个元素，如果此列表为空，则返回null public E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素 public E pop() { return removeFirst(); } // ***********中间删除*********** // 移除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）。返回从列表中删除的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } // ***********删除核心实现*********** // 取消链接非空的第一个节点f private E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // assert f == first \u0026amp;\u0026amp; f != null; // 获取node节点的元素element final E element = f.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = f.next; // 将node节点持有的元素item置为null f.item = null; // 将node节点持有的后继节点指针置为null f.next = null; // help GC // node节点的下一个节点成为first节点 first = next; // 如果next节点为null，说明最后一个节点也被删除了，那么last节点置为null if (next == null) last = null; else // 否则node节点置为null next.prev = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空的最后一个节点l private E unlinkLast(Node\u0026lt;E\u0026gt; l) { // assert l == last \u0026amp;\u0026amp; l != null; // 获取node节点的元素element final E element = l.item; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = l.prev; // 将node节点持有的元素item置为null l.item = null; // 将node节点持有的前躯节点指针置为null l.prev = null; // help GC // node节点的上一个节点成为last节点 last = prev; // 如果prev节点为null，说明最后一个节点也被删除了，那么first节点置为null if (prev == null) first = null; else // 否则node节点置为null prev.next = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空节点x E unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null; // 获取node节点的元素element final E element = x.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = x.next; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 如果prev节点为null，说明是头部删除，那么next节点成为first节点 if (prev == null) { first = next; } else { // 如果prev节点不为null，说明是中间删除，那么next节点成为前驱节点prev的下一个节点 prev.next = next; // node节点的前驱节点指针置为null x.prev = null; } // 如果next节点为null，说明是尾部删除，那么prev节点成为last节点 if (next == null) { last = prev; } else { // 如果prev节点不为null，说明是中间删除，那么prev节点成为后继节点next的上一个节点 next.prev = prev; // node节点的后继节点指针置为null x.next = null; } // 将node节点持有的元素item置为null x.item = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果此列表不包含该元素，则它保持不变。更正式地说，删除具有最低索引i元素 public boolean remove(Object o) { // 如果要删除的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后执行删除 if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果要删除的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后执行删除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 2.4.3、更改 1 2 3 4 5 6 7 8 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { checkElementIndex(index); Node\u0026lt;E\u0026gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 2.4.4、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ***********头部检索*********** // 检索但不删除此列表的头部（第一个元素） public E element() { return getFirst(); } // 检索但不删除此列表的头部（第一个元素） public E peek() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // 返回此列表中的第一个元素 public E getFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 检索但不删除此列表的第一个元素，如果此列表为空，则返回null public E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // ***********尾部检索*********** // 返回此列表中的最后一个元素 public E getLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回null public E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } // ***********中间检索*********** // 返回此列表中指定位置的元素 public E get(int index) { checkElementIndex(index); return node(index).item; } 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 返回此列表中指定元素第一次出现的索引，如果此列表不包含该元素，则返回 -1，更正式地说，返回具有最低索引i元素 public int indexOf(Object o) { int index = 0; // 如果要查找的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后返回index if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { // 如果要查找的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后返回index for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 三、总结 在LinkedList的源码中，并没有与并发相关的代码，所以说LinkedList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new LinkedList(...)); 另外，LinkedList要根据实际的业务场景来使用，比如说，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，使用LinkedList会有更好的性能。\n","date":"2023-04-19T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBlinkedlist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读LinkedList源码「JDK11」"},{"categories":null,"contents":" 此博客主要用来对日常的开发等相关的内容进行记录，如果需要转载请表明出处。\n欢迎关注我的公众号 👇👇👇 ","date":"2023-04-16T20:53:15+08:00","permalink":"https://anddevmk.cn/about/","section":"","tags":null,"title":"关于"},{"categories":["Java"],"contents":"一、概述 ArrayList是经常用到的一个容器，它是Java Collections Framework的一个成员，然后底层是基于定长数组来实现的，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据。\n因此，扩容机制是ArrayList的核心所在，这一点是务必要掌握的；除此之外，本文还会叙述ArrayList的基本操作是怎样实现的，以及其它的细节。\n二、ArrayList源码解读 2.1、继承关系 从UML类图中可以看到，ArrayList直接或间接实现了Iterable、Collection、List、RandomAccess、Cloneable、Serializable这6个接口；ArrayList直接或间接继承了AbstractList、AbstractCollection这2个抽象类。\n疑问来了：为什么AbstractList实现了List接口，ArrayList还要去再实现一次List接口，是吃饱了撑着吗？\n带着疑问，我立马去网上冲浪一波，然后发现了3个对此的解释。\n观点1：如果ArrayList没去实现List接口，会导致class的getInterfaces方法返回不同的结果，这么做是为了方便基于List接口的动态代理。\n观点2：这可能是为了增加继承结构的可追踪性。当浏览Javadoc或类似的东西时，就不必遍历整个继承树，它不会有任何不良影响，并且可以帮助理解代码。\n观点3：ArrayList的作者Josh Bloch曾经认为ArrayList再实现一次List接口是有一些价值的，但后来发现这是个错误。\n以上3个观点均出自stackoverflow的一个帖子，我们了解下就好了，深究意义不大，具体原因还得是作者自己才知道。\n2.1.1、Iterable接口 2.1.1.1、概述 Iterable表示可迭代的，它有个iterator方法，需要返回Iterator对象，Iterator是一个接口，表示为迭代器。Iterable接口的定义如下：\n1 2 3 4 5 6 public interface Iterable\u0026lt;T\u0026gt; { Iterator\u0026lt;T\u0026gt; iterator(); // .....省略 } 那么实现Iterable接口有什么作用呢？先说结论：只要对象实现了Iterable接口，就可以使用for-each语法，编译器会转换为调用Iterable和Iterator接口的方法。\n我们平常用for-each语法遍历list时，你可能会写下如下代码：\n1 2 3 4 5 6 7 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(3); list.add(1); list.add(2); list.add(3); for (Integer value : list) { System.out.println(\u0026#34;value: \u0026#34; + value); } 这种for-each语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：\n1 2 3 4 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.next()); } 除了Iterable接口的iterator方法外，List接口也有一个listIterator方法，需要返回ListIterator对象，ListIterator是一个接口，它对Iterator接口做了扩展。比如，可以从末尾往前遍历，如下代码：\n1 2 3 4 ListIterator\u0026lt;Integer\u0026gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.previous()); } 2.1.1.2、fail-fast机制 那些年，年少时所犯下的错误，想起自己刚入门Java时，曾经写过如下代码：\n1 2 3 4 5 for (Integer value : list) { if (value \u0026lt; 3) { list.remove(value); } } 当年的直觉告诉你，这么写不存在问题，但是运行却会报并发修改的错误：\n1 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException 显然，这里是没有并发的代码，我们去看看ConcurrentModificationException的注释描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 当不允许进行此类修改时，已检测到对象的并发修改的方法可能会抛出此异常。 * This exception may be thrown by methods that have detected concurrent * modification of an object when such modification is not permissible. * \u0026lt;p\u0026gt; * 例如，通常不允许一个线程在另一个线程迭代集合时修改集合。 * For example, it is not generally permissible for one thread to modify a Collection * while another thread is iterating over it. * 通常，在这些情况下迭代的结果是不确定的。 * In general, the results of the iteration are undefined under these circumstances. * 如果检测到此行为，某些 Iterator 实现（包括 JRE 提供的所有通用集合实现）可能会选择抛出此异常。 * Some Iterator implementations (including those of all the general purpose collection implementations * provided by the JRE) may choose to throw this exception if this behavior is * detected. * 执行此操作的迭代器被称为fail-fast迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间出现任意的、不确定的行为的风险。 * Iterators that do this are known as \u0026lt;i\u0026gt;fail-fast\u0026lt;/i\u0026gt; iterators, * as they fail quickly and cleanly, rather that risking arbitrary, * non-deterministic behavior at an undetermined time in the future. * \u0026lt;p\u0026gt; * 请注意，此异常并不总是表示对象已被不同的线程并发修改。 * Note that this exception does not always indicate that an object has * been concurrently modified by a \u0026lt;i\u0026gt;different\u0026lt;/i\u0026gt; thread. * 如果单个线程发出一系列违反对象契约的方法调用，则该对象可能会抛出此异常。 * If a single thread issues a sequence of method invocations that violates the * contract of an object, the object may throw this exception. * 例如，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。 * For example, if a thread modifies a collection directly while it is * iterating over the collection with a fail-fast iterator, the iterator * will throw this exception. * 请注意，不能保证fail-fast行为，因为一般来说，在存在非同步并发修改的情况下不可能做出任何硬性保证。 * \u0026lt;p\u0026gt;Note that fail-fast behavior cannot be guaranteed as it is, generally * speaking, impossible to make any hard guarantees in the presence of * unsynchronized concurrent modification. * ail-fast操作会尽最大努力抛出ConcurrentModificationException。 * Fail-fast operations throw {@code ConcurrentModificationException} on a best-effort basis. * 因此，编写依赖于此异常的正确性的程序是错误的： ConcurrentModificationException应该仅用于检测错误。 * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: \u0026lt;i\u0026gt;{@code ConcurrentModificationException} * should be used only to detect bugs.\u0026lt;/i\u0026gt; * * @author Josh Bloch * @see Collection * @see Iterator * @see Spliterator * @see ListIterator * @see Vector * @see LinkedList * @see HashSet * @see Hashtable * @see TreeMap * @see AbstractList * @since 1.2 */ 上面的注释说的很明显了，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。\n那么如何避免异常呢？可以使用迭代器的remove方法，如下所示：\n1 2 3 4 5 6 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { if (iterator.next() \u0026lt; 3) { iterator.remove(); } } 它自己的remove方法为何又可以使用呢？我们需要看下迭代器的原理了。\n2.1.1.3、迭代器的原理 我们先来看下ArrayList中iterator方法的实现，代码如下：\n1 2 3 4 5 6 7 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } } iterator方法实现很简单，直接new一个Itr对象返回，Itr是ArrayList的一个成员内部类，实现了Iterator接口，它的代码量并不多，所以直接贴出来了，看注释应该就能明白。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return 下一个要返回的元素位置 int lastRet = -1; // index of last element returned; -1 if no such 最后一个返回的索引位置，如果没有，为-1 int expectedModCount = modCount; // 期望的修改次数，初始化为外部类当前的修改次数modCount // prevent creating a synthetic constructor Itr() {} public boolean hasNext() { return cursor != size; // cursor与数组元素数量的比较 } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { // 校验是否发生了结构性变化 checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 更新cursor的值，每次+1 cursor = i + 1; // 更新lastRet值，返回对应的元素 return (E) elementData[lastRet = i]; } public void remove() { // 注意：lastRet \u0026lt; 0时会抛出异常，所以调用remove()之前需要先调用next()去更新lastRet的值 if (lastRet \u0026lt; 0) throw new IllegalStateException(); // 校验是否发生了结构性变化 checkForComodification(); try { // 执行ArrayList的remove方法，modCount++ ArrayList.this.remove(lastRet); // 更新cursor的值，remove后元素数量少了一个，相当于cursor=cursor-1 cursor = lastRet; // 重置lastRet lastRet = -1; // 更新expectedModCount expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 校验是否发生了结构性变化，所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 迭代器源码中next方法，remove方法都会调用checkForComodification方法进行校验是否发生了结构性变化，由此可见，迭代器的内部维护了索引位置相关的数据，要求在迭代过程中，不能发生结构性变化，否则这些索引位置功能就会失效。\n2.1.2、RandomAccess接口 RandomAccess内部是没有任何代码的接口，它属于标记接口，其定义如下：\n1 2 public interface RandomAccess { } 实现了RandomAccess接口的类表示支持快速随机访问，用在一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现，比如Collections类的binarySearch方法，会根据List是否实现了RandomAccess接口而采用不同的实现，代码如下：\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } 2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。注意：要将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少 // 可以理解为标记调空参数构造方法 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 都将扩展为 DEFAULT_CAPACITY。 transient Object[] elementData; // ArrayList的大小（它包含的元素数） private int size; // 要分配的数组的最大大小（除非必要） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表，使得正在进行的迭代可能会产生不正确的结果。 protected transient int modCount = 0; 疑问来了：我们知道了ArrayList实现了Serializable接口，但是elementData为何要用transient修饰，这不表示elementData不能被序列化？\n其实玄机在于ArrayList中的两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 将ArrayList实例的状态保存到流中（即序列化它）。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // 从流中重构ArrayList实例（即反序列化） private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { elements[i] = s.readObject(); } elementData = elements; } else if (size == 0) { elementData = EMPTY_ELEMENTDATA; } else { throw new java.io.InvalidObjectException(\u0026#34;Invalid size: \u0026#34; + size); } } ArrayList在序列化的时候会调用writeObject方法，直接将size和element写入ObjectOutputStream；反序列化时调用readObject方法，从ObjectInputStream获取size和element，再恢复到elementData。\nelementData是存储ArrayList元素的数组缓冲区，通常扩容后都会预留一些空间，也就是说有部分空间实际没有存储元素，序列化时只序列化实际存储的那些元素，而不是整个数组，从而可以节省空间和时间。\n疑问来了：为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8而不是Integer.MAX_VALUE？\n因为存储了Array的头部信息，所以这里需要减去8。\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 空参构造方法 public ArrayList() { // 由于没有指定初始容量，所以赋值一个空实例的共享空数组实例，可以理解为标记调空参数构造方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定了初始容量的构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 创建指定大小的Object数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 elementData = c.toArray(); if ((size = elementData.length) != 0) { // 重复调用Arrays.copyOf()是为了防止c.toArray()不返回Object[] // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } } 2.4、核心方法 2.4.1、add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将指定的元素附加到此列表的末尾 public boolean add(E e) { // 此列表在结构上被修改的次数 modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { // 数组容量满了，执行扩容机制 if (s == elementData.length) // 得到一个扩容后的新数组 elementData = grow(); // size位置插入元素 elementData[s] = e; // 更新size大小：原元素个数大小+1 size = s + 1; } // 在此列表中的指定位置插入指定元素 public void add(int index, E element) { // 校验index的范围 rangeCheckForAdd(index); modCount++; // 当前元素个数大小 final int s; Object[] elementData; // 数组容量满了，执行扩容机制 if ((s = size) == (elementData = this.elementData).length) // 得到一个扩容后的新数组 elementData = grow(); // 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 移动后，index位置空余出来，即可将element插入到index位置 elementData[index] = element; // 更新size大小：原元素个数大小+1 size = s + 1; } // 将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; // 原数组的剩余容量不够插入数组的大小时，就进行扩容 if (numNew \u0026gt; (elementData = this.elementData).length - (s = size)) // 得到一个扩容后的新数组 elementData = grow(s + numNew); // 将插入数组的元素拷贝到扩容数组上 System.arraycopy(a, 0, elementData, s, numNew); // 更新size大小：原元素个数大小+插入数组的长度 size = s + numNew; return true; } 关于add方法，如果是末尾插入，那么平均时间复杂度为O(1)；如果是非末尾插入，因为需要移动元素，那么平均时间复杂度为O(n)。因此，我们应该尽量避免在大数据量中调用add带索引参数的方法。\n2.4.2、grow方法（扩容机制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private Object[] grow() { return grow(size + 1); } // 增加容量以确保它至少可以容纳最小容量参数指定的元素数 private Object[] grow(int minCapacity) { // minCapacity = size + 1 // 先计算新容量大小，再根据新容量大小创建一个Object[]新数组，把数据拷贝到新数组上 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 返回至少与给定最小容量一样大的容量。如果足够，返回增加 50% 的当前容量。除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。 private int newCapacity(int minCapacity) { // overflow-conscious code // 旧容量 = 原数组的长度 int oldCapacity = elementData.length; // 新容量 = 旧容量 + 旧容量右移一位（相当于除于2） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt;= 0) { // 如果是调用了无参数构造方法，没有指定初始容量时 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 默认初始容量就为10 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 其它情况一律size + 1 return minCapacity; } // 如果还没达到最大容量，那就是新容量大小，否则返回一个返回一个巨大的容量 return (newCapacity - MAX_ARRAY_SIZE \u0026lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // size+1 \u0026gt; MAX_ARRAY_SIZE时，那么返回一个巨大的容量Integer.MAX_VALUE，否则MAX_ARRAY_SIZE return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 2.4.3、remove方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 移除此列表中指定位置的元素 public E remove(int index) { // 校验index的范围 Objects.checkIndex(index, size); final Object[] es = elementData; // 取出要移除的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E oldValue = (E) es[index]; // 删除元素 fastRemove(es, index); // 返回要移除的元素 return oldValue; } // 跳过边界检查并且不返回删除的值的私有删除方法 private void fastRemove(Object[] es, int i) { modCount++; final int newSize; // 如果删除的元素索引位置非最后一个元素位置，那么将当前位于该位置的元素（如果有）和任何后续元素向左移动（将其索引减一）。 if ((newSize = size - 1) \u0026gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); // 移动原size-1位置多余了，需要置null es[size = newSize] = null; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果列表不包含该元素，则它不变。 public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; // 使用了java label语法 found: { // 如果传入null，那么遍历去查看是否存在null的元素，找到就跳出循环 if (o == null) { for (; i \u0026lt; size; i++) if (es[i] == null) break found; } else { // 如果传入不为null，那么遍历去查看是否存在相同的元素，找到就跳出循环 for (; i \u0026lt; size; i++) if (o.equals(es[i])) break found; } // 上面两个条件下都找不到要查找的元素，则返回false return false; } // 找到要删除的元素后执行删除 fastRemove(es, i); return true; } 2.4.4、set方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { // 校验index的范围 Objects.checkIndex(index, size); // 获取索引位置对应的元素 E oldValue = elementData(index); // 设置索引位置对应的元素 elementData[index] = element; // 返回要修改的元素 return oldValue; } // 返回索引位置对应的元素 E elementData(int index) { return (E) elementData[index]; } 2.4.5、get方法 1 2 3 4 5 6 7 // 返回此列表中指定位置的元素 public E get(int index) { // 校验index的范围 Objects.checkIndex(index, size); // 返回索引位置对应的元素 return elementData(index); } 2.5、其它方法 2.5.1、ensureCapacity方法 1 2 3 4 5 6 7 8 9 10 11 12 // 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数。 // 也就是说，这个方法的使用场景是如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数 public void ensureCapacity(int minCapacity) { // 最小容量不得低于原数组的长度，同时原数组不是第一次调用空参数构造方法和第一次扩容 if (minCapacity \u0026gt; elementData.length \u0026amp;\u0026amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u0026amp;\u0026amp; minCapacity \u0026lt;= DEFAULT_CAPACITY)) { modCount++; // 进行扩容 grow(minCapacity); } } 2.5.2、trimToSize方法 1 2 3 4 5 6 7 8 9 10 11 12 // 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList实例的存储 public void trimToSize() { modCount++; // 数组容量没装满元素 if (size \u0026lt; elementData.length) { // 如果元素个数为0，那么赋值一个空实例的共享空数组实例 elementData = (size == 0) ? EMPTY_ELEMENTDATA // 否则拷贝元素到新数组上，新数组的大小就是元素个数的数量 : Arrays.copyOf(elementData, size); } } 三、总结 在ArrayList的源码中，并没有与并发相关的代码，所以说ArrayList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new ArrayList(...)); 另外，ArrayList是经常用到的一个容器，要根据实际的业务场景来使用，比如说，当添加、删除数据不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会有更好的性能。\n","date":"2023-04-16T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraylist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayList源码「JDK11」"}]