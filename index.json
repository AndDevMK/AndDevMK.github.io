[{"categories":["Java"],"contents":"一、概述 假设你对ArrayDeque的源码一无所知，那么仅凭ArrayDeque名字来看的话，大概可以猜到它的实现和Array数组有关。\nArrayDeque是Java Collections Framework的一个成员，它的底层是基于定长数组实现的一个双端队列，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据，并且维护了双端队列头部元素的索引head和尾部元素的索引tail，使得它成为了一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始。\n我们知道，数组非尾部的插入和删除效率是比较低的，然而，这在ArrayDeque上的表现却是效率高，这是怎么实现的呢？\n接下来，本文会叙述ArrayDeque是如何维护这样一个循环数组，它的扩容机制是怎么实现的，这些都是ArrayDeque的核心所在；除此之外，本文还会叙述ArrayDeque的基本操作是怎样实现的，以及其它的细节。\n好了，让我们一起逐步揭开它的神秘面纱。\n二、ArrayDeque源码解读 2.1、继承关系 从UML类图中可以看到，ArrayDeque直接或间接实现了Iterable、Collection、Deque、Queue、Cloneable、Serializable这6个接口；ArrayDeque继承了AbstractCollection这个抽象类。\nArrayDeque和LinkedList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，比如说Deque接口、Queue接口的解读，本文不再次叙述，想去了解的话，可参考之前的Java集合系列：一文解读LinkedList源码「JDK11」一文。\n2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 // 存储双端队列元素的数组。所有不包含双端队列元素的数组单元格始终为空。该数组始终至少有一个空槽（在尾部）。 transient Object[] elements; // 双端队列头部元素的索引（这是将被 remove() 或 pop() 删除的元素）；或者任意数字 0 \u0026lt;= head \u0026lt; elements.length 等于 tail 如果双端队列为空。 transient int head; // 将下一个元素添加到双端队列尾部的索引（通过 addLast(E)、add(E) 或 push(E)）； elements[tail] 始终为空。 transient int tail; // 要分配的数组的最大大小。一些 VM 在数组中保留一些标题字。尝试分配更大的数组可能会导致 OutOfMemoryError: Requested array size exceeds VM limit private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从成员变量head、tail的注释可以知道，数组的长度、头部元素、尾部元素都和这两个变量有关，那么当数组初始化后，这样的数组表现形式有4种情况：\n头部元素的索引head == 尾部元素的索引tail，那么数组为空，也就是数组内部没有元素，如下图所示： 头部元素的索引head \u0026lt; 尾部元素的索引tail，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到tail-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail == 0，那么头部元素为elements[head]，尾部元素为elements[elements.length-1]，元素索引从head到elements.length-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail != 0，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构造一个空数组双端队列，其初始容量足以容纳16个元素 public ArrayDeque() { elements = new Object[16]; } // 构造一个空数组双端队列，其初始容量足以容纳指定数量的元素 public ArrayDeque(int numElements) { elements = new Object[(numElements \u0026lt; 1) ? 1 : (numElements == Integer.MAX_VALUE) ? Integer.MAX_VALUE : numElements + 1]; } // 构造一个包含指定集合元素的双端队列，按照集合迭代器返回元素的顺序。（集合的迭代器返回的第一个元素成为第一个元素，或双端队列的前面。） public ArrayDeque(Collection\u0026lt;? extends E\u0026gt; c) { this(c.size()); copyElements(c); } // 将集合c的元素循环添加到队尾 private void copyElements(Collection\u0026lt;? extends E\u0026gt; c) { c.forEach(this::addLast); } 我们看下第二个构造方法，需要传入一个numElements，这里有3种情况确定数组大小：\n如果numElements \u0026lt; 1，那么数组大小为1；\n如果numElements == Integer.MAX_VALUE，那么数组大小为Integer.MAX_VALUE；\n如果numElements \u0026gt;= 1 \u0026amp;\u0026amp; numElements \u0026lt; Integer.MAX_VALUE，那么数组大小为numElements + 1;\n第三种情况：为什么要numElements + 1呢？\n因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置。\n2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ***********尾部插入*********** // 在此双端队列的末尾插入指定的元素 public boolean add(E e) { addLast(e); return true; } // 在此双端队列的末尾插入指定的元素 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 上面说了，tail索引对应的位置是一个空位，所以这里用来存放元素e es[tail] = e; // 计算tail的新索引位置，赋值给tail变量；如果(tail+1) \u0026gt;= es.length，那么tail = 0，否则就是tail+1 // 判断是否head == tail，如果是则表示数组存满了，需要进行扩容 if (head == (tail = inc(tail, es.length))) // 执行扩容 grow(1); } static final int inc(int i, int modulus) { if (++i \u0026gt;= modulus) i = 0; return i; } // 在此双端队列的末尾插入指定的元素 public boolean offer(E e) { return offerLast(e); } // 在此双端队列的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 将指定集合中的所有元素添加到此双端队列的末尾，就像对每个元素调用addLast一样，按照集合的迭代器返回它们的顺序。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // s：原数组的元素个数 // needed：所需的最低额外容量 final int s, needed; // needed = 原数组的元素个数 + 集合c的长度 + 1（tail索引占位）- 原数组长度 // 如果needed\u0026gt;0，说明数组元素个数 + 集合c的长度 + 1（tail索引占位) \u0026gt; 原数组长度，也就是原数组容量不够装集合c了，需要扩容 if ((needed = (s = size()) + c.size() + 1 - elements.length) \u0026gt; 0) // 执行扩容 grow(needed); // 扩容完成后，将集合c的元素循环添加到队尾 copyElements(c); // 如果此双端队列发生了更改，那么返回true return size() \u0026gt; s; } // ***********头部插入*********** // 在此双端队列的前面插入指定的元素 public void addFirst(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 计算head的新索引位置，赋值给head变量；如果(head-1) \u0026lt; 0，那么head = es.length-1，否则就是head-1 es[head = dec(head, es.length)] = e; // 判断是否head==tail，如果是则表示数组存满了，需要进行扩容 if (head == tail) // 执行扩容 grow(1); } static final int dec(int i, int modulus) { if (--i \u0026lt; 0) i = modulus - 1; return i; } // 在此双端队列的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素压入此双端队列所代表的堆栈。换句话说，将元素插入到这个双端队列的前面 public void push(E e) { addFirst(e); } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // ***********尾部删除*********** public E removeLast() { E e = pollLast(); if (e == null) throw new NoSuchElementException(); return e; } public E pollLast() { final Object[] es; // 记录tail的新索引位置 final int t; // 计算tail的新索引位置，赋值给临时变量t；如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出t索引对应的元素 E e = elementAt(es = elements, t = dec(tail, es.length)); if (e != null) // 将t赋值给tail，然后将tail索引位置的元素置为null es[tail = t] = null; return e; } // ***********头部删除*********** // 检索并删除由此双端队列表示的队列的头部。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E remove() { return removeFirst(); } // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。 public E poll() { return pollFirst(); } public E removeFirst() { E e = pollFirst(); if (e == null) throw new NoSuchElementException(); return e; } public E pollFirst() { final Object[] es; // 记录head索引位置 final int h; // 在数组中取出head索引对应的元素 E e = elementAt(es = elements, h = head); if (e != null) { // 将head索引位置的元素置为null es[h] = null; // 计算head的新索引位置，赋值给head；如果(head+1) \u0026gt;= es.length，那么head = 0，否则就是head+1 head = inc(h, es.length); } // 返回head索引对应的元素 return e; } // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。 public E pop() { return removeFirst(); } 2.4.3、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // ***********头部检索*********** // 检索但不删除由此双端队列表示的队列的头部。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E element() { return getFirst(); } // 检索但不删除由此双端队列表示的队列的头部，或者如果此双端队列为空则返回null 。 public E peek() { return peekFirst(); } public E getFirst() { // 在数组中取出head索引对应的元素 E e = elementAt(elements, head); if (e == null) throw new NoSuchElementException(); // 返回head索引对应的元素 return e; } // 返回数组索引 i 处的元素。这是对泛型的轻微滥用，被 javac 所接受 static final \u0026lt;E\u0026gt; E elementAt(Object[] es, int i) { return (E) es[i]; } public E peekFirst() { // 在数组中取出head索引对应的元素 return elementAt(elements, head); } // ***********尾部检索*********** public E getLast() { final Object[] es = elements; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 E e = elementAt(es, dec(tail, es.length)); if (e == null) throw new NoSuchElementException(); return e; } public E peekLast() { final Object[] es; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 return elementAt(es = elements, dec(tail, es.length)); } 2.4.4、扩容机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 将此双端队列的容量至少增加给定的数量 // need：所需的最低额外容量 private void grow(int needed) { // overflow-conscious code // 获取旧容量大小 final int oldCapacity = elements.length; // 记录新容量大小 int newCapacity; // Double capacity if small; else grow by 50% // jump：可译为跳跃，是基于旧容量计算的一个值，姑且叫跳跃容量 // 如果oldCapacity \u0026lt; 64，那么jump = oldCapacity + 2，为什么这里是+2？+1不行吗？因为+2有两个含义，一个是给tail占位使用，另一个就是给新元素插入使用 // 如果oldCapacity \u0026gt;= 64，那么jump = oldCapacity \u0026gt;\u0026gt; 1，右移一位表示除2，相当于oldCapacity/2 int jump = (oldCapacity \u0026lt; 64) ? (oldCapacity + 2) : (oldCapacity \u0026gt;\u0026gt; 1); // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 如果（跳跃容量 + 旧容量）\u0026gt; MAX_ARRAY_SIZE，说明超过数组长度允许最大值了 // // newCapacity的值有两个情况： // 如果oldCapacity \u0026lt; 64，那newCapacity为oldCapacity * 2 + 2 // 如果oldCapacity \u0026gt;= 64，那newCapacity为oldCapacity * 1.5 if (jump \u0026lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE \u0026gt; 0) // 出现上面说的两种情况时，需要重新调整新容量大小 newCapacity = newCapacity(needed, jump); // 将原数组的元素全部拷贝到新数组中去 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated // 此时数组只是扩大了，但是tail==head，即依然指向同一位置，为避免歧义，需要调整head和tail的位置 if (tail \u0026lt; head || (tail == head \u0026amp;\u0026amp; es[head] != null)) { // wrap around; slide first leg forward to end of array // 计算扩容后数组的剩余空间 int newSpace = newCapacity - oldCapacity; // 将旧数据复制到新位置 System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); // 将旧位置的旧数据全部清空，head成为新位置⾸元素的位置 for (int i = head, to = (head += newSpace); i \u0026lt; to; i++) es[i] = null; } } // 边缘条件的容量计算，尤其是溢出 private int newCapacity(int needed, int jump) { final int oldCapacity = elements.length, minCapacity; // 边界处理：判断旧容量 + 所需的最低额外容量是否超过数组长度允许最大值 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE \u0026gt; 0) { if (minCapacity \u0026lt; 0) throw new IllegalStateException(\u0026#34;Sorry, deque too big\u0026#34;); return Integer.MAX_VALUE; } // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 返回minCapacity = oldCapacity + needed if (needed \u0026gt; jump) return minCapacity; // 如果最小容量minCapacity没有超过数组长度允许最大值，并且need \u0026lt;= jump return (oldCapacity + jump - MAX_ARRAY_SIZE \u0026lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; } 下面通过一个小例子去演示扩容机制的执行流程，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 初始时，数组⻓度是5，真实索引是0-4，head = tail = 0 ArrayDeque\u0026lt;Integer\u0026gt; arrayDeque = new ArrayDeque\u0026lt;\u0026gt;(4); // 执行完，head = 0, tail = 1；此时数组为：[1, null, null, null, null] arrayDeque.addLast(1); // 执行完，head = 4，tail = 1；此时数组为：[1, null, null, null, 2] arrayDeque.addFirst(2); // 执行完，head = 3，tail = 1；此时数组为：[1, null, null, 3, 2] arrayDeque.addFirst(3); // 执行完，head = 2，tail = 1；此时数组为：[1, null, 4, 3, 2] arrayDeque.addFirst(4); // 执行完，head = tail = 1，触发扩容；此时数组为：[1, 5, 4, 3, 2]，扩容容量为5*2+2 // 然后将旧数据复制到新位置，此时数组为：[1, 5, 4, 3, 2, null, null, null, 5, 4, 3, 2] // 接着清掉旧数据，这时head = 8，tail = 1；此时数组为：[1, null, null, null, null, null, null, null, 5, 4, 3, 2] arrayDeque.addFirst(5); // 执行完，head = 8, tail = 2；此时数组为：[1, 6, null, null, null, null, null, null, 5, 4, 3 ,2] arrayDeque.addLast(6); 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 // 返回此双端队列中的元素数 public int size() { // i = tail，j = head，modulus = elements.length // 那么i -= j为i = i-j，代入后是tail = tail - head，然后判断计算后的tail是否 \u0026lt; 0 // 如果 \u0026lt; 0，说明是head \u0026gt; tail的情况，对应于前面讲成员变量提到的数组情况3或4，这种情况下， tail会再次计算，tail = tail + elements.length，这样计算就可以求出数组的元素个数，不明白可以对照图来看 // 如果 \u0026gt;= 0，说明是head \u0026lt;= tail的情况，对应于前面讲成员变量提到的数组情况1或2，这种情况下，直接把tail返回即可，因为if条件判断时已经计算过了，这样计算就可以求出数组的元素个数，不明白可以对照图来看 return sub(tail, head, elements.length); } static final int sub(int i, int j, int modulus) { if ((i -= j) \u0026lt; 0) i += modulus; return i; } 三、总结 在ArrayDeque的源码中，并没有与并发相关的代码，所以说ArrayDeque是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。\nArrayDeque没有索引位置的概念，不能根据索引位置进行操作，所以没有更改操作，如set方法。\n另外，ArrayDeque禁止添加空元素。最关键一点是：ArrayDeque用作堆栈时很可能比Stack快，用作队列时比LinkedList快。\n","date":"2023-04-24T14:41:31+08:00","permalink":"https://AndDevMK.github.io/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraydeque%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayDeque源码「JDK11」"},{"categories":["Java"],"contents":"一、概述 LinkedList是Java Collections Framework的一个成员，然后底层是基于双向链表来实现的。对于LinkedList来说，可能平常开发用的频率并没有ArrayList多，这并不是我们不去学习LinkedList原理的理由。我们知道，ArrayList的特点是随机访问效率很高，但是非尾部的插入和删除性能就比较低，因为要挪动元素位置。LinkedList和ArrayList一样实现了List接口，因为两者底层的实现不一样，造就了它的特点与ArrayList几乎正好相反。\n接下来，本文会叙述LinkedList是如何维护这样一个双向链表的，基本操作是怎样实现的，以及其它的细节。\n二、LinkedList源码解读 2.1、继承关系 从UML类图中可以看到，LinkedList直接或间接实现了Iterable、Collection、List、Deque、Queue、Cloneable、Serializable这7个接口；LinkedList直接或间接继承了AbstractSequentialList、AbstractList、AbstractCollection这3个抽象类。\n可能细心的同学会发现，为什么AbstractList实现了List接口，LinkedList还要去再实现一次List接口？\n关于这一点，在之前的Java集合系列：一文解读ArrayList源码「JDK11」一文中已有解答，除此之外，LinkedList和ArrayList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，本文不再次叙述，想去了解的话，可点击上文链接去了解。\n2.1.1、Queue接口 Queue接口是一个队列接口，它对Collection接口进行了扩展。所谓队列，就类似于日常生活中的各种排队，特点就是先进先出，在尾部添加元素，从头部删除元素，它的接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此队列，则在成功时返回true并在当前没有可用空间时抛出IllegalStateException boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，当使用容量受限的队列时，此方法通常优于add，后者可能仅通过抛出异常来插入元素失败 boolean offer(E e); // 检索并删除此队列的头部。此方法与poll()的不同之处仅在于，如果此队列为空，它会抛出异常 E remove(); // 检索并删除此队列的头部，如果此队列为空，则返回null E poll(); // 检索但不删除此队列的头部。此方法与peek不同之处仅在于，如果此队列为空，它会抛出异常 E element(); // 检索但不删除此队列的头部，如果此队列为空，则返回null E peek(); } Queue队列提供了插入、删除和检查操作。这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（null或false ，具体取决于操作），如下图所示： 注意：Queue队列实现通常不允许插入null元素，尽管某些实现（例如 LinkedList）不禁止插入null。即使在允许它的实现中，也不应将null插入到Queue队列中，因为null也被poll方法用作特殊的返回值，以指示队列不包含任何元素。\n实践一下，我们把LinkedList当作Queue队列来使用，如下代码：\n1 2 3 4 5 6 7 Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(\u0026#34;Jerry\u0026#34;); queue.offer(\u0026#34;Tom\u0026#34;); queue.offer(\u0026#34;May\u0026#34;); while (queue.peek() != null) { System.out.println(queue.poll()); } 2.1.2、Deque接口 Deque接口对Queue接口进行了扩展，Deque是“double ended queue”的缩写，它定义了访问双端队列两端元素的方法，接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此双端队列的前面，如果当前没有可用空间则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerFirst void addFirst(E e); // 如果可以在不违反容量限制的情况下立即插入指定的元素，则在此双端队列的末尾插入指定的元素，如果当前没有可用空间，则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerLast。此方法等效于add void addLast(E e); // 将指定的元素插入此双端队列的前面，除非它违反容量限制。当使用容量受限的双端队列时，此方法通常优于addFirst方法，后者仅通过抛出异常才能插入元素失败。 boolean offerFirst(E e); // 除非违反容量限制，否则在此双端队列的末尾插入指定的元素。当使用容量受限的双端队列时，此方法通常优于addLast方法，后者仅通过抛出异常才能插入元素失败 boolean offerLast(E e); // 检索并删除此双端队列的第一个元素。此方法与pollFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeFirst(); // 检索并删除此双端队列的最后一个元素。此方法与pollLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeLast(); // 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null E pollFirst(); // 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null E pollLast(); // 检索但不删除此双端队列的第一个元素。此方法与peekFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getFirst(); // 检索但不删除此双端队列的最后一个元素。此方法与peekLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getLast(); // 检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回null E peekFirst(); // 检索但不删除此双端队列的最后一个元素，如果此双端队列为空则返回null E peekLast(); // *** Queue methods *** // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true并在当前没有可用空间时抛出IllegalStateException .使用容量受限的双端队列时，通常最好使用offer 。此方法等效于addLast boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true ，如果当前没有可用空间则返回false 。当使用容量受限的双端队列时，此方法通常优于add方法，后者仅通过抛出异常才能插入元素失败。此方法等效于offerLast boolean offer(E e); // 检索并删除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于removeFirst() E remove(); // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。此方法等效于pollFirst() E poll(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于getFirst() E element(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回null 。此方法等效于peekFirst() E peek(); // *** Stack methods *** // 如果可以在不违反容量限制的情况下立即将元素推入此双端队列表示的堆栈（换句话说，在此双端队列的头部），如果当前没有可用空间则抛出IllegalStateException void push(E e); // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。此方法等效于removeFirst() E pop(); } Deque接口提供了插入、删除和检查的方法，这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（ null或false ，具体取决于操作），如下图所示： 当双端队列用作队列时，会产生FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。从Queue接口继承的方法与Deque接口方法完全等价，如下图所示： 除此之外，双端队列也可以用作LIFO（后进先出）堆栈。应优先使用此接口而不是使用Stack类。当双端队列用作堆栈时，元素从双端队列的开头被压入和弹出。Stack方法等同于Deque方法，如下图所示： 实践一下，我们把LinkedList当作Deque堆栈来使用，如下代码：\n1 2 3 4 5 6 7 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;Jerry\u0026#34;); deque.push(\u0026#34;Tom\u0026#34;); deque.push(\u0026#34;May\u0026#34;); while (deque.peek() != null) { System.out.println(deque.pop()); } 注意：当双端队列用作队列或堆栈时，peek方法同样有效；在任何一种情况下，元素都是从双端队列的开头提取的。\n虽然并未严格要求Deque队列实现禁止插入空元素，但强烈建议它们这样做。强烈建议任何确实允许null元素的Deque实现的用户不要利用插入null的能力。之所以如此，是因为null被各种方法用作特殊的返回值，以指示双端队列为空。\nDeque接口除了上面介绍的核心方法外，它还有一个迭代器方法，可以从后往前遍历，如下代码：\n1 2 3 4 5 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(new String[]{\u0026#34;Jerry\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;May\u0026#34;})); Iterator\u0026lt;String\u0026gt; iterator = deque.descendingIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2.2、成员变量 1 2 3 4 5 6 7 8 // LinkedList的大小（它包含的元素数） transient int size = 0; // 指向第一个节点的指针 transient Node\u0026lt;E\u0026gt; first; // 指向最后一个节点的指针 transient Node\u0026lt;E\u0026gt; last; LinkedList的成员变量不多，我们重点看下内部类Node节点的实现，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static class Node\u0026lt;E\u0026gt; { // 存储元素 E item; // 后继节点 Node\u0026lt;E\u0026gt; next; // 前驱节点 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 从上面Node节点的构造函数来看，Node节点的结构如下图所示： LinkedList就是由一个个的Node节点双向连接而成，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 // 构造一个空列表 public LinkedList() { } // 构造一个包含指定集合元素的列表，按照集合迭代器返回元素的顺序 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { this(); // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 addAll(c); } 2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // ***********尾部插入*********** // 将指定的元素附加到此列表的末尾 public boolean add(E e) { linkLast(e); return true; } // 将指定的元素附加到此列表的末尾 public void addLast(E e) { linkLast(e); } // 添加指定元素作为此列表的尾部（最后一个元素） public boolean offer(E e) { return add(e); } // 在此列表的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return addAll(size, c); } // ***********头部插入*********** // 在此列表的开头插入指定的元素 public void addFirst(E e) { linkFirst(e); } // 在此列表的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素推入此列表表示的堆栈中。换句话说，将元素插入此列表的前面 public void push(E e) { addFirst(e); } // ***********中间插入*********** // 在此列表中的指定位置插入指定元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一） public void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 如果插入的索引位置为size，那说明是尾部插入 if (index == size) // 执行尾部插入 linkLast(element); else // 先找到当前链表上指定index位置的node节点，然后再插入新节点 linkBefore(element, node(index)); } // ***********插入核心实现*********** // 链接e作为最后一个元素 void linkLast(E e) { // 获取当前链表的last节点 final Node\u0026lt;E\u0026gt; l = last; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 让新节点成为last节点 last = newNode; // 如果last节点为null，说明这是第一次插入新节点，所以新节点也是first节点 if (l == null) first = newNode; else // 否则新节点是last节点的下一个节点 l.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 链接e作为第一个元素 private void linkFirst(E e) { // 获取当前链表的first节点 final Node\u0026lt;E\u0026gt; f = first; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 让新节点成为last节点 first = newNode; // 如果first节点为null，说明这是第一次插入新节点，所以新节点也是last节点 if (f == null) last = newNode; else // 否则新节点是first节点的上一个节点 f.prev = newNode; // 更新size：元素个数+1 size++; modCount++; } // 返回指定元素索引处的（非空）节点。 Node\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1 == size/2 // 如果index \u0026lt; size/2，那么就从first节点开始往后遍历查找 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 如果index \u0026gt;= size/2，那么就从last节点开始往前遍历查找 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } // 在非空节点 succ 之前插入元素 e void linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; // 获取当前链表的succ节点的前一个节点pred final Node\u0026lt;E\u0026gt; pred = succ.prev; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 让新节点成为succ节点的前一个节点 succ.prev = newNode; // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 将指定集合中的所有元素插入此列表，从指定位置开始。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的​​迭代器返回的顺序出现在列表中。 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 将集合c的元素按集合c的顺序转换为数组返回 Object[] a = c.toArray(); // 如果数组长度为0，那么返回false int numNew = a.length; if (numNew == 0) return false; // 定义当前链表index索引对应的succ节点，以及succ节点的前节点pred Node\u0026lt;E\u0026gt; pred, succ; // 如果index == size，说明是尾部插入 if (index == size) { // size位置的节点为null succ = null; // pred节点为插入位置的前节点last pred = last; } else { // 否则是中间插入，那么先找到当前链表上指定index位置的node节点，然后再插入新节点 succ = node(index); // pred为succ的前节点 pred = succ.prev; } // 遍历数组，让数组转换为链表 for (Object o : a) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新节点 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 每一轮循环结束，新节点就是pred节点 pred = newNode; } // 如果succ节点为null，说明是尾部插入，此时插入已经完成，那么pred节点为数组的最后一个节点，所以理所应当成为last节点 if (succ == null) { last = pred; } else { // 如果succ节点不为null，说明是中间插入，此时插入已经完成，那么数组的最后一个节点指向插入位置节点succ pred.next = succ; // 数组的最后一个节点pred，理所应当成为插入位置节点succ的上一个节点 succ.prev = pred; } // 更新size：元素个数+数组长度 size += numNew; modCount++; return true; } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 // ***********尾部删除*********** // 从此列表中移除并返回最后一个元素 public E removeLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 检索并删除此列表的最后一个元素，如果此列表为空，则返回null public E pollLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : unlinkLast(l); } // ***********头部删除*********** // 检索并删除此列表的头部（第一个元素） public E remove() { return removeFirst(); } // 检索并删除此列表的头部（第一个元素） public E poll() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表中移除并返回第一个元素。 public E removeFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 检索并删除此列表的第一个元素，如果此列表为空，则返回null public E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素 public E pop() { return removeFirst(); } // ***********中间删除*********** // 移除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）。返回从列表中删除的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } // ***********删除核心实现*********** // 取消链接非空的第一个节点f private E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // assert f == first \u0026amp;\u0026amp; f != null; // 获取node节点的元素element final E element = f.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = f.next; // 将node节点持有的元素item置为null f.item = null; // 将node节点持有的后继节点指针置为null f.next = null; // help GC // node节点的下一个节点成为first节点 first = next; // 如果next节点为null，说明最后一个节点也被删除了，那么last节点置为null if (next == null) last = null; else // 否则node节点置为null next.prev = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空的最后一个节点l private E unlinkLast(Node\u0026lt;E\u0026gt; l) { // assert l == last \u0026amp;\u0026amp; l != null; // 获取node节点的元素element final E element = l.item; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = l.prev; // 将node节点持有的元素item置为null l.item = null; // 将node节点持有的前躯节点指针置为null l.prev = null; // help GC // node节点的上一个节点成为last节点 last = prev; // 如果prev节点为null，说明最后一个节点也被删除了，那么first节点置为null if (prev == null) first = null; else // 否则node节点置为null prev.next = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空节点x E unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null; // 获取node节点的元素element final E element = x.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = x.next; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 如果prev节点为null，说明是头部删除，那么next节点成为first节点 if (prev == null) { first = next; } else { // 如果prev节点不为null，说明是中间删除，那么next节点成为前驱节点prev的下一个节点 prev.next = next; // node节点的前驱节点指针置为null x.prev = null; } // 如果next节点为null，说明是尾部删除，那么prev节点成为last节点 if (next == null) { last = prev; } else { // 如果prev节点不为null，说明是中间删除，那么prev节点成为后继节点next的上一个节点 next.prev = prev; // node节点的后继节点指针置为null x.next = null; } // 将node节点持有的元素item置为null x.item = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果此列表不包含该元素，则它保持不变。更正式地说，删除具有最低索引i元素 public boolean remove(Object o) { // 如果要删除的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后执行删除 if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果要删除的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后执行删除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 2.4.3、更改 1 2 3 4 5 6 7 8 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { checkElementIndex(index); Node\u0026lt;E\u0026gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 2.4.4、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ***********头部检索*********** // 检索但不删除此列表的头部（第一个元素） public E element() { return getFirst(); } // 检索但不删除此列表的头部（第一个元素） public E peek() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // 返回此列表中的第一个元素 public E getFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 检索但不删除此列表的第一个元素，如果此列表为空，则返回null public E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // ***********尾部检索*********** // 返回此列表中的最后一个元素 public E getLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回null public E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } // ***********中间检索*********** // 返回此列表中指定位置的元素 public E get(int index) { checkElementIndex(index); return node(index).item; } 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 返回此列表中指定元素第一次出现的索引，如果此列表不包含该元素，则返回 -1，更正式地说，返回具有最低索引i元素 public int indexOf(Object o) { int index = 0; // 如果要查找的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后返回index if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { // 如果要查找的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后返回index for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 三、总结 在LinkedList的源码中，并没有与并发相关的代码，所以说LinkedList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new LinkedList(...)); 另外，LinkedList要根据实际的业务场景来使用，比如说，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，使用LinkedList会有更好的性能。\n","date":"2023-04-19T14:41:31+08:00","permalink":"https://AndDevMK.github.io/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBlinkedlist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读LinkedList源码「JDK11」"},{"categories":null,"contents":" 此博客主要用来对日常的开发等相关的内容进行记录，如果需要转载请表明出处。\n欢迎关注我的公众号 👇👇👇 ","date":"2023-04-16T20:53:15+08:00","permalink":"https://AndDevMK.github.io/about/","section":"","tags":null,"title":"About"},{"categories":["Java"],"contents":"一、概述 ArrayList是经常用到的一个容器，它是Java Collections Framework的一个成员，然后底层是基于定长数组来实现的，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据。\n因此，扩容机制是ArrayList的核心所在，这一点是务必要掌握的；除此之外，本文还会叙述ArrayList的基本操作是怎样实现的，以及其它的细节。\n二、ArrayList源码解读 2.1、继承关系 从UML类图中可以看到，ArrayList直接或间接实现了Iterable、Collection、List、RandomAccess、Cloneable、Serializable这6个接口；ArrayList直接或间接继承了AbstractList、AbstractCollection这2个抽象类。\n疑问来了：为什么AbstractList实现了List接口，ArrayList还要去再实现一次List接口，是吃饱了撑着吗？\n带着疑问，我立马去网上冲浪一波，然后发现了3个对此的解释。\n观点1：如果ArrayList没去实现List接口，会导致class的getInterfaces方法返回不同的结果，这么做是为了方便基于List接口的动态代理。\n观点2：这可能是为了增加继承结构的可追踪性。当浏览Javadoc或类似的东西时，就不必遍历整个继承树，它不会有任何不良影响，并且可以帮助理解代码。\n观点3：ArrayList的作者Josh Bloch曾经认为ArrayList再实现一次List接口是有一些价值的，但后来发现这是个错误。\n以上3个观点均出自stackoverflow的一个帖子，我们了解下就好了，深究意义不大，具体原因还得是作者自己才知道。\n2.1.1、Iterable接口 2.1.1.1、概述 Iterable表示可迭代的，它有个iterator方法，需要返回Iterator对象，Iterator是一个接口，表示为迭代器。Iterable接口的定义如下：\n1 2 3 4 5 6 public interface Iterable\u0026lt;T\u0026gt; { Iterator\u0026lt;T\u0026gt; iterator(); // .....省略 } 那么实现Iterable接口有什么作用呢？先说结论：只要对象实现了Iterable接口，就可以使用for-each语法，编译器会转换为调用Iterable和Iterator接口的方法。\n我们平常用for-each语法遍历list时，你可能会写下如下代码：\n1 2 3 4 5 6 7 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(3); list.add(1); list.add(2); list.add(3); for (Integer value : list) { System.out.println(\u0026#34;value: \u0026#34; + value); } 这种for-each语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：\n1 2 3 4 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.next()); } 除了Iterable接口的iterator方法外，List接口也有一个listIterator方法，需要返回ListIterator对象，ListIterator是一个接口，它对Iterator接口做了扩展。比如，可以从末尾往前遍历，如下代码：\n1 2 3 4 ListIterator\u0026lt;Integer\u0026gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.previous()); } 2.1.1.2、fail-fast机制 那些年，年少时所犯下的错误，想起自己刚入门Java时，曾经写过如下代码：\n1 2 3 4 5 for (Integer value : list) { if (value \u0026lt; 3) { list.remove(value); } } 当年的直觉告诉你，这么写不存在问题，但是运行却会报并发修改的错误：\n1 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException 显然，这里是没有并发的代码，我们去看看ConcurrentModificationException的注释描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 当不允许进行此类修改时，已检测到对象的并发修改的方法可能会抛出此异常。 * This exception may be thrown by methods that have detected concurrent * modification of an object when such modification is not permissible. * \u0026lt;p\u0026gt; * 例如，通常不允许一个线程在另一个线程迭代集合时修改集合。 * For example, it is not generally permissible for one thread to modify a Collection * while another thread is iterating over it. * 通常，在这些情况下迭代的结果是不确定的。 * In general, the results of the iteration are undefined under these circumstances. * 如果检测到此行为，某些 Iterator 实现（包括 JRE 提供的所有通用集合实现）可能会选择抛出此异常。 * Some Iterator implementations (including those of all the general purpose collection implementations * provided by the JRE) may choose to throw this exception if this behavior is * detected. * 执行此操作的迭代器被称为fail-fast迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间出现任意的、不确定的行为的风险。 * Iterators that do this are known as \u0026lt;i\u0026gt;fail-fast\u0026lt;/i\u0026gt; iterators, * as they fail quickly and cleanly, rather that risking arbitrary, * non-deterministic behavior at an undetermined time in the future. * \u0026lt;p\u0026gt; * 请注意，此异常并不总是表示对象已被不同的线程并发修改。 * Note that this exception does not always indicate that an object has * been concurrently modified by a \u0026lt;i\u0026gt;different\u0026lt;/i\u0026gt; thread. * 如果单个线程发出一系列违反对象契约的方法调用，则该对象可能会抛出此异常。 * If a single thread issues a sequence of method invocations that violates the * contract of an object, the object may throw this exception. * 例如，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。 * For example, if a thread modifies a collection directly while it is * iterating over the collection with a fail-fast iterator, the iterator * will throw this exception. * 请注意，不能保证fail-fast行为，因为一般来说，在存在非同步并发修改的情况下不可能做出任何硬性保证。 * \u0026lt;p\u0026gt;Note that fail-fast behavior cannot be guaranteed as it is, generally * speaking, impossible to make any hard guarantees in the presence of * unsynchronized concurrent modification. * ail-fast操作会尽最大努力抛出ConcurrentModificationException。 * Fail-fast operations throw {@code ConcurrentModificationException} on a best-effort basis. * 因此，编写依赖于此异常的正确性的程序是错误的： ConcurrentModificationException应该仅用于检测错误。 * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: \u0026lt;i\u0026gt;{@code ConcurrentModificationException} * should be used only to detect bugs.\u0026lt;/i\u0026gt; * * @author Josh Bloch * @see Collection * @see Iterator * @see Spliterator * @see ListIterator * @see Vector * @see LinkedList * @see HashSet * @see Hashtable * @see TreeMap * @see AbstractList * @since 1.2 */ 上面的注释说的很明显了，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。\n那么如何避免异常呢？可以使用迭代器的remove方法，如下所示：\n1 2 3 4 5 6 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { if (iterator.next() \u0026lt; 3) { iterator.remove(); } } 它自己的remove方法为何又可以使用呢？我们需要看下迭代器的原理了。\n2.1.1.3、迭代器的原理 我们先来看下ArrayList中iterator方法的实现，代码如下：\n1 2 3 4 5 6 7 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } } iterator方法实现很简单，直接new一个Itr对象返回，Itr是ArrayList的一个成员内部类，实现了Iterator接口，它的代码量并不多，所以直接贴出来了，看注释应该就能明白。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return 下一个要返回的元素位置 int lastRet = -1; // index of last element returned; -1 if no such 最后一个返回的索引位置，如果没有，为-1 int expectedModCount = modCount; // 期望的修改次数，初始化为外部类当前的修改次数modCount // prevent creating a synthetic constructor Itr() {} public boolean hasNext() { return cursor != size; // cursor与数组元素数量的比较 } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { // 校验是否发生了结构性变化 checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 更新cursor的值，每次+1 cursor = i + 1; // 更新lastRet值，返回对应的元素 return (E) elementData[lastRet = i]; } public void remove() { // 注意：lastRet \u0026lt; 0时会抛出异常，所以调用remove()之前需要先调用next()去更新lastRet的值 if (lastRet \u0026lt; 0) throw new IllegalStateException(); // 校验是否发生了结构性变化 checkForComodification(); try { // 执行ArrayList的remove方法，modCount++ ArrayList.this.remove(lastRet); // 更新cursor的值，remove后元素数量少了一个，相当于cursor=cursor-1 cursor = lastRet; // 重置lastRet lastRet = -1; // 更新expectedModCount expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 校验是否发生了结构性变化，所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 迭代器源码中next方法，remove方法都会调用checkForComodification方法进行校验是否发生了结构性变化，由此可见，迭代器的内部维护了索引位置相关的数据，要求在迭代过程中，不能发生结构性变化，否则这些索引位置功能就会失效。\n2.1.2、RandomAccess接口 RandomAccess内部是没有任何代码的接口，它属于标记接口，其定义如下：\n1 2 public interface RandomAccess { } 实现了RandomAccess接口的类表示支持快速随机访问，用在一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现，比如Collections类的binarySearch方法，会根据List是否实现了RandomAccess接口而采用不同的实现，代码如下：\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } 2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。注意：要将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少 // 可以理解为标记调空参数构造方法 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 都将扩展为 DEFAULT_CAPACITY。 transient Object[] elementData; // ArrayList的大小（它包含的元素数） private int size; // 要分配的数组的最大大小（除非必要） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表，使得正在进行的迭代可能会产生不正确的结果。 protected transient int modCount = 0; 疑问来了：我们知道了ArrayList实现了Serializable接口，但是elementData为何要用transient修饰，这不表示elementData不能被序列化？\n其实玄机在于ArrayList中的两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 将ArrayList实例的状态保存到流中（即序列化它）。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // 从流中重构ArrayList实例（即反序列化） private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { elements[i] = s.readObject(); } elementData = elements; } else if (size == 0) { elementData = EMPTY_ELEMENTDATA; } else { throw new java.io.InvalidObjectException(\u0026#34;Invalid size: \u0026#34; + size); } } ArrayList在序列化的时候会调用writeObject方法，直接将size和element写入ObjectOutputStream；反序列化时调用readObject方法，从ObjectInputStream获取size和element，再恢复到elementData。\nelementData是存储ArrayList元素的数组缓冲区，通常扩容后都会预留一些空间，也就是说有部分空间实际没有存储元素，序列化时只序列化实际存储的那些元素，而不是整个数组，从而可以节省空间和时间。\n疑问来了：为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8而不是Integer.MAX_VALUE？\n因为存储了Array的头部信息，所以这里需要减去8。\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 空参构造方法 public ArrayList() { // 由于没有指定初始容量，所以赋值一个空实例的共享空数组实例，可以理解为标记调空参数构造方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定了初始容量的构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 创建指定大小的Object数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 elementData = c.toArray(); if ((size = elementData.length) != 0) { // 重复调用Arrays.copyOf()是为了防止c.toArray()不返回Object[] // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } } 2.4、核心方法 2.4.1、add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将指定的元素附加到此列表的末尾 public boolean add(E e) { // 此列表在结构上被修改的次数 modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { // 数组容量满了，执行扩容机制 if (s == elementData.length) // 得到一个扩容后的新数组 elementData = grow(); // size位置插入元素 elementData[s] = e; // 更新size大小：原元素个数大小+1 size = s + 1; } // 在此列表中的指定位置插入指定元素 public void add(int index, E element) { // 校验index的范围 rangeCheckForAdd(index); modCount++; // 当前元素个数大小 final int s; Object[] elementData; // 数组容量满了，执行扩容机制 if ((s = size) == (elementData = this.elementData).length) // 得到一个扩容后的新数组 elementData = grow(); // 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 移动后，index位置空余出来，即可将element插入到index位置 elementData[index] = element; // 更新size大小：原元素个数大小+1 size = s + 1; } // 将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; // 原数组的剩余容量不够插入数组的大小时，就进行扩容 if (numNew \u0026gt; (elementData = this.elementData).length - (s = size)) // 得到一个扩容后的新数组 elementData = grow(s + numNew); // 将插入数组的元素拷贝到扩容数组上 System.arraycopy(a, 0, elementData, s, numNew); // 更新size大小：原元素个数大小+插入数组的长度 size = s + numNew; return true; } 关于add方法，如果是末尾插入，那么平均时间复杂度为O(1)；如果是非末尾插入，因为需要移动元素，那么平均时间复杂度为O(n)。因此，我们应该尽量避免在大数据量中调用add带索引参数的方法。\n2.4.2、grow方法（扩容机制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private Object[] grow() { return grow(size + 1); } // 增加容量以确保它至少可以容纳最小容量参数指定的元素数 private Object[] grow(int minCapacity) { // minCapacity = size + 1 // 先计算新容量大小，再根据新容量大小创建一个Object[]新数组，把数据拷贝到新数组上 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 返回至少与给定最小容量一样大的容量。如果足够，返回增加 50% 的当前容量。除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。 private int newCapacity(int minCapacity) { // overflow-conscious code // 旧容量 = 原数组的长度 int oldCapacity = elementData.length; // 新容量 = 旧容量 + 旧容量右移一位（相当于除于2） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt;= 0) { // 如果是调用了无参数构造方法，没有指定初始容量时 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 默认初始容量就为10 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 其它情况一律size + 1 return minCapacity; } // 如果还没达到最大容量，那就是新容量大小，否则返回一个返回一个巨大的容量 return (newCapacity - MAX_ARRAY_SIZE \u0026lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // size+1 \u0026gt; MAX_ARRAY_SIZE时，那么返回一个巨大的容量Integer.MAX_VALUE，否则MAX_ARRAY_SIZE return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 2.4.3、remove方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 移除此列表中指定位置的元素 public E remove(int index) { // 校验index的范围 Objects.checkIndex(index, size); final Object[] es = elementData; // 取出要移除的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E oldValue = (E) es[index]; // 删除元素 fastRemove(es, index); // 返回要移除的元素 return oldValue; } // 跳过边界检查并且不返回删除的值的私有删除方法 private void fastRemove(Object[] es, int i) { modCount++; final int newSize; // 如果删除的元素索引位置非最后一个元素位置，那么将当前位于该位置的元素（如果有）和任何后续元素向左移动（将其索引减一）。 if ((newSize = size - 1) \u0026gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); // 移动原size-1位置多余了，需要置null es[size = newSize] = null; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果列表不包含该元素，则它不变。 public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; // 使用了java label语法 found: { // 如果传入null，那么遍历去查看是否存在null的元素，找到就跳出循环 if (o == null) { for (; i \u0026lt; size; i++) if (es[i] == null) break found; } else { // 如果传入不为null，那么遍历去查看是否存在相同的元素，找到就跳出循环 for (; i \u0026lt; size; i++) if (o.equals(es[i])) break found; } // 上面两个条件下都找不到要查找的元素，则返回false return false; } // 找到要删除的元素后执行删除 fastRemove(es, i); return true; } 2.4.4、set方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { // 校验index的范围 Objects.checkIndex(index, size); // 获取索引位置对应的元素 E oldValue = elementData(index); // 设置索引位置对应的元素 elementData[index] = element; // 返回要修改的元素 return oldValue; } // 返回索引位置对应的元素 E elementData(int index) { return (E) elementData[index]; } 2.4.5、get方法 1 2 3 4 5 6 7 // 返回此列表中指定位置的元素 public E get(int index) { // 校验index的范围 Objects.checkIndex(index, size); // 返回索引位置对应的元素 return elementData(index); } 2.5、其它方法 2.5.1、ensureCapacity方法 1 2 3 4 5 6 7 8 9 10 11 12 // 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数。 // 也就是说，这个方法的使用场景是如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数 public void ensureCapacity(int minCapacity) { // 最小容量不得低于原数组的长度，同时原数组不是第一次调用空参数构造方法和第一次扩容 if (minCapacity \u0026gt; elementData.length \u0026amp;\u0026amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u0026amp;\u0026amp; minCapacity \u0026lt;= DEFAULT_CAPACITY)) { modCount++; // 进行扩容 grow(minCapacity); } } 2.5.2、trimToSize方法 1 2 3 4 5 6 7 8 9 10 11 12 // 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList实例的存储 public void trimToSize() { modCount++; // 数组容量没装满元素 if (size \u0026lt; elementData.length) { // 如果元素个数为0，那么赋值一个空实例的共享空数组实例 elementData = (size == 0) ? EMPTY_ELEMENTDATA // 否则拷贝元素到新数组上，新数组的大小就是元素个数的数量 : Arrays.copyOf(elementData, size); } } 三、总结 在ArrayList的源码中，并没有与并发相关的代码，所以说ArrayList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new ArrayList(...)); 另外，ArrayList是经常用到的一个容器，要根据实际的业务场景来使用，比如说，当添加、删除数据不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会有更好的性能。\n","date":"2023-04-16T14:41:31+08:00","permalink":"https://AndDevMK.github.io/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraylist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayList源码「JDK11」"}]