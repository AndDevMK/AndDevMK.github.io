[{"categories":["Kotlin"],"contents":" 注：本文代码基于Kotlin 1.9.0\n前言 一般而言，Kotlin的协程实现分为两个层次：\n基础设施层：标准库的协程API，主要对协程提供了概念和语义上最基本的支持，API所在包名的前缀为kotlin.coroutines.*。基于此，本文主要内容就是解读Kotlin协程启动源码。\n业务框架层：协程的上层框架支持，API所在包名的前缀为kotlinx.coroutines.*。\n整体上，将通过Kotlin协程的基础设施创建的协程称为简单协程，将基于简单协程实现的各种业务层进行封装之后得到的协程称为复合协程。\n一、协程的创建 在Kotlin当中创建一个简单协程不是什么难事，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) 标准库中提供了一个createCoroutine方法，我们可以通过它来创建协程，不过这个协程并不会立即执行，我们先来看看它的声明:\n1 2 3 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; 这里解释下上面的声明：\n1、suspend ()-\u0026gt;T是createCoroutine方法的Receiver，Receiver是一个被suspend关键字修饰的挂起函数，这也是协程的执行体，我们不妨称它为协程体。这里补充一条Kotlin基础知识：Kotlin扩展的本质就是定义了一个函数，当程序用对象调用扩展方法时，Kotlin在编译过程中会执行静态解析，将调用扩展函数的调用者作为函数的第一个参数传入，也就是说，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，对于本文后面的内容来说，这是一个伏笔，叫它伏笔1吧；\n2、参数completion会在协程执行完成后调用，实际上就是协程的完成回调；\n3、返回值是一个Continuation对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动。\n二、协程的启动 调用continuation的resume方法之后，协程体会立即开始执行，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 此时要抛出本文要重点解决的问题：为什么调用continuation.resume(Unit)就会触发协程体的执行呢？\n如果按一般思路去理解，上面代码返回的变量continuation就是问题的突破口，只要找出continuation变量的真身，就能定位到resume方法的具体实现，从而找出触发协程体执行的所在。\nOK，一步步来，我们先看suspend方法的源码：\n1 public inline fun \u0026lt;R\u0026gt; suspend(noinline block: suspend () -\u0026gt; R): suspend () -\u0026gt; R = block suspend方法比较简单，把传入的挂起函数原封不动地返回，但是要注意：suspend方法是一个内联方法，而参数block是非内联的，意味着block在编译后会生成一个函数对象（匿名内部类），这里是埋下伏笔2。\ncreateCoroutine方法的声明我们前面讲过了，现在完整看下createCoroutine方法的源码：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 由源码可知，这里调用了2个参数的构造方法创建了SafeContinuation对象，其中第1个参数先不管，后面会讲到，第2个参数为COROUTINE_SUSPENDED。知道了continuation变量的实例对象是SafeContinuation，也就是说可以推测下，调用continuation变量的resume方法实际上是调用了SafeContinuation的resume方法，继续跟踪SafeContinuation的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal expect class SafeContinuation\u0026lt;in T\u0026gt; : Continuation\u0026lt;T\u0026gt; { internal constructor(delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any?) @PublishedApi internal constructor(delegate: Continuation\u0026lt;T\u0026gt;) @PublishedApi internal fun getOrThrow(): Any? override val context: CoroutineContext override fun resumeWith(result: Result\u0026lt;T\u0026gt;): Unit } public interface Continuation\u0026lt;in T\u0026gt; { public val context: CoroutineContext public fun resumeWith(result: Result\u0026lt;T\u0026gt;) } 通过观察SafeContinuation的源码，可以得到3个结论：\n1、SafeContinuation类是expect关键字修饰，意味着它是一个跨平台类，也就是说不同平台该类有不同的实现。这里先说明，后面我们只看Kotlin平台下的具体实现；\n2、SafeContinuation类实现了接口Continuation；\n3、SafeContinuation类中并没有resume方法，然而我们先前推测过，调用continuation的resume方法实际上是调用了SafeContinuation的resume方法，很显然这是错的。\n看到这里或许已经一头雾水了，但是先不要着急哈，继续寻找突破口，先看下continuation变量的resume方法的源码：\n1 2 public inline fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resume(value: T): Unit = resumeWith(Result.success(value)) 由源码可知，resume方法是接口Continuation的一个扩展方法，其内部调用了Continuation的resumeWith方法，结合前面说的，SafeContinuation实现了接口Continuation，那么最终调用的就是SafeContinuation的resumeWith方法了。\n但是SafeContinuation是一个跨平台类，要先找到它的具体实现，在Kotlin平台上的具体实现位置为：\nSafeContinuation具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 internal actual class SafeContinuation\u0026lt;in T\u0026gt; internal actual constructor( private val delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any? ) : Continuation\u0026lt;T\u0026gt;, CoroutineStackFrame { @PublishedApi internal actual constructor(delegate: Continuation\u0026lt;T\u0026gt;) : this(delegate, UNDECIDED) public actual override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { while (true) { // lock-free loop val cur = this.result // atomic read when { cur === UNDECIDED -\u0026gt; if (RESULT.compareAndSet(this, UNDECIDED, result.value)) return cur === COROUTINE_SUSPENDED -\u0026gt; if (RESULT.compareAndSet(this, COROUTINE_SUSPENDED, RESUMED)) { delegate.resumeWith(result) return } else -\u0026gt; throw IllegalStateException(\u0026#34;Already resumed\u0026#34;) } } } } 先前讲过，创建SafeContinuation对象时传入的第2个参数为COROUTINE_SUSPENDED，那么可以知道，SafeContinuation的resumeWith方法执行后实际上调用的是delegate变量的resumeWith方法，于是乎，现在可以从找continuation变量的真身转为找delegate变量的真身了，因为SafeContinuation只是个包装马甲，真正做事情的是delegate变量，那么delegate变量又是什么了？\nSafeContinuation对象被创建是通过调用2个参数的构造方法，其中delegate变量是第1个参数待传入，我们可以回去跟踪下SafeContinuation被创建时的源码：\n1 2 3 4 5 6 7 8 9 10 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) public expect fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; public expect fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; 由源码可知，delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() 而且发现createCoroutineUnintercepted方法和intercepted方法都是跨平台方法，要先找到它们的具体实现，在Kotlin平台上的具体实现位置为：\ncreateCoroutineUnintercepted方法和intercepted方法的具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) // ① return if (this is BaseContinuationImpl) create(probeCompletion) // ② else createCoroutineFromSuspendFunction(probeCompletion) { // ③ (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } private inline fun \u0026lt;T\u0026gt; createCoroutineFromSuspendFunction( completion: Continuation\u0026lt;T\u0026gt;, crossinline block: (Continuation\u0026lt;T\u0026gt;) -\u0026gt; Any? ): Continuation\u0026lt;Unit\u0026gt; { val context = completion.context // label == 0 when coroutine is not started yet (initially) or label == 1 when it was return if (context === EmptyCoroutineContext) object : RestrictedContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } else object : ContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;, context) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } } public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this // ④ 这里解释下上面的标号地方：\n标号①、probeCoroutineCreated方法如下：\n1 2 3 internal fun \u0026lt;T\u0026gt; probeCoroutineCreated(completion: Continuation\u0026lt;T\u0026gt;): Continuation\u0026lt;T\u0026gt; { return completion } 代码很简单，就是把传入的completion原封不动的返回。\n标号②、如果suspend () -\u0026gt; T是BaseContinuationImpl的子类，那么调用BaseContinuationImpl类的create方法，并返回Continuation\u0026lt;Unit\u0026gt;，该方法如下：\n1 2 3 4 5 6 7 8 internal abstract class BaseContinuationImpl( public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public open fun create(completion: Continuation\u0026lt;*\u0026gt;): Continuation\u0026lt;Unit\u0026gt; { throw UnsupportedOperationException(\u0026#34;create(Continuation) has not been overridden\u0026#34;) } } BaseContinuationImpl类的create方法默认没有实现，估计是其子类实现了。\n标号③、如果suspend () -\u0026gt; T不是BaseContinuationImpl的子类，那么调用createCoroutineFromSuspendFunction方法，并返回Continuation\u0026lt;Unit\u0026gt;，其方法闭包中会将suspend () -\u0026gt; T强制转换为Function1接口，并调用Function1接口的invoke方法。\n解释下createCoroutineFromSuspendFunction方法的实现：\ncreateCoroutineFromSuspendFunction方法内部会先判断context变量是否为EmptyCoroutineContext对象，如果是的话则返回RestrictedContinuationImpl对象，否则就返回ContinuationImpl对象。\n标号④、将调用Continuation接口扩展方法intercepted的调用者强制转换为ContinuationImpl对象，如果转换成功，则调用ContinuationImpl的intercepted方法，否则返回调用者本身。\nOK，上面分析那么多，发现有2个名字比较显眼：ContinuationImpl和BaseContinuationImpl，可以认为它们和delegate的构建肯定有关系，到这里就不往下看源码了，因为看不懂了，啊哈哈～。\n既然按一般思路去跟踪源码无法定位到问题，那么只能反编译源码了，去看看编译器是否在编译后添加了“魔法”，回顾下先前协程启动的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 运行过上面代码后，点击IDEA的Tools-\u0026gt;Kotlin-\u0026gt;Show Kotlin ByteCode来查看字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 // ================com/pengmj/kotlincoroutine/SampleKt.class ================= // class version 52.0 (52) // access flags 0x31 public final class com/pengmj/kotlincoroutine/SampleKt { // access flags 0x19 public final static main()V L0 LINENUMBER 6 L0 L1 LINENUMBER 9 L1 L2 LINENUMBER 6 L2 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ACONST_NULL INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V CHECKCAST kotlin/jvm/functions/Function1 ASTORE 1 L3 ALOAD 1 L4 LINENUMBER 9 L4 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 DUP INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.\u0026lt;init\u0026gt; ()V CHECKCAST kotlin/coroutines/Continuation INVOKESTATIC kotlin/coroutines/ContinuationKt.createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; L5 LINENUMBER 6 L5 ASTORE 0 L6 LINENUMBER 17 L6 ALOAD 0 ASTORE 1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; ASTORE 2 L7 ALOAD 1 GETSTATIC kotlin/Result.Companion : Lkotlin/Result$Companion; POP ALOAD 2 INVOKESTATIC kotlin/Result.constructor-impl (Ljava/lang/Object;)Ljava/lang/Object; L8 INVOKEINTERFACE kotlin/coroutines/Continuation.resumeWith (Ljava/lang/Object;)V (itf) L9 LINENUMBER 18 L9 RETURN L10 LOCALVARIABLE continuation Lkotlin/coroutines/Continuation; L6 L10 0 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x1009 public static synthetic main([Ljava/lang/String;)V INVOKESTATIC com/pengmj/kotlincoroutine/SampleKt.main ()V RETURN MAXSTACK = 0 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=2, d1={\u0026#34;\\u0000\\u0008\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001\\u00a8\\u0006\\u0002\u0026#34;}, d2={\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.class ================= // class version 52.0 (52) // access flags 0x30 // signature Lkotlin/coroutines/jvm/internal/SuspendLambda;Lkotlin/jvm/functions/Function1\u0026lt;Lkotlin/coroutines/Continuation\u0026lt;-Ljava/lang/Integer;\u0026gt;;Ljava/lang/Object;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin.coroutines.jvm.internal.SuspendLambda implements kotlin.jvm.functions.Function1\u0026lt;kotlin.coroutines.Continuation\u0026lt;? super java.lang.Integer\u0026gt;, java.lang.Object\u0026gt; final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { // access flags 0x11 public final invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object; @Lorg/jetbrains/annotations/Nullable;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 INVOKESTATIC kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED ()Ljava/lang/Object; L0 LINENUMBER 6 L0 ASTORE 3 ALOAD 0 GETFIELD com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.label : I TABLESWITCH 0: L1 default: L2 L1 ALOAD 1 INVOKESTATIC kotlin/ResultKt.throwOnFailure (Ljava/lang/Object;)V L3 LINENUMBER 7 L3 BIPUSH 88 ISTORE 2 L4 LINENUMBER 8 L4 BIPUSH 123 ILOAD 2 IADD INVOKESTATIC kotlin/coroutines/jvm/internal/Boxing.boxInt (I)Ljava/lang/Integer; L5 ARETURN L2 LINENUMBER 6 L2 NEW java/lang/IllegalStateException DUP LDC \u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34; INVOKESPECIAL java/lang/IllegalStateException.\u0026lt;init\u0026gt; (Ljava/lang/String;)V ATHROW LOCALVARIABLE x I L4 L5 2 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$1; L3 L2 0 LOCALVARIABLE $result Ljava/lang/Object; L3 L2 1 MAXSTACK = 3 MAXLOCALS = 4 @Lkotlin/coroutines/jvm/internal/DebugMetadata;(f=\u0026#34;sample.kt\u0026#34;, l={}, i={}, s={}, n={}, m=\u0026#34;invokeSuspend\u0026#34;, c=\u0026#34;com.pengmj.kotlincoroutine.SampleKt$main$continuation$1\u0026#34;) // access flags 0x0 \u0026lt;init\u0026gt;(Lkotlin/coroutines/Continuation;)V ALOAD 0 ICONST_1 ALOAD 1 INVOKESPECIAL kotlin/coroutines/jvm/internal/SuspendLambda.\u0026lt;init\u0026gt; (ILkotlin/coroutines/Continuation;)V RETURN MAXSTACK = 3 MAXLOCALS = 2 // access flags 0x0 I label // access flags 0x11 // signature (Lkotlin/coroutines/Continuation\u0026lt;*\u0026gt;;)Lkotlin/coroutines/Continuation\u0026lt;Lkotlin/Unit;\u0026gt;; // declaration: kotlin.coroutines.Continuation\u0026lt;kotlin.Unit\u0026gt; create(kotlin.coroutines.Continuation\u0026lt;?\u0026gt;) public final create(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; @Lorg/jetbrains/annotations/NotNull;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 ALOAD 1 LDC \u0026#34;completion\u0026#34; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullParameter (Ljava/lang/Object;Ljava/lang/String;)V NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ALOAD 1 INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V ASTORE 2 ALOAD 2 ARETURN L1 LOCALVARIABLE this Lkotlin/coroutines/jvm/internal/BaseContinuationImpl; L0 L1 0 LOCALVARIABLE completion Lkotlin/coroutines/Continuation; L0 L1 1 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x11 public final invoke(Ljava/lang/Object;)Ljava/lang/Object; ALOAD 0 ALOAD 1 CHECKCAST kotlin/coroutines/Continuation INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.create (Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; CHECKCAST com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.invokeSuspend (Ljava/lang/Object;)Ljava/lang/Object; ARETURN MAXSTACK = 2 MAXLOCALS = 2 @Lkotlin/Metadata;(mv={1, 9, 0}, k=3, d1={\u0026#34;\\u0000\\n\\n\\u0000\\n\\u0002\\u0010\\u0008\\n\\u0002\\u0008\\u0002\\u0010\\u0000\\u001a\\u00020\\u0001H\\u008a@\\u00a2\\u0006\\u0004\\u0008\\u0002\\u0010\\u0003\u0026#34;}, d2={\u0026#34;\u0026lt;anonymous\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;invoke\u0026#34;, \u0026#34;(Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;}) OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.class ================= // class version 52.0 (52) // access flags 0x31 // signature Ljava/lang/Object;Lkotlin/coroutines/Continuation\u0026lt;Ljava/lang/Integer;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin.coroutines.Continuation\u0026lt;java.lang.Integer\u0026gt; public final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin/coroutines/Continuation { OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x1 public getContext()Lkotlin/coroutines/CoroutineContext; @Lorg/jetbrains/annotations/NotNull;() // invisible L0 LINENUMBER 11 L0 GETSTATIC kotlin/coroutines/EmptyCoroutineContext.INSTANCE : Lkotlin/coroutines/EmptyCoroutineContext; CHECKCAST kotlin/coroutines/CoroutineContext ARETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public resumeWith(Ljava/lang/Object;)V // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 LINENUMBER 14 L0 ALOAD 1 INVOKESTATIC kotlin/Result.toString-impl (Ljava/lang/Object;)Ljava/lang/String; ASTORE 2 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L2 L3 LINENUMBER 15 L3 RETURN L4 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L4 0 LOCALVARIABLE result Ljava/lang/Object; L0 L4 1 MAXSTACK = 2 MAXLOCALS = 3 // access flags 0x0 \u0026lt;init\u0026gt;()V L0 LINENUMBER 9 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=1, d1={\u0026#34;\\u0000%\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0008\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0003\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0002*\\u0001\\u0000\\u0008\\n\\u0018\\u00002\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\u0001J\\u001e\\u0010\\u0007\\u001a\\u00020\\u00082\\u000c\\u0010\\u0009\\u001a\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\nH\\u0016\\u00f8\\u0001\\u0000\\u00a2\\u0006\\u0002\\u0010\\u000bR\\u0014\\u0010\\u0003\\u001a\\u00020\\u00048VX\\u0096\\u0004\\u00a2\\u0006\\u0006\\u001a\\u0004\\u0008\\u0005\\u0010\\u0006\\u0082\\u0002\\u0004\\n\\u0002\\u0008\\u0019\\u00a8\\u0006\\u000c\u0026#34;}, d2={\u0026#34;com/pengmj/kotlincoroutine/SampleKt$main$continuation$2\u0026#34;, \u0026#34;Lkotlin/coroutines/Continuation;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;context\u0026#34;, \u0026#34;Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;getContext\u0026#34;, \u0026#34;()Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;resumeWith\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;Lkotlin/Result;\u0026#34;, \u0026#34;(Ljava/lang/Object;)V\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================META-INF/Kotlin.kotlin_module ================= \u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000 \u0026amp; \u001acom.pengmj.kotlincoroutine\u0012\u0008SampleKt\u0026#34;\u0000*\u0000 在上面一大片字节码中，我们着重看这几行：\n1 2 3 4 5 6 7 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { } 由上面字节码可知：\n编译器帮我们创建了2个匿名内部类SampleKt$main$continuation$1和SampleKt$main$continuation$2，它们的类名是\u0026lt;FileName\u0026gt;Kt$\u0026lt;FunctionName\u0026gt;$continuation$1这样的形式，其中\u0026lt;FileName\u0026gt;和\u0026lt;FunctionName\u0026gt;指代的是代码所在的文件名和函数名。\n这里会有个疑问：这些匿名内部类是哪来的？\n第一个匿名内部类SampleKt$main$continuation$1，它就是我们的协程体，那个用以创建协程的suspend方法传入的Lambda表达式，即suspend ()-\u0026gt;R，也对应了前面说过的埋下伏笔2；\n并且SampleKt$main$continuation$1继承了抽象类SuspendLambda，还实现了Function1接口，继续追踪SuspendLambda时，发现它间接实现了Continuation接口，与先前提到的ContinuationImpl、BaseContinuationImpl存在继承关系，如下图所示：\n第二个匿名内部类SampleKt$main$continuation$2，从它的字节码中可以看出它有getContext方法、resumeWith方法以及无参构造方法，可以猜到它就是createCoroutine方法传入的对象表达式，学过Kotlin基础的应该明白，对象表达式其实是增强版的匿名内部类。\n到目前为止还看不出什么，还需要把字节码再转译一下，点击Kotlin ByteCode面板上的Decompile按钮，转译后的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } }); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { // ① @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } // $FF: synthetic method public static void main(String[] var0) { main(); } } 这里解释下上面的标号地方：\n标号①、调用了ContinuationKt的createCoroutine方法，第一个参数传入var1变量，而var1变量的类型是Function1，对应的Koltin实际代码为：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 前面提过埋下伏笔1，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，此时可以推断出，这里的var1就是第一个匿名内部类SampleKt$main$continuation$1的实例；createCoroutine方法第二个参数则是completion回调，也是前面说的第二个匿名内部类SampleKt$main$continuation$2。\n标号②、还记得前面说的createCoroutineUnintercepted方法和intercepted方法的具体实现吗？\n1 2 3 4 5 6 7 8 9 10 11 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) return if (this is BaseContinuationImpl) create(probeCompletion) // ① else createCoroutineFromSuspendFunction(probeCompletion) { (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } 因为SampleKt$main$continuation$1是BaseContinuationImpl的子类，所以会执行上面①处的create方法，此处调用的是BaseContinuationImpl类的create方法，但是BaseContinuationImpl类中没有具体实现create方法，所以由子类SampleKt$main$continuation$1来实现，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } }); } 发现在create方法中又创建了一个匿名内部类对象var2，类型为Function1，那么可以知道createCoroutineUnintercepted方法返回的就是新的SampleKt$main$continuation$1对象。\n有一个疑问：var2和外部new Function1创建的匿名内部类对象var1有什么区别和关联呢？\n先声明下，从Kotlin代码反编译而来的Java代码可能会出现不符合Java代码执行逻辑的情况。外部创建的匿名内部类对象var1主要是用来帮助启动协程，因此completion传入为null；而create方法中创建的匿名内部类对象var2主要是用来管理协程的状态。\n如果你看到本文的后续内容后，可能会回过头来问，为什么var2可以调用var1中的invokeSuspend方法，它们不是两个不同的对象吗？\n是的，没错，它们的确是两个不同的对象，但是因为反编译后的源码不一定能准确的表达完整Java代码执行逻辑，这里我再手动转译一下，应该就能看明白了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public final class SampleKt { final class SampleKt$main$continuation$1 extends SuspendLambda implements Function1 { public SampleKt$main$continuation$1(Continuation completion){ super(completion) } int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new SampleKt$main$continuation$1(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } } public static final void main() { SampleKt$main$continuation$1 var1 = new SampleKt$main$continuation$1(null); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } } 还记得我们最初的那个任务吗？就是找到delegate变量的真身，我们已经知道delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() createCoroutineUnintercepted方法已经分析了，返回的就是新的SampleKt$main$continuation$1对象，那么继续看intercepted方法：\n1 2 public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this 很明显，SampleKt$main$continuation$1也是ContinuationImpl的子类，因而这里调用了ContinuationImpl的intercepted方法：\n1 2 3 4 5 6 7 8 9 10 internal abstract class ContinuationImpl( completion: Continuation\u0026lt;Any?\u0026gt;?, private val _context: CoroutineContext? ) : BaseContinuationImpl(completion) { public fun intercepted(): Continuation\u0026lt;Any?\u0026gt; = intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this) .also { intercepted = it } } 上面代码说明如果设置了协程的拦截器，那么就从上下文中去找，如果上下文中也没有，则用自身SampleKt$main$continuation$1，最后赋值。很显然，本例是没有设置协程的拦截器，那么intercepted方法返回的就是SampleKt$main$continuation$1，所以delegate变量的真身就是SampleKt$main$continuation$1。\n接下来看看delegate变量调用了resumeWith方法的流程，因为SampleKt$main$continuation$1中没有resumeWith方法，再根据继承关系，我们看BaseContinuationImpl类的resumeWith方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal abstract class BaseContinuationImpl( // This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet // it has a public getter (since even untrusted code is allowed to inspect its call stack). public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public final override fun resumeWith(result: Result\u0026lt;Any?\u0026gt;) { // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume var current = this var param = result while (true) { // Invoke \u0026#34;resume\u0026#34; debug probe on every resumed continuation, so that a debugging library infrastructure // can precisely track what part of suspended callstack was already resumed probeCoroutineResumed(current) with(current) { val completion = completion!! // fail fast when trying to resume continuation without completion val outcome: Result\u0026lt;Any?\u0026gt; = try { val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) } catch (exception: Throwable) { Result.failure(exception) } releaseIntercepted() // this state machine instance is terminating if (completion is BaseContinuationImpl) { // unrolling recursion via loop current = completion param = outcome } else { // top-level completion reached -- invoke and return completion.resumeWith(outcome) return } } } } protected abstract fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? } 上面代码的重点是调用了invokeSuspend方法，这是个抽象方法，由子类SampleKt$main$continuation$1实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } } } 这里invokeSuspend方法通过状态机来执行协程体中的逻辑，最终返回处理结果Boxing.boxInt(123 + x)，很显然，invokeSuspend方法其实就是suspend {}闭包中的处理逻辑。\n回到BaseContinuationImpl类的resumeWith方法，看下这2行代码：\n1 2 val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return 如果invokeSuspend方法返回值是挂起状态COROUTINE_SUSPENDED，则resumeWith方法直接退出，否则就通过调用completion.resumeWith(outcome)传递给外部。\n至此，协程启动流程就讲解完成了。\n","date":"2023-07-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBkotlin%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81/","section":"post","tags":null,"title":"解读Kotlin协程启动源码"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 事件分发机制是View体系中一个非常重要的核心知识点，也是难点，不少Android开发者搞了几年的Android，或许也还没完全弄明白它的原理。\n另外，在Android开发过程中难免会碰到滑动冲突的场景，而解决滑动冲突的理论基础就是事件分发机制，因此掌握事件分发机制十分必要。\n接下来，本文会先从实践的角度总结出结论，然后从源码的角度去看事件分发的过程，最后利用前面所学知识去演示如何解决开发中常见的滑动冲突。\n二、从实践的角度总结出结论 2.1、实践前的理论知识 事件分发主要涉及3个方法，代码如下：\n1 2 3 4 5 6 7 8 // Activity、ViewGroup、View都有提供该方法，该方法的作用：事件的分发 public boolean dispatchTouchEvent(MotionEvent event) // 仅ViewGroup提供该方法，该方法的作用：事件的拦截 public boolean onInterceptTouchEvent(MotionEvent ev) // Activity、View都有提供该方法，该方法的作用：事件的处理 public boolean onTouchEvent(MotionEvent event) 这3个方法有2个共同点，第一个共同点就是都有一个入参MotionEvent，它表示当用户触摸屏幕时所进行的每一次交互（每一次交互指的是手指在UI控件上从按下、滑动再到抬起的过程），都会产生一次同一序列的触摸事件，这些触摸事件被封装进了MotionEvent类里，通过以下方法可以获取触摸事件的类型，代码如下：\n1 val action = ev?.action 在事件分发过程中，常用的触摸事件类型有以下4种：\nACTION_DOWN：表示手指按下的事件。\nACTION_MOVE：表示手指移动的事件。\nACTION_UP：表示手指抬起的事件。\nACTION_CANCEL：表示当前触摸事件已终止。\n第二个共同点是都需要返回boolean类型的返回值，关于返回值的作用是什么后面会讲到。\n那么，事件分发中这3个方法之间有什么关系呢？\n它们之间的关系可以用以下伪代码来表示：\n1 2 3 4 5 6 7 8 9 public boolean dispatchTouchEvent(MotionEvent ev) { boolean result = false; if (onInterceptTouchEvent(ev)) { result = onTouchEvent(ev); } else { result = child.dispatchTouchEvent(ev); } return result; } 通过伪代码，先大致了解下触摸事件的传递规则：对于一个根ViewGroup来说，触摸事件产生后，首先会传递给它，这时它的dispatchTouchEvent方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。\n2.2、实践开始 开始前，我们先编写一个UI界面，本文之后的讲解都是基于该UI界面的层次结构，UI界面运行后的效果如下：\n从运行效果图可以知道，该UI界面内部嵌套了一个紫色的MyViewGroup2控件、一个绿色的MyViewGroup1控件以及一个黑色的MyView控件，布局文件代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup2 android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;@color/purple_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup1 android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;@color/black\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup1\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup2\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 其中MyViewGroup2控件和MyViewGroup1控件的实现是一样的，都是继承自ConstraintLayout，以MyViewGroup2为例，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyViewGroup2 : ConstraintLayout { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 而MyView继承自View，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyView : View { constructor(context: Context?) : super(context) constructor( context: Context?, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 最后，MainActivity的代码如下：\n1 2 3 4 5 6 7 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } 之前介绍事件分发的相关方法时，代码注释里有描述过，在Activity、ViewGroup、View中都有dispatchTouchEvent方法，在Activity、View中都有onTouchEvent方法，对于ViewGroup而言，则多了一个onInterceptTouchEvent方法。\n因此，本文先讲解不包含onInterceptTouchEvent方法时的事件分发过程，然后再讲解包含onInterceptTouchEvent方法时的事件分发过程。\n2.2.1、ACTION_DOWN的事件分发过程（不包含onInterceptTouchEvent方法的情况） 既然先讨论的是不包含onInterceptTouchEvent方法的情况，那么只需将MainActivity、MyViewGroup2、MyViewGroup1、MyView都重写dispatchTouchEvent方法和onTouchEvent方法，为了验证在这种情况下的ACTION_DOWN事件分发过程，都打上日志进行观察，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.onTouchEvent(event) } 为什么要加上if (LOG_ACTION_DOWN)判断条件呢？这是一个开关，用于日志过滤，方便观察。本文所有源码将在文末贴出。\n2.2.1.1、在dispatchTouchEvent方法中拦截ACTION_DOWN事件 在dispatchTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道dispatchTouchEvent方法需要返回boolean类型的返回值，它的返回值有3种情况：\n情况一：返回super.dispatchTouchEvent dispatchTouchEvent方法默认返回super.dispatchTouchEvent，表示不拦截任何事件，它是View体系中默认的事件分发过程。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n情况二：返回true 在dispatchTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.dispatchTouchEvent(ev) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true之后，ACTION_DOWN事件就会直接停止传递，后面的子控件都不会接收到这个事件。\n情况三：返回false 和之前返回true的情况一样，这里返回false的情况也有两种方式拦截ACTION_DOWN事件，并且两种情况下的表现对于ACTION_DOWN事件来说是没区别的，最终打印结果是一样的，所以这里演示的是仅拦截ACTION_DOWN事件。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return false } } return super.dispatchTouchEvent(ev) } 运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup2的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup1的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyView的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回false拦截事件之后，事件并不会直接停止传递，而是向父控件的onTouchEvent方法回传。\n2.2.1.2、在onTouchEvent方法中拦截ACTION_DOWN事件 在onTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和View体系中默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面的结论也是针对情况二来讲。\n在onTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论在哪个控件的onTouchEvent方法中拦截ACTION_DOWN事件并返回true，事件都会直接停止传递，后面的父控件都不会接收到这个事件。\n2.2.2、ACTION_DOWN的事件分发过程（包含onInterceptTouchEvent方法的情况） 在onInterceptTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onInterceptTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onInterceptTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面结论也是针对情况二来讲。\n在onInterceptTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n若在ViewGroup的onInterceptTouchEvent方法中拦截ACTION_DOWN事件，只会改变ACTION_DOWN事件的正常流向，事件会直接流向自己的onTouchEvent方法中，并不会截断事件。\n2.2.3、多个方法拦截的情况 一般我们在拦截事件时，都是共同使用onInterceptTouchEvent方法和onTouchEvent方法的，通过在onInterceptTouchEvent方法中返回true，将ACTION_DOWN消息流向自己的onTouchEvent方法中，然后在该onTouchEvent方法中返回true拦截事件。\n下面以MyViewGroup1为例，在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true，在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true。\n修改MyViewGroup1的onInterceptTouchEvent方法和onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n2.2.4、ACTION_MOVE和ACTION_UP的事件分发过程 ACTION_MOVE和ACTION_UP事件的分发过程与之前所讲的ACTION_DOWN事件并不是完全一样的，为了对比两者，我会用黑色箭头表示ACTION_DOWN的事件分发过程，用红色箭头合并表示ACTION_MOVE和ACTION_UP的事件分发过程，为什么两者都用红色箭头表示呢？这是因为ACTION_MOVE和ACTION_UP的事件流向是完全相同的，后面都以ACTION_MOVE事件来讲解。\n2.2.4.1、ACTION_MOVE默认的事件分发过程 ACTION_MOVE默认的事件分发过程，和之前所讲的ACTION_DOWN事件默认的事件分发过程是一样的，也就是所有的事件分发方法都不做拦截处理。\n修改MainActivity、MyView的dispatchTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 修改MyViewGroup2、MyViewGroup1的dispatchTouchEvent方法、onInterceptTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.2、在dispatchTouchEvent方法中拦截ACTION_MOVE事件 按照之前在dispatchTouchEvent方法中拦截ACTION_DOWN事件的写法，同样地，在dispatchTouchEvent方法中拦截ACTION_MOVE事件，比如说修改MyViewGroup2的dispatchTouchEvent方法，你可能会写下如下代码：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } } return super.dispatchTouchEvent(ev) 然而代码运行后，发现并不能如愿地看到想要的ACTION_MOVE日志，也就是说代码没有起作用，这是因为ACTION_MOVE事件根本就不会流到MyViewGroup2的dispatchTouchEvent方法中，前面讲过，默认情况下，ACTION_MOVE事件的流向是从MainActivity的dispatchTouchEvent方法直接到MainActivity的onTouchEvent方法。\n那如何让ACTION_MOVE事件继续往子控件流向呢？\n解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。其中前一种方式与后两种方式对于ACTION_MOVE事件的流向，它们的表现形式是不一样的；后两种方式对于ACTION_MOVE事件来说没区别，最终打印结果是一样的，所以本文后面会介绍第一种方式和第三种方式。\n2.2.4.2.1、仅拦截ACTION_DOWN事件 在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。\n2.2.4.2.2、拦截所有事件 在MainActivity的dispatchTouchEvent方法中拦截所有事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回true拦截事件之后，ACTION_MOVE事件的流向与ACTION_DOWN事件的完全相同，事件会直接停止传递，后面的子控件都不会接收到这个事件。\n2.2.4.3、在onTouchEvent方法中拦截ACTION_MOVE事件 和在dispatchTouchEvent方法中拦截ACTION_MOVE事件相似，对于希望在onTouchEvent方法中拦截ACTION_MOVE事件，解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。又因为这里只有仅拦截ACTION_DOWN事件和拦截所有事件的表现是不一样的，所以本文只会演示这2种。\n2.2.4.3.1、仅拦截ACTION_DOWN事件 在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun onTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n此处结论同2.2.4.2.1小节。\n2.2.4.3.2、拦截所有事件 在MainActivity的onTouchEvent方法中拦截所有事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截所有事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论ACTION_DOWN消息的流向是怎样的，只要最终流到onTouchEvent函数中就行。假设控件A最终在onTouchEvent函数中消费了ACTION_DOWN消息，那么ACTION_MOVE消息的流向就是先流到控件A的dispatchTouchEvent函数中，最终直接流到控件A的onTouchEvent函数中，进而消息停止传递。\n2.2.4.4、多个方法拦截的情况 注：下面演示都是拦截所有事件\n2.2.4.4.1、组合dispatchTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyView的dispatchTouchEvent方法中返回false，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyView的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return false } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.2、组合onInterceptTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyViewGroup1的onInterceptTouchEvent方法中返回true，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyViewGroup1的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.3、一种特殊情况 在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_MOVE事件返回true，而在MyView的onTouchEvent方法中返回true*。\n修改MyViewGroup2的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return super.onInterceptTouchEvent(ev) } 修改MyView的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: onTouchEvent -\u0026gt; ACTION_CANCEL ACTION_MOVE事件分发过程如下图所示：\n本来ACTION_MOVE事件依然会从MainActivity的dispatchTouchEvent方法流向子控件，但是在到达MyViewGroup2的onInterceptTouchEvent方法时，ACTION_MOVE事件被拦截了。到这里，这次的ACTION_MOVE事件就没有了，变成了ACTION_CANCEL事件继续向子控件传递，一直传递到ACTION_MOVE事件原本要传递的位置，通知所有被截断的子控件，它们的事件取消了，后面没有事件再传递过来。\n三、从源码的角度去看事件分发的过程 3.1、Activity的事件分发过程 当用户触摸屏幕的时候，触摸事件就会传递给当前的Activity，由Activity的dispatchTouchEvent方法进行事件分发，所以先从该方法进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // android.app.Activity public boolean dispatchTouchEvent(MotionEvent ev) { // 分析1 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 分析2 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 分析3 return onTouchEvent(ev); } 分析1：这里是个if条件判断，如果触摸事件的类型是ACTION_DOWN，那么调用onUserInteraction方法，onUserInteraction方法的解释如下：\n1 2 3 4 5 6 7 // android.app.Activity // 当用户与屏幕交互（例如触摸、键盘输入或轨迹球滚动）时，系统会调用该方法 // 此回调和onUserLeaveHint方法旨在帮助Activity智能管理状态栏通知；具体来说，用于帮助Activity确定取消通知的适当时间 // 所有对Activity的onUserLeaveHint回调的调用都将伴随对onUserInteraction调用。这确保Activity将被告知相关的用户活动，例如下拉通知窗格并触摸那里的项目 public void onUserInteraction() { } 分析2：这里有也是个if条件判断，它调用了getWindow的superDispatchTouchEvent方法，一旦if条件为true成立，那么直接return true，整个dispatchTouchEvent方法便会执行完毕，后面的onTouchEvent方法不会被触发。\n继续看getWindow方法，代码如下：\n1 2 3 4 5 // android.app.Activity public Window getWindow() { return mWindow; } getWindow方法返回的是一个mWindow，而mWindow的初始化在Activity的attach方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // android.app.Activity final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); // ... } 可以看到，mWindow是一个PhoneWindow对象，也就是说之前if条件中getWindow的superDispatchTouchEvent方法实际上是调用了PhoneWindow对象的superDispatchTouchEvent方法，那么继续看PhoneWindow对象的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 // com.android.internal.policy.PhoneWindow @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } PhoneWindow对象的superDispatchTouchEvent方法又转接给了mDecor的superDispatchTouchEvent方法，而mDecor是一个DecorView对象，它是窗口的顶层视图，包含窗口装饰，DecorView初始化的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // com.android.internal.policy.PhoneWindow @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the // decor, when theme attributes and the like are crysta // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } // ... } private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted \u0026amp;\u0026amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } else { mDecor.setWindow(this); } // ... } protected DecorView generateDecor(int featureId) { // System process doesn\u0026#39;t have application context and in that case we need to directly // the context we have. Otherwise we want the application context, so we don\u0026#39;t cling to // activity. // ... return new DecorView(context, featureId, this, getAttributes()); } DecorView是在installDecor方法中被初始化的，此处代码和Activity的setContentView方法的源码相关联，只是这里的分析不是本文的重点，所以不会展开讲解。\nOK，回到之前流程，那么调用的是DecorView的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 // com.android.internal.policy.DecorView public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } } DecorView继承自FrameLayout，FrameLayout继承自ViewGroup，而FrameLayout没有重写dispatchTouchEvent方法，那么super.dispatchTouchEvent调用的就是ViewGroup的dispatchTouchEvent方法了。\n至此，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup。\n分析3：如果getWindow的superDispatchTouchEvent方法返回false，那么if条件判断不成立，就会继续执行Activity的onTouchEvent方法。\n继续看Activity的onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 // android.app.Activity public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 这里调用了mWindow的shouldCloseOnTouch方法，我们知道，mWindow的实现类是PhoneWindow，所以shouldCloseOnTouch方法的具体实现应该就在PhoneWindow对象里，可惜PhoneWindow中并没有实现该方法，所以只能找Window对象本身了，果然Window类下有shouldCloseOnTouch方法的实现，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // android.view.Window @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public boolean shouldCloseOnTouch(Context context, MotionEvent event) { final boolean isOutside = event.getAction() == MotionEvent.ACTION_UP \u0026amp;\u0026amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside \u0026amp;\u0026amp; peekDecorView() != null \u0026amp;\u0026amp; isOutside) { return true; } return false; } isOutside表示触摸位置是否在DecorView的外部，它的判断逻辑为：如果触摸事件为ACTION_UP事件并且触摸事件的坐标x，y超出了DecorView边界时，则认为触摸位置在DecorView的外部；如果触摸事件为ACTION_OUTSIDE，那么也认为触摸位置在DecorView的外部。\n然后来到if条件的判断了，第一个条件是一个mCloseOnTouchOutside布尔值，它表示点击DecorView外部时是否可以关闭。如果将Activity设置成Dialog样式的时候，可以通过setCloseOnTouchOutside方法设置mCloseOnTouchOutside布尔值为true；第二个条件是一个peekDecorView方法，它返回的是mDecor对象，也就是判断mDecor对象是否为null；第三个条件就是我们的isOutside值了。\n如果同时满足上面所说的3个条件，那么整个shouldCloseOnTouch方法就会返回true，否则返回false。但是一般情况下很少将Activity设置为Dialog样式，所以也就用不到setCloseOnTouchOutside方法，所以mCloseOnTouchOutside的值false，那么if条件判断为false，整个shouldCloseOnTouch方法返回false，所以最终onTouchEvent方法也是返回false。\n3.2、ViewGroup的事件分发过程 上面分析了Activity的事件分发过程，可以知道，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup，那么继续看ViewGroup的dispatchTouchEvent方法，因为ViewGroup的dispatchTouchEvent方法很长，所以我们先分析前面一部分代码，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... // 分析1 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // 分析2 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // 分析3 // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 分析3.1 final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // 分析3.1.1 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { // 分析3.1.2 intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. // 分析3.2 intercepted = true; } // ... } // ... return handled; } 分析1：handled布尔值用来标记事件分发的处理结果，并最终作为dispatchTouchEvent方法的返回值；onFilterTouchEventForSecurity方法是做一个安全性检查，默认返回true；但是在我们执行敏感控件的点击事件时，有可能会被恶意软件在此之上加上一个不可接受事件的窗口，骗取我们的点击，那么解决办法是调用View的setFilterTouchesWhenObscured方法设置true，它会往View的setFlags方法中添加FILTER_TOUCHES_WHEN_OBSCURED，表示当视图的窗口被另一个可见窗口遮挡时框架丢弃触摸事件，这时onFilterTouchEventForSecurity方法就会返回false，从而dispatchTouchEvent方法返回false。\n分析2：if判断如果触摸事件的类型为ACTION_DOWN，表示新的ACTION_DOWN事件来了，也就是同一序列的触摸事件的起点，所以需要调用cancelAndClearTouchTargets方法来取消并清除所有触摸目标，以及调用resetTouchState方法来重置所有触摸状态以准备新的循环。这两方法里面的重点是清空mFirstTouchTarget，重置FLAG_DISALLOW_INTERCEPT标记，这里cancelAndClearTouchTargets方法和resetTouchState方法的源码就不列出来了，可自行查阅。\n分析3：intercepted布尔值用来表示是否拦截事件；接下来是一个if判断，条件一是触摸事件的类型为ACTION_DOWN，条件二是mFirstTouchTarget != null。mFirstTouchTarget和后面的代码逻辑有关，它的作用就是当ViewGroup不拦截事件并将事件交由子元素处理时，mFirstTouchTarget会被赋值并指向子元素，这时mFirstTouchTarget != null成立。\n如果if判断为true 接下来，如果触摸事件的类型为ACTION_DOWN，或者mFirstTouchTarget != null时，就会进入分析3.1，布尔值disallowIntercept用来表示不允许父View拦截事件，它和FLAG_DISALLOW_INTERCEPT这个标志位有关，并且该标志位的位运算可以通过requestDisallowInterceptTouchEvent方法设置，从而改变disallowIntercept的值。\n默认情况下，也就是没设置FLAG_DISALLOW_INTERCEPT标志位时，disallowIntercept的值为false，此时就会进入分析3.1.1，接着调用onInterceptTouchEvent方法拦截事件，如果onInterceptTouchEvent方法返回true，表示ViewGroup会拦截当前事件，那么intercepted被赋值为true，反之赋值为false。来看下onInterceptTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // android.view.ViewGroup public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } onInterceptTouchEvent方法比较简单，if条件第一个判断触摸事件是否来自鼠标设备；第二个判断触摸事件的类型是否是ACTION_DOWN；第三个检查是否按下了鼠标按键；第四个判断触摸位置是否在滚动条上。在大多数情况下if条件不会成立，也就是可以认为默认情况下onInterceptTouchEvent方法返回false。\n如果通过requestDisallowInterceptTouchEvent方法设置FLAG_DISALLOW_INTERCEPT标志位，此时disallowIntercept为true，那么就不满足if(!disallowIntercept)条件了，所以不会再调用onInterceptTouchEvent方法，而是走的else逻辑，从而进入分析3.1.2，将intercepted赋值为false。\n注意：FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件。\n为什么？\n因为前面说过，ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。因此，子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN事件的处理。\n如果if判断为false 如果ViewGroup拦截事件，那么子View就无法获得事件，当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN ||mFirstTouchTarget ! = null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，然后走的是else逻辑，也就是进入分析3.2，将intercepted赋值为true。\n到这里，我们已经知道，intercepted的值如果为true，表示ViewGroup要拦截事件，反之不拦截，接下来，继续看ViewGroup的不拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE; final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0 \u0026amp;\u0026amp; !isMouseEvent; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex); final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } } } 如果不是ACTION_CANCEL事件或者ViewGroup不拦截事件时，倒叙遍历子View，然后调用dispatchTransformedTouchEvent方法进行分发事件，注意该方法第三个参数child，此时child不为null，继续看dispatchTransformedTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // android.view.ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 前面说过，此时child不为null，那么就会调用child的dispatchTouchEvent方法进行事件的分发，如果child的dispatchTouchEvent方法返回true，那么if(dispatchTransformedTouchEvent)条件成立，就会执行后面的addTouchTarget方法，给mFirstTouchTarget赋值，addTouchTarget方法代码如下：\n1 2 3 4 5 6 7 8 // android.view.ViewGroup private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } 从上面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。那么如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）。\n接下来，继续看ViewGroup拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { } } return handled; } 如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。在这两种情况下，ViewGroup会自己处理点击事件。注意dispatchTransformedTouchEvent方法的第三个参数child，此时child为null，从前面的分析可以知道，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。\n3.3、View的事件分发过程 上面分析了ViewGroup的事件分发过程，可以知道，ViewGroup拦截事件后，让触摸事件的分发从ViewGroup流转到了View，那么继续看View的dispatchTouchEvent方法，这里省略了一些不重要的代码，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean dispatchTouchEvent(MotionEvent event) { boolean result = false; if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } return result; } 可以看到View的dispatchTouchEvent方法处理比较简单，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，如果没有设置mOnTouchListener监听器，或者onTouch方法返回false时，那么就会调用View的onTouchEvent方法，继续看onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // android.view.View public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED \u0026amp;\u0026amp; (mPrivateFlags4 \u0026amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn\u0026#39;t respond to them. return clickable; } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } return false; } 从上面代码可以知道，View处于不可用时依然会消耗事件。如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法。好了，继续看onTouchEvent对事件的处理，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // android.view.View public boolean onTouchEvent(MotionEvent event) { if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } } mIgnoreNextUpEvent = false; break; } return true; } return false; } 只要View满足clickable，当ACTION_UP事件发生时，最终会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean performClick() { // We still need to call this method to handle the cases where p // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; } 至此，事件分发机制的源码就分析完成了。\n四、解决开发中常见的滑动冲突 经过前面理论知识的准备，下面就要进入解决开发中常见的滑动冲突的实战环节。\n4.1、常见的滑动冲突场景\u0026amp;处理思路 当内外两层View都可以滑动的时候，就会产生滑动冲突，常见的滑动冲突场景如下图所示：\n场景一：外部滑动方向和内部滑动方向不一致 此种场景可以根据当前滑动方向是横向还是纵向来判断事件到底该交给谁来处理。\n那滑动方向怎么判断呢？\n在滑动过程中会有两个点的坐标，通过两个点的坐标就可以计算手指的移动距离，如图所示：\n手指移动后横向距离变化为dx，纵向距离变化为dy，如果dx＞dy，那么此次滑动就算作横向滑动；相反，则认为此次滑动是纵向滑动。\n场景二：外部滑动方向和内部滑动方向不致 当内外两层都在同一个方向可以滑动的时候，显然存在逻辑问题。因为当手指开始滑动的时候，系统无法知道用户到底是想让哪一层滑动，所以当手指滑动的时候就会出现问题，要么只有一层能滑动，要么就是内外两层都滑动得很卡顿。\n这种得根据业务需求，通过下面的拦截与禁止拦截的方法，决定在什么情况下滑动哪个View。\n场景三：上面两种情况的嵌套 上面图中没放出来，是场景一和场景二都存在的情况，也就是它们之间互相嵌套，或者多层嵌套，然而不管多么复杂，解决思路都是一毛一样的，按照上面提的解决思路一层一层处理即可。\n4.2、解决滑动冲突的办法 4.2.1、外部拦截法 所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。\n外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { if(父控件需要当前点击事件){ intercepted = true }else{ intercepted = false } } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } 解释下上面代码，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；\n其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false；\n最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onClick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。\n4.2.2、内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if(自己需要当前点击事件){ parent.requestDisallowInterceptTouchEvent(true) }else{ parent.requestDisallowInterceptTouchEvent(false) } } } return super.dispatchTouchEvent(event) } 解释下上面代码，我留意到一些文章中会写到在子控件的ACTION_DOWN消息中使用getParent().requestDisallowInterceptTouchEvent(true)；，这是无效的，因为如果父控件拦截了ACTION_DOWN消息，则这里写的函数根本不会执行。\n4.3、滑动冲突实战 先上布局文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.core.widget.NestedScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.appcompat.widget.AppCompatEditText android:id=\u0026#34;@+id/edit_text\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;@dimen/edit_text_height\u0026#34; android:text=\u0026#34;@string/edit_text_content\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;1000dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; android:gravity=\u0026#34;center\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/edit_text\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/androidx.core.widget.NestedScrollView\u0026gt; \u0026lt;/layout\u0026gt; 上面是一个EditText，但是这个EditText的内容超出了显示区域，所以它的内容是可以上下滑动的，下面是一个View，高度给得非常大，用来支撑外部的NestedScrollView足够可以滑动，因为NestedScrollView也可以上下滑动，由于双方都可以上下滑动，导致冲突了，运行效果图如下：\n可以看到，在没有处理滑动冲突，在EditText向上滑动时，依然是整体NestedScrollView在滑动，这属于常见的滑动冲突场景里的情况二了，OK，下面就来解决冲突。\n用外部拦截法解决滑动冲突问题 使用外部拦截法来解决滑动冲突问题的话，需要重写NestedScrollView，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class MyNestedScrollView : NestedScrollView { constructor(context: Context) : super(context) { doInit(context) } constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) { doInit(context) } constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) { doInit(context) } private var editTextHeight: Int = 0 private fun doInit(context: Context) { editTextHeight = context.resources.getDimensionPixelSize(R.dimen.edit_text_height) } private var downY: Int = 0 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { downY = ev.y.toInt() intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { intercepted = downY \u0026gt; editTextHeight } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } } 解释下上面代码，因为EditText的高度是固定的，在这个高度之前触摸的位置都是EditText的内容区域，此时让NestedScrollView不要拦截事件，在这个内容区域值之外的位置，让NestedScrollView拦截事件。\n可以看到，在使用外部拦截法时，需要提前知道不拦截消息的区域，这样才能做好消息处理，所以也只有在子控件的位置和大小是固定的并且能获取到的情况下，外部拦截法才是有用的。\n将自定义的MyNestedScrollView替换布局文件里的NestedScrollView即可，运行后效果如下：\n用内部拦截法解决滑动冲突问题 使用内部拦截法来解决滑动冲突问题的话，需要重写EditText，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyEditText : AppCompatEditText { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { parent.requestDisallowInterceptTouchEvent(true) } } return super.dispatchTouchEvent(event) } } 因为在ACTION_MOVE消息到来时，EditText需要自己处理消息，所以这里并没有内部拦截法中判断是否需要该事件的if（自己需要这类点击事件）代码。\n将自定义的MyEditText替换布局文件里的EditText即可，运行后效果同用外部拦截法解决滑动冲突。\n","date":"2023-06-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","section":"post","tags":null,"title":"Android事件分发机制"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 XML文件在Android中是一种非常常见的文件格式，例如你的主页面布局文件activity_main.xml、Android清单文件AndroidManifest.xml、XXX.xml的res资源文件等等，然而我们在日常开发中往往会忽略XML文件本身，因为AS太过智能化，根据AS智能提示很容易就能写出想要的XML文件，但是我们真的有了解过XML文件吗？还有为什么要去了解XML文件？阅读本文后，你应该可以找到问题的答案。\n因此，本文会把关注点放到XML文件本身，学习它的基础语法，然后循序渐进地讲解Android中怎么解析XML数据，这对之后在Framework层遇到XML解析流程时非常有帮助，比如Activity的setContentView源码里，它是如何将我们写的layout布局文件解析出来的。\n二、XML简单介绍 2.1、什么是XML？ XML的全称为Extensible Markup Language，翻译过来是可扩展标记语言，它是标准通用标记语言的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。\n2.2、XML的基本语法 2.2.1、必须有声明语句 XML声明是XML文档的第一句，代码如下：\n1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; 2.2.2、XML文档有且只有一个根元素 良好格式的XML文档必须有一个根元素，就是紧接着声明后面建立的第一个元素，其他元素都是这个根元素的子元素，根元素完全包括文档中其他所有的元素，根元素的起始标记要放在所有其他元素的起始标记之前；根元素的结束标记要放在所有其他元素的结束标记之后，代码如下：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 在上面代码中，root称为根元素。\n2.2.3、XML标签对大小写敏感 在XML文档中，大小写是有区别的，例如下面代码中“a”和“A”是不同的标记。注意在写元素时，前后标记的大小写要保持一致。最好养成一种习惯，或者全部大写，或者全部小写，或者大写第一个字母，这样可以减少因为大小写不匹配而产生的文档错误。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;A\u0026gt;\u0026lt;/A\u0026gt; \u0026lt;/root\u0026gt; 2.2.4、属性值必须加引号 XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误。\n如下代码为错误演示：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;element id=999\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 如下代码为正确演示：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element id=\u0026#34;999\u0026#34;\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 2.2.5、所有的标记必须有相应的结束标记 在XML中，所有标记必须成对出现，有一个开始标记，就必须有一个结束标记，否则将被视为错误。\n2.2.6、实体引用 在XML中，一些字符拥有特殊的意义，如果你把字符\u0026quot;\u0026lt;\u0026ldquo;放在XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;count\u0026gt;num \u0026lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 为了避免这个错误，需要用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符。\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;count\u0026gt;num \u0026amp;lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 在XML中，有5个预定义的实体引用。\n2.2.7、命名空间 在XML中，因为元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。\n这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的table元素，就会发生命名冲突，XML解析器无法确定如何处理这类冲突。\n如果以Java的思维来描述，可以认为是在同一个包下，创建了两个类名都为Table的类，那么在使用时就会不知道要用的是哪个了。\n因此，需要用XML命名空间来解决该冲突问题。XML命名空间属性被放置于元素的开始标签之中，其语法为：\n1 xmlns:namespace-prefix=\u0026#34;namespaceURI\u0026#34; 当XML命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;root\u0026gt; \u0026lt;s:table xmlns:s=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 命名空间也可以在XML根元素中声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;root xmlns:s=\u0026#34;https://www.student.com/\u0026#34; xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;s:table\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作，其语法为：\n1 xmlns=\u0026#34;namespaceURI\u0026#34; 这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table xmlns=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table xmlns=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 三、Android解析XML数据 3.1、选择XML解释器 Android提供了三种类型的XML解析器，它们是DOM、SAX和XmlPullParser，但是官方建议使用XmlPullParser，这是一种在Android上解析XML的高效且可维护的方式，Android有此接口的两个实现如下：\nKXmlParser，使用XmlPullParserFactory.newPullParser() ExpatPullParser，使用Xml.newPullParser() 上面两种任一选择都可以，在本文的示例中使用的是ExpatPullParser和Xml.newPullParser()。\n3.1.1、XmlPullParser接口 这里仅列举XmlPullParser接口和后面示例有联系的变量和方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public interface XmlPullParser { // ***************next()报告的事件类型*************** // 表明解析器位于文档的最开头，尚未读取任何内容，这种事件类型只能通过在第一次调用next()、nextToken或nextTag()之前调用getEventType()来观察 int START_DOCUMENT = 0; // xml文档的逻辑结束，当到达输入文档的末尾时，从getEventType()、next()和nextToken()返回 int END_DOCUMENT = 1; // 读取开始标记时从getEventType()、next()、nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得（如果命名空间已启用） int START_TAG = 2; // 读取结束标记时从getEventType()、next()或nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得 int END_TAG = 3; // 已读取字符数据并将通过调用getText()获得 int TEXT = 4; // 该数组可用于将事件类型整型常量（如START_TAG或TEXT）转换为字符串。例如，TYPES[START_TAG]的值是字符串“START_TAG”。该数组仅用于诊断输出。依赖数组的内容可能是危险的，因为恶意应用程序可能会更改数组，尽管它是最终的，但由于Java语言的限制 String [] TYPES = { \u0026#34;START_DOCUMENT\u0026#34;, \u0026#34;END_DOCUMENT\u0026#34;, \u0026#34;START_TAG\u0026#34;, \u0026#34;END_TAG\u0026#34;, \u0026#34;TEXT\u0026#34;, \u0026#34;CDSECT\u0026#34;, \u0026#34;ENTITY_REF\u0026#34;, \u0026#34;IGNORABLE_WHITESPACE\u0026#34;, \u0026#34;PROCESSING_INSTRUCTION\u0026#34;, \u0026#34;COMMENT\u0026#34;, \u0026#34;DOCDECL\u0026#34; }; // ***************命名空间相关特性*************** // 这个特性决定了解析器是否处理命名空间。对于所有功能，默认值为false // 注意：该值在解析期间不能更改，必须在解析前设置 String FEATURE_PROCESS_NAMESPACES = \u0026#34;http://xmlpull.org/v1/doc/features.html#process-namespaces\u0026#34;; // 使用此调用来更改解析器的一般行为，例如命名空间处理或文档类型声明处理。必须在第一次调用next或nextToken之前调用此方法。否则，将抛出异常 void setFeature(String name, boolean state) throws XmlPullParserException; // 将解析器的输入源设置为给定的阅读器并重置解析器。事件类型设置为初始值 START_DOCUMENT。将读取器设置为null只会停止解析并重置解析器状态，从而允许解析器释放解析缓冲区等内部资源 void setInput(Reader in) throws XmlPullParserException; // 设置解析器将要处理的输入流。此调用重置解析器状态并将事件类型设置为初始值START_DOCUMENT // 注意：如果传递了输入编码字符串，则必须使用它。否则，如果inputEncoding为null，解析器应该尝试确定遵循XML 1.0规范的输入编码（见下文） void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException; // ***************TEXT相关方法*************** // 检查当前TEXT事件是否只包含空白字符。对于IGNORABLE_WHITESPACE，这始终为真。对于TEXT和CDSECT，当当前事件文本至少包含一个非空白字符时返回false。对于任何其他事件类型，都会抛出异常 boolean isWhitespace() throws XmlPullParserException; // 以String形式返回当前事件的文本内容。返回值取决于当前事件类型，例如对于TEXT事件，它是元素内容（这是使用next()时的典型情况） String getText (); // ***************START_TAG END_TAG共享方法*************** // 对于START_TAG或END_TAG事件，启用命名空间时返回当前元素的（本地）名称。当命名空间处理被禁用时，原始名称被返回。对于ENTITY_REF事件，返回实体名称。如果当前事件不是START_TAG、END_TAG或ENTITY_REF，则返回null String getName(); // ***************START_TAG属性检索方法*************** // 返回由命名空间URI和命名空间localName标识的属性值。如果命名空间被禁用，命名空间必须为空。如果当前事件类型不是START_TAG，则将抛出IndexOutOfBoundsException String getAttributeValue(String namespace, String name); // ***************实际解析方法*************** // 返回当前事件的类型（START_TAG、END_TAG、TEXT等） int getEventType() throws XmlPullParserException; // 获取下一个解析事件 - 元素内容将被合并，并且必须为整个元素内容只返回一个TEXT事件（将忽略注释和处理指令，并且必须扩展实体引用，或者如果实体引用无法扩展则必须抛出异常）。如果元素内容为空（内容为“”），则不会报告TEXT事件 int next() throws XmlPullParserException, IOException; // ***************使XML解析更容易的实用方法*************** // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配。null将匹配任何名称空间和任何名称。如果测试未通过，则抛出异常。异常文本表示解析器位置、预期事件和不符合要求的当前事件 void require(int type, String namespace, String name) throws XmlPullParserException, IOException; // 如果是START_TAG或END_TAG，则调用next()并返回事件，否则抛出异常。如果有的话，它将跳过实际标记之前的空白TEXT int nextTag() throws XmlPullParserException, IOException; } 接下来，只讲解一下重点的方法。\n3.1.1.1、next方法 从上面的注释可以知道，next方法用于获取下一个解析事件，但是它有一些现象需要知道下。\n现象一：如果元素内容为空，则不会报告TEXT事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // kotlin原始字符串 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) var eventType = parser.eventType while (eventType != XmlPullParser.END_DOCUMENT) { Log.e(\u0026#34;MinKin\u0026#34;, \u0026#34;eventType: ${XmlPullParser.TYPES[eventType]}; name: ${parser.name}; text: ${parser.text}\u0026#34;) eventType = parser.next() } 打印结果如下：\n1 2 3 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: END_TAG; name: school; text: null 从打印结果来看，school元素内容为空时，的确没有触发TEXT事件。\n不知到你们是否留意到，为什么也没有触发END_DOCUMENT事件？\n其实是有触发的，只是不满足条件没法打印出来。因为While循环的判断条件为eventType != XmlPullParser.END_DOCUMENT，当eventType == XmlPullParser.END_DOCUMENT时，此时早已退出循环了，所以没有打印出来。\n特性二：如果实体引用无法扩展则必须抛出异常。 将上面代码中的xml变量替换为如下代码：\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 此时因为school标签之间多了\u0026rdquo;\u0026lt;\u0026quot;，运行时会触发XmlPullParserException这样的一个崩溃。把字符\u0026quot;\u0026lt;\u0026ldquo;放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始，为了避免这个错误，用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符，这也是我们之前讲过的。\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 修改为实体引用后，打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: \u0026lt; E/MinKin: eventType: END_TAG; name: school; text: null 特性三：标签之间不是黏连一起的，比如之间有空格，或者出现了换行，或者存在子标签的情况下，都会报告TEXT事件。 将上面代码中的xml变量替换为如下代码：\n1 2 3 4 // 标签之间有空格 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 1 2 3 4 5 // 标签之间出现了换行 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里school标签之间多打印了一次TEXT事件。如果是存在子标签的情况下，代码如下：\n1 2 3 4 5 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;count\u0026gt;1000\u0026lt;/count\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 5 6 7 8 9 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: START_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: 1000 E/MinKin: eventType: END_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里count标签前后多打印了两次TEXT事件。\n3.1.1.2、nextTag方法 如果当前事件不是START_TAG或END_TAG，会抛出XmlPullParserException异常，例如下面代码就会崩溃。\n1 2 3 4 5 6 7 8 9 10 11 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;清华大学\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) parser.next() parser.nextTag() 分析原因：初始时，当前事件为START_DOCUMENT，调用parser的next方法后，事件变为START_TAG，然后再调用parser的nextTag方法时，它的事件状态应该不满足START_TAG或END_TAG，从而抛出了异常。\n为什么不满足？nextTag方法本质源码为：\n1 2 3 4 5 6 7 8 int eventType = next(); if(eventType == TEXT \u0026amp;\u0026amp; isWhitespace()) { // skip whitespace eventType = next(); } if (eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG) { throw new XmlPullParserException(\u0026#34;expected start or end tag\u0026#34;, this, null); } return eventType; 可以看到，会优先调用next方法，此时当前事件为TEXT，接着会去判断eventType == TEXT \u0026amp;\u0026amp; isWhitespace()，但是isWhitespace方法是不满足的，因为school标签中存在元素内容“清华大学”，所以isWhitespace方法返回false，也就无法进入if条件去进一步调用next，事件停留在TEXT，满足了后面的eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG，从而抛出了异常。\n注意：next方法和nextTag方法需要在合理的地方使用，使用不当就会抛出异常。\n3.2、分析animal 创建一个animal.xml文件，解析animal的第一步是确定感兴趣的字段，解析器会提取这些字段的数据，并忽略其余字段。本案例会演示如何忽略cat标签，仅提取需要的字段。\n要解析的XML内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;animal xmlns=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Rufus\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;labrador\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=labrador\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;拉布拉多猎犬（英文名：Labrador retriever）是起源于加拿大的纽芬兰岛，最早被训练在冰冷的海上将渔网收回和担任搬运工作的一种猎犬。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Marty\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;whippet\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=whippet\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;小灵狗是一种赛狗，性温顺。和蔼。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;cat\u0026gt; \u0026lt;name\u0026gt;大黄\u0026lt;/name\u0026gt; \u0026lt;/cat\u0026gt; \u0026lt;/animal\u0026gt; 习惯性，animal标签包含了命名空间xmlns，profile标签的元素内容标记为HTML，所以要把HTML内容当成整体的纯文本去提取，这里给HTML内容包裹一层\u0026lt;![CDATA[ HTML内容 ]]，否则HTML中的标签会被XML当成元素去解析。\n3.3、实例化XML解释器 解析animal的下一步就是实例化解析器和启动解析的过程，此代码段会初始化一个解析器，使其不处理命名空间并将提供的InputStream用作输入，它通过调用nextTag方法开始解析过程，并调用readAnimal方法，该方法将提取并处理应用感兴趣的数据，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimalXMLParser { // 不使用命名空间 private val ns: String? = null @Throws(XmlPullParserException::class, IOException::class) fun parse(inputStream: InputStream): List\u0026lt;Dog\u0026gt; { inputStream.use { val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(it, null) parser.nextTag() return readAnimal(parser) } } // ... } 3.4、读取animal readAnimal方法执行处理animal的实际工作，它会查找标记为“dog”的元素作为以递归方式处理animal的起点，如果某个标签不是dog标签，则会跳过它，以递归方式处理完整个animal后，readAnimal方法将返回结果集List，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Throws(XmlPullParserException::class, IOException::class) private fun readAnimal(parser: XmlPullParser): List\u0026lt;Dog\u0026gt; { val dogs = mutableListOf\u0026lt;Dog\u0026gt;() // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配 parser.require(XmlPullParser.START_TAG, ns, \u0026#34;animal\u0026#34;) while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } if (parser.name == \u0026#34;dog\u0026#34;) { dogs.add(readDog(parser)) } else { skip(parser) } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;animal\u0026#34;) return dogs } 其中Dog类为：\n1 2 3 4 5 6 data class Dog( val name: String?, val breed: String?, val link: String?, val profile: String? ) 3.5、解析XML 解析XML animal的步骤如下：\n按照分析animal中所述，确定希望包含在应用中的标签。此示例提取了dog标签及其嵌套标签name、breed、link和profile的数据。\n创建以下方法：\n要包含的每个标签的“read”方法，例如readDog方法。解析器会从输入流中读取标签。当遇到此示例中名为name、breed、link和profile的标签时，它会调用该标签的相应方法。否则，它会跳过该标签。 为每个不同类型的标签提取数据并推动解析器解析下一个标签的方法。在此示例中，相关方法如下所示： 对于name、breed和profile标签，解析器会调用 readText方法。此方法通过调用parser的getText方法提取这些标签的数据。 对于link标签，解析器首先会确定链接是否为其感兴趣的类型，再提取该链接的数据。然后使用parser的getAttributeValue方法提取该链接的值。 对于dog标签，解析器会调用readDog方法。此方法会解析条目的嵌套标签，并返回包含数据成员name、breed、link和profile的Dog对象。 一种递归的辅助skip方法。 以下代码段展示了解析器如何解析name、breed、link和profile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @Throws(XmlPullParserException::class, IOException::class) private fun readDog(parser: XmlPullParser): Dog { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;dog\u0026#34;) var name: String? = null var breed: String? = null var link: String? = null var profile: String? = null while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } when (parser.name) { \u0026#34;name\u0026#34; -\u0026gt; name = readName(parser) \u0026#34;breed\u0026#34; -\u0026gt; breed = readBreed(parser) \u0026#34;link\u0026#34; -\u0026gt; link = readLink(parser) \u0026#34;profile\u0026#34; -\u0026gt; profile = readProfile(parser) else -\u0026gt; skip(parser) } } return Dog(name, breed, link, profile) } @Throws(XmlPullParserException::class, IOException::class) private fun readProfile(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;profile\u0026#34;) val profile = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;profile\u0026#34;) return profile } @Throws(XmlPullParserException::class, IOException::class) private fun readLink(parser: XmlPullParser): String { var link = \u0026#34;\u0026#34; parser.require(XmlPullParser.START_TAG, ns, \u0026#34;link\u0026#34;) val tag = parser.name val relType = parser.getAttributeValue(null, \u0026#34;rel\u0026#34;) if (tag == \u0026#34;link\u0026#34;) { if (relType == \u0026#34;alternate\u0026#34;) { link = parser.getAttributeValue(null, \u0026#34;href\u0026#34;) parser.nextTag() } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;link\u0026#34;) return link } @Throws(XmlPullParserException::class, IOException::class) private fun readBreed(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;breed\u0026#34;) val breed = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;breed\u0026#34;) return breed } @Throws(XmlPullParserException::class, IOException::class) private fun readName(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;name\u0026#34;) val name = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;name\u0026#34;) return name } @Throws(XmlPullParserException::class, IOException::class) private fun readText(parser: XmlPullParser): String { var result = \u0026#34;\u0026#34; if (parser.next() == XmlPullParser.TEXT) { result = parser.text parser.nextTag() } return result } 3.6、跳过不感兴趣的标签 解析器需要跳过不感兴趣的标签，下面是解析器的skip方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Throws(XmlPullParserException::class, IOException::class) private fun skip(parser: XmlPullParser) { if (parser.eventType != XmlPullParser.START_TAG) { throw IllegalStateException() } var depth = 1 while (depth != 0) { when (parser.next()) { XmlPullParser.END_TAG -\u0026gt; depth-- XmlPullParser.START_TAG -\u0026gt; depth++ } } } 其工作原理如下：\n如果当前事件不是START_TAG，则会抛出异常。 它会使用START_TAG以及直到匹配的END_TAG（含）的所有事件。 为确保其在遇到正确的END_TAG时停止，而非在遇到原始 START_TAG之后的首个标签时停止，它会不断追踪嵌套深度。 因此，如果当前元素具有嵌套元素，在解析器使用了原始START_TAG及其匹配的END_TAG之间的所有事件之前，depth的值不会为0。例如，看看解析器如何跳过拥有name这个嵌套元素的 cat元素：\n第一次经历while循环时，解析器在\u0026lt;cat\u0026gt;之后遇到的下一个标签是\u0026lt;name\u0026gt;的START_TAG。depth的值递增到2。 第二次经历while循环时，解析器遇到的下一个标签是 END_TAG，也就是\u0026lt;/name\u0026gt;。depth的值递减为1。 第三次，也就是最后一次经历while循环时，解析器遇到的下一个标签是END_TAG，也就是。depth的值递减为0，这表明该方法已成功跳过\u0026lt;cat\u0026gt;元素。 3.7、使用XML数据 第一步：把animal.xml文件放到Assets目录下。\n第二步：本文使用Databinding，所以需要在app的build.gradle中添加依赖：\n1 2 3 4 5 android { dataBinding { enabled = true } } 第三步：改造activity_main.xml布局，这里只有一个点击按钮，给按钮绑定点击事件，点击按钮时触发XML的解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;presenter\u0026#34; type=\u0026#34;com.pengmj.androidparsexml.Presenter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{(view)-\u0026gt;presenter.onParseXML(view)}\u0026#34; android:text=\u0026#34;解析XML\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 第四步：实现点击事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Presenter { companion object { private val tag: String = Presenter::class.java.simpleName } fun onParseXML(view: View) { val inputStream = view.context.assets.open(\u0026#34;animal.xml\u0026#34;) val list = AnimalXMLParser().parse(inputStream) Log.e(tag, list.toString()) } } 第五步：在MainActivity中将Databinding绑定UI层，设置页面点击事件对象。\n1 2 3 4 5 6 7 8 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView\u0026lt;ActivityMainBinding\u0026gt;(this, R.layout.activity_main) binding.presenter = Presenter() } } 本文源码地址： AndroidParseXML\n","date":"2023-05-07T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E8%A7%A3%E6%9E%90xml%E6%95%B0%E6%8D%AE/","section":"post","tags":null,"title":"Android解析XML数据"},{"categories":["Java"],"contents":"一、概述 假设你对ArrayDeque的源码一无所知，那么仅凭ArrayDeque名字来看的话，大概可以猜到它的实现和Array数组有关。\nArrayDeque是Java Collections Framework的一个成员，它的底层是基于定长数组实现的一个双端队列，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据，并且维护了双端队列头部元素的索引head和尾部元素的索引tail，使得它成为了一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始。\n我们知道，数组非尾部的插入和删除效率是比较低的，然而，这在ArrayDeque上的表现却是效率高，这是怎么实现的呢？\n接下来，本文会叙述ArrayDeque是如何维护这样一个循环数组，它的扩容机制是怎么实现的，这些都是ArrayDeque的核心所在；除此之外，本文还会叙述ArrayDeque的基本操作是怎样实现的，以及其它的细节。\n好了，让我们一起逐步揭开它的神秘面纱。\n二、ArrayDeque源码解读 2.1、继承关系 从UML类图中可以看到，ArrayDeque直接或间接实现了Iterable、Collection、Deque、Queue、Cloneable、Serializable这6个接口；ArrayDeque继承了AbstractCollection这个抽象类。\nArrayDeque和LinkedList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，比如说Deque接口、Queue接口的解读，本文不再次叙述，想去了解的话，可参考之前的Java集合系列：一文解读LinkedList源码「JDK11」一文。\n2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 // 存储双端队列元素的数组。所有不包含双端队列元素的数组单元格始终为空。该数组始终至少有一个空槽（在尾部）。 transient Object[] elements; // 双端队列头部元素的索引（这是将被 remove() 或 pop() 删除的元素）；或者任意数字 0 \u0026lt;= head \u0026lt; elements.length 等于 tail 如果双端队列为空。 transient int head; // 将下一个元素添加到双端队列尾部的索引（通过 addLast(E)、add(E) 或 push(E)）； elements[tail] 始终为空。 transient int tail; // 要分配的数组的最大大小。一些 VM 在数组中保留一些标题字。尝试分配更大的数组可能会导致 OutOfMemoryError: Requested array size exceeds VM limit private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从成员变量head、tail的注释可以知道，数组的长度、头部元素、尾部元素都和这两个变量有关，那么当数组初始化后，这样的数组表现形式有4种情况：\n头部元素的索引head == 尾部元素的索引tail，那么数组为空，也就是数组内部没有元素，如下图所示： 头部元素的索引head \u0026lt; 尾部元素的索引tail，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到tail-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail == 0，那么头部元素为elements[head]，尾部元素为elements[elements.length-1]，元素索引从head到elements.length-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail != 0，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构造一个空数组双端队列，其初始容量足以容纳16个元素 public ArrayDeque() { elements = new Object[16]; } // 构造一个空数组双端队列，其初始容量足以容纳指定数量的元素 public ArrayDeque(int numElements) { elements = new Object[(numElements \u0026lt; 1) ? 1 : (numElements == Integer.MAX_VALUE) ? Integer.MAX_VALUE : numElements + 1]; } // 构造一个包含指定集合元素的双端队列，按照集合迭代器返回元素的顺序。（集合的迭代器返回的第一个元素成为第一个元素，或双端队列的前面。） public ArrayDeque(Collection\u0026lt;? extends E\u0026gt; c) { this(c.size()); copyElements(c); } // 将集合c的元素循环添加到队尾 private void copyElements(Collection\u0026lt;? extends E\u0026gt; c) { c.forEach(this::addLast); } 我们看下第二个构造方法，需要传入一个numElements，这里有3种情况确定数组大小：\n如果numElements \u0026lt; 1，那么数组大小为1；\n如果numElements == Integer.MAX_VALUE，那么数组大小为Integer.MAX_VALUE；\n如果numElements \u0026gt;= 1 \u0026amp;\u0026amp; numElements \u0026lt; Integer.MAX_VALUE，那么数组大小为numElements + 1;\n第三种情况：为什么要numElements + 1呢？\n因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置。\n2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ***********尾部插入*********** // 在此双端队列的末尾插入指定的元素 public boolean add(E e) { addLast(e); return true; } // 在此双端队列的末尾插入指定的元素 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 上面说了，tail索引对应的位置是一个空位，所以这里用来存放元素e es[tail] = e; // 计算tail的新索引位置，赋值给tail变量；如果(tail+1) \u0026gt;= es.length，那么tail = 0，否则就是tail+1 // 判断是否head == tail，如果是则表示数组存满了，需要进行扩容 if (head == (tail = inc(tail, es.length))) // 执行扩容 grow(1); } static final int inc(int i, int modulus) { if (++i \u0026gt;= modulus) i = 0; return i; } // 在此双端队列的末尾插入指定的元素 public boolean offer(E e) { return offerLast(e); } // 在此双端队列的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 将指定集合中的所有元素添加到此双端队列的末尾，就像对每个元素调用addLast一样，按照集合的迭代器返回它们的顺序。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // s：原数组的元素个数 // needed：所需的最低额外容量 final int s, needed; // needed = 原数组的元素个数 + 集合c的长度 + 1（tail索引占位）- 原数组长度 // 如果needed\u0026gt;0，说明数组元素个数 + 集合c的长度 + 1（tail索引占位) \u0026gt; 原数组长度，也就是原数组容量不够装集合c了，需要扩容 if ((needed = (s = size()) + c.size() + 1 - elements.length) \u0026gt; 0) // 执行扩容 grow(needed); // 扩容完成后，将集合c的元素循环添加到队尾 copyElements(c); // 如果此双端队列发生了更改，那么返回true return size() \u0026gt; s; } // ***********头部插入*********** // 在此双端队列的前面插入指定的元素 public void addFirst(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 计算head的新索引位置，赋值给head变量；如果(head-1) \u0026lt; 0，那么head = es.length-1，否则就是head-1 es[head = dec(head, es.length)] = e; // 判断是否head==tail，如果是则表示数组存满了，需要进行扩容 if (head == tail) // 执行扩容 grow(1); } static final int dec(int i, int modulus) { if (--i \u0026lt; 0) i = modulus - 1; return i; } // 在此双端队列的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素压入此双端队列所代表的堆栈。换句话说，将元素插入到这个双端队列的前面 public void push(E e) { addFirst(e); } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // ***********尾部删除*********** public E removeLast() { E e = pollLast(); if (e == null) throw new NoSuchElementException(); return e; } public E pollLast() { final Object[] es; // 记录tail的新索引位置 final int t; // 计算tail的新索引位置，赋值给临时变量t；如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出t索引对应的元素 E e = elementAt(es = elements, t = dec(tail, es.length)); if (e != null) // 将t赋值给tail，然后将tail索引位置的元素置为null es[tail = t] = null; return e; } // ***********头部删除*********** // 检索并删除由此双端队列表示的队列的头部。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E remove() { return removeFirst(); } // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。 public E poll() { return pollFirst(); } public E removeFirst() { E e = pollFirst(); if (e == null) throw new NoSuchElementException(); return e; } public E pollFirst() { final Object[] es; // 记录head索引位置 final int h; // 在数组中取出head索引对应的元素 E e = elementAt(es = elements, h = head); if (e != null) { // 将head索引位置的元素置为null es[h] = null; // 计算head的新索引位置，赋值给head；如果(head+1) \u0026gt;= es.length，那么head = 0，否则就是head+1 head = inc(h, es.length); } // 返回head索引对应的元素 return e; } // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。 public E pop() { return removeFirst(); } 2.4.3、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // ***********头部检索*********** // 检索但不删除由此双端队列表示的队列的头部。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E element() { return getFirst(); } // 检索但不删除由此双端队列表示的队列的头部，或者如果此双端队列为空则返回null 。 public E peek() { return peekFirst(); } public E getFirst() { // 在数组中取出head索引对应的元素 E e = elementAt(elements, head); if (e == null) throw new NoSuchElementException(); // 返回head索引对应的元素 return e; } // 返回数组索引 i 处的元素。这是对泛型的轻微滥用，被 javac 所接受 static final \u0026lt;E\u0026gt; E elementAt(Object[] es, int i) { return (E) es[i]; } public E peekFirst() { // 在数组中取出head索引对应的元素 return elementAt(elements, head); } // ***********尾部检索*********** public E getLast() { final Object[] es = elements; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 E e = elementAt(es, dec(tail, es.length)); if (e == null) throw new NoSuchElementException(); return e; } public E peekLast() { final Object[] es; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 return elementAt(es = elements, dec(tail, es.length)); } 2.4.4、扩容机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将此双端队列的容量至少增加给定的数量 // need：所需的最低额外容量 private void grow(int needed) { // overflow-conscious code // 获取旧容量大小 final int oldCapacity = elements.length; // 记录新容量大小 int newCapacity; // Double capacity if small; else grow by 50% // jump：可译为跳跃，是基于旧容量计算的一个值，姑且叫跳跃容量 // 如果oldCapacity \u0026lt; 64，那么jump = oldCapacity + 2，为什么这里是+2？+1不行吗？因为+2有两个含义，一个是给tail占位使用，另一个就是给新元素插入使用 // 如果oldCapacity \u0026gt;= 64，那么jump = oldCapacity \u0026gt;\u0026gt; 1，右移一位表示除2，相当于oldCapacity/2 int jump = (oldCapacity \u0026lt; 64) ? (oldCapacity + 2) : (oldCapacity \u0026gt;\u0026gt; 1); // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 如果（跳跃容量 + 旧容量）\u0026gt; MAX_ARRAY_SIZE，说明超过数组长度允许最大值了 // // newCapacity的值有两个情况： // 如果oldCapacity \u0026lt; 64，那newCapacity为oldCapacity * 2 + 2 // 如果oldCapacity \u0026gt;= 64，那newCapacity为oldCapacity * 1.5 if (jump \u0026lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE \u0026gt; 0) // 出现上面说的两种情况时，需要重新调整新容量大小 newCapacity = newCapacity(needed, jump); // 将原数组的元素全部拷贝到新数组中去 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated // 此时数组只是扩大了，但是tail==head，即依然指向同一位置，为避免歧义，需要调整head和tail的位置 if (tail \u0026lt; head || (tail == head \u0026amp;\u0026amp; es[head] != null)) { // wrap around; slide first leg forward to end of array // 计算扩容后数组的剩余空间 int newSpace = newCapacity - oldCapacity; // 将旧数据复制到新位置 System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); // 将旧位置的旧数据全部清空，head成为新位置⾸元素的位置 for (int i = head, to = (head += newSpace); i \u0026lt; to; i++) es[i] = null; } } // 边缘条件的容量计算，尤其是溢出 private int newCapacity(int needed, int jump) { final int oldCapacity = elements.length, minCapacity; // 边界处理：判断旧容量 + 所需的最低额外容量是否超过数组长度允许最大值 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE \u0026gt; 0) { if (minCapacity \u0026lt; 0) throw new IllegalStateException(\u0026#34;Sorry, deque too big\u0026#34;); return Integer.MAX_VALUE; } // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 返回minCapacity = oldCapacity + needed if (needed \u0026gt; jump) return minCapacity; // 如果最小容量minCapacity没有超过数组长度允许最大值，并且need \u0026lt;= jump // 边界处理：判断旧容量+跳跃容量是否超过数组长度允许最大值 return (oldCapacity + jump - MAX_ARRAY_SIZE \u0026lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; } 下面通过一个小例子去演示扩容机制的执行流程，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 初始时，数组⻓度是5，真实索引是0-4，head = tail = 0 ArrayDeque\u0026lt;Integer\u0026gt; arrayDeque = new ArrayDeque\u0026lt;\u0026gt;(4); // 执行完，head = 0, tail = 1；此时数组为：[1, null, null, null, null] arrayDeque.addLast(1); // 执行完，head = 4，tail = 1；此时数组为：[1, null, null, null, 2] arrayDeque.addFirst(2); // 执行完，head = 3，tail = 1；此时数组为：[1, null, null, 3, 2] arrayDeque.addFirst(3); // 执行完，head = 2，tail = 1；此时数组为：[1, null, 4, 3, 2] arrayDeque.addFirst(4); // 执行完，head = tail = 1，触发扩容；此时数组为：[1, 5, 4, 3, 2]，扩容容量为5*2+2 // 然后将旧数据复制到新位置，此时数组为：[1, 5, 4, 3, 2, null, null, null, 5, 4, 3, 2] // 接着清掉旧数据，这时head = 8，tail = 1；此时数组为：[1, null, null, null, null, null, null, null, 5, 4, 3, 2] arrayDeque.addFirst(5); // 执行完，head = 8, tail = 2；此时数组为：[1, 6, null, null, null, null, null, null, 5, 4, 3 ,2] arrayDeque.addLast(6); 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 返回此双端队列中的元素数 public int size() { // i = tail，j = head，modulus = elements.length // 那么i -= j为i = i-j，代入后是tail = tail - head，然后判断计算后的tail是否 \u0026lt; 0 // 如果 \u0026lt; 0，说明是head \u0026gt; tail的情况，对应于前面讲成员变量提到的数组情况3或4，这种情况下， tail会再次计算，tail = tail + elements.length，这样计算就可以求出数组的元素个数，不明白可以对照图来看 // 如果 \u0026gt;= 0，说明是head \u0026lt;= tail的情况，对应于前面讲成员变量提到的数组情况1或2，这种情况下，直接把tail返回即可，因为if条件判断时已经计算过了，这样计算就可以求出数组的元素个数，不明白可以对照图来看 return sub(tail, head, elements.length); } static final int sub(int i, int j, int modulus) { if ((i -= j) \u0026lt; 0) i += modulus; return i; } // 如果此双端队列包含指定元素，则返回true 。更正式地说，当且仅当此双端队列包含至少一个满足o.equals(e)的元素e时才返回true public boolean contains(Object o) { if (o != null) { final Object[] es = elements; // to = (i \u0026lt;= end) ? end : es.length; 代入为：to = （head \u0026lt;= tail）? tail : es.length; // 这里要判断head \u0026lt;= tail，如果是true，那么to==end，即to为tail，说明内层for循环只需要遍历区间[head,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false // 如果head \u0026gt; tail，如果为true，那么to = es.length，说明内层for循环要遍历区间[head,es.length)中是否存在和o元素相同的元素，如果存在，返回true // 否则，内存for循环执行完成，外层for循环此时执行 i = 0, to = end； // 接着内存for循环继续要遍历区间[0,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false for (int i = head, end = tail, to = (i \u0026lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i \u0026lt; to; i++) if (o.equals(es[i])) return true; if (to == end) break; } } return false; } 三、总结 在ArrayDeque的源码中，并没有与并发相关的代码，所以说ArrayDeque是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。\nArrayDeque没有索引位置的概念，不能根据索引位置进行操作，所以没有更改操作，如set方法。\n另外，ArrayDeque禁止添加空元素。最关键一点是：ArrayDeque用作堆栈时很可能比Stack快，用作队列时比LinkedList快。\n","date":"2023-04-24T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraydeque%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayDeque源码「JDK11」"},{"categories":["Java"],"contents":"一、概述 LinkedList是Java Collections Framework的一个成员，然后底层是基于双向链表来实现的。对于LinkedList来说，可能平常开发用的频率并没有ArrayList多，这并不是我们不去学习LinkedList原理的理由。我们知道，ArrayList的特点是随机访问效率很高，但是非尾部的插入和删除性能就比较低，因为要挪动元素位置。LinkedList和ArrayList一样实现了List接口，因为两者底层的实现不一样，造就了它的特点与ArrayList几乎正好相反。\n接下来，本文会叙述LinkedList是如何维护这样一个双向链表的，基本操作是怎样实现的，以及其它的细节。\n二、LinkedList源码解读 2.1、继承关系 从UML类图中可以看到，LinkedList直接或间接实现了Iterable、Collection、List、Deque、Queue、Cloneable、Serializable这7个接口；LinkedList直接或间接继承了AbstractSequentialList、AbstractList、AbstractCollection这3个抽象类。\n可能细心的同学会发现，为什么AbstractList实现了List接口，LinkedList还要去再实现一次List接口？\n关于这一点，在之前的Java集合系列：一文解读ArrayList源码「JDK11」一文中已有解答，除此之外，LinkedList和ArrayList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，本文不再次叙述，想去了解的话，可点击上文链接去了解。\n2.1.1、Queue接口 Queue接口是一个队列接口，它对Collection接口进行了扩展。所谓队列，就类似于日常生活中的各种排队，特点就是先进先出，在尾部添加元素，从头部删除元素，它的接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此队列，则在成功时返回true并在当前没有可用空间时抛出IllegalStateException boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，当使用容量受限的队列时，此方法通常优于add，后者可能仅通过抛出异常来插入元素失败 boolean offer(E e); // 检索并删除此队列的头部。此方法与poll()的不同之处仅在于，如果此队列为空，它会抛出异常 E remove(); // 检索并删除此队列的头部，如果此队列为空，则返回null E poll(); // 检索但不删除此队列的头部。此方法与peek不同之处仅在于，如果此队列为空，它会抛出异常 E element(); // 检索但不删除此队列的头部，如果此队列为空，则返回null E peek(); } Queue队列提供了插入、删除和检查操作。这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（null或false ，具体取决于操作），如下图所示：\n注意：Queue队列实现通常不允许插入null元素，尽管某些实现（例如 LinkedList）不禁止插入null。即使在允许它的实现中，也不应将null插入到Queue队列中，因为null也被poll方法用作特殊的返回值，以指示队列不包含任何元素。\n实践一下，我们把LinkedList当作Queue队列来使用，如下代码：\n1 2 3 4 5 6 7 Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(\u0026#34;Jerry\u0026#34;); queue.offer(\u0026#34;Tom\u0026#34;); queue.offer(\u0026#34;May\u0026#34;); while (queue.peek() != null) { System.out.println(queue.poll()); } 2.1.2、Deque接口 Deque接口对Queue接口进行了扩展，Deque是“double ended queue”的缩写，它定义了访问双端队列两端元素的方法，接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此双端队列的前面，如果当前没有可用空间则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerFirst void addFirst(E e); // 如果可以在不违反容量限制的情况下立即插入指定的元素，则在此双端队列的末尾插入指定的元素，如果当前没有可用空间，则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerLast。此方法等效于add void addLast(E e); // 将指定的元素插入此双端队列的前面，除非它违反容量限制。当使用容量受限的双端队列时，此方法通常优于addFirst方法，后者仅通过抛出异常才能插入元素失败。 boolean offerFirst(E e); // 除非违反容量限制，否则在此双端队列的末尾插入指定的元素。当使用容量受限的双端队列时，此方法通常优于addLast方法，后者仅通过抛出异常才能插入元素失败 boolean offerLast(E e); // 检索并删除此双端队列的第一个元素。此方法与pollFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeFirst(); // 检索并删除此双端队列的最后一个元素。此方法与pollLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeLast(); // 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null E pollFirst(); // 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null E pollLast(); // 检索但不删除此双端队列的第一个元素。此方法与peekFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getFirst(); // 检索但不删除此双端队列的最后一个元素。此方法与peekLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getLast(); // 检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回null E peekFirst(); // 检索但不删除此双端队列的最后一个元素，如果此双端队列为空则返回null E peekLast(); // *** Queue methods *** // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true并在当前没有可用空间时抛出IllegalStateException .使用容量受限的双端队列时，通常最好使用offer 。此方法等效于addLast boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true ，如果当前没有可用空间则返回false 。当使用容量受限的双端队列时，此方法通常优于add方法，后者仅通过抛出异常才能插入元素失败。此方法等效于offerLast boolean offer(E e); // 检索并删除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于removeFirst() E remove(); // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。此方法等效于pollFirst() E poll(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于getFirst() E element(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回null 。此方法等效于peekFirst() E peek(); // *** Stack methods *** // 如果可以在不违反容量限制的情况下立即将元素推入此双端队列表示的堆栈（换句话说，在此双端队列的头部），如果当前没有可用空间则抛出IllegalStateException void push(E e); // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。此方法等效于removeFirst() E pop(); } Deque接口提供了插入、删除和检查的方法，这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（ null或false ，具体取决于操作），如下图所示：\n当双端队列用作队列时，会产生FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。从Queue接口继承的方法与Deque接口方法完全等价，如下图所示：\n除此之外，双端队列也可以用作LIFO（后进先出）堆栈。应优先使用此接口而不是使用Stack类。当双端队列用作堆栈时，元素从双端队列的开头被压入和弹出。Stack方法等同于Deque方法，如下图所示：\n实践一下，我们把LinkedList当作Deque堆栈来使用，如下代码：\n1 2 3 4 5 6 7 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;Jerry\u0026#34;); deque.push(\u0026#34;Tom\u0026#34;); deque.push(\u0026#34;May\u0026#34;); while (deque.peek() != null) { System.out.println(deque.pop()); } 注意：当双端队列用作队列或堆栈时，peek方法同样有效；在任何一种情况下，元素都是从双端队列的开头提取的。\n虽然并未严格要求Deque队列实现禁止插入空元素，但强烈建议它们这样做。强烈建议任何确实允许null元素的Deque实现的用户不要利用插入null的能力。之所以如此，是因为null被各种方法用作特殊的返回值，以指示双端队列为空。\nDeque接口除了上面介绍的核心方法外，它还有一个迭代器方法，可以从后往前遍历，如下代码：\n1 2 3 4 5 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(new String[]{\u0026#34;Jerry\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;May\u0026#34;})); Iterator\u0026lt;String\u0026gt; iterator = deque.descendingIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2.2、成员变量 1 2 3 4 5 6 7 8 // LinkedList的大小（它包含的元素数） transient int size = 0; // 指向第一个节点的指针 transient Node\u0026lt;E\u0026gt; first; // 指向最后一个节点的指针 transient Node\u0026lt;E\u0026gt; last; LinkedList的成员变量不多，我们重点看下内部类Node节点的实现，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static class Node\u0026lt;E\u0026gt; { // 存储元素 E item; // 后继节点 Node\u0026lt;E\u0026gt; next; // 前驱节点 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 从上面Node节点的构造函数来看，Node节点的结构如下图所示：\nLinkedList就是由一个个的Node节点双向连接而成，如下图所示：\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 // 构造一个空列表 public LinkedList() { } // 构造一个包含指定集合元素的列表，按照集合迭代器返回元素的顺序 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { this(); // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 addAll(c); } 2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // ***********尾部插入*********** // 将指定的元素附加到此列表的末尾 public boolean add(E e) { linkLast(e); return true; } // 将指定的元素附加到此列表的末尾 public void addLast(E e) { linkLast(e); } // 添加指定元素作为此列表的尾部（最后一个元素） public boolean offer(E e) { return add(e); } // 在此列表的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return addAll(size, c); } // ***********头部插入*********** // 在此列表的开头插入指定的元素 public void addFirst(E e) { linkFirst(e); } // 在此列表的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素推入此列表表示的堆栈中。换句话说，将元素插入此列表的前面 public void push(E e) { addFirst(e); } // ***********中间插入*********** // 在此列表中的指定位置插入指定元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一） public void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 如果插入的索引位置为size，那说明是尾部插入 if (index == size) // 执行尾部插入 linkLast(element); else // 先找到当前链表上指定index位置的node节点，然后再插入新节点 linkBefore(element, node(index)); } // ***********插入核心实现*********** // 链接e作为最后一个元素 void linkLast(E e) { // 获取当前链表的last节点 final Node\u0026lt;E\u0026gt; l = last; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 让新节点成为last节点 last = newNode; // 如果last节点为null，说明这是第一次插入新节点，所以新节点也是first节点 if (l == null) first = newNode; else // 否则新节点是last节点的下一个节点 l.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 链接e作为第一个元素 private void linkFirst(E e) { // 获取当前链表的first节点 final Node\u0026lt;E\u0026gt; f = first; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 让新节点成为last节点 first = newNode; // 如果first节点为null，说明这是第一次插入新节点，所以新节点也是last节点 if (f == null) last = newNode; else // 否则新节点是first节点的上一个节点 f.prev = newNode; // 更新size：元素个数+1 size++; modCount++; } // 返回指定元素索引处的（非空）节点。 Node\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1 == size/2 // 如果index \u0026lt; size/2，那么就从first节点开始往后遍历查找 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 如果index \u0026gt;= size/2，那么就从last节点开始往前遍历查找 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } // 在非空节点 succ 之前插入元素 e void linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; // 获取当前链表的succ节点的前一个节点pred final Node\u0026lt;E\u0026gt; pred = succ.prev; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 让新节点成为succ节点的前一个节点 succ.prev = newNode; // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 将指定集合中的所有元素插入此列表，从指定位置开始。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的​​迭代器返回的顺序出现在列表中。 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 将集合c的元素按集合c的顺序转换为数组返回 Object[] a = c.toArray(); // 如果数组长度为0，那么返回false int numNew = a.length; if (numNew == 0) return false; // 定义当前链表index索引对应的succ节点，以及succ节点的前节点pred Node\u0026lt;E\u0026gt; pred, succ; // 如果index == size，说明是尾部插入 if (index == size) { // size位置的节点为null succ = null; // pred节点为插入位置的前节点last pred = last; } else { // 否则是中间插入，那么先找到当前链表上指定index位置的node节点，然后再插入新节点 succ = node(index); // pred为succ的前节点 pred = succ.prev; } // 遍历数组，让数组转换为链表 for (Object o : a) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新节点 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 每一轮循环结束，新节点就是pred节点 pred = newNode; } // 如果succ节点为null，说明是尾部插入，此时插入已经完成，那么pred节点为数组的最后一个节点，所以理所应当成为last节点 if (succ == null) { last = pred; } else { // 如果succ节点不为null，说明是中间插入，此时插入已经完成，那么数组的最后一个节点指向插入位置节点succ pred.next = succ; // 数组的最后一个节点pred，理所应当成为插入位置节点succ的上一个节点 succ.prev = pred; } // 更新size：元素个数+数组长度 size += numNew; modCount++; return true; } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 // ***********尾部删除*********** // 从此列表中移除并返回最后一个元素 public E removeLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 检索并删除此列表的最后一个元素，如果此列表为空，则返回null public E pollLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : unlinkLast(l); } // ***********头部删除*********** // 检索并删除此列表的头部（第一个元素） public E remove() { return removeFirst(); } // 检索并删除此列表的头部（第一个元素） public E poll() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表中移除并返回第一个元素。 public E removeFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 检索并删除此列表的第一个元素，如果此列表为空，则返回null public E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素 public E pop() { return removeFirst(); } // ***********中间删除*********** // 移除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）。返回从列表中删除的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } // ***********删除核心实现*********** // 取消链接非空的第一个节点f private E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // assert f == first \u0026amp;\u0026amp; f != null; // 获取node节点的元素element final E element = f.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = f.next; // 将node节点持有的元素item置为null f.item = null; // 将node节点持有的后继节点指针置为null f.next = null; // help GC // node节点的下一个节点成为first节点 first = next; // 如果next节点为null，说明最后一个节点也被删除了，那么last节点置为null if (next == null) last = null; else // 否则node节点置为null next.prev = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空的最后一个节点l private E unlinkLast(Node\u0026lt;E\u0026gt; l) { // assert l == last \u0026amp;\u0026amp; l != null; // 获取node节点的元素element final E element = l.item; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = l.prev; // 将node节点持有的元素item置为null l.item = null; // 将node节点持有的前躯节点指针置为null l.prev = null; // help GC // node节点的上一个节点成为last节点 last = prev; // 如果prev节点为null，说明最后一个节点也被删除了，那么first节点置为null if (prev == null) first = null; else // 否则node节点置为null prev.next = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空节点x E unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null; // 获取node节点的元素element final E element = x.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = x.next; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 如果prev节点为null，说明是头部删除，那么next节点成为first节点 if (prev == null) { first = next; } else { // 如果prev节点不为null，说明是中间删除，那么next节点成为前驱节点prev的下一个节点 prev.next = next; // node节点的前驱节点指针置为null x.prev = null; } // 如果next节点为null，说明是尾部删除，那么prev节点成为last节点 if (next == null) { last = prev; } else { // 如果prev节点不为null，说明是中间删除，那么prev节点成为后继节点next的上一个节点 next.prev = prev; // node节点的后继节点指针置为null x.next = null; } // 将node节点持有的元素item置为null x.item = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果此列表不包含该元素，则它保持不变。更正式地说，删除具有最低索引i元素 public boolean remove(Object o) { // 如果要删除的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后执行删除 if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果要删除的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后执行删除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 2.4.3、更改 1 2 3 4 5 6 7 8 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { checkElementIndex(index); Node\u0026lt;E\u0026gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 2.4.4、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ***********头部检索*********** // 检索但不删除此列表的头部（第一个元素） public E element() { return getFirst(); } // 检索但不删除此列表的头部（第一个元素） public E peek() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // 返回此列表中的第一个元素 public E getFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 检索但不删除此列表的第一个元素，如果此列表为空，则返回null public E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // ***********尾部检索*********** // 返回此列表中的最后一个元素 public E getLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回null public E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } // ***********中间检索*********** // 返回此列表中指定位置的元素 public E get(int index) { checkElementIndex(index); return node(index).item; } 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 返回此列表中指定元素第一次出现的索引，如果此列表不包含该元素，则返回 -1，更正式地说，返回具有最低索引i元素 public int indexOf(Object o) { int index = 0; // 如果要查找的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后返回index if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { // 如果要查找的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后返回index for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 三、总结 在LinkedList的源码中，并没有与并发相关的代码，所以说LinkedList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new LinkedList(...)); 另外，LinkedList要根据实际的业务场景来使用，比如说，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，使用LinkedList会有更好的性能。\n","date":"2023-04-19T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBlinkedlist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读LinkedList源码「JDK11」"},{"categories":null,"contents":" 此博客主要用来对日常的开发等相关的内容进行记录，如果需要转载请表明出处。\n欢迎关注我的公众号 👇👇👇 ","date":"2023-04-16T20:53:15+08:00","permalink":"https://anddevmk.cn/about/","section":"","tags":null,"title":"关于"},{"categories":["Java"],"contents":"一、概述 ArrayList是经常用到的一个容器，它是Java Collections Framework的一个成员，然后底层是基于定长数组来实现的，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据。\n因此，扩容机制是ArrayList的核心所在，这一点是务必要掌握的；除此之外，本文还会叙述ArrayList的基本操作是怎样实现的，以及其它的细节。\n二、ArrayList源码解读 2.1、继承关系 从UML类图中可以看到，ArrayList直接或间接实现了Iterable、Collection、List、RandomAccess、Cloneable、Serializable这6个接口；ArrayList直接或间接继承了AbstractList、AbstractCollection这2个抽象类。\n疑问来了：为什么AbstractList实现了List接口，ArrayList还要去再实现一次List接口，是吃饱了撑着吗？\n带着疑问，我立马去网上冲浪一波，然后发现了3个对此的解释。\n观点1：如果ArrayList没去实现List接口，会导致class的getInterfaces方法返回不同的结果，这么做是为了方便基于List接口的动态代理。\n观点2：这可能是为了增加继承结构的可追踪性。当浏览Javadoc或类似的东西时，就不必遍历整个继承树，它不会有任何不良影响，并且可以帮助理解代码。\n观点3：ArrayList的作者Josh Bloch曾经认为ArrayList再实现一次List接口是有一些价值的，但后来发现这是个错误。\n以上3个观点均出自stackoverflow的一个帖子，我们了解下就好了，深究意义不大，具体原因还得是作者自己才知道。\n2.1.1、Iterable接口 2.1.1.1、概述 Iterable表示可迭代的，它有个iterator方法，需要返回Iterator对象，Iterator是一个接口，表示为迭代器。Iterable接口的定义如下：\n1 2 3 4 5 6 public interface Iterable\u0026lt;T\u0026gt; { Iterator\u0026lt;T\u0026gt; iterator(); // .....省略 } 那么实现Iterable接口有什么作用呢？先说结论：只要对象实现了Iterable接口，就可以使用for-each语法，编译器会转换为调用Iterable和Iterator接口的方法。\n我们平常用for-each语法遍历list时，你可能会写下如下代码：\n1 2 3 4 5 6 7 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(3); list.add(1); list.add(2); list.add(3); for (Integer value : list) { System.out.println(\u0026#34;value: \u0026#34; + value); } 这种for-each语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：\n1 2 3 4 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.next()); } 除了Iterable接口的iterator方法外，List接口也有一个listIterator方法，需要返回ListIterator对象，ListIterator是一个接口，它对Iterator接口做了扩展。比如，可以从末尾往前遍历，如下代码：\n1 2 3 4 ListIterator\u0026lt;Integer\u0026gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.previous()); } 2.1.1.2、fail-fast机制 那些年，年少时所犯下的错误，想起自己刚入门Java时，曾经写过如下代码：\n1 2 3 4 5 for (Integer value : list) { if (value \u0026lt; 3) { list.remove(value); } } 当年的直觉告诉你，这么写不存在问题，但是运行却会报并发修改的错误：\n1 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException 显然，这里是没有并发的代码，我们去看看ConcurrentModificationException的注释描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 当不允许进行此类修改时，已检测到对象的并发修改的方法可能会抛出此异常。 * This exception may be thrown by methods that have detected concurrent * modification of an object when such modification is not permissible. * \u0026lt;p\u0026gt; * 例如，通常不允许一个线程在另一个线程迭代集合时修改集合。 * For example, it is not generally permissible for one thread to modify a Collection * while another thread is iterating over it. * 通常，在这些情况下迭代的结果是不确定的。 * In general, the results of the iteration are undefined under these circumstances. * 如果检测到此行为，某些 Iterator 实现（包括 JRE 提供的所有通用集合实现）可能会选择抛出此异常。 * Some Iterator implementations (including those of all the general purpose collection implementations * provided by the JRE) may choose to throw this exception if this behavior is * detected. * 执行此操作的迭代器被称为fail-fast迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间出现任意的、不确定的行为的风险。 * Iterators that do this are known as \u0026lt;i\u0026gt;fail-fast\u0026lt;/i\u0026gt; iterators, * as they fail quickly and cleanly, rather that risking arbitrary, * non-deterministic behavior at an undetermined time in the future. * \u0026lt;p\u0026gt; * 请注意，此异常并不总是表示对象已被不同的线程并发修改。 * Note that this exception does not always indicate that an object has * been concurrently modified by a \u0026lt;i\u0026gt;different\u0026lt;/i\u0026gt; thread. * 如果单个线程发出一系列违反对象契约的方法调用，则该对象可能会抛出此异常。 * If a single thread issues a sequence of method invocations that violates the * contract of an object, the object may throw this exception. * 例如，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。 * For example, if a thread modifies a collection directly while it is * iterating over the collection with a fail-fast iterator, the iterator * will throw this exception. * 请注意，不能保证fail-fast行为，因为一般来说，在存在非同步并发修改的情况下不可能做出任何硬性保证。 * \u0026lt;p\u0026gt;Note that fail-fast behavior cannot be guaranteed as it is, generally * speaking, impossible to make any hard guarantees in the presence of * unsynchronized concurrent modification. * ail-fast操作会尽最大努力抛出ConcurrentModificationException。 * Fail-fast operations throw {@code ConcurrentModificationException} on a best-effort basis. * 因此，编写依赖于此异常的正确性的程序是错误的： ConcurrentModificationException应该仅用于检测错误。 * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: \u0026lt;i\u0026gt;{@code ConcurrentModificationException} * should be used only to detect bugs.\u0026lt;/i\u0026gt; * * @author Josh Bloch * @see Collection * @see Iterator * @see Spliterator * @see ListIterator * @see Vector * @see LinkedList * @see HashSet * @see Hashtable * @see TreeMap * @see AbstractList * @since 1.2 */ 上面的注释说的很明显了，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。\n那么如何避免异常呢？可以使用迭代器的remove方法，如下所示：\n1 2 3 4 5 6 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { if (iterator.next() \u0026lt; 3) { iterator.remove(); } } 它自己的remove方法为何又可以使用呢？我们需要看下迭代器的原理了。\n2.1.1.3、迭代器的原理 我们先来看下ArrayList中iterator方法的实现，代码如下：\n1 2 3 4 5 6 7 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } } iterator方法实现很简单，直接new一个Itr对象返回，Itr是ArrayList的一个成员内部类，实现了Iterator接口，它的代码量并不多，所以直接贴出来了，看注释应该就能明白。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return 下一个要返回的元素位置 int lastRet = -1; // index of last element returned; -1 if no such 最后一个返回的索引位置，如果没有，为-1 int expectedModCount = modCount; // 期望的修改次数，初始化为外部类当前的修改次数modCount // prevent creating a synthetic constructor Itr() {} public boolean hasNext() { return cursor != size; // cursor与数组元素数量的比较 } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { // 校验是否发生了结构性变化 checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 更新cursor的值，每次+1 cursor = i + 1; // 更新lastRet值，返回对应的元素 return (E) elementData[lastRet = i]; } public void remove() { // 注意：lastRet \u0026lt; 0时会抛出异常，所以调用remove()之前需要先调用next()去更新lastRet的值 if (lastRet \u0026lt; 0) throw new IllegalStateException(); // 校验是否发生了结构性变化 checkForComodification(); try { // 执行ArrayList的remove方法，modCount++ ArrayList.this.remove(lastRet); // 更新cursor的值，remove后元素数量少了一个，相当于cursor=cursor-1 cursor = lastRet; // 重置lastRet lastRet = -1; // 更新expectedModCount expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 校验是否发生了结构性变化，所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 迭代器源码中next方法，remove方法都会调用checkForComodification方法进行校验是否发生了结构性变化，由此可见，迭代器的内部维护了索引位置相关的数据，要求在迭代过程中，不能发生结构性变化，否则这些索引位置功能就会失效。\n2.1.2、RandomAccess接口 RandomAccess内部是没有任何代码的接口，它属于标记接口，其定义如下：\n1 2 public interface RandomAccess { } 实现了RandomAccess接口的类表示支持快速随机访问，用在一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现，比如Collections类的binarySearch方法，会根据List是否实现了RandomAccess接口而采用不同的实现，代码如下：\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } 2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。注意：要将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少 // 可以理解为标记调空参数构造方法 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 都将扩展为 DEFAULT_CAPACITY。 transient Object[] elementData; // ArrayList的大小（它包含的元素数） private int size; // 要分配的数组的最大大小（除非必要） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表，使得正在进行的迭代可能会产生不正确的结果。 protected transient int modCount = 0; 疑问来了：我们知道了ArrayList实现了Serializable接口，但是elementData为何要用transient修饰，这不表示elementData不能被序列化？\n其实玄机在于ArrayList中的两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 将ArrayList实例的状态保存到流中（即序列化它）。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // 从流中重构ArrayList实例（即反序列化） private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { elements[i] = s.readObject(); } elementData = elements; } else if (size == 0) { elementData = EMPTY_ELEMENTDATA; } else { throw new java.io.InvalidObjectException(\u0026#34;Invalid size: \u0026#34; + size); } } ArrayList在序列化的时候会调用writeObject方法，直接将size和element写入ObjectOutputStream；反序列化时调用readObject方法，从ObjectInputStream获取size和element，再恢复到elementData。\nelementData是存储ArrayList元素的数组缓冲区，通常扩容后都会预留一些空间，也就是说有部分空间实际没有存储元素，序列化时只序列化实际存储的那些元素，而不是整个数组，从而可以节省空间和时间。\n疑问来了：为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8而不是Integer.MAX_VALUE？\n因为存储了Array的头部信息，所以这里需要减去8。\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 空参构造方法 public ArrayList() { // 由于没有指定初始容量，所以赋值一个空实例的共享空数组实例，可以理解为标记调空参数构造方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定了初始容量的构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 创建指定大小的Object数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 elementData = c.toArray(); if ((size = elementData.length) != 0) { // 重复调用Arrays.copyOf()是为了防止c.toArray()不返回Object[] // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } } 2.4、核心方法 2.4.1、add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将指定的元素附加到此列表的末尾 public boolean add(E e) { // 此列表在结构上被修改的次数 modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { // 数组容量满了，执行扩容机制 if (s == elementData.length) // 得到一个扩容后的新数组 elementData = grow(); // size位置插入元素 elementData[s] = e; // 更新size大小：原元素个数大小+1 size = s + 1; } // 在此列表中的指定位置插入指定元素 public void add(int index, E element) { // 校验index的范围 rangeCheckForAdd(index); modCount++; // 当前元素个数大小 final int s; Object[] elementData; // 数组容量满了，执行扩容机制 if ((s = size) == (elementData = this.elementData).length) // 得到一个扩容后的新数组 elementData = grow(); // 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 移动后，index位置空余出来，即可将element插入到index位置 elementData[index] = element; // 更新size大小：原元素个数大小+1 size = s + 1; } // 将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; // 原数组的剩余容量不够插入数组的大小时，就进行扩容 if (numNew \u0026gt; (elementData = this.elementData).length - (s = size)) // 得到一个扩容后的新数组 elementData = grow(s + numNew); // 将插入数组的元素拷贝到扩容数组上 System.arraycopy(a, 0, elementData, s, numNew); // 更新size大小：原元素个数大小+插入数组的长度 size = s + numNew; return true; } 关于add方法，如果是末尾插入，那么平均时间复杂度为O(1)；如果是非末尾插入，因为需要移动元素，那么平均时间复杂度为O(n)。因此，我们应该尽量避免在大数据量中调用add带索引参数的方法。\n2.4.2、grow方法（扩容机制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private Object[] grow() { return grow(size + 1); } // 增加容量以确保它至少可以容纳最小容量参数指定的元素数 private Object[] grow(int minCapacity) { // minCapacity = size + 1 // 先计算新容量大小，再根据新容量大小创建一个Object[]新数组，把数据拷贝到新数组上 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 返回至少与给定最小容量一样大的容量。如果足够，返回增加 50% 的当前容量。除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。 private int newCapacity(int minCapacity) { // overflow-conscious code // 旧容量 = 原数组的长度 int oldCapacity = elementData.length; // 新容量 = 旧容量 + 旧容量右移一位（相当于除于2） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt;= 0) { // 如果是调用了无参数构造方法，没有指定初始容量时 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 默认初始容量就为10 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 其它情况一律size + 1 return minCapacity; } // 如果还没达到最大容量，那就是新容量大小，否则返回一个返回一个巨大的容量 return (newCapacity - MAX_ARRAY_SIZE \u0026lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // size+1 \u0026gt; MAX_ARRAY_SIZE时，那么返回一个巨大的容量Integer.MAX_VALUE，否则MAX_ARRAY_SIZE return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 2.4.3、remove方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 移除此列表中指定位置的元素 public E remove(int index) { // 校验index的范围 Objects.checkIndex(index, size); final Object[] es = elementData; // 取出要移除的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E oldValue = (E) es[index]; // 删除元素 fastRemove(es, index); // 返回要移除的元素 return oldValue; } // 跳过边界检查并且不返回删除的值的私有删除方法 private void fastRemove(Object[] es, int i) { modCount++; final int newSize; // 如果删除的元素索引位置非最后一个元素位置，那么将当前位于该位置的元素（如果有）和任何后续元素向左移动（将其索引减一）。 if ((newSize = size - 1) \u0026gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); // 移动原size-1位置多余了，需要置null es[size = newSize] = null; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果列表不包含该元素，则它不变。 public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; // 使用了java label语法 found: { // 如果传入null，那么遍历去查看是否存在null的元素，找到就跳出循环 if (o == null) { for (; i \u0026lt; size; i++) if (es[i] == null) break found; } else { // 如果传入不为null，那么遍历去查看是否存在相同的元素，找到就跳出循环 for (; i \u0026lt; size; i++) if (o.equals(es[i])) break found; } // 上面两个条件下都找不到要查找的元素，则返回false return false; } // 找到要删除的元素后执行删除 fastRemove(es, i); return true; } 2.4.4、set方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { // 校验index的范围 Objects.checkIndex(index, size); // 获取索引位置对应的元素 E oldValue = elementData(index); // 设置索引位置对应的元素 elementData[index] = element; // 返回要修改的元素 return oldValue; } // 返回索引位置对应的元素 E elementData(int index) { return (E) elementData[index]; } 2.4.5、get方法 1 2 3 4 5 6 7 // 返回此列表中指定位置的元素 public E get(int index) { // 校验index的范围 Objects.checkIndex(index, size); // 返回索引位置对应的元素 return elementData(index); } 2.5、其它方法 2.5.1、ensureCapacity方法 1 2 3 4 5 6 7 8 9 10 11 12 // 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数。 // 也就是说，这个方法的使用场景是如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数 public void ensureCapacity(int minCapacity) { // 最小容量不得低于原数组的长度，同时原数组不是第一次调用空参数构造方法和第一次扩容 if (minCapacity \u0026gt; elementData.length \u0026amp;\u0026amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u0026amp;\u0026amp; minCapacity \u0026lt;= DEFAULT_CAPACITY)) { modCount++; // 进行扩容 grow(minCapacity); } } 2.5.2、trimToSize方法 1 2 3 4 5 6 7 8 9 10 11 12 // 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList实例的存储 public void trimToSize() { modCount++; // 数组容量没装满元素 if (size \u0026lt; elementData.length) { // 如果元素个数为0，那么赋值一个空实例的共享空数组实例 elementData = (size == 0) ? EMPTY_ELEMENTDATA // 否则拷贝元素到新数组上，新数组的大小就是元素个数的数量 : Arrays.copyOf(elementData, size); } } 三、总结 在ArrayList的源码中，并没有与并发相关的代码，所以说ArrayList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new ArrayList(...)); 另外，ArrayList是经常用到的一个容器，要根据实际的业务场景来使用，比如说，当添加、删除数据不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会有更好的性能。\n","date":"2023-04-16T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraylist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayList源码「JDK11」"}]