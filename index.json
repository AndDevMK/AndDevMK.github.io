[{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在之前解读Flutter源码之Navigator（命令式）一文中，已分析过Navigator的相关方法API与底层原理，知道了Navigator内部通过Overlay组件来管理路由页面堆栈。\n在Flutter1.22版本发布之后，可以发现本次对路由相关API的改动较大，官方表示由于传统的命令式并没有给开发者一种灵活的方式去直接管理路由栈，甚至觉得已经过时了，一点也不Flutter。\n1 As mentioned by a participant in one of Flutter\u0026#39;s user studies, the API also feels outdated and not very Flutter-y. 而Navigator 2.0引入了一套全新的声明式API，与以往不同，这类API可以实现用一组声明式的不可变的Page页面列表表示应用中的历史路由页面，从而转换成实际代码中Navigator的Routes。\n因此，本文会带你逐步了解Navigator 2.0的实现方式以及它的底层原理。\n二、为什么需要新的API？ Flutter团队为什么要不惜这些代价对Navigator API做这么大的重构，肯定不只是为了让Navigator API的使用更像声明式那么简单，可能有如下几点原因：\n1、原始Navigator API中的initialRoute参数，即系统默认的初始页面，在应用运行后就不能再更改了。这种情况下，如果用户接收到一个系统通知，点击后想要从当前的路由栈状态 [Main -\u0026gt; Profile -\u0026gt; Settings] 切换到新的 Main -\u0026gt; List -\u0026gt; Detail[id=24]，Navigator 1.0并没有一种优雅的实现方式实现这种效果。\n2、原始的命令式Navigator API只提供给了开发者一些非常针对性的接口，如push、pop等方法，而没有给出一种更灵活的方式让我们直接操作路由栈，这种做法其实与Flutter理念相违背。\n3、在嵌套路由的情况下，手机设备自带的回退按钮只能由根Navigator响应。在目前的应用中，我们很多场景都需要在某个子tab内单独管理一个子路由栈，假设有这个场景，用户在子路由栈中做一系列路由操作之后，点击系统回退按钮，消失的将是整个上层的根路由，我们当然可以使用某种措施来避免这种状况，但归咎起来，这也不应该是应用开发者应该考虑的问题。\n4、还有更重要的一点就是对Web的支持，声明式Navigator API支持浏览器的前进按钮、后退按钮以及地址栏索引，这是原始Navigator API做不到的。\n三、分析关键API Navigator 2.0提供了一系列全新的接口，可以实现将路由状态成为应用状态的一部分，并能够通过底层API实现参数解析的功能，新增的API一些是在Navigator中配置，另一些是在MaterialApp.router中配置。\n3.1、在Navigator中配置 3.1.1、pages属性 pages属性需要传入一组Page对象，它与Navigator底层路由栈一一对应。换句话说，当你修改pages列表时其实也是对Navigator底层路由栈的修改。\nPage继承自RouteSettings，它用来描述Route的配置，包含路由名称（name，如\u0026quot;/settings\u0026quot;），参数（arguments）等信息。如果你想push一个Route，不再是调用Navigator的push方法，而是往pages列表添加一个Page对象。与此相反，如果你想pop一个Route，不再是调用Navigator的pop方法，而是移除pages列表最后一个Page对象。当修改pages列表后，底层会对之前pages与当前pages进行diff算法比较，然后更新Navigator底层路由栈。\nPage的实现类有两个，一个是MaterialPage，另一个是CupertinoPage。一般情况下，这两个实现类已经够用了，当然了你也可以自定义Page。\n从下面源码也可以发现，Page与Widget的相似度很高。Widget只保存组件配置信息，框架层内置了一个createElement()可以创建与之对应的Element实例。Page同样只保存页面路由相关信息，框架层也存在一个createRoute()方法可以创建与之对应的Route实例。\nWidget和Page中也都有一个canUpdate()方法，用于底层判断Page是否已更新或改变，甚至连比较的条件都是runtimeType与key。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 abstract class Page\u0026lt;T\u0026gt; extends RouteSettings { const Page({ this.key, super.name, super.arguments, this.restorationId, }); final LocalKey? key; final String? restorationId; bool canUpdate(Page\u0026lt;dynamic\u0026gt; other) { return other.runtimeType == runtimeType \u0026amp;\u0026amp; other.key == key; } @factory Route\u0026lt;T\u0026gt; createRoute(BuildContext context); @override String toString() =\u0026gt; \u0026#39;${objectRuntimeType(this, \u0026#39;Page\u0026#39;)}(\u0026#34;$name\u0026#34;, $key, $arguments)\u0026#39;; } 除此之外，Navigator 2.0与Navigator 1.0也可以一起工作，但是对于Navigator 1.0来说，使用push等方法添加到历史记录中的这些Route不对应于Page对象。\n不对应于Page对象的Route称为无页路由，并绑定到与历史中位于其下方的Page对象对应的Route。如果一个页面被移除，而该页面上有其它使用push方法推送的无页路由，那么这些无页路由也会被移除。\n最后，在Navigator中使用pages属性，例如下面代码。\n1 2 3 4 5 6 Navigator( pages: [ MaterialPage(child: HomePage(), key: ValueKey(\u0026#39;/\u0026#39;), name: \u0026#39;/\u0026#39;), MaterialPage(child: SecondPage(), key: ValueKey(\u0026#39;/secondPage\u0026#39;), name: \u0026#39;/secondPage\u0026#39;), ], ); 3.1.2、onPopPage属性 如果你使用了上面的pages属性，那么还必须提供onPopPage回调，否则在Navigator的initState方法中进行assert校验时会抛出错误：\n1 The Navigator.onPopPage must be provided to use the Navigator.pages API onPopPage回调的作用是系统在pop页面时给你清理pages列表中该页面的机会。在onPopPage方法中，如果你同意关闭该页面，就可以调用route.didPop(result)，该方法默认返回true。在Navigator中使用onPopPage属性，例如下面代码。\n1 2 3 4 5 6 7 8 9 bool _onPopPage(Route\u0026lt;dynamic\u0026gt; route, result) { if (!route.didPop(result)) { return false; } // 这里做一些工作，例如：清理pages列表中栈顶page与通知pages更新等 return true; } 那么问题来了，当你接收到onPopPage回调并且同意关闭该页面（onPopPage回调返回true），但是你没有从pages中移除相应的Page对象时，这会发生什么现象呢？\n首先Flutter底层依然会移除路由栈中该页面的历史记录，其次是当下次pages列表更新时，如果该Route对应的Page仍然存在，则会被解释为新的路由进行显示。\n很明显，onPopPage回调已经把底层页面关闭的逻辑下放给开发者了，也就是说，某个页面是否能够关闭完全由你掌控，而不是单纯交给系统的Navigator.pop()。在onPopPage回调中，如果你不想关闭某个页面可以做相应的判断并返回false。\n至此，Navigator有了pages与onPopPage两大属性，就可以实现声明式的路由管理了。只是如果还要兼容Web端的话，例如处理浏览器的前进与后退按钮，同步浏览器地址栏中的链接等，就需要在MaterialApp.router中配置了。\n3.2、在MaterialApp.router中配置 3.2.1、routeInformationProvider属性 routeInformationProvider属性需要传入一个RouteInformationProvider对象，可以为null，也可以使用自定义的RouteInformationProvider对象。如果不传入时Flutter会使用默认的PlatformRouteInformationProvider对象。\n它向WidgetsBinding注册了一个WidgetsBindingObserver监听回调，当在某系统平台上触发了与导航相关的操作时，例如在Web端中，点击了浏览器的前进按钮与后退按钮等，WidgetsBinding就会把来自某系统平台的导航信息MethodCall转换为RouteInformation，然后分发给RouteInformationProvider。\n最后，RouteInformationProvider对象将持有的RouteInformation给到RouteInformationParser去解析处理。\n如果该Router不依赖路由信息来构建其内容，则该RouteInformationProvider可以为空。在这种情况下，RouteInformationParser也必须为null。\n3.2.2、routeInformationParser属性 routeInformationProvider属性需要传入一个RouteInformationParser对象，它用于将来自routeInformationProvider的路由信息​​解析为通用数据类型，以便稍后由routerDelegate处理。\nrouteInformationProvider对象需要开发者自己去实现，它有两个要实现的方法：\nparseRouteInformation方法 该方法的入参RouteInformation来自之前的RouteInformationProvider，在这里可以去将RouteInformation解析成你想要的数据类型。\n该方法要求返回一个Future对象，如果可以同步计算结果，请考虑使用SynchronousFuture，这样Router就不需要等待下一个微任务将数据传递给RouterDelegate。\n除此之外，还有一个parseRouteInformationWithDependencies方法，与parseRouteInformation方法一样，只不过多了一个BuildContext入参。如果解析依赖于BuildContext中的其它依赖项，则可以实现parseRouteInformationWithDependencies。\nrestoreRouteInformation方法 该方法可以从RouterDelegate对象的currentConfiguration返回的当前配置恢复RouteInformation。\n等后续再需要用到该RouteInformation对象，就可以重新解析使用，例如当执行了RouterState的didChangeDependencies方法。\n3.2.3、routerDelegate属性 routerDelegate属性需要传入一个RouterDelegate对象，它是一个委托，用于配置Navigator，并使用来自RouteInformationParser的解析结果。\n另外，该委托也是Router的核心部分，用来响应来自引擎的推送路由和弹出路由意图，并通知Router进行重建。\nrouterDelegate对象需要开发者自己去实现，一般情况下，它有三个要实现的方法\u0026amp;属性：\nsetNewRoutePath方法 当Router.routeInformationProvider报告操作系统已将新路由推送到应用程序时，该方法由Router调用，一般情况下，可以在setNewRoutePath方法中根据条件去更新你的pages。\n对于该方法的返回值，如果可以同步计算结果，请考虑使用SynchronousFuture，这样Router就不需要等待下一个微任务来安排构建。\nbuild方法 通常，此方法返回一个适当配置的Navigator。\ncurrentConfiguration属性 当Router检测到路由信息可能因重建而发生更改时调用。如果此getter返回非空，则Router将开始向引擎报告新的路由信息​​。在Web应用程序中，新的路由信息​​用于填充浏览器历史记录，以支持前进和后退按钮。\n当重写此方法时，此getter返回的配置必须能够构造当前的应用程序状态，并在build方法中使用相同的配置来构建Widget。否则，浏览器的后退和前进按钮将无法正常工作。\n默认情况下，该getter返回null，这会阻止Router上报路由信息。要选择加入，子类可以重写此getter以返回当前配置。\n最多一个Router可以选择加入路由信息报告。通常，只有WidgetsApp.router创建的最顶层Router才应选择路由信息报告。\n3.2.4、backButtonDispatcher属性 backButtonDispatcher属性决定是否处理Android后退按钮意图的委托。如果未提供，应用程序将默认创建RootBackButtonDispatcher。一般情况下，当用到BackButtonListener时才会与此关联。\n3.3、MaterialApp.router的两种配置方式 MaterialApp.router有两种配置方式，一种是直接传入routeInformationParser、routerDelegate等属性。另一种是传入一个routerConfig。\n上面两种方式没区别，但是如果提供了routerConfig，则其它与路由器相关的委托、 routeInformationParser、routeInformationProvider、routerDelegate和backButtonDispatcher必须全部为null。\n3.4、Router交互原理 如果上面文字看不明白，可以看下面这张图，它展示了RouterDelegate与Router、RouteInformationParser以及应用状态的交互原理。\n结合上面图示，大致流程如下：\n1、当系统打开新页面（如 “books/ 2”）时，RouteInformationParser会将其转换为应用中的具体数据类型T（如BooksRoutePath）。\n2、该数据类型会被传递给RouterDelegate的setNewRoutePath方法，我们可以在这里更新路由状态（如通过设置selectedBookId）并调用notifyListeners响应该操作。\n3、notifyListeners会通知Router重建RouterDelegate（通过 build() 方法）。\n4、RouterDelegate.build()返回一个新的Navigator实例，并最终展示出我们想要打开的页面（如selectedBookId）。\n四、Navigator 2.0实战 Navigator 2.0需要做到以下几点实现：\n1、 实现解析路由信息，其中包括系统初始路由、浏览器前进按钮、后退按钮以及地址栏索引，这个对应于RouteInformationParser的parseRouteInformation方法。\n2、 实现pages的管理，对于push页面情况，如果要打开的页面在栈中已存在，则将该页面之上的所有页面进行出栈（这里可按需求处理，这是其中一个方案）。对于pop页面情况，将栈顶页面出栈即可。\n3、 对于Page的创建，统一采用MaterialPage，这里不需要用到自定义Page，其所关联的Widget通过路由表配置后来获取，并且页面传参通过Widget的构造方法来完成。\n4、 实现onPopPage方法，更新pages列表，最后通知RouterDelegate去更新Navigator。\n5、 实现恢复路由信息，对于Web端是很有必要的。这个对应于RouteInformationParser的restoreRouteInformation方法。\n6、 实现统一的跳转逻辑，例如提供一个统一的pushNamed方法。这时可能有人会感到疑惑，说好的声明式，现在怎么又变回命令式了。其实要明白，声明式的尽头还是命令式。\n不像之前Navigator 1.0那样的push去操作Route，pushNamed方法还是去更新pages，所以本质上也还是声明式的，为了方便更新pages不得已而为之。这样做也有一个好处，就是不需要通过Widget去传入大量回调。\n7、 实现页面监听onResume或onPause方法，这也是一个比较有意思的功能，也只有Navigator 2.0才可以做到（注意：手机HOME退到后台，再切换到前台，这种情况不支持）。\n8、 实现统一的页面弹出控制，把result回传给上一个页面，这里和Navigator 1.0通过Future去等待结果不同，因为无法获取Route.popped，所以这里通过监听回调来完成。\n9、 \u0026hellip;\nOK，这里就不带大家一步步实现了，直接给出最终源码，一些欠考虑的地方请看注释，最后运行效果UI请自行运行程序查看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp.router( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), routeInformationParser: CustomRouteInformationParser(), routerDelegate: CustomRouterDelegate(), ); } } class CustomRouteInformationParser extends RouteInformationParser\u0026lt;RouteSettings\u0026gt; { @override Future\u0026lt;RouteSettings\u0026gt; parseRouteInformation(RouteInformation routeInformation) { final Uri uri = routeInformation.uri; final String location = Uri.decodeComponent(uri.toString()); // == uri.toString debugPrint(\u0026#39;CustomRouteInformationParser-\u0026gt;parseRouteInformation：$location\u0026#39;); // 这里只对移动端做了路由解析，例如：\u0026#34;/\u0026#34;、\u0026#34;/secondPage\u0026#34;这样的地址 // 如果要适配Web端，这里路由解析不会那么简单，例如：\u0026#34;/details/3\u0026#34;这样的地址，这段path后面的3可以是传给详情页面的ID // 所以在本案例中，Web端通过地址栏输入地址来跳转到要创建的新页面或者点击浏览器前进后退按钮时， // 这里RouteSettings因为没有传入参数，此时会导致跳转后的页面获取不了参数 final RouteSettings routeSettings = RouteSettings(name: uri.path.isEmpty ? \u0026#39;/\u0026#39; : uri.path); return SynchronousFuture\u0026lt;RouteSettings\u0026gt;(routeSettings); } @override RouteInformation? restoreRouteInformation(RouteSettings configuration) { debugPrint(\u0026#39;CustomRouteInformationParser-\u0026gt;restoreRouteInformation：${configuration.name}\u0026#39;); return RouteInformation(uri: Uri.parse(configuration.name!)); } } class CustomRouterDelegate extends RouterDelegate\u0026lt;RouteSettings\u0026gt; with ChangeNotifier, PopNavigatorRouterDelegateMixin\u0026lt;RouteSettings\u0026gt;, _PagesHandler { CustomRouterDelegate() : navigatorKey = GlobalKey\u0026lt;NavigatorState\u0026gt;() { NavigatorHelper() ..registerOnJumpListener((RouteSettings routeSettings) { debugPrint(\u0026#39;跳转回调：$routeSettings\u0026#39;); _routeSettings = routeSettings; _updatePages(); }) ..registerOnRoutePopListener(_onRoutePop); // 问题：Hot Reload时，_pages为空，导致报错：The Navigator.pages must not be empty to use the Navigator.pages API // bug位置：NavigatorState-\u0026gt;initState // 最初fix方案：当_pages为空时，给_pages赋值为const \u0026lt;Page\u0026lt;dynamic\u0026gt;\u0026gt;[] // 但是产生新问题：Hot Reload时，_pages为空，导致报错：Navigator.onGenerateRoute was null, but the route named // bug位置：NavigatorState-\u0026gt;restoreState-\u0026gt;defaultGenerateInitialRoutes-\u0026gt;_routeNamed // 最终fix：在NavigatorState-\u0026gt;initState执行之前，给_pages一个初始值即可 _pages.add(_buildPage(name: Routes.rootPage)); } Object? _result; // 从栈顶页面返回的数据 void _onRoutePop([Object? result]) { _result = result; popRoute(); } List\u0026lt;Page\u0026gt; _pages = []; RouteSettings _routeSettings = const RouteSettings(name: Routes.rootPage); @override Widget build(BuildContext context) { debugPrint(\u0026#39;CustomRouterDelegate-\u0026gt;build\u0026#39;); return Navigator( key: navigatorKey, // 问题：如果_pages用final修饰，会导致oldWidget.pages != widget.pages判断不成立， // 从而无法执行_updatePages方法，也就触发不了路由栈映射，所以页面UI就无法跳转。 // bug位置：NavigatorState-\u0026gt;didUpdateWidget // fix：在每次build时，这里的_pages引用需要不相等，也就是要创建一个_pages新对象 pages: _pages, onPopPage: _onPopPage, ); } bool _onPopPage(Route\u0026lt;dynamic\u0026gt; route, result) { debugPrint(\u0026#39;CustomRouterDelegate-\u0026gt;_onPopPage\u0026#39;); if (!route.didPop(result)) { return false; } _routeSettings = _pages[_pages.length - 2]; // 前一个页面的_routeSettings _updatePages(pop: true); if (_result != null) { NavigatorHelper().notifyRoutePop(_routeSettings, _result!); _result = null; } return true; } @override GlobalKey\u0026lt;NavigatorState\u0026gt;? navigatorKey; @override RouteSettings? get currentConfiguration =\u0026gt; _routeSettings; @override Future\u0026lt;void\u0026gt; setNewRoutePath(RouteSettings configuration) { debugPrint(\u0026#39;CustomRouterDelegate-\u0026gt;setNewRoutePath: ${configuration.name}\u0026#39;); _routeSettings = configuration; _updatePages(); return SynchronousFuture\u0026lt;void\u0026gt;(null); } void _updatePages({bool pop = false}) { List\u0026lt;Page\u0026gt; tempPages = [..._pages]; // 用副本处理 if (pop) { tempPages.removeLast(); } else { final int index = _getCurPageIndex(tempPages, _routeSettings); if (index != -1) { if (tempPages[index] is MaterialPage) { MaterialPage materialPage = tempPages[index] as MaterialPage; debugPrint(\u0026#39;将${materialPage.child}页面之上的所有页面进行出栈\u0026#39;); } // 这里可根据实际情况处理，这里给个一般方案： // 要打开的页面在栈中已存在，则将该页面之上的所有页面进行出栈 tempPages = tempPages.sublist(0, index + 1); // [0, index] } else { Page newPage = _buildPage(name: _routeSettings.name!, arguments: _routeSettings.arguments); if (newPage is MaterialPage) { debugPrint(\u0026#39;创建新页面：${newPage.child}\u0026#39;); } tempPages.add(newPage); } } NavigatorHelper().notifyRouteChange(_pages, tempPages); _pages = tempPages; List\u0026lt;Widget\u0026gt; widgets = _pages.whereType\u0026lt;MaterialPage\u0026gt;().map((page) =\u0026gt; page.child).toList(); debugPrint(\u0026#39;此时路由栈：$widgets\u0026#39;); notifyListeners(); } } /// Pages处理相关方法 mixin _PagesHandler { int _getCurPageIndex(List\u0026lt;Page\u0026gt; pages, RouteSettings routeSettings) { return pages.indexWhere((page) =\u0026gt; page.name == routeSettings.name); // 找不到返回-1 } Page _buildPage({required String name, Object? arguments}) { return MaterialPage( child: _buildWidget(name: name, arguments: arguments), key: ValueKey(name), name: name, arguments: arguments, ); } Widget _buildWidget({required String name, Object? arguments}) { dynamic widgetBuilder = Routes.routeMap[name]; if (widgetBuilder == null) { return const UnknownPage(); } if (arguments == null) { return widgetBuilder(name); } return widgetBuilder(name, arguments: arguments); } } /// 路由表 class Routes { static const String rootPage = \u0026#39;/\u0026#39;; static const String secondPage = \u0026#39;/secondPage\u0026#39;; static const String thirdPage = \u0026#39;/thirdPage\u0026#39;; static var routeMap = { rootPage: (String name) =\u0026gt; const HomePage(), secondPage: (String name, {Object? arguments}) =\u0026gt; SecondPage(arguments: arguments), thirdPage: (String name, {Object? arguments}) =\u0026gt; ThirdPage(arguments: arguments), }; } class NavigatorHelper { static final NavigatorHelper _singleton = NavigatorHelper._internal(); NavigatorHelper._internal(); factory NavigatorHelper() =\u0026gt; _singleton; OnRouteJumpListener? _onRouteJumpListener; void registerOnJumpListener(OnRouteJumpListener onRouteJumpListener) { _onRouteJumpListener = onRouteJumpListener; } void pushNamed({required String name, Object? arguments}) { _onRouteJumpListener?.call(RouteSettings(name: name, arguments: arguments)); } final Map\u0026lt;String, OnRouteChangeListener\u0026gt; onRouteChangeListeners = {}; void registerOnRouteChangeListener(String name, OnRouteChangeListener onRouteChangeListener) { onRouteChangeListeners[name] = onRouteChangeListener; } void unregisterOnRouteChangeListener(String name) =\u0026gt; onRouteChangeListeners.remove(name); RouteSettings? previous; /// 遗憾之处：新建Page的onResume无法监听，因为notifyRouteChange方法先于 /// 新建Page的initState方法执行，所以新建Page还没注册OnRouteChangeListeners /// fix：SchedulerBinding.instance.addPostFrameCallback /// 但是，当页面很复杂并且渲染出现丢帧时，不知道此处回调是否在build方法之后执行，如果不在，则此处该处理无意义 void notifyRouteChange(List\u0026lt;Page\u0026gt; previousPages, List\u0026lt;Page\u0026gt; currentPages) { if (previousPages == currentPages) { return; } // 此方法不请求新帧。如果帧已经在进行中并且帧后回调的执行尚未开始，则注册的回调将在当前帧结束时执行。否则，注册的回调将在下一帧之后执行（无论何时，如果有的话） // 帧后回调无法取消注册。它们只被调用一次 SchedulerBinding.instance.addPostFrameCallback((timeStamp) { debugPrint(\u0026#39;分发RouteChange回调：$onRouteChangeListeners\u0026#39;); onRouteChangeListeners.forEach((key, value) { if (previous?.name != key \u0026amp;\u0026amp; currentPages.last.name == key) { value(RoutePageStatus.resume); } else if (previous?.name == key \u0026amp;\u0026amp; currentPages.last.name != key) { value(RoutePageStatus.pause); } }); previous = RouteSettings(name: currentPages.last.name, arguments: currentPages.last.arguments); }); } OnRoutePopListener? _onRoutePopListener; void registerOnRoutePopListener(OnRoutePopListener onRoutePopListener) { _onRoutePopListener = onRoutePopListener; } void pop\u0026lt;T extends Object?\u0026gt;([T? result]) { _onRoutePopListener?.call(result); } final Map\u0026lt;String, OnRoutePopListener\u0026gt; _onRoutePopListeners = {}; void registerOnRoutePopListenerForResult(String name, OnRoutePopListener onRoutePopListener) { _onRoutePopListeners[name] = onRoutePopListener; } void unregisterOnRoutePopListenerForResult(String name) { _onRoutePopListeners.remove(name); } void notifyRoutePop(RouteSettings settings, Object result) { _onRoutePopListeners.forEach((key, value) { if (key == settings.name) value(result); }); } } typedef OnRouteJumpListener = void Function(RouteSettings routeSettings); typedef OnRouteChangeListener = void Function(RoutePageStatus routePageStatus); enum RoutePageStatus { resume, pause } typedef OnRoutePopListener\u0026lt;T extends Object?\u0026gt; = void Function([T? result]); class HomePage extends StatefulWidget { const HomePage({super.key}); @override State\u0026lt;HomePage\u0026gt; createState() =\u0026gt; _HomePageState(); } class _HomePageState extends State\u0026lt;HomePage\u0026gt; { @override void initState() { super.initState(); debugPrint(\u0026#39;HomePage-\u0026gt;initState\u0026#39;); NavigatorHelper().registerOnRouteChangeListener(Routes.rootPage, (RoutePageStatus routePageStatus) { if (routePageStatus == RoutePageStatus.resume) { debugPrint(\u0026#39;HomePage-\u0026gt;onResume\u0026#39;); } else if (routePageStatus == RoutePageStatus.pause) { debugPrint(\u0026#39;HomePage-\u0026gt;onPause\u0026#39;); } }); NavigatorHelper().registerOnRoutePopListenerForResult(Routes.rootPage, ([result]) { if (!mounted) return; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(\u0026#39;$result\u0026#39;))); }); } @override void dispose() { super.dispose(); NavigatorHelper().unregisterOnRouteChangeListener(Routes.rootPage); NavigatorHelper().unregisterOnRoutePopListenerForResult(Routes.rootPage); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;HomePage-\u0026gt;build\u0026#39;); return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;HomePage\u0026#39;), ), body: Center( child: OutlinedButton( onPressed: () =\u0026gt; NavigatorHelper().pushNamed(name: Routes.secondPage, arguments: 20), child: const Text(\u0026#39;带参数跳转SecondPage\u0026#39;), ), ), ); } } class SecondPage extends StatefulWidget { final Object? arguments; const SecondPage({super.key, this.arguments}); @override State\u0026lt;SecondPage\u0026gt; createState() =\u0026gt; _SecondPageState(); } class _SecondPageState extends State\u0026lt;SecondPage\u0026gt; { @override void initState() { super.initState(); debugPrint(\u0026#39;SecondPage-\u0026gt;initState\u0026#39;); NavigatorHelper().registerOnRouteChangeListener(Routes.secondPage, (RoutePageStatus routePageStatus) { if (routePageStatus == RoutePageStatus.resume) { debugPrint(\u0026#39;SecondPage-\u0026gt;onResume\u0026#39;); } else if (routePageStatus == RoutePageStatus.pause) { debugPrint(\u0026#39;SecondPage-\u0026gt;onPause\u0026#39;); } }); NavigatorHelper().registerOnRoutePopListenerForResult(Routes.secondPage, ([result]) { if (!mounted) return; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(\u0026#39;$result\u0026#39;))); }); } @override void dispose() { super.dispose(); NavigatorHelper().unregisterOnRouteChangeListener(Routes.secondPage); NavigatorHelper().unregisterOnRoutePopListenerForResult(Routes.secondPage); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;SecondPage-\u0026gt;build\u0026#39;); int itemCount = 0; if (widget.arguments != null \u0026amp;\u0026amp; widget.arguments is int) { itemCount = widget.arguments as int; } return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;SecondPage\u0026#39;), ), body: ListView.builder( itemBuilder: (context, index) { return ListTile( title: Text( \u0026#39;第$index条\u0026#39;, style: const TextStyle(fontSize: 24), ), trailing: OutlinedButton( onPressed: () { if (index == 0) { NavigatorHelper().pop(999999); } else { NavigatorHelper().pushNamed(name: Routes.thirdPage, arguments: index); } }, child: index == 0 ? const Text(\u0026#39;带参数999999返回HomePage\u0026#39;) : const Text(\u0026#39;带参数跳转ThirdPage\u0026#39;), ), ); }, itemCount: itemCount, ), ); } } class ThirdPage extends StatelessWidget { final Object? arguments; const ThirdPage({super.key, this.arguments}); @override Widget build(BuildContext context) { debugPrint(\u0026#39;ThirdPage-\u0026gt;build\u0026#39;); return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;ThirdPage\u0026#39;), ), body: Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( \u0026#39;获取SecondPage的传参：$arguments\u0026#39;, style: const TextStyle(fontSize: 24), ), const SizedBox(height: 10), OutlinedButton( onPressed: () =\u0026gt; NavigatorHelper().pushNamed(name: Routes.rootPage), child: const Text(\u0026#39;返回首页\u0026#39;), ), const SizedBox(height: 10), OutlinedButton( onPressed: () =\u0026gt; NavigatorHelper().pop(888888), child: const Text(\u0026#39;带参数666666返回SecondPage\u0026#39;), ), ], ), ), ); } } class UnknownPage extends StatelessWidget { const UnknownPage({super.key}); @override Widget build(BuildContext context) { return const ColoredBox( color: Colors.redAccent, child: Center( child: Text( \u0026#39;未知页面\u0026#39;, style: TextStyle( fontSize: 24, color: Colors.white, ), ), ), ); } } 五、源码分析 5.1、系统平台Navigation信息传递 不禁让人联想到WidgetsBinding，因为它是widgets layer和Flutter engine之间的粘合剂，看下它的initInstances方法。\n1 2 3 4 5 6 7 8 9 10 @override void initInstances() { super.initInstances(); _instance = this; ... // 注册了用于在此通道上接收方法调用的回调 // 当系统平台触发导航操作时，例如点击Web端的前进按钮等，就会回调到_handleNavigationInvocation方法 SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation); ... } 看下WidgetsBinding的 _handleNavigationInvocation 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Future\u0026lt;dynamic\u0026gt; _handleNavigationInvocation(MethodCall methodCall) { switch (methodCall.method) { // 当系统希望删除当前路由时（例如，如果用户点击系统级后退按钮），就会调用它。 case \u0026#39;popRoute\u0026#39;: return handlePopRoute(); // 当操作系统指示应用程序打开特定页面时，使用单个字符串参数调用它。 case \u0026#39;pushRoute\u0026#39;: return handlePushRoute(methodCall.arguments as String); // 当操作系统指示应用程序打开特定页面时，将使用包含位置字符串和状态对象的Map来调用它。这些参数存储在Map中的键“location”和“state”下。 case \u0026#39;pushRouteInformation\u0026#39;: return _handlePushRouteInformation(methodCall.arguments as Map\u0026lt;dynamic, dynamic\u0026gt;); } return Future\u0026lt;dynamic\u0026gt;.value(); } 这里以handlePushRoute方法为例，看下它的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 final List\u0026lt;WidgetsBindingObserver\u0026gt; _observers = \u0026lt;WidgetsBindingObserver\u0026gt;[]; void addObserver(WidgetsBindingObserver observer) =\u0026gt; _observers.add(observer); bool removeObserver(WidgetsBindingObserver observer) =\u0026gt; _observers.remove(observer); @protected @mustCallSuper Future\u0026lt;void\u0026gt; handlePushRoute(String route) async { // 将route字符串转化为RouteInformation final RouteInformation routeInformation = RouteInformation(uri: Uri.parse(route)); // 遍历_observers，只要有对象注册了WidgetsBindingObserver，这里就会通过didPushRouteInformation方法分发RouteInformation for (final WidgetsBindingObserver observer in List\u0026lt;WidgetsBindingObserver\u0026gt;.of(_observers)) { if (await observer.didPushRouteInformation(routeInformation)) { return; } } } 看下WidgetsBindingObserver的didPushRouteInformation方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Future\u0026lt;bool\u0026gt; didPushRouteInformation(RouteInformation routeInformation) { final Uri uri = routeInformation.uri; return didPushRoute( Uri.decodeComponent( Uri( path: uri.path.isEmpty ? \u0026#39;/\u0026#39; : uri.path, queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll, fragment: uri.fragment.isEmpty ? null : uri.fragment, ).toString(), ), ); } @Deprecated( \u0026#39;Use didPushRouteInformation instead. \u0026#39; \u0026#39;This feature was deprecated after v3.8.0-14.0.pre.\u0026#39; ) Future\u0026lt;bool\u0026gt; didPushRoute(String route) =\u0026gt; Future\u0026lt;bool\u0026gt;.value(false); 可以看到，在WidgetsBindingObserver的didPushRouteInformation方法中执行了didPushRoute方法，什么也没做。\n其实这里的didPushRouteInformation方法由注册了WidgetsBindingObserver的对象去实现，这里是PlatformRouteInformationProvider。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // PlatformRouteInformationProvider混入了WidgetsBindingObserver，ChangeNotifier class PlatformRouteInformationProvider extends RouteInformationProvider with WidgetsBindingObserver, ChangeNotifier { @override RouteInformation get value =\u0026gt; _value; RouteInformation _value; RouteInformation _valueInEngine = RouteInformation(uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName)); void _platformReportsNewRouteInformation(RouteInformation routeInformation) { if (_value == routeInformation) { return; } // 将RouteInformation缓存一下，后续通过_value可以获取 _value = routeInformation; _valueInEngine = routeInformation; // 这里非常关键，因为混入了ChangeNotifier，所以会触发addListener传入的VoidCallback回调 // 这里调用地方等下讲 notifyListeners(); } // 外部调用PlatformRouteInformationProvider的addListener方法时，就会注册WidgetsBindingObserver回调 // 这里调用地方等下讲 @override void addListener(VoidCallback listener) { if (!hasListeners) { WidgetsBinding.instance.addObserver(this); } super.addListener(listener); } @override void removeListener(VoidCallback listener) { super.removeListener(listener); if (!hasListeners) { WidgetsBinding.instance.removeObserver(this); } } @override Future\u0026lt;bool\u0026gt; didPushRouteInformation(RouteInformation routeInformation) async { assert(hasListeners); _platformReportsNewRouteInformation(routeInformation); return true; } } 至此，系统Navigation信息传递给了PlatformRouteInformationProvider。\n5.2、_MaterialAppState 的build方法 从MaterialApp入手，因为它是一个StatefulWidget，所以看下 _MaterialAppState 的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @override Widget build(BuildContext context) { // 执行_buildWidgetApp方法 Widget result = _buildWidgetApp(context); ... return ScrollConfiguration( behavior: widget.scrollBehavior ?? const MaterialScrollBehavior(), child: HeroControllerScope( controller: _heroController, child: result, ), ); } 看下 _MaterialAppState 的 _buildWidgetApp 方法，可以发现它根据 _usesRouter 来选择不同的WidgetsApp构造方法进行创建WidgetsApp。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // _usesRouter表示是否使用Router，此处为true bool get _usesRouter =\u0026gt; widget.routerDelegate != null || widget.routerConfig != null; Widget _buildWidgetApp(BuildContext context) { ... if (_usesRouter) { // Router方式实现路由导航（声明式） return WidgetsApp.router( key: GlobalObjectKey (this), routeInformationProvider: widget.routeInformationProvider, routeInformationParser: widget.routeInformationParser, routerDelegate: widget.routerDelegate, routerConfig: widget.routerConfig, backButtonDispatcher: widget.backButtonDispatcher, ... ); } // 直接Navigator方式实现路由导航（命令式） return WidgetsApp( ... ); } 先看下 _WidgetsAppState 的initState方法。\n1 2 3 4 5 6 @override void initState() { super.initState(); _updateRouting(); ... } 看下 _WidgetsAppState 的 _updateRouting 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 String get _initialRouteName =\u0026gt; WidgetsBinding.instance.platformDispatcher.defaultRouteName != Navigator.defaultRouteName ? WidgetsBinding.instance.platformDispatcher.defaultRouteName : widget.initialRoute ?? WidgetsBinding.instance.platformDispatcher.defaultRouteName; // 此处_usesRouterWithDelegates为true bool get _usesRouterWithDelegates =\u0026gt; widget.routerDelegate != null; void _updateRouting({WidgetsApp? oldWidget}) { if (_usesRouterWithDelegates) { assert(!_usesNavigator \u0026amp;\u0026amp; !_usesRouterWithConfig); _clearNavigatorResource(); // 如果没有传入routeInformationProvider，那么创建一个默认的PlatformRouteInformationProvider if (widget.routeInformationProvider == null \u0026amp;\u0026amp; widget.routeInformationParser != null) { _defaultRouteInformationProvider ??= PlatformRouteInformationProvider( // 此处创建的RouteInformation会赋值给PlatformRouteInformationProvider中的_value initialRouteInformation: RouteInformation( // 设置初始路由_initialRouteName，一般为\u0026#39;/\u0026#39; uri: Uri.parse(_initialRouteName), ), ); } else { _defaultRouteInformationProvider?.dispose(); _defaultRouteInformationProvider = null; } // 如果没有传入backButtonDispatcher，那么创建一个默认的RootBackButtonDispatcher if (widget.backButtonDispatcher == null) { _defaultBackButtonDispatcher ??= RootBackButtonDispatcher(); } } else if (_usesNavigator) { ... } else { ... } ... } 再看下 _WidgetsAppState 的 build 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // 此处_usesRouterWithDelegates为true bool get _usesRouterWithDelegates =\u0026gt; widget.routerDelegate != null; bool get _usesRouterWithConfig =\u0026gt; widget.routerConfig != null; bool get _usesNavigator =\u0026gt; widget.home != null || (widget.routes?.isNotEmpty ?? false) || widget.onGenerateRoute != null || widget.onUnknownRoute != null; @override Widget build(BuildContext context) { Widget? routing; if (_usesRouterWithDelegates) { // Router方式实现路由导航（声明式） routing = Router\u0026lt;Object\u0026gt;( restorationScopeId: \u0026#39;router\u0026#39;, routeInformationProvider: _effectiveRouteInformationProvider, routeInformationParser: widget.routeInformationParser, routerDelegate: widget.routerDelegate!, backButtonDispatcher: _effectiveBackButtonDispatcher, ); } else if (_usesNavigator) { // 直接Navigator方式实现路由导航（命令式） assert(_navigator != null); routing = FocusScope( debugLabel: \u0026#39;Navigator Scope\u0026#39;, autofocus: true, child: Navigator( clipBehavior: Clip.none, restorationScopeId: \u0026#39;nav\u0026#39;, key: _navigator, initialRoute: _initialRouteName, onGenerateRoute: _onGenerateRoute, onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null ? Navigator.defaultGenerateInitialRoutes : (NavigatorState navigator, String initialRouteName) { return widget.onGenerateInitialRoutes!(initialRouteName); }, onUnknownRoute: _onUnknownRoute, observers: widget.navigatorObservers!, reportsRouteUpdateToEngine: true, ), ); } else if (_usesRouterWithConfig) { // 带config的Router方式实现路由导航（声明式） routing = Router\u0026lt;Object\u0026gt;.withConfig( restorationScopeId: \u0026#39;router\u0026#39;, config: widget.routerConfig!, ); } ... return RootRestorationScope( restorationId: widget.restorationScopeId, child: SharedAppData( child: Shortcuts( debugLabel: \u0026#39;\u0026lt;Default WidgetsApp Shortcuts\u0026gt;\u0026#39;, shortcuts: widget.shortcuts ?? WidgetsApp.defaultShortcuts, child: DefaultTextEditingShortcuts( child: Actions( ... child: FocusTraversalGroup( policy: ReadingOrderTraversalPolicy(), child: TapRegionSurface( child: ShortcutRegistrar( child: Localizations( locale: appLocale, delegates: _localizationsDelegates.toList(), // 最后将包装多层的routing，放到这里 child: title, ), ), ), ), ), ), ), ), ); } 上面已知道 _WidgetsAppState 的 build 方法中用到了Router，而Router是一个StatefulWidget，看下创建的 _RouterState 的initState方法。\n1 2 3 4 5 6 7 8 9 10 @override void initState() { super.initState(); // routeInformationProvider注册了监听，也就是routeInformationProvider内部执行notifyListeners方法时，_handleRouteInformationProviderNotification方法就会被回调 widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification); widget.backButtonDispatcher?.addCallback (_handleBackButtonDispatcherNotification); // routerDelegate注册了监听，也就是routerDelegate内部执行notifyListeners方法时，_handleRouterDelegateNotification方法就会被回调 widget.routerDelegate.addListener(_handleRouterDelegateNotification); } 再看下 _RouterState 的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @override Widget build(BuildContext context) { return UnmanagedRestorationScope( bucket: bucket, // _RouterScope是一个InheritedWidget，外部可以获取它的属性routerState，比如Route的navigate方法 child: _RouterScope( routeInformationProvider: widget.routeInformationProvider, backButtonDispatcher: widget.backButtonDispatcher, routeInformationParser: widget.routeInformationParser, routerDelegate: widget.routerDelegate, // 此处传入了routerState routerState: this, child: Builder( // Use a Builder so that the build method below will have a // BuildContext that contains the _RouterScope. This also prevents // dependencies look ups in routerDelegate from rebuilding Router // widget that may result in re-parsing the route information. // 此处调用的是routerDelegate的build方法，也就是说只要Router通过setState更新UI，routerDelegate的build方法就会被调用 builder: widget.routerDelegate.build, ), ), ); } 在上面实战中，Navigator定义在routerDelegate的build方法里。Navigator是一个StatefulWidget，看下它创建的 NavigatorState 的initState方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @override void initState() { super.initState(); assert(() { // 初始化时，如果pages为空，就会抛出异常 if (widget.pages != const \u0026lt;Page\u0026lt;dynamic\u0026gt;\u0026gt;[]) { // This navigator uses page API. if (widget.pages.isEmpty) { FlutterError.reportError( FlutterErrorDetails( exception: FlutterError( \u0026#39;The Navigator.pages must not be empty to use the \u0026#39; \u0026#39;Navigator.pages API\u0026#39;, ), library: \u0026#39;widget library\u0026#39;, stack: StackTrace.current, ), ); } else if (widget.onPopPage == null) { // 如果使用了pages，那么onPopPage也必须不为null，否则抛出异常 FlutterError.reportError( FlutterErrorDetails( exception: FlutterError( \u0026#39;The Navigator.onPopPage must be provided to use the \u0026#39; \u0026#39;Navigator.pages API\u0026#39;, ), library: \u0026#39;widget library\u0026#39;, stack: StackTrace.current, ), ); } } return true; }()); ... } 关于Navigator的更多细节，这里就不展开讲解了，可参考前言中提到的一文。\n5.3、根布局路由信息解析 当执行到 _RouterState 的didChangeDependencies方法，看下它的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @override void didChangeDependencies() { _routeParsePending = true; // 分析一 super.didChangeDependencies(); // super.didChangeDependencies可能已经解析了路由信息。如果didChangeDependencies是由状态恢复或首次构建触发的，则可能会发生这种情况。 // The super.didChangeDependencies may have parsed the route information. // This can happen if the didChangeDependencies is triggered by state // restoration or first build. // 分析二 if (widget.routeInformationProvider != null \u0026amp;\u0026amp; _routeParsePending) { _processRouteInformation(widget.routeInformationProvider!.value, () =\u0026gt; widget.routerDelegate.setNewRoutePath); } _routeParsePending = false; // 分析三 _maybeNeedToReportRouteInformation(); } 分析一：\n因为 _RouterState 混入了RestorationMixin，所以执行RestorationMixin的didChangeDependencies方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @override void didChangeDependencies() { super.didChangeDependencies(); final RestorationBucket? oldBucket = _bucket; final bool needsRestore = restorePending; _currentParent = RestorationScope.maybeOf(context); final bool didReplaceBucket = _updateBucketIfNecessary(parent: _currentParent, restorePending: needsRestore); // 执行这里 if (needsRestore) { _doRestore(oldBucket); } if (didReplaceBucket) { assert(oldBucket != _bucket); oldBucket?.dispose(); } } 看下RestorationMixin的 _doRestore 方法。\n1 2 3 4 5 6 void _doRestore(RestorationBucket? oldBucket) { ... restoreState(oldBucket, _firstRestorePending); _firstRestorePending = false; ... } 在RestorationMixin的 _doRestore 方法中，执行了restoreState方法，该方法由子类 _RouterState 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override void restoreState(RestorationBucket? oldBucket, bool initialRestore) { // 注册RestorableProperty以进行状态恢复 registerForRestoration(_routeInformation, \u0026#39;route\u0026#39;); // 此处_routeInformation.value为null if (_routeInformation.value != null) { assert(widget.routeInformationParser != null); _processRouteInformation(_routeInformation.value!, () =\u0026gt; widget.routerDelegate.setRestoredRoutePath); } else if (widget.routeInformationProvider != null) { // 执行这里，其中routeInformationProvider!.value已经在_WidgetsAppState的 _updateRouting方法中赋值了，后面则是routerDelegate的setInitialRoutePath方法 _processRouteInformation(widget.routeInformationProvider!.value, () =\u0026gt; widget.routerDelegate.setInitialRoutePath); } } 看下 _RouterState 的 _processRouteInformation 方法。\n1 2 3 4 5 6 7 8 9 10 11 void _processRouteInformation(RouteInformation information, ValueGetter\u0026lt;_RouteSetter\u0026lt;T\u0026gt;\u0026gt; delegateRouteSetter) { assert(_routeParsePending); // 此处_routeParsePending赋值为false，表示路由不需要延迟解析。 _routeParsePending = false; _currentRouterTransaction = Object(); // 执行routeInformationParser的parseRouteInformationWithDependencies方法， // 该方法返回一个Future，等到该Future执行完成，就会执行_processParsedRouteInformation方法 widget.routeInformationParser! .parseRouteInformationWithDependencies(information, context) .then\u0026lt;void\u0026gt;(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter)); } 看下RouteInformationParser的parseRouteInformationWithDependencies方法。\n1 2 3 Future\u0026lt;T\u0026gt; parseRouteInformationWithDependencies(RouteInformation routeInformation, BuildContext context) { return parseRouteInformation(routeInformation); } 在RouteInformationParser的parseRouteInformationWithDependencies方法中，执行了parseRouteInformation方法，该方法由子类CustomRouteInformationParser实现。\n至此，CustomRouteInformationParser的parseRouteInformation方法被触发，上面实战示例中返回了一个SynchronousFuture，表示同步等待结果。\n继续看下 _RouterState 的 _processParsedRouteInformation 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 此处delegateRouteSetter为routerDelegate的setInitialRoutePath方法 _RouteSetter\u0026lt;T\u0026gt; _processParsedRouteInformation(Object? transaction, ValueGetter\u0026lt;_RouteSetter\u0026lt;T\u0026gt;\u0026gt; delegateRouteSetter) { return (T data) async { if (_currentRouterTransaction != transaction) { return; } // 等待routerDelegate的setInitialRoutePath方法执行完成 await delegateRouteSetter()(data); if (_currentRouterTransaction == transaction) { // 执行这里 _rebuild(); } }; } 看下RouterDelegate的setInitialRoutePath方法。\n1 2 3 Future\u0026lt;void\u0026gt; setInitialRoutePath(T configuration) { return setNewRoutePath(configuration); } 在RouterDelegate的setInitialRoutePath方法中，执行了setNewRoutePath方法，该方法由子类CustomRouterDelegate实现。\n至此，CustomRouterDelegate的setNewRoutePath方法被触发，上面实战示例中返回了一个SynchronousFuture，表示同步等待结果。\n在上面实战示例中，CustomRouterDelegate的setNewRoutePath方法里执行了 _updatePages 方法，在 _updatePages 方法中又会执行notifyListeners方法。\n之前讲的 _RouterState 的initState中，routerDelegate添加了监听回调方法 _handleRouterDelegateNotification，此时就会执行该方法。\n1 2 3 4 5 void _handleRouterDelegateNotification() { // 此处触发Router的UI更新，那么CustomRouterDelegate的build方法也会更新 setState(() {/* routerDelegate wants to rebuild */}); _maybeNeedToReportRouteInformation(); } 在 _RouterState 的 _handleRouterDelegateNotification 方法中，执行了 _maybeNeedToReportRouteInformation 方法。\n1 2 3 4 5 6 void _maybeNeedToReportRouteInformation() { // 这里讲RouteInformation赋值给_routeInformation.value _routeInformation.value = _retrieveNewRouteInformation(); _currentIntentionToReport ??= RouteInformationReportingType.none; _scheduleRouteInformationReportingTask(); } 看下 _RouterState 的 _maybeNeedToReportRouteInformation 方法。\n1 2 3 4 5 6 7 8 9 RouteInformation? _retrieveNewRouteInformation() { // 执行了routerDelegate的currentConfiguration，获取当前配置 final T? configuration = widget.routerDelegate.currentConfiguration; if (configuration == null) { return null; } // 执行routeInformationParser的restoreRouteInformation方法，返回一个RouteInformation，这是第一次执行restoreRouteInformation方法 return widget.routeInformationParser?.restoreRouteInformation(configuration); } 等待routerDelegate的setInitialRoutePath方法执行完成，就会执行then之后的方法，也就是 _processParsedRouteInformation 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 _RouteSetter\u0026lt;T\u0026gt; _processParsedRouteInformation(Object? transaction, ValueGetter\u0026lt;_RouteSetter\u0026lt;T\u0026gt;\u0026gt; delegateRouteSetter) { return (T data) async { if (_currentRouterTransaction != transaction) { return; } await delegateRouteSetter()(data); if (_currentRouterTransaction == transaction) { // 执行这里 _rebuild(); } }; } 继续看下 _RouterState 的 _rebuild 方法。\n1 2 3 4 5 6 Future\u0026lt;void\u0026gt; _rebuild([void value]) { // 此处触发Router的UI更新，那么CustomRouterDelegate的build方法也会更新 setState(() {/* routerDelegate is ready to rebuild */}); _maybeNeedToReportRouteInformation(); return SynchronousFuture\u0026lt;void\u0026gt;(value); } 在 _RouterState 的 _maybeNeedToReportRouteInformation 方法中，接着又会执行routeInformationParser的restoreRouteInformation方法，这是第二次执行。\n分析二：\n回到 _RouterState 的didChangeDependencies方法，前面分析一super.didChangeDependencies中已经解析了路由信息，并且 _routeParsePending 被赋值为false，所以这里if条件不成立。\n1 2 3 if (widget.routeInformationProvider != null \u0026amp;\u0026amp; _routeParsePending) { _processRouteInformation(widget.routeInformationProvider!.value, () =\u0026gt; widget.routerDelegate.setNewRoutePath); } 分析三：\n回到 _RouterState 的didChangeDependencies方法，继续执行了 _RouterState 的 _maybeNeedToReportRouteInformation 方法，这与分析一中的逻辑一样，也就是说会再次执行routeInformationParser的restoreRouteInformation方法，这是第三次执行。\n5.4、Navigator中pages转化 当CustomRouterDelegate的build被触发后，因为此时pages发生了变化，所以Navigator会执行NavigatorState的didUpdateWidget方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @override void didUpdateWidget(Navigator oldWidget) { super.didUpdateWidget(oldWidget); ... if (oldWidget.pages != widget.pages \u0026amp;\u0026amp; !restorePending) { assert(() { if (widget.pages.isEmpty) { FlutterError.reportError( FlutterErrorDetails( exception: FlutterError( \u0026#39;The Navigator.pages must not be empty to use the \u0026#39; \u0026#39;Navigator.pages API\u0026#39;, ), library: \u0026#39;widget library\u0026#39;, stack: StackTrace.current, ), ); } return true; }()); _updatePages(); } // Route进行重建 for (final _RouteEntry entry in _history) { entry.route.changedExternalState(); } } 在NavigatorState的didUpdateWidget方法中，执行了 _updatePages 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 void _updatePages() { ... // 这尝试将新页面列表 (widget.pages) 与旧 _RouteEntry(s) 列表 (_history) 进行比较，并生成新的 _RouteEntry(s) 列表作为新的 _history 列表。 // 此方法大致遵循 RenderObjectElement.updateChildren 的相同轮廓。 // This attempts to diff the new pages list (widget.pages) with // the old _RouteEntry(s) list (_history), and produces a new list of // _RouteEntry(s) to be the new list of _history. This method roughly // follows the same outline of RenderObjectElement.updateChildren. // // 它尝试优化的情况是： // The cases it tries to optimize for are: // - 旧列表为空 // - 新列表中的所有页面都可以匹配旧列表中的基于页面的路由，并且它们的顺序相同。 // - 新列表中的所有页面都可以匹配旧列表中的基于页面的路由，并且它们的顺序相同。 // - the old list is empty // - All the pages in the new list can match the page-based routes in the old // list, and their orders are the same. // - there is an insertion or removal of one or more page-based route in // only one place in the list // 如果带有键的基于页面的路由同时存在于两个列表中，则它将同步。没有密钥的基于页面的路由可能会同步，但不能保证。 // If a page-based route with a key is in both lists, it will be synced. // Page-based routes without keys might be synced but there is no guarantee. // 一般的做法是向后同步整个新列表，如下所示： // The general approach is to sync the entire new list backwards, as follows: // 1. 从底部开始遍历列表，同步节点并记录无页路由，直到不再有匹配的节点。 // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes, // until you no longer have matching nodes. // 2. 从顶部开始遍历列表，不同步节点，直到不再有匹配的节点。我们将在最后同步这些节点。我们现在不同步它们，因为我们想要从头到尾按顺序同步所有节点。 // 2. Walk the lists from the top, without syncing nodes, until you no // longer have matching nodes. We\u0026#39;ll sync these nodes at the end. We // don\u0026#39;t sync them now because we want to sync all the nodes in order // from beginning to end. // 此时，我们将新旧列表缩小到节点不再匹配的程度。 // At this point we narrowed the old and new lists to the point // where the nodes no longer match. // 3. 遍历旧列表的缩小部分以获取键列表。 // 3. Walk the narrowed part of the old list to get the list of // keys. // 4. 向前移动新列表的缩小部分： // 4. Walk the narrowed part of the new list forwards: // * 为非键控项创建一个新的_RouteEntry，并为transitionDelegate记录它们。 // * Create a new _RouteEntry for non-keyed items and record them for // transitionDelegate. // * 将键控项与源同步（如果存在）。 // * Sync keyed items with the source if it exists. // 5. 再次遍历旧列表的缩小部分以记录需要为transitionDelegate删除的_RouteEntry（s）以及无页路由。 // 5. Walk the narrowed part of the old list again to records the // _RouteEntry(s), as well as pageless routes, needed to be removed for // transitionDelegate. // 5. 再次走到列表顶部，同步节点并记录无页路由。 // 5. Walk the top of the list again, syncing the nodes and recording // pageless routes. // 6. 使用transitionDelegate 明确决定 _RouteEntry(s) 如何在屏幕上过渡或过渡 // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s) // transition in or off the screens. // 7. 将无页路由填回新历史记录中。 // 7. Fill pageless routes back into the new history. bool needsExplicitDecision = false; int newPagesBottom = 0; int oldEntriesBottom = 0; int newPagesTop = widget.pages.length - 1; int oldEntriesTop = _history.length - 1; final List\u0026lt;_RouteEntry\u0026gt; newHistory = \u0026lt;_RouteEntry\u0026gt;[]; final Map\u0026lt;_RouteEntry?, List\u0026lt;_RouteEntry\u0026gt;\u0026gt; pageRouteToPagelessRoutes = \u0026lt;_RouteEntry?, List\u0026lt;_RouteEntry\u0026gt;\u0026gt;{}; // 更新列表底部。 // Updates the bottom of the list. _RouteEntry? previousOldPageRouteEntry; while (oldEntriesBottom \u0026lt;= oldEntriesTop) { final _RouteEntry oldEntry = _history[oldEntriesBottom]; assert(oldEntry.currentState != _RouteLifecycle.disposed); // 记录无页路由。最底部的无页路由将存储在 key = null 中。 // Records pageless route. The bottom most pageless routes will be // stored in key = null. if (!oldEntry.pageBased) { final List\u0026lt;_RouteEntry\u0026gt; pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent( previousOldPageRouteEntry, () =\u0026gt; \u0026lt;_RouteEntry\u0026gt;[], ); pagelessRoutes.add(oldEntry); oldEntriesBottom += 1; continue; } if (newPagesBottom \u0026gt; newPagesTop) { break; } final Page\u0026lt;dynamic\u0026gt; newPage = widget.pages[newPagesBottom]; if (!oldEntry.canUpdateFrom(newPage)) { break; } previousOldPageRouteEntry = oldEntry; oldEntry.route._updateSettings(newPage); newHistory.add(oldEntry); newPagesBottom += 1; oldEntriesBottom += 1; } final List\u0026lt;_RouteEntry\u0026gt; unattachedPagelessRoutes=\u0026lt;_RouteEntry\u0026gt;[]; // 扫描列表顶部，直到找到无法更新的基于页面的路由。 // Scans the top of the list until we found a page-based route that cannot be // updated. while ((oldEntriesBottom \u0026lt;= oldEntriesTop) \u0026amp;\u0026amp; (newPagesBottom \u0026lt;= newPagesTop)) { final _RouteEntry oldEntry = _history[oldEntriesTop]; assert(oldEntry.currentState != _RouteLifecycle.disposed); if (!oldEntry.pageBased) { unattachedPagelessRoutes.add(oldEntry); oldEntriesTop -= 1; continue; } final Page\u0026lt;dynamic\u0026gt; newPage = widget.pages[newPagesTop]; if (!oldEntry.canUpdateFrom(newPage)) { break; } // 我们找到了下面所有连续无页路由的页面。将这些无页路由附加到页面。 // We found the page for all the consecutive pageless routes below. Attach these // pageless routes to the page. if (unattachedPagelessRoutes.isNotEmpty) { pageRouteToPagelessRoutes.putIfAbsent( oldEntry, () =\u0026gt; List\u0026lt;_RouteEntry\u0026gt;.from(unattachedPagelessRoutes), ); unattachedPagelessRoutes.clear(); } oldEntriesTop -= 1; newPagesTop -= 1; } // 恢复无法更新的无页路由。 // Reverts the pageless routes that cannot be updated. oldEntriesTop += unattachedPagelessRoutes.length; // 扫描旧条目的中间并将页面密钥记录到旧条目映射。 // Scans middle of the old entries and records the page key to old entry map. int oldEntriesBottomToScan = oldEntriesBottom; final Map\u0026lt;LocalKey, _RouteEntry\u0026gt; pageKeyToOldEntry = \u0026lt;LocalKey, _RouteEntry\u0026gt;{}; // 该集合包含正在转出但仍在路由堆栈中的条目。 // This set contains entries that are transitioning out but are still in // the route stack. final Set\u0026lt;_RouteEntry\u0026gt; phantomEntries = \u0026lt;_RouteEntry\u0026gt;{}; while (oldEntriesBottomToScan \u0026lt;= oldEntriesTop) { final _RouteEntry oldEntry = _history[oldEntriesBottomToScan]; oldEntriesBottomToScan += 1; assert( oldEntry.currentState != _RouteLifecycle.disposed, ); // 当我们更新旧列表的中间部分时，将记录无页路由。 // Pageless routes will be recorded when we update the middle of the old // list. if (!oldEntry.pageBased) { continue; } final Page\u0026lt;dynamic\u0026gt; page = oldEntry.route.settings as Page\u0026lt;dynamic\u0026gt;; if (page.key == null) { continue; } if (!oldEntry.willBePresent) { phantomEntries.add(oldEntry); continue; } assert(!pageKeyToOldEntry.containsKey(page.key)); pageKeyToOldEntry[page.key!] = oldEntry; } // 更新列表的中间部分。 // Updates the middle of the list. while (newPagesBottom \u0026lt;= newPagesTop) { final Page\u0026lt;dynamic\u0026gt; nextPage = widget.pages[newPagesBottom]; newPagesBottom += 1; if ( nextPage.key == null || !pageKeyToOldEntry.containsKey(nextPage.key) || !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage) ) { // 旧历史记录中没有匹配的键，我们需要创建一个新路由并等待转换委托决定如何将其添加到历史记录中。 // There is no matching key in the old history, we need to create a new // route and wait for the transition delegate to decide how to add // it into the history. final _RouteEntry newEntry = _RouteEntry( nextPage.createRoute(context), pageBased: true, initialState: _RouteLifecycle.staging, ); needsExplicitDecision = true; assert( newEntry.route.settings == nextPage, \u0026#39;The settings getter of a page-based Route must return a Page object. \u0026#39; \u0026#39;Please set the settings to the Page in the Page.createRoute method.\u0026#39;, ); newHistory.add(newEntry); } else { // 从 pageKeyToOldEntry 中删除键以指示它已被占用。 // Removes the key from pageKeyToOldEntry to indicate it is taken. final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!; assert(matchingEntry.canUpdateFrom(nextPage)); matchingEntry.route._updateSettings(nextPage); newHistory.add(matchingEntry); } } // 任何剩余的不匹配的旧路由都需要被删除。 // Any remaining old routes that do not have a match will need to be removed. final Map\u0026lt;RouteTransitionRecord?, RouteTransitionRecord\u0026gt; locationToExitingPageRoute = \u0026lt;RouteTransitionRecord?, RouteTransitionRecord\u0026gt;{}; while (oldEntriesBottom \u0026lt;= oldEntriesTop) { final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom]; oldEntriesBottom += 1; if (!potentialEntryToRemove.pageBased) { assert(previousOldPageRouteEntry != null); final List\u0026lt;_RouteEntry\u0026gt; pagelessRoutes = pageRouteToPagelessRoutes .putIfAbsent( previousOldPageRouteEntry, () =\u0026gt; \u0026lt;_RouteEntry\u0026gt;[], ); pagelessRoutes.add(potentialEntryToRemove); if (previousOldPageRouteEntry!.isWaitingForExitingDecision \u0026amp;\u0026amp; potentialEntryToRemove.willBePresent) { potentialEntryToRemove.markNeedsExitingDecision(); } continue; } final Page\u0026lt;dynamic\u0026gt; potentialPageToRemove = potentialEntryToRemove.route.settings as Page\u0026lt;dynamic\u0026gt;; // 如果此旧页面没有密钥、在更新新页面的中间期间未获取或已过渡出去，则需要删除转换委托的标记。 // Marks for transition delegate to remove if this old page does not have // a key, was not taken during updating the middle of new page, or is // already transitioning out. if (potentialPageToRemove.key == null || pageKeyToOldEntry.containsKey(potentialPageToRemove.key) || phantomEntries.contains(potentialEntryToRemove)) { locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove; // 只有在尚未弹出的情况下我们才需要做出决定。 // We only need a decision if it has not already been popped. if (potentialEntryToRemove.willBePresent) { potentialEntryToRemove.markNeedsExitingDecision(); } } previousOldPageRouteEntry = potentialEntryToRemove; } // 我们已经扫描了整个列表。 // We\u0026#39;ve scanned the whole list. assert(oldEntriesBottom == oldEntriesTop + 1); assert(newPagesBottom == newPagesTop + 1); newPagesTop = widget.pages.length - 1; oldEntriesTop = _history.length - 1; // 验证我们是否到达底部或 oldEntriesBottom 必须可由 newPagesBottom 更新。 // Verifies we either reach the bottom or the oldEntriesBottom must be updatable // by newPagesBottom. assert(() { if (oldEntriesBottom \u0026lt;= oldEntriesTop) { return newPagesBottom \u0026lt;= newPagesTop \u0026amp;\u0026amp; _history[oldEntriesBottom].pageBased \u0026amp;\u0026amp; _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]); } else { return newPagesBottom \u0026gt; newPagesTop; } }()); // 更新列表顶部。 // Updates the top of the list. while ((oldEntriesBottom \u0026lt;= oldEntriesTop) \u0026amp;\u0026amp; (newPagesBottom \u0026lt;= newPagesTop)) { final _RouteEntry oldEntry = _history[oldEntriesBottom]; assert(oldEntry.currentState != _RouteLifecycle.disposed); if (!oldEntry.pageBased) { assert(previousOldPageRouteEntry != null); final List\u0026lt;_RouteEntry\u0026gt; pagelessRoutes = pageRouteToPagelessRoutes .putIfAbsent( previousOldPageRouteEntry, () =\u0026gt; \u0026lt;_RouteEntry\u0026gt;[], ); pagelessRoutes.add(oldEntry); continue; } previousOldPageRouteEntry = oldEntry; final Page\u0026lt;dynamic\u0026gt; newPage = widget.pages[newPagesBottom]; assert(oldEntry.canUpdateFrom(newPage)); oldEntry.route._updateSettings(newPage); newHistory.add(oldEntry); oldEntriesBottom += 1; newPagesBottom += 1; } // 最后，如果需要，使用转换委托做出明确的决定。 // Finally, uses transition delegate to make explicit decision if needed. needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty; Iterable\u0026lt;_RouteEntry\u0026gt; results = newHistory; if (needsExplicitDecision) { // 执行transitionDelegate的_transition方法，因为在实战示例中，没有在Navigator传入，所以默认是DefaultTransitionDelegate results = widget.transitionDelegate._transition( // 新路由 newPageRouteHistory: newHistory, // 即将退出的路由 locationToExitingPageRoute: locationToExitingPageRoute, // 无页路由 pageRouteToPagelessRoutes: pageRouteToPagelessRoutes, ).cast\u0026lt;_RouteEntry\u0026gt;(); } _history = \u0026lt;_RouteEntry\u0026gt;[]; // 添加主要的无页面路由（如果有）。 // Adds the leading pageless routes if there is any. if (pageRouteToPagelessRoutes.containsKey(null)) { _history.addAll(pageRouteToPagelessRoutes[null]!); } // 添加正常的有Page的路由 for (final _RouteEntry result in results) { _history.add(result); // 最后添加依附于当前路由result的无页路由 if (pageRouteToPagelessRoutes.containsKey(result)) { _history.addAll(pageRouteToPagelessRoutes[result]!); } } assert(() {_debugUpdatingPage = false; return true;}()); assert(() { _debugLocked = true; return true; }()); // 执行_history更新 _flushHistoryUpdates(); assert(() { _debugLocked = false; return true; }()); } 看下TransitionDelegate的 _transition 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Iterable\u0026lt;RouteTransitionRecord\u0026gt; _transition({ required List\u0026lt;RouteTransitionRecord\u0026gt; newPageRouteHistory, required Map\u0026lt;RouteTransitionRecord?, RouteTransitionRecord\u0026gt; locationToExitingPageRoute, required Map\u0026lt;RouteTransitionRecord?, List\u0026lt;RouteTransitionRecord\u0026gt;\u0026gt; pageRouteToPagelessRoutes, }) { final Iterable\u0026lt;RouteTransitionRecord\u0026gt; results = resolve( newPageRouteHistory: newPageRouteHistory, locationToExitingPageRoute: locationToExitingPageRoute, pageRouteToPagelessRoutes: pageRouteToPagelessRoutes, ); // 做出决定后验证其完整性。 // Verifies the integrity after the decisions have been made. // // 规则如下： // Here are the rules: // - newPageRouteHistory 中的所有进入路由都必须推送或添加。 // - All the entering routes in newPageRouteHistory must either be pushed or // added. // - locationToExitingPageRoute 中的所有现有路由必须弹出、完成或删除。 // - All the exiting routes in locationToExitingPageRoute must either be // popped, completed or removed. // - 属于现有路由的所有无页路由必须弹出、完成或删除。 // - All the pageless routes that belong to exiting routes must either be // popped, completed or removed. // - 结果中的所有进入路由必须与 newPageRouteHistory 中的进入路由保持相同的顺序，并且结果必须包含所有退出路由。 // - All the entering routes in the result must preserve the same order as // the entering routes in newPageRouteHistory, and the result must contain // all exiting routes. // 例如： // ex: // // newPageRouteHistory = [A, B, C] // // locationToExitingPageRoute = {A -\u0026gt; D, C -\u0026gt; E} // // results = [A, B ,C ,D ,E] is valid // results = [D, A, B ,C ,E] is also valid because exiting route can be // inserted in any place // // results = [B, A, C ,D ,E] is invalid because B must be after A. // results = [A, B, C ,E] is invalid because results must include D. ... return results; } 在TransitionDelegate的 _transition 方法中，执行了resolve方法，该方法由子类DefaultTransitionDelegate实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @override Iterable\u0026lt;RouteTransitionRecord\u0026gt; resolve({ required List\u0026lt;RouteTransitionRecord\u0026gt; newPageRouteHistory, required Map\u0026lt;RouteTransitionRecord?, RouteTransitionRecord\u0026gt; locationToExitingPageRoute, required Map\u0026lt;RouteTransitionRecord?, List\u0026lt;RouteTransitionRecord\u0026gt;\u0026gt; pageRouteToPagelessRoutes, }) { final List\u0026lt;RouteTransitionRecord\u0026gt; results = \u0026lt;RouteTransitionRecord\u0026gt;[]; // 此方法将处理该位置处的现有路由及其相应的无页路由。它还会递归地检查其上方是否有任何其他退出路由并相应地处理它们。 // This method will handle the exiting route and its corresponding pageless // route at this location. It will also recursively check if there is any // other exiting routes above it and handle them accordingly. void handleExitingRoute(RouteTransitionRecord? location, bool isLast) { final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location]; if (exitingPageRoute == null) { return; } if (exitingPageRoute.isWaitingForExitingDecision) { final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute); final bool isLastExitingPageRoute = isLast \u0026amp;\u0026amp; !locationToExitingPageRoute.containsKey(exitingPageRoute); if (isLastExitingPageRoute \u0026amp;\u0026amp; !hasPagelessRoute) { // 标记路由状态为pop exitingPageRoute.markForPop(exitingPageRoute.route.currentResult); } else { // 标记路由状态为complete exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult); } if (hasPagelessRoute) { final List\u0026lt;RouteTransitionRecord\u0026gt; pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute]!; for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) { // 属于现有基于页面的路由的无页面路由可能不需要退出决策。如果页面列表在 Navigator.pop 之后立即更新，则可能会发生这种情况。 // It is possible that a pageless route that belongs to an exiting // page-based route does not require exiting decision. This can // happen if the page list is updated right after a Navigator.pop. if (pagelessRoute.isWaitingForExitingDecision) { if (isLastExitingPageRoute \u0026amp;\u0026amp; pagelessRoute == pagelessRoutes.last) { pagelessRoute.markForPop(pagelessRoute.route.currentResult); } else { pagelessRoute.markForComplete(pagelessRoute.route.currentResult); } } } } } results.add(exitingPageRoute); // It is possible there is another exiting route above this exitingPageRoute. handleExitingRoute(exitingPageRoute, isLast); } // Handles exiting route in the beginning of list. handleExitingRoute(null, newPageRouteHistory.isEmpty); for (final RouteTransitionRecord pageRoute in newPageRouteHistory) { final bool isLastIteration = newPageRouteHistory.last == pageRoute; if (pageRoute.isWaitingForEnteringDecision) { if (!locationToExitingPageRoute.containsKey(pageRoute) \u0026amp;\u0026amp; isLastIteration) { // 标记路由状态为push pageRoute.markForPush(); } else { // 标记路由状态为add pageRoute.markForAdd(); } } results.add(pageRoute); handleExitingRoute(pageRoute, isLastIteration); } return results; } 5.5、pushNamed执行逻辑 在本实战示例中，执行NavigatorHelper的pushNamed方法后，就会触发在CustomRouterDelegate构造方法中注册的registerOnJumpListener回调方法。\n在该回调中执行了 _updatePages 方法，那么就会更新pages，同时内部也调用了notifyListeners方法。\n前面讲过，routerDelegate添加了监听回调方法 _handleRouterDelegateNotification，此时就会执行该方法。\n首先执行setState方法更新UI，最后，又执行了routeInformationParser的restoreRouteInformation方法。\n5.6、pop执行逻辑 当点击标题栏中返回按钮时，就会触发CustomRouterDelegate的 _onPopPage 方法，那么又会触发 _updatePages 方法，之后的逻辑与前面一致。\n六、参考文献 Flutter Navigator 2.0 全面解析 ","date":"2023-11-26T09:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bnavigator%E5%A3%B0%E6%98%8E%E5%BC%8F/","section":"post","tags":null,"title":"解读Flutter源码之Navigator（声明式）"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、什么是Navigator？ 先来看下Navigator的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 /// 一个使用堆栈规则管理一组子widgets的widget /// A c that manages a set of child widgets with a stack discipline. /// /// 许多应用程序在其widget层次结构顶部附近都有一个navigator，以便使用 [Overlay] 显示其逻辑历史记录，并将最近访问的页面直观地显示在旧页面的顶部。 /// 使用此模式可以让navigator通过在overlay中移动widgets来直观地从一个页面过渡到另一页面。 /// 同样，navigator可用于通过将对话框widget放置在当前页面上方来显示对话框。 /// Many apps have a navigator near the top of their widget hierarchy in order /// to display their logical history using an [Overlay] with the most recently /// visited pages visually on top of the older pages. Using this pattern lets /// the navigator visually transition from one page to another by moving the widgets /// around in the overlay. Similarly, the navigator can be used to show a dialog /// by positioning the dialog widget above the current page. /// /// ## 使用Pages API /// ## Using the Pages API /// /// 如果提供的话，[Navigator] 会将其 [Navigator.pages] 转换为一堆 [Route]。 /// [Navigator.pages] 中的更改将触发 [Route] 堆栈的更新 /// [Navigator] 将更新其routes以匹配其 [Navigator.pages] 的新配置。 /// 要使用此 API，可以创建一个 [Page] 子类并为 [Navigator.pages] 定义一系列 [Page]。 /// 还需要 [Navigator.onPopPage] 回调来在弹出时正确清理输入页面。 /// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s /// if it is provided. A change in [Navigator.pages] will trigger an update to /// the stack of [Route]s. The [Navigator] will update its routes to match the /// new configuration of its [Navigator.pages]. To use this API, one can create /// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A /// [Navigator.onPopPage] callback is also required to properly clean up the /// input pages in case of a pop. /// /// 默认情况下，[Navigator] 将使用 [DefaultTransitionDelegate] 来决定routes如何转入或转出屏幕。 /// 要自定义它，请定义 [TransitionDelegate] 子类并将其提供给 [Navigator.transitionDelegate]。 /// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide /// how routes transition in or out of the screen. To customize it, define a /// [TransitionDelegate] subclass and provide it to the /// [Navigator.transitionDelegate]. /// /// 有关使用pages API 的更多信息，请参阅 [Router] widget. /// For more information on using the pages API, see the [Router] widget. /// /// ## 使用Navigator API /// ## Using the Navigator API /// /// 移动应用程序通常通过称为“屏幕”或“页面”的全屏元素显示其内容。 /// 在 Flutter 中，这些元素称为routes，它们由 [Navigator] widget管理。 /// 导航器管理 [Route] 对象的堆栈，并提供两种管理堆栈的方式，声明式 API [Navigator.pages] 或命令式 API [Navigator.push] 和 [Navigator.pop]。 /// Mobile apps typically reveal their contents via full-screen elements /// called \u0026#34;screens\u0026#34; or \u0026#34;pages\u0026#34;. In Flutter these elements are called /// routes and they\u0026#39;re managed by a [Navigator] widget. The navigator /// manages a stack of [Route] objects and provides two ways for managing /// the stack, the declarative API [Navigator.pages] or imperative API /// [Navigator.push] and [Navigator.pop]. /// /// 当您的用户界面适合这种堆栈范例时，用户应该能够_导航_回到堆栈中较早的元素，那么使用routes和Navigator是合适的。 /// 在某些平台（例如 Android）上，系统 UI 将提供后退按钮（在应用程序范围之外），允许用户导航回应用程序堆栈中较早的routes。 /// 在没有这种内置导航机制的平台上，使用 [AppBar]（通常在 [Scaffold.appBar] 属性中使用）可以自动添加用于用户导航的后退按钮。 /// When your user interface fits this paradigm of a stack, where the user /// should be able to _navigate_ back to an earlier element in the stack, /// the use of routes and the Navigator is appropriate. On certain platforms, /// such as Android, the system UI will provide a back button (outside the /// bounds of your application) that will allow the user to navigate back /// to earlier routes in your application\u0026#39;s stack. On platforms that don\u0026#39;t /// have this build-in navigation mechanism, the use of an [AppBar] (typically /// used in the [Scaffold.appBar] property) can automatically add a back /// button for user navigation. /// /// ### 全屏显示route /// ### Displaying a full-screen route /// /// 虽然您可以直接创建导航器，但最常见的是使用“Router”创建的导航器，它本身是由 [WidgetsApp] 或 [MaterialApp] widget创建和配置的。您可以使用 [Navigator.of] 引用该导航器。 /// Although you can create a navigator directly, it\u0026#39;s most common to use the /// navigator created by the `Router` which itself is created and configured by /// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator /// with [Navigator.of]. /// /// [MaterialApp] 是最简单的设置方法。 [MaterialApp] 的home成为 [Navigator] 堆栈底部的route。这是您在启动应用程序时看到的内容。 /// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]\u0026#39;s /// home becomes the route at the bottom of the [Navigator]\u0026#39;s stack. It is what /// you see when the app is launched. /// /// ```dart /// void main() { /// runApp(const MaterialApp(home: MyAppHome())); /// } /// ``` /// /// 要将新route推送到堆栈上，您可以使用builder函数创建 [MaterialPageRoute] 的实例，该builder函数可以创建您想要在屏幕上显示的任何内容。例如： /// To push a new route on the stack you can create an instance of /// [MaterialPageRoute] with a builder function that creates whatever you /// want to appear on the screen. For example: /// /// ```dart /// Navigator.push(context, MaterialPageRoute\u0026lt;void\u0026gt;( /// builder: (BuildContext context) { /// return Scaffold( /// appBar: AppBar(title: const Text(\u0026#39;My Page\u0026#39;)), /// body: Center( /// child: TextButton( /// child: const Text(\u0026#39;POP\u0026#39;), /// onPressed: () { /// Navigator.pop(context); /// }, /// ), /// ), /// ); /// }, /// )); /// ``` /// /// 该route使用builder函数而不是子widget定义其widget，因为它将根据推送和弹出的时间在不同的上下文中构建和重建。 /// The route defines its widget with a builder function instead of a /// child widget because it will be built and rebuilt in different /// contexts depending on when it\u0026#39;s pushed and popped. /// /// 如您所见，可以使用 Navigator 的 pop 方法弹出新路线，显示应用程序的主页： /// As you can see, the new route can be popped, revealing the app\u0026#39;s home /// page, with the Navigator\u0026#39;s pop method: /// /// ```dart /// Navigator.pop(context); /// ``` /// /// 通常不需要提供一个使用 [Scaffold] 在路径中弹出Navigator的widget，因为 Scaffold 会自动向其 AppBar 添加“后退”按钮。 /// 按后退按钮会调用 [Navigator.pop]。在 Android 上，按系统后退按钮会执行相同的操作。 /// It usually isn\u0026#39;t necessary to provide a widget that pops the Navigator /// in a route with a [Scaffold] because the Scaffold automatically adds a /// \u0026#39;back\u0026#39; button to its AppBar. Pressing the back button causes /// [Navigator.pop] to be called. On Android, pressing the system back /// button does the same thing. /// /// ### 使用命名路由 /// ### Using named navigator routes /// /// 移动应用程序通常管理大量routes，并且通常最容易通过名称引用它们。 /// 按照惯例，route名称使用类似路径的结构（例如“/a/b/c”）。应用程序的主页route默认命名为“/”。 /// Mobile apps often manage a large number of routes and it\u0026#39;s often /// easiest to refer to them by name. Route names, by convention, /// use a path-like structure (for example, \u0026#39;/a/b/c\u0026#39;). /// The app\u0026#39;s home page route is named \u0026#39;/\u0026#39; by default. /// /// [MaterialApp] 可以使用 [Map\u0026lt;String, WidgetBuilder\u0026gt;] 创建，它将route的名称map到将创建它的builder函数。 /// [MaterialApp] 使用此map为其导航器的 [onGenerateRoute] 回调创建一个值。 /// The [MaterialApp] can be created /// with a [Map\u0026lt;String, WidgetBuilder\u0026gt;] which maps from a route\u0026#39;s name to /// a builder function that will create it. The [MaterialApp] uses this /// map to create a value for its navigator\u0026#39;s [onGenerateRoute] callback. /// /// ```dart /// void main() { /// runApp(MaterialApp( /// home: const MyAppHome(), // becomes the route named \u0026#39;/\u0026#39; /// routes: \u0026lt;String, WidgetBuilder\u0026gt; { /// \u0026#39;/a\u0026#39;: (BuildContext context) =\u0026gt; const MyPage(title: Text(\u0026#39;page A\u0026#39;)), /// \u0026#39;/b\u0026#39;: (BuildContext context) =\u0026gt; const MyPage(title: Text(\u0026#39;page B\u0026#39;)), /// \u0026#39;/c\u0026#39;: (BuildContext context) =\u0026gt; const MyPage(title: Text(\u0026#39;page C\u0026#39;)), /// }, /// )); /// } /// ``` /// /// 要按名称显示route： /// To show a route by name: /// /// ```dart /// Navigator.pushNamed(context, \u0026#39;/b\u0026#39;); /// ``` /// /// ### route可以返回一个值 /// ### Routes can return a value /// /// 当推送route向用户询问值时，可以通过 [pop] 方法的结果参数返回该值。 /// When a route is pushed to ask the user for a value, the value can be /// returned via the [pop] method\u0026#39;s result parameter. /// /// 推送route的方法返回 [Future]。当弹出路由时，Future会解析，并且 [Future] 的值是 [pop] 方法的“result”参数。 /// Methods that push a route return a [Future]. The Future resolves when the /// route is popped and the [Future]\u0026#39;s value is the [pop] method\u0026#39;s `result` /// parameter. /// /// 例如，如果我们想要求用户按“确定”来确认操作，我们可以“等待”[Navigator.push]的结果： /// For example if we wanted to ask the user to press \u0026#39;OK\u0026#39; to confirm an /// operation we could `await` the result of [Navigator.push]: /// /// ```dart /// bool? value = await Navigator.push(context, MaterialPageRoute\u0026lt;bool\u0026gt;( /// builder: (BuildContext context) { /// return Center( /// child: GestureDetector( /// child: const Text(\u0026#39;OK\u0026#39;), /// onTap: () { Navigator.pop(context, true); } /// ), /// ); /// } /// )); /// ``` /// /// 如果用户按“确定”，则值将为 true。如果用户退出路线，例如按 Scaffold 的后退按钮，则该值将为 null。 /// If the user presses \u0026#39;OK\u0026#39; then value will be true. If the user backs /// out of the route, for example by pressing the Scaffold\u0026#39;s back button, /// the value will be null. /// /// 当route用于返回值时，route的类型参数必须与[pop]结果的类型匹配。 /// 这就是为什么我们使用 `MaterialPageRoute\u0026lt;bool\u0026gt;` 而不是 `MaterialPageRoute\u0026lt;void\u0026gt;` 或只是 `MaterialPageRoute`。 （不过，如果您不想指定类型，也没关系。） /// When a route is used to return a value, the route\u0026#39;s type parameter must /// match the type of [pop]\u0026#39;s result. That\u0026#39;s why we\u0026#39;ve used /// `MaterialPageRoute\u0026lt;bool\u0026gt;` instead of `MaterialPageRoute\u0026lt;void\u0026gt;` or just /// `MaterialPageRoute`. (If you prefer to not specify the types, though, that\u0026#39;s /// fine too.) /// /// ### Popup路由 /// ### Popup routes /// /// Routes不必遮盖整个屏幕。 [PopupRoute] 使用 [ModalRoute.barrierColor] 覆盖屏幕，该颜色只能部分不透明，以允许当前屏幕显示出来。 /// 弹出路由是“模态的”，因为它们阻止对下面的小部件的输入。 /// Routes don\u0026#39;t have to obscure the entire screen. [PopupRoute]s cover the /// screen with a [ModalRoute.barrierColor] that can be only partially opaque to /// allow the current screen to show through. Popup routes are \u0026#34;modal\u0026#34; because /// they block input to the widgets below. /// /// 有一些功能可以创建和显示popup路由。例如：[showDialog]、[showMenu] 和 [showModalBottomSheet]。 /// 这些函数返回其推送路线的 Future，如上所述。 /// 调用者可以等待返回值，以便在弹出路由时采取操作，或者发现路由的值。 /// There are functions which create and show popup routes. For /// example: [showDialog], [showMenu], and [showModalBottomSheet]. These /// functions return their pushed route\u0026#39;s Future as described above. /// Callers can await the returned value to take an action when the /// route is popped, or to discover the route\u0026#39;s value. /// /// 还有一些创建popup路由的widgets，例如 [PopupMenuButton] 和 [DropdownButton]。 /// 这些widgets创建 PopupRoute 的内部子类，并使用导航器的推送和弹出方法来显示和关闭它们。 /// There are also widgets which create popup routes, like [PopupMenuButton] and /// [DropdownButton]. These widgets create internal subclasses of PopupRoute /// and use the Navigator\u0026#39;s push and pop methods to show and dismiss them. /// /// ### 自定义路由 /// ### Custom routes /// /// 您可以创建自己的widget库路由类之一的子类，例如 [PopupRoute]、[ModalRoute] 或 [PageRoute]，以控制用于显示路由的动画过渡、路由模态屏障的颜色和行为，以及route的其它方面。 /// You can create your own subclass of one of the widget library route classes /// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated /// transition employed to show the route, the color and behavior of the route\u0026#39;s /// modal barrier, and other aspects of the route. /// /// [PageRouteBuilder] 类可以根据回调定义自定义路由。 /// 下面是一个示例，当route出现或消失时，其子级会旋转和淡出。 /// 该route不会遮挡整个屏幕，因为它指定了“opaque: false”，就像popup路由一样。 /// The [PageRouteBuilder] class makes it possible to define a custom route /// in terms of callbacks. Here\u0026#39;s an example that rotates and fades its child /// when the route appears or disappears. This route does not obscure the entire /// screen because it specifies `opaque: false`, just as a popup route does. /// /// ```dart /// Navigator.push(context, PageRouteBuilder\u0026lt;void\u0026gt;( /// opaque: false, /// pageBuilder: (BuildContext context, _, __) { /// return const Center(child: Text(\u0026#39;My PageRoute\u0026#39;)); /// }, /// transitionsBuilder: (___, Animation\u0026lt;double\u0026gt; animation, ____, Widget child) { /// return FadeTransition( /// opacity: animation, /// child: RotationTransition( /// turns: Tween\u0026lt;double\u0026gt;(begin: 0.5, end: 1.0).animate(animation), /// child: child, /// ), /// ); /// } /// )); /// ``` /// /// 页面路由由两部分组成：“页面”和“转换”。 /// 该页面成为传递给“transitionsBuilder”函数的子级的后代。 /// 通常，页面仅构建一次，因为它不依赖于其动画参数（在本例中用“_”和“__”省略）。过渡是在其持续时间内的每一帧上构建的。 /// The page route is built in two parts, the \u0026#34;page\u0026#34; and the /// \u0026#34;transitions\u0026#34;. The page becomes a descendant of the child passed to /// the `transitionsBuilder` function. Typically the page is only built once, /// because it doesn\u0026#39;t depend on its animation parameters (elided with `_` /// and `__` in this example). The transition is built on every frame /// for its duration. /// /// 在此示例中，“void”用作路由的返回类型，因为它不返回值。 /// (In this example, `void` is used as the return type for the route, because /// it does not return a value.) /// /// ### 嵌套导航 /// ### Nesting Navigators /// /// 一个应用程序可以使用多个[Navigator]。将一个 [Navigator] 嵌套在另一个 [Navigator] 之下可用于创建“内部旅程”，例如选项卡式导航、用户注册、商店结帐或代表整个应用程序的一部分的其他独立旅程。 /// An app can use more than one [Navigator]. Nesting one [Navigator] below /// another [Navigator] can be used to create an \u0026#34;inner journey\u0026#34; such as tabbed /// navigation, user registration, store checkout, or other independent journeys /// that represent a subsection of your overall application. /// /// #### 示例 /// #### Example /// /// iOS应用程序的标准做法是使用选项卡式导航，其中每个选项卡都维护自己的导航历史记录。因此，每个选项卡都有自己的[Navigator]，创建了一种“并行导航”。 /// It is standard practice for iOS apps to use tabbed navigation where each /// tab maintains its own navigation history. Therefore, each tab has its own /// [Navigator], creating a kind of \u0026#34;parallel navigation.\u0026#34; /// /// 除了选项卡的并行导航之外，仍然可以启动完全覆盖选项卡的全屏页面。例如：入门流程或警报对话框。 /// 因此，必须存在一个位于选项卡导航上方的“根”[Navigator]。因此，每个选项卡的 [Navigator] 实际上都是嵌套的 [Navigator]，位于单个根 [Navigator] 的下方。 /// In addition to the parallel navigation of the tabs, it is still possible to /// launch full-screen pages that completely cover the tabs. For example: an /// on-boarding flow, or an alert dialog. Therefore, there must exist a \u0026#34;root\u0026#34; /// [Navigator] that sits above the tab navigation. As a result, each of the /// tab\u0026#39;s [Navigator]s are actually nested [Navigator]s sitting below a single /// root [Navigator]. /// /// 实际上，用于选项卡式导航的嵌套 [Navigator] 位于 [WidgetsApp] 和 [CupertinoTabView] widgets中，不需要显式创建或管理。 /// In practice, the nested [Navigator]s for tabbed navigation sit in the /// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly /// created or managed. /// /// {@tool sample} /// 以下示例演示了如何使用嵌套的 [Navigator] 来呈现独立的用户注册过程。 /// The following example demonstrates how a nested [Navigator] can be used to /// present a standalone user registration journey. /// /// 尽管此示例使用两个 [Navigator] 来演示嵌套的 [Navigator]，但仅使用单个 [Navigator] 也可能获得类似的结果。 /// Even though this example uses two [Navigator]s to demonstrate nested /// [Navigator]s, a similar result is possible using only a single [Navigator]. /// /// 使用“flutter run --route=/signup”运行此示例，以通过注册流程而不是在主页上启动它。 /// Run this example with `flutter run --route=/signup` to start it with /// the signup flow instead of on the home page. /// /// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart ** /// {@end-tool} /// /// [Navigator.of] 对给定 [BuildContext] 最近的祖先 [Navigator] 进行操作。 /// 请务必在预期的 [Navigator] 下方提供 [BuildContext]，尤其是在创建嵌套 [Navigator] 的大型“构建”方法中。 /// [Builder] widget可用于访问widget子树中所需位置的 [BuildContext]。 /// [Navigator.of] operates on the nearest ancestor [Navigator] from the given /// [BuildContext]. Be sure to provide a [BuildContext] below the intended /// [Navigator], especially in large `build` methods where nested [Navigator]s /// are created. The [Builder] widget can be used to access a [BuildContext] at /// a desired location in the widget subtree. /// /// ### 寻找封闭route /// ### Finding the enclosing route /// /// 在模态路由的常见情况下，可以使用 [ModalRoute.of] 从构建方法内部获取封闭路由。 /// 要确定封闭路由是否是活动路由（例如，以便在路由不活动时控件可以变暗），可以在返回的路由上检查 [Route.isCurrent] 属性。 /// In the common case of a modal route, the enclosing route can be obtained /// from inside a build method using [ModalRoute.of]. To determine if the /// enclosing route is the active route (e.g. so that controls can be dimmed /// when the route is not active), the [Route.isCurrent] property can be checked /// on the returned route. /// /// ## 状态恢复 /// ## State Restoration /// /// 如果提供了 [restorationScopeId] 并且当被有效的 [RestorationScope] 包围时，[Navigator] 将通过在状态恢复期间重新创建 [Route] 的当前历史堆栈以及恢复这些 [Route] 的内部状态来恢复其状态。然而，并不是堆栈上的所有[Route]都可以恢复： /// If provided with a [restorationScopeId] and when surrounded by a valid /// [RestorationScope] the [Navigator] will restore its state by recreating /// the current history stack of [Route]s during state restoration and by /// restoring the internal state of those [Route]s. However, not all [Route]s /// on the stack can be restored: /// /// * 如果提供了 [Page.restorationId]，基于 [Page] 的路由将恢复其状态。 /// * [Page]-based routes restore their state if [Page.restorationId] is /// provided. /// * 使用经典命令式 API（[push]、[pushNamed] 等）添加的 [Route] 永远无法恢复其状态。 /// * [Route]s added with the classic imperative API ([push], [pushNamed], and /// friends) can never restore their state. /// * 添加了可恢复命令式 API（[restorablePush]、[restorablePushNamed] 以及名称中带有“restorable”的所有其他命令式方法）的 [Route] 将恢复其状态，如果它下面的所有路由一直到并包括第一个 [Page]-其下方的基本路线已恢复。如果它下面没有基于 [Page] 的路由，则只有当它下面的所有路由都恢复其状态时，它才会恢复其状态。 /// * A [Route] added with the restorable imperative API ([restorablePush], /// [restorablePushNamed], and all other imperative methods with \u0026#34;restorable\u0026#34; /// in their name) restores its state if all routes below it up to and /// including the first [Page]-based route below it are restored. If there /// is no [Page]-based route below it, it only restores its state if all /// routes below it restore theirs. /// /// 如果 [Route] 被视为可恢复，[Navigator] 会将其 [Route.restorationScopeId] 设置为非空值。路由可以使用该 ID 来存储和恢复自己的状态。 /// 例如，[ModalRoute] 将使用此 ID 为其内容widgets创建 [RestorationScope]。 /// If a [Route] is deemed restorable, the [Navigator] will set its /// [Route.restorationScopeId] to a non-null value. Routes can use that ID to /// store and restore their own state. As an example, the [ModalRoute] will /// use this ID to create a [RestorationScope] for its content widgets. 由上面注释可以总结一下Navigator的特性：\n1、Navigator是一个使用堆栈规则管理一组子Widgets的Widget\n2、Navigator通过在Overlay中移动Widgets来直观地从一个页面过渡到另一页面\n3、移动App通常通过称为“屏幕”或“页面”的全屏元素显示其内容，而在Flutter中，这些元素称为Routes，它们由Navigator管理\n4、Navigator管理Route对象的堆栈，并提供两种管理堆栈的方式，声明式APINavigator.pages或命令式APINavigator.push和Navigator.pop，本文所讲的是命令式API\n5、对于声明式API，Navigator会将其Navigator.pages转换为一堆Route。Navigator.pages中的更改将触发Route堆栈的更新；同理，Navigator将更新其Routes以匹配其Navigator.pages的新配置\n6、WidgetsApp或MaterialApp底层已创建和配置Navigator，MaterialApp的home成为Navigator堆栈底部的Route，然后可以使用Navigator.of引用该Navigator\n7、默认情况下，Navigator将使用DefaultTransitionDelegate来决定Routes如何转入或转出屏幕。要自定义它，请定义TransitionDelegate子类并将其提供给Navigator.transitionDelegate\n8、移动App通常管理大量Routes，并且通常最容易通过名称引用它们。按照惯例，Route名称使用类似路径的结构（例如“/a/b/c”）。应用程序的主页Route默认命名为“/”。\n这里给出了Navigator的部分特性，主要是想让大家对Navigator有一个初级认知。\n二、Navigator的相关方法 2.1、路由跳转方法 对于路由跳转方法，它有两种方式：\n组件路由跳转：想要跳转到哪个Page，那么直接将Page当作参数传递进去就可以了。 注意：不建议组件路由跳转与命名路由跳转进行混用，对于组件路由跳转来说，它没有路由名称，在使用pushAndRemoveUntil或pushNamedAndRemoveUntil方法时会因为无法找到ModalRoute.withName配置的路由名称而导致不能实现预期效果。\n命名路由跳转：先将Page注册到路由表内并起一个名字，然后其它页面通过这个名字进行跳转。 官方建议：对于大多数应用程序，我们不建议使用命名路由。虽然命名路由可以处理深层链接，但其行为始终相同，无法定制。当平台收到新的深度链接时，Flutter将新的Route推到Navigator上，而不管用户当前在哪里。对于应用程序使用命名路由Flutter也是不支持浏览器的前进按钮，出于这些原因，我们不建议在大多数应用程序中使用命名路由。具有高级导航和路由要求的Flutter应用应该使用一个路由包，如go_router，它可以解析路由路径并在应用程序收到新的深度链接时配置Navigator。因为像go_router这样的包是声明性的，所以当接收到深度链接时，它们将始终显示相同的屏幕。\nOK，接下来开始分析路由跳转方法。\n2.1.1、push/pushNamed方法 方法描述：在栈顶入栈一个新的路由\npush方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C push D\n3、当前路由栈中的路由顺序变为A-\u0026gt;B-\u0026gt;C-\u0026gt;D\n2.1.2、pushReplacement/pushReplacementNamed方法 方法描述：将当前栈顶路由替换为一个新的路由\npushReplacement方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C pushReplacement D\n3、当前路由栈中的路由顺序变为A-\u0026gt;B-\u0026gt;D\n2.1.3、pushAndRemoveUntil/pushNamedAndRemoveUntil方法 方法描述：在栈顶入栈一个新的路由，然后删除所有先前的路由，直到predicate返回true。\n这里分为两种情况：\n如果要删除推送路由下面的所有路由，请使用始终返回false的RoutePredicate （例如(Route\u0026lt;dynamic\u0026gt; route) =\u0026gt; false），pushAndRemoveUntil方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C pushAndRemoveUntil D\n3、当前路由栈中的路由顺序变为D，此时D成为根路由\n如果要删除路由直到具有特定名称的路由，请使用从ModalRoute.withName返回的RoutePredicate（例如ModalRoute.withName('/')），pushAndRemoveUntil方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C pushAndRemoveUntil D\n3、当前路由栈中的路由顺序变为A-\u0026gt;D\n2.2、路由出栈方法 2.2.1、pop方法 方法描述：将栈顶路由出栈\npop方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C pop\n3、当前路由栈中的路由顺序变为A-\u0026gt;B\n2.2.2、popUntil方法 方法描述：将栈顶路由逐个出栈，直到predicate返回true。\n要弹出具有特定名称的路由，请使用从ModalRoute.withName返回的RoutePredicate（例如ModalRoute.withName('/')），popUntil方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C popUntil\n3、当前路由栈中的路由顺序变为A\n2.2.3、popAndPushNamed方法 方法描述：将栈顶路由出栈，然后在栈顶入栈一个新的路由，弹出和推送的动画是同时执行的，即使旧Route和新Route都是不透明的，下面的Route也可能会短暂可见\npopAndPushNamed方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C popAndPushNamed D\n3、当前路由栈中的路由顺序变为A-\u0026gt;B-\u0026gt;D\n2.2.4、canPop方法 方法描述：判断当前路由是否可以出栈，如果栈内只有当前路由，返回false，如果当前路由前面还有路由，返回true\n2.2.5、maybePop方法 方法描述：当前路由如能出栈就出栈，如果不能就什么都不做。\n2.3、路由删除方法 2.3.1、removeRoute方法 方法描述：删除Route，然后Route.dispose它。此方法调用不会运行任何动画。给定的Route必须在历史记录中；如果不是，此方法将抛出异常。使用场景例如：此方法用于立即关闭屏幕方向更改时出现的下拉菜单。\nremoveRoute方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C removeRoute B\n3、当前路由栈中的路由顺序变为A-\u0026gt;C\n2.3.2、removeRouteBelow方法 方法描述：删除Route，然后Route.dispose它。要删除的Route是给定的anchorRoute下面的Route。此方法调用不会运行任何动画。给定的anchorRoute必须在历史记录中，并且下面必须有一条Route；如果不是或者没有，这个方法会抛出异常\nremoveRouteBelow方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从C removeRouteBelow B\n3、当前路由栈中的路由顺序变为B-\u0026gt;C\n2.4、路由替换方法 2.4.1、replace方法 方法描述：用一个新的Route，将路由表内的一个已存在的Route替换掉。旧Route当前不得可见，因为此方法会跳过动画，因此如果旧Route可见，则删除会很不和谐。要替换最顶层的路由，请考虑使用pushReplacement，它会为新路由设置动画，并延迟删除旧路由，直到新路由完成动画处理。\nreplace方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从B replace newB\n3、当前路由栈中的路由顺序变为A-\u0026gt;newB-\u0026gt;C\n2.4.2、replaceRouteBelow方法 方法描述：用一个新的Route，将路由表内的一个已存在的anchorRoute的前面的Route给替换掉。旧Route当前不得可见，因为此方法会跳过动画，因此如果旧Route可见，则删除会很不和谐。要替换最顶层的路由，请考虑使用pushReplacement，它会为新路由设置动画，并延迟删除旧路由，直到新路由完成动画处理。\nreplaceRouteBelow方法执行后，路由栈的变化情况：\n1、当前路由栈中的路由顺序为A-\u0026gt;B-\u0026gt;C（由下往上）\n2、从B replaceRouteBelow newB\n3、当前路由栈中的路由顺序变为newB-\u0026gt;B-\u0026gt;C\n2.5、其它方法 2.5.1、of方法 方法描述：获取给定上下文的此类的最近实例的NavigatorState。如果rootNavigator设置为 true，则给出距此类最远实例的NavigatorState。如果给定context中没有Navigator，则该函数将在调试模式下抛出FlutterError，并在发布模式下抛出异常。这种方法可能很昂贵（它遍历Element树）。\n2.5.2、maybeOf方法 方法描述：获取给定上下文（如果有）的此类的最近实例的NavigatorState。如果rootNavigator设置为true，则给出距此类最远实例的状态。如果context中没有祖先Navigator，则返回null。这种方法可能很昂贵（它遍历Element树）。\n2.5.3、restorableXXX方法 这些方法与Route的恢复相关，一般情况下用不到这些方法，感兴趣可以自行学习。\n三、源码分析 在Flutter中，万物皆Widget，Navigator自然也不例外，只是我们没有主动添加过Navigator，但是又可以通过Navigator来进行页面跳转，这是怎么一回事呢？\n在进行Flutter开发时，一般情况下需要以MaterialApp或WidgetsApp（MaterialApp是对WidgetsApp的包装）来作为第一个Widget，否则可能会出现一些不可预估的错误。\n例如，如果你没有以MaterialApp作为第一个Widget，后续在使用Navigator的方法时，可能就会因为找不到Navigator而报错。\n这是因为Flutter默认在MaterialApp中添加了第一个Navigator，也就是根Navigator，如果您不主动添加过其它Navigator的话，一般情况下的跳转就是通过这个根Navigator来实现的。\n看下面的例子，通过Navigator跳转传参以及将数据返回给上一个页面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyHomePage(title: \u0026#39;Navigator示例\u0026#39;), ); } } class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State\u0026lt;MyHomePage\u0026gt; createState() =\u0026gt; _MyHomePageState(); } class _MyHomePageState extends State\u0026lt;MyHomePage\u0026gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ OutlinedButton( onPressed: () async { Object? value = await Navigator.push( context, MaterialPageRoute( builder: (context) =\u0026gt; const SecondPage(argument: 888), ), ); if (!mounted) return; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(\u0026#39;SecondPage返回的数据为：$value\u0026#39;))); }, child: const Text(\u0026#39;跳转（从SecondPage构造方法传入参数）\u0026#39;), ), OutlinedButton( onPressed: () async { Object? value = await Navigator.push( context, MaterialPageRoute( builder: (context) =\u0026gt; const SecondPage(), settings: const RouteSettings(arguments: 999), ), ); if (!mounted) return; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(\u0026#39;SecondPage返回的数据为：$value\u0026#39;))); }, child: const Text(\u0026#39;跳转（从settings传入参数）\u0026#39;), ), ], ), ), ); } } class SecondPage extends StatelessWidget { final Object? argument; const SecondPage({super.key, this.argument}); @override Widget build(BuildContext context) { Object? value = argument ?? ModalRoute.of(context)?.settings.arguments; return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;SecondPage\u0026#39;), ), body: Center( child: OutlinedButton( onPressed: () =\u0026gt; Navigator.pop(context, value), child: Text(\u0026#39;获取的返回值为：$value，点击返回\u0026#39;), ), ), ); } } 程序运行起来后，UI效果如下所示。\n然后通过Flutter Inspector查看Widget层次结构，可以发现MaterialApp中的确默认添加了第一个Navigator。\nOK，下面按照示例来分析Navigator的源码（命令式部分）。\n3.1、_MaterialAppState 的build方法 从MaterialApp入手，因为它是一个StatefulWidget，所以看下 _MaterialAppState 的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @override Widget build(BuildContext context) { // 执行_buildWidgetApp方法 Widget result = _buildWidgetApp(context); ... return ScrollConfiguration( behavior: widget.scrollBehavior ?? const MaterialScrollBehavior(), child: HeroControllerScope( controller: _heroController, child: result, ), ); } 看下 _MaterialAppState 的 _buildWidgetApp 方法，可以发现它根据 _usesRouter 来选择不同的WidgetsApp构造方法进行创建WidgetsApp。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // _usesRouter表示是否使用Router，它是声明式的范畴，本文所讲是命令式，因此_usesRouter可视为false bool get _usesRouter =\u0026gt; widget.routerDelegate != null || widget.routerConfig != null; Widget _buildWidgetApp(BuildContext context) { ... if (_usesRouter) { // Router方式实现路由导航（声明式） return WidgetsApp.router( ... ); } // 直接Navigator方式实现路由导航（命令式） return WidgetsApp( key: GlobalObjectKey(this), // 此处是MaterialApp传入的navigatorKey navigatorKey: widget.navigatorKey, navigatorObservers: widget.navigatorObservers!, // 返回MaterialPageRoute，这个和根布局Route相关，后面讲 pageRouteBuilder: \u0026lt;T\u0026gt;(RouteSettings settings, WidgetBuilder builder) { return MaterialPageRoute\u0026lt;T\u0026gt;(settings: settings, builder: builder); }, // 此处是MaterialApp传入的根布局 home: widget.home, // 此处是MaterialApp传入的路由表 routes: widget.routes!, // 此处是MaterialApp传入的初始路由名称 initialRoute: widget.initialRoute, // 此处是MaterialApp传入的onGenerateRoute路由钩子函数 onGenerateRoute: widget.onGenerateRoute, // 此处是MaterialApp传入的onGenerateInitialRoutes初始路由钩子函数 onGenerateInitialRoutes: widget.onGenerateInitialRoutes, // 此处是MaterialApp传入的onUnknownRoute未知路由钩子函数 onUnknownRoute: widget.onUnknownRoute, ... ); } 对于WidgetsApp构造方法传入的navigatorKey，如果没在MaterialApp中传入，那么它会创建一个默认的navigatorKey，先看下 _WidgetsAppState 的initState方法。\n1 2 3 4 5 6 7 8 @override void initState() { super.initState(); // 执行_updateRouting方法 _updateRouting(); _locale = _resolveLocales(WidgetsBinding.instance.platformDispatcher.locales, widget.supportedLocales); WidgetsBinding.instance.addObserver(this); } 看下 _WidgetsAppState 的 _updateRouting 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool get _usesNavigator =\u0026gt; widget.home != null || (widget.routes?.isNotEmpty ?? false) || widget.onGenerateRoute != null || widget.onUnknownRoute != null; GlobalKey\u0026lt;NavigatorState\u0026gt;? _navigator; void _updateRouting({WidgetsApp? oldWidget}) { if (_usesRouterWithDelegates) { ... } else if (_usesNavigator) { assert(!_usesRouterWithDelegates \u0026amp;\u0026amp; !_usesRouterWithConfig); _clearRouterResource(); // 创建一个默认的navigatorKey，也就是GlobalObjectKey\u0026lt;NavigatorState\u0026gt;，赋值给_navigator if (_navigator == null || widget.navigatorKey != oldWidget!.navigatorKey) { _navigator = widget.navigatorKey ?? GlobalObjectKey\u0026lt;NavigatorState\u0026gt;(this); } assert(_navigator != null); } else { ... } // If we use a navigator, we have a navigator key. assert(_usesNavigator == (_navigator != null)); } 再看下 _WidgetsAppState 的 build 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 bool get _usesRouterWithDelegates =\u0026gt; widget.routerDelegate != null; bool get _usesRouterWithConfig =\u0026gt; widget.routerConfig != null; bool get _usesNavigator =\u0026gt; widget.home != null || (widget.routes?.isNotEmpty ?? false) || widget.onGenerateRoute != null || widget.onUnknownRoute != null; @override Widget build(BuildContext context) { Widget? routing; if (_usesRouterWithDelegates) { // Router方式实现路由导航（声明式） routing = Router\u0026lt;Object\u0026gt;( restorationScopeId: \u0026#39;router\u0026#39;, routeInformationProvider: _effectiveRouteInformationProvider, routeInformationParser: widget.routeInformationParser, routerDelegate: widget.routerDelegate!, backButtonDispatcher: _effectiveBackButtonDispatcher, ); } else if (_usesNavigator) { // 直接Navigator方式实现路由导航（命令式） assert(_navigator != null); routing = FocusScope( debugLabel: \u0026#39;Navigator Scope\u0026#39;, autofocus: true, child: Navigator( clipBehavior: Clip.none, restorationScopeId: \u0026#39;nav\u0026#39;, // 因为我们没在MaterialApp中传入navigatorKey，所以这里使用了前面创建的默认_navigator key: _navigator, // 引用成员变量_initialRouteName，后面讲 initialRoute: _initialRouteName, // 引用成员方法_onGenerateRoute，后面讲 onGenerateRoute: _onGenerateRoute, // onGenerateInitialRoutes这里的判断后面再讲 onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null ? Navigator.defaultGenerateInitialRoutes : (NavigatorState navigator, String initialRouteName) { return widget.onGenerateInitialRoutes!(initialRouteName); }, // 引用成员方法_onUnknownRoute，后面讲 onUnknownRoute: _onUnknownRoute, observers: widget.navigatorObservers!, reportsRouteUpdateToEngine: true, ), ); } else if (_usesRouterWithConfig) { // 带config的Router方式实现路由导航（声明式） routing = Router\u0026lt;Object\u0026gt;.withConfig( restorationScopeId: \u0026#39;router\u0026#39;, config: widget.routerConfig!, ); } ... return RootRestorationScope( restorationId: widget.restorationScopeId, child: SharedAppData( child: Shortcuts( debugLabel: \u0026#39;\u0026lt;Default WidgetsApp Shortcuts\u0026gt;\u0026#39;, shortcuts: widget.shortcuts ?? WidgetsApp.defaultShortcuts, child: DefaultTextEditingShortcuts( child: Actions( ... child: FocusTraversalGroup( policy: ReadingOrderTraversalPolicy(), child: TapRegionSurface( child: ShortcutRegistrar( child: Localizations( locale: appLocale, delegates: _localizationsDelegates.toList(), // 最后将包装多层的routing，放到这里 child: title, ), ), ), ), ), ), ), ), ); } 上面已知道 _WidgetsAppState 的 build 方法中用到了Navigator，而Navigator是一个StatefulWidget，看下创建的NavigatorState的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 注意：_overlayKey是延迟初始化 late GlobalKey\u0026lt;OverlayState\u0026gt; _overlayKey; /// Navigator套了Overlay，Overlay是一个StatefulWidget，此处是Overlay的OverlayState /// The overlay this navigator uses for its visual presentation. OverlayState? get overlay =\u0026gt; _overlayKey.currentState; // 此处是Overlay的initialEntries，后面讲 Iterable\u0026lt;OverlayEntry\u0026gt; get _allRouteOverlayEntries { return \u0026lt;OverlayEntry\u0026gt;[ for (final _RouteEntry entry in _history) ...entry.route.overlayEntries, ]; } @override Widget build(BuildContext context) { ... return HeroControllerScope.none( child: Listener( onPointerDown: _handlePointerDown, onPointerUp: _handlePointerUpOrCancel, onPointerCancel: _handlePointerUpOrCancel, child: AbsorbPointer( absorbing: false, // it\u0026#39;s mutated directly by _cancelActivePointers above child: FocusTraversalGroup( policy: FocusTraversalGroup.maybeOf(context), child: Focus( focusNode: focusNode, autofocus: true, skipTraversal: true, includeSemantics: false, child: UnmanagedRestorationScope( bucket: bucket, // 此处用到了Overlay，它是可以独立管理的条目堆栈 // 通过将独立的子widgets插入到overlay的堆栈中，overlay可以让独立的子widgets将视觉元素“浮动”在其它widgets的顶部。overlay允许每个widgets使用OverlayEntry对象管理它们在overlay中的参与。 child: Overlay( key: _overlayKey, clipBehavior: widget.clipBehavior, // 因为_overlayKey是late延迟加载，所以一开始overlay会为null，此处传入的是_allRouteOverlayEntries initialEntries: overlay == null ? _allRouteOverlayEntries.toList(growable: false) : const \u0026lt;OverlayEntry\u0026gt;[], ), ), ), ), ), ), ); } 3.2、Navigator的push方法 1 2 3 4 @optionalTypeArgs static Future\u0026lt;T?\u0026gt; push\u0026lt;T extends Object?\u0026gt;(BuildContext context, Route\u0026lt;T\u0026gt; route) { return Navigator.of(context).push(route); } 看下of方法，它的返回是NavigatorState对象，然后可以通过该对象实现路由跳转，例如调用上面的push方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 static NavigatorState of( BuildContext context, { bool rootNavigator = false, }) { // Handles the case where the input context is a navigator element. // 处理输入上下文是navigator element的情况。 NavigatorState? navigator; if (context is StatefulElement \u0026amp;\u0026amp; context.state is NavigatorState) { navigator = context.state as NavigatorState; } // rootNavigator表示是否查找根Navigator if (rootNavigator) { // 向上查找根Navigator所创建的NavigatorState，如果找到就赋值给navigator navigator = context.findRootAncestorStateOfType\u0026lt;NavigatorState\u0026gt;() ?? navigator; } else { // 向上查找最近的一个Navigator所创建的NavigatorState，，如果找到就赋值给navigator navigator = navigator ?? context.findAncestorStateOfType\u0026lt;NavigatorState\u0026gt;(); } // 如果上面context中没有找到navigator，就会报错 // 这也就是前面说的如果你没有以MaterialApp作为第一个Widget，后续在使用Navigator的方法时，可能就会因为找不到Navigator而报错。 assert(() { if (navigator == null) { throw FlutterError( \u0026#39;Navigator operation requested with a context that does not include a Navigator.\\n\u0026#39; \u0026#39;The context used to push or pop routes from the Navigator must be that of a \u0026#39; \u0026#39;widget that is a descendant of a Navigator widget.\u0026#39;, ); } return true; }()); // 最后把查找的NavigatorState返回 return navigator!; } 看下context的findRootAncestorStateOfType方法，因为context是一个句柄，所以看它的实现类Element的findRootAncestorStateOfType方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override T? findRootAncestorStateOfType\u0026lt;T extends State\u0026lt;StatefulWidget\u0026gt;\u0026gt;() { assert(_debugCheckStateIsActiveForAncestorLookup()); Element? ancestor = _parent; StatefulElement? statefulAncestor; // 从当前Element的父Element开始遍历，一直找到最远的一个StatefulElement，然后将它的State转为T while (ancestor != null) { if (ancestor is StatefulElement \u0026amp;\u0026amp; ancestor.state is T) { statefulAncestor = ancestor; } ancestor = ancestor._parent; } return statefulAncestor?.state as T?; } 看下实现类Element的findAncestorStateOfType方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override T? findAncestorStateOfType\u0026lt;T extends State\u0026lt;StatefulWidget\u0026gt;\u0026gt;() { assert(_debugCheckStateIsActiveForAncestorLookup()); Element? ancestor = _parent; // 从当前Element的父Element开始遍历，一直找到最近的一个StatefulElement，然后将它的State转为T while (ancestor != null) { if (ancestor is StatefulElement \u0026amp;\u0026amp; ancestor.state is T) { break; } ancestor = ancestor._parent; } final StatefulElement? statefulAncestor = ancestor as StatefulElement?; return statefulAncestor?.state as T?; } 可以看到，of方法需要传入一个context来获取根Navigator或者最近一个Navigator所创建的NavigatorState。\n但是，在某些需求（如Token失效跳转登录页）下，无法拿到context对象，但又需要跳转，那该如何处理？\n之前讲过，MaterialApp可以传入一个navigatorKey，在不传的情况下底层也会创建一个默认的navigatorKey，现在的解决办法就是可以通过传入navigatorKey来获取根Navigator所创建的NavigatorState。\nOK，再来看下NavigatorState的push方法。\n1 2 3 4 5 6 7 8 @optionalTypeArgs Future\u0026lt;T?\u0026gt; push\u0026lt;T extends Object?\u0026gt;(Route\u0026lt;T\u0026gt; route) { // 将Route包装为_RouteEntry对象，然后交给_pushEntry方法处理 // 注意此时initialState为_RouteLifecycle.push，等下用到 _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push)); // 此处popped是一个Completer，其内部用到Future，等到_RouteLifecycle的状态变为complete，就会调用Route的didComplete方法，然后将结果值放入Completer中，这个后面讲。 return route.popped; } 先看下 _RouteEntry 的部分源码，可以发现它继承自RouteTransitionRecord，而RouteTransitionRecord是为TransitionDelegate暂存的Route包装器接口，用来决定其底层Route应如何在屏幕上或屏幕外转换。\nRouteTransitionRecord提供了几个markXXX抽象方法，例如markForPush、markForAdd等，用来标记Route，表示它会进行一些操作，子类 _RouteEntry 对markXXX方法的实现一般是修改当前所处的 _RouteLifecycle 状态。\n对于 _RouteEntry，因为构造方法传入了Route，所以 _RouteEntry 实际上是对Route的方法操作与Route的生命周期管理，例如handleAdd方法等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class _RouteEntry extends RouteTransitionRecord { _RouteEntry( // 传入Route对象 this.route, { // Route生命周期的初始状态 required _RouteLifecycle initialState, // 这个和声明式的page相关，不会讲 required this.pageBased, // 恢复信息，这里用不到这个 this.restorationInformation, }) : assert(!pageBased || route.settings is Page), assert( initialState == _RouteLifecycle.staging || initialState == _RouteLifecycle.add || initialState == _RouteLifecycle.push || initialState == _RouteLifecycle.pushReplace || initialState == _RouteLifecycle.replace, ), // 将初始状态赋值给当前状态 currentState = initialState; // 重写父类RouteTransitionRecord的成员变量 @override final Route\u0026lt;dynamic\u0026gt; route; final _RestorationInformation? restorationInformation; final bool pageBased; static Route\u0026lt;dynamic\u0026gt; notAnnounced = _NotAnnounced(); _RouteLifecycle currentState; ... void handleAdd({ required NavigatorState navigator, required Route\u0026lt;dynamic\u0026gt;? previousPresent }) { assert(currentState == _RouteLifecycle.add); assert(navigator._debugLocked); assert(route._navigator == null); route._navigator = navigator; // 管理Route的操作 route.install(); assert(route.overlayEntries.isNotEmpty); // 管理Route的生命周期 currentState = _RouteLifecycle.adding; navigator._observedRouteAdditions.add( _NavigatorPushObservation(route, previousPresent), ); } ... @override void markForPush() { assert( isWaitingForEnteringDecision \u0026amp;\u0026amp; !isWaitingForExitingDecision, \u0026#39;This route cannot be marked for push. Either a decision has already been \u0026#39; \u0026#39;made or it does not require an explicit decision on how to transition in.\u0026#39;, ); // 管理Route的生命周期 currentState = _RouteLifecycle.push; } ... } 上面涉及一个Route生命周期类 _RouteLifecycle，看下它的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 // _RouteLifecycle 状态机（仅下降）： // The _RouteLifecycle state machine (only goes down): // // [creation of a _RouteEntry] // | // + // |\\ // | \\ // | staging // | / // |/ // +-+----------+--+-------+ // / | | | // / | | | // / | | | // / | | | // / | | | // pushReplace push* add* replace* // \\ | | | // \\ | | / // +--pushing# adding / // \\ / / // \\ / / // idle--+-----+ // / \\ // / +------+ // / | | // / | complete* // | | / // pop* remove* // / \\ // / removing# // popping# | // | | // [finalizeRoute] | // \\ | // dispose* // | // disposing // | // disposed // | // | // [_RouteEntry garbage collected] // (terminal state) // // *号表示这些状态是暂时的；一旦 _flushHistoryUpdates 运行，路由entry就会退出该状态。 // * These states are transient; as soon as _flushHistoryUpdates is run the // route entry will exit that state. // #号表示这些状态等待futures或其它事件，然后自动转换。 // # These states await futures or other events, then transition automatically. enum _RouteLifecycle { // 我们将等待过渡代理决定如何处理该路由。 staging, // we will wait for transition delegate to decide what to do with this route. // 存在的路由: // routes that are present: // // 我们需要运行install、didAdd等；由onGenerateInitialRoutes或初始widget.pages创建的路由 add, // we\u0026#39;ll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages // 我们将等待来自最顶层路由的didPush完成的future adding, // we\u0026#39;ll waiting for the future from didPush of top-most route to complete // 已准备好过渡的路由。 // routes that are ready for transition. // 我们需要运行install、didPush等；通过push()和friends添加的路由 push, // we\u0026#39;ll want to run install, didPush, etc; a route added via push() and friends // 我们需要运行install、didPush等；通过pushReplace()和friends添加的路由 pushReplace, // we\u0026#39;ll want to run install, didPush, etc; a route added via pushReplace() and friends // 我们正在等待来自didPush完成的future pushing, // we\u0026#39;re waiting for the future from didPush to complete // 我们需要运行install、didReplace等；通过replace()和friends添加的路由 replace, // we\u0026#39;ll want to run install, didReplace, etc; a route added via replace() and friends // 路由是无害的 idle, // route is being harmless // 不存在的路由： // routes that are not present: // // 应包含在路由公告中并且仍应侦听转换更改的路由。 // routes that should be included in route announcement and should still listen to transition changes. // 我们要调用didPop pop, // we\u0026#39;ll want to call didPop // 我们要调用didComplete complete, // we\u0026#39;ll want to call didComplete, // 我们要运行didReplace/didRemove等 remove, // we\u0026#39;ll want to run didReplace/didRemove etc // 路由不应包含在路由公告中，但仍应监听转换更改。 // routes should not be included in route announcement but should still listen to transition changes. // 我们正在等待路由调用finalizeRoute来切换到dispose popping, // we\u0026#39;re waiting for the route to call finalizeRoute to switch to dispose // 我们正在等待后续路由完成动画，然后将切换到dispose removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose // 从navigator和overlay中完全删除的路由。 // routes that are completely removed from the navigator and overlay. // 我们将立即dispose路由 dispose, // we will dispose the route momentarily // 该entry正在等待其widget子树首先被dispose。在等待时，它存储在 _entryWaitingForSubTreeDisposal中。 disposing, // The entry is waiting for its widget subtree to be disposed // first. It is stored in _entryWaitingForSubTreeDisposal while // awaiting that. // 我们已经dispose了路由 disposed, // we have disposed the route } OK，关于 _RouteEntry 和 _RouteLifecycle 的表达\u0026amp;功能，现已大致了解清楚，继续看NavigatorState的 _pushEntry 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 List\u0026lt;_RouteEntry\u0026gt; _history = \u0026lt;_RouteEntry\u0026gt;[]; void _pushEntry(_RouteEntry entry) { assert(!_debugLocked); assert(() { _debugLocked = true; return true; }()); assert(entry.route._navigator == null); assert(entry.currentState == _RouteLifecycle.push); // 将_RouteEntry存入_history这个List中 _history.add(entry); // 执行_flushHistoryUpdates方法 _flushHistoryUpdates(); assert(() { _debugLocked = false; return true; }()); _afterNavigation(entry.route); } 在 _pushEntry 方法中，执行了 _flushHistoryUpdates 方法，此时currentState为 _RouteLifecycle.push。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 void _flushHistoryUpdates({bool rearrangeOverlay = true}) { assert(_debugLocked \u0026amp;\u0026amp; !_debugUpdatingPage); _flushingHistory = true; ... // _history中最后一个索引位置 int index = _history.length - 1; // 下一个_RouteEntry _RouteEntry? next; // _history中最后一个索引位置的_RouteEntry _RouteEntry? entry = _history[index]; // 前一个_RouteEntry _RouteEntry? previous = index \u0026gt; 0 ? _history[index - 1] : null; // 顶部是否有完全不透明的路由以静默删除或添加下面的路由。 bool canRemoveOrAdd = false; // Whether there is a fully opaque route on top to silently remove or add route underneath. // 应在顶部活动路由上触发didPopNext的路由。 Route\u0026lt;dynamic\u0026gt;? poppedRoute; // The route that should trigger didPopNext on the top active route. // 我们是否已经看到将获得didPopNext的路由。 bool seenTopActiveRoute = false; // Whether we\u0026#39;ve seen the route that would get didPopNext. final List\u0026lt;_RouteEntry\u0026gt; toBeDisposed = \u0026lt;_RouteEntry\u0026gt;[]; // while循环倒序遍历 while (index \u0026gt;= 0) { switch (entry!.currentState) { case ... case _RouteLifecycle.push: // 此时currentState为_RouteLifecycle.push，所以执行这里 case _RouteLifecycle.pushReplace: case _RouteLifecycle.replace: assert(rearrangeOverlay); // 执行_RouteEntry的handlePush方法 entry.handlePush( navigator: this, previous: previous?.route, previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route, isNewFirst: next == null, ); assert(entry.currentState != _RouteLifecycle.push); assert(entry.currentState != _RouteLifecycle.pushReplace); assert(entry.currentState != _RouteLifecycle.replace); if (entry.currentState == _RouteLifecycle.idle) { continue; } case ... } // 更新循环条件 index -= 1; next = entry; entry = previous; previous = index \u0026gt; 0 ? _history[index - 1] : null; } ... // 重点：因为_flushHistoryUpdates方法没有传入rearrangeOverlay，所以rearrangeOverlay默认为true，此时会执行OverlayState的rearrange方法。 // 有两个情况： // 1、如果是根布局home，因为一开始OverlayKey是延迟加载，所以这里overlay为null，不会执行rearrange方法，后面讲。 // 2、如果是跳转新页面，这里的overlay已经有值了，所以会执行rearrange方法 if (rearrangeOverlay) { overlay?.rearrange(_allRouteOverlayEntries); } ... _flushingHistory = false; } 在while循环中，此时currentState为 _RouteLifecycle.push ，所以会执行 _RouteEntry 的 handlePush 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 void handlePush({ required NavigatorState navigator, required bool isNewFirst, required Route\u0026lt;dynamic\u0026gt;? previous, required Route\u0026lt;dynamic\u0026gt;? previousPresent }) { ... // 将currentState赋值给前一个状态 final _RouteLifecycle previousState = currentState; // Route持有navigator引用 route._navigator = navigator; // 执行Route的install方法 route.install(); assert(route.overlayEntries.isNotEmpty); if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) { // 执行Route的didPush方法 final TickerFuture routeFuture = route.didPush(); // 将currentState修改为_RouteLifecycle.pushing currentState = _RouteLifecycle.pushing; routeFuture.whenCompleteOrCancel(() { if (currentState == _RouteLifecycle.pushing) { // 等到didPush方法处理完成（这里是等待页面跳转动画完成），将currentState修改为_RouteLifecycle.idle currentState = _RouteLifecycle.idle; assert(!navigator._debugLocked); assert(() { navigator._debugLocked = true; return true; }()); // 再次调用_flushHistoryUpdates方法 navigator._flushHistoryUpdates(); assert(() { navigator._debugLocked = false; return true; }()); } }); } else { assert(currentState == _RouteLifecycle.replace); route.didReplace(previous); currentState = _RouteLifecycle.idle; } // isNewFirst传入的next == null，那么倒序遍历第一个_RouteEntry时next肯定为null，所以这里为true if (isNewFirst) { // 执行Route的didChangeNext方法，该方法和动画操作相关 route.didChangeNext(null); } if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) { navigator._observedRouteAdditions.add( _NavigatorReplaceObservation(route, previousPresent), ); } else { assert(previousState == _RouteLifecycle.push); // previousState当前为_RouteLifecycle.push，所以创建一个_NavigatorPushObservation对象添加进_observedRouteAdditions，采用观察者模式， // 后续通知去执行Route的一些操作 navigator._observedRouteAdditions.add( _NavigatorPushObservation(route, previousPresent), ); } } 在 _RouteEntry 的handlePush方法中，执行了Route的install方法，但是install是个抽象方法，需要Route的子类来实现。\n一般情况下，当调用Navigator的push方法时，传入的Route为MaterialPageRoute，它的继承关系如下。\n在上面的继承关系中，MaterialPageRoute与PageRoute均没有实现install方法，所以看下 ModalRoute的install方法。\n1 2 3 4 5 6 7 @override void install() { // 执行父类的install方法 super.install(); _animationProxy = ProxyAnimation(super.animation); _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation); } 可以看到，这里只是ProxyAnimation动画初始化，看下父类TransitionRoute的install方法。\n1 2 3 4 5 6 7 8 9 @override void install() { ... // 执行父类的install方法 super.install(); if (_animation!.isCompleted \u0026amp;\u0026amp; overlayEntries.isNotEmpty) { overlayEntries.first.opaque = opaque; } } 继续看下父类OverlayRoute的install方法，OverlayRoute是在Navigator的Overlay中显示Widgets的路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /// 子类应该重写此getter以返回overlay的构建器 /// Subclasses should override this getter to return the builders for the overlay. @factory Iterable\u0026lt;OverlayEntry\u0026gt; createOverlayEntries(); @override List\u0026lt;OverlayEntry\u0026gt; get overlayEntries =\u0026gt; _overlayEntries; final List\u0026lt;OverlayEntry\u0026gt; _overlayEntries = \u0026lt;OverlayEntry\u0026gt;[]; @override void install() { assert(_overlayEntries.isEmpty); // 通过createOverlayEntries方法创建OverlayEntry放入_overlayEntries，以待后续使用 _overlayEntries.addAll(createOverlayEntries()); super.install(); } 其中，createOverlayEntries方法由子类ModalRoute实现，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // one of the builders late OverlayEntry _modalBarrier; Widget _buildModalBarrier(BuildContext context) { Widget barrier = buildModalBarrier(); ... return barrier; } /// 为此[ModalRoute]构建障碍，子类可以重写此方法以使用自定义功能（例如颜色或辅助功能焦点大小）创建自己的障碍。 /// Build the barrier for this [ModalRoute], subclasses can override /// this method to create their own barrier with customized features such as /// color or accessibility focus size. Widget buildModalBarrier() { Widget barrier; if (barrierColor != null \u0026amp;\u0026amp; barrierColor!.alpha != 0 \u0026amp;\u0026amp; !offstage) { ... } else { barrier = ModalBarrier( dismissible: barrierDismissible, // changedInternalState is called if barrierDismissible updates semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates barrierSemanticsDismissible: semanticsDismissible, ); } return barrier; } // 我们缓存模态范围中不随帧变化的部分，以便最大限度地减少发生的构建量。 // We cache the part of the modal scope that doesn\u0026#39;t change from frame to // frame so that we minimize the amount of building that happens. Widget? _modalScopeCache; // one of the builders Widget _buildModalScope(BuildContext context) { // To be sorted before the _modalBarrier. return _modalScopeCache ??= Semantics( sortKey: const OrdinalSortKey(0.0), child: _ModalScope\u0026lt;T\u0026gt;( key: _scopeKey, // 此处this指MaterialPageRoute route: this, // _ModalScope calls buildTransitions() and buildChild(), defined above ), ); } late OverlayEntry _modalScope; @override Iterable\u0026lt;OverlayEntry\u0026gt; createOverlayEntries() { return \u0026lt;OverlayEntry\u0026gt;[ // 创建了一个Barrier所对应的OverlayEntry（屏障） _modalBarrier = OverlayEntry(builder: _buildModalBarrier), // 创建了一个跳转新页面所对应的OverlayEntry _modalScope = OverlayEntry(builder: _buildModalScope, maintainState: maintainState), ]; } 上面通过createOverlayEntries方法已创建了两个OverlayEntry，然后添加给 _overlayEntries，它的结构是这样的。\n那么，OverlayRoute中的overlayEntries是在哪里被用到呢？它是在NavigatorState的成员变量 _allRouteOverlayEntries 中被用到。\n1 2 3 4 5 6 7 8 // install方法后，此时_allRouteOverlayEntries的元素为[根布局屏障、根布局页面，新布局屏障、新布局页面] Iterable\u0026lt;OverlayEntry\u0026gt; get _allRouteOverlayEntries { return \u0026lt;OverlayEntry\u0026gt;[ // 遍历了_history中所有的_RouteEntry，每个_RouteEntry都包装了一个Route，每个Route都有一层Barrier和一层跳转新页面 for (final _RouteEntry entry in _history) ...entry.route.overlayEntries, ]; } 而成员变量 _allRouteOverlayEntries 会在两个地方被用到。\n1、NavigatorState的build方法，作为Overlay的initialEntries传入，这个前面讲过了，因为 _overlayKey 是late延迟加载，所以一开始overlay会为null，传入的就是 _allRouteOverlayEntries，它所包含的是一层Barrier和一层根布局home页面，根布局home的初始化后面讲。\n2、在 _flushHistoryUpdates 方法中执行，因为当执行完handlePush方法后，就会接着执行overlay的rearrange方法。\n1 2 3 if (rearrangeOverlay) { overlay?.rearrange(_allRouteOverlayEntries); } 看下overlay的rearrange方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void rearrange(Iterable\u0026lt;OverlayEntry\u0026gt; newEntries, { OverlayEntry? below, OverlayEntry? above }) { // 取出newEntries（也就是传入的_allRouteOverlayEntries），赋值给newEntriesList // growable为false，表示列表是固定长度 final List\u0026lt;OverlayEntry\u0026gt; newEntriesList = newEntries is List\u0026lt;OverlayEntry\u0026gt; ? newEntries : newEntries.toList(growable: false); ... // 此时newEntriesList不为null，因为已经包含了根布局的两层OverlayEntry以及新页面的两层OverlayEntry if (newEntriesList.isEmpty) { return; } // 判断OverlayState中的_entries是否与newEntriesList相同，此处肯定不相同，因为跳转了新页面，多出两层OverlayEntry // 但是要注意：因为handlePush方法中还会执行_flushHistoryUpdates方法，造成第二次执行rearrange，此时两个List已经相等，所以此处会被拦截 if (listEquals(_entries, newEntriesList)) { return; } // 将旧的OverlayEntry列表包装为LinkedHashSet final LinkedHashSet\u0026lt;OverlayEntry\u0026gt; old = LinkedHashSet\u0026lt;OverlayEntry\u0026gt;.of(_entries); // 让newEntriesList中所有的OverlayEntry持有OverlayState引用 for (final OverlayEntry entry in newEntriesList) { entry._overlay ??= this; } // 刷新Overlay页面UI，触发OverlayState的build方法执行 setState(() { // 更新OverlayState中的_entries为newEntriesList _entries.clear(); _entries.addAll(newEntriesList); // 移除与newEntriesList相交部分（根布局两层OverlayEntry），那么此时old为空了 old.removeAll(newEntriesList); // 此处below为null，above为null，所以_insertionIndex的值为_entries的长度，也就是此时newEntriesList的长度 // 然后重新把旧_entries在新_entries末尾插入，old为空了相当于插入了个寂寞 _entries.insertAll(_insertionIndex(below, above), old); }); } OK，总结下OverlayState的build方法两次执行过程。\n1、我们知道，跳转新页面会伴随着动画，这个动画控制类在TransitionRoute的install方法中初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 @override void install() { ... // 添加动画状态监听_handleStatusChanged _animation = createAnimation() ..addStatusListener(_handleStatusChanged); assert(_animation != null, \u0026#39;$runtimeType.createAnimation() returned null.\u0026#39;); super.install(); if (_animation!.isCompleted \u0026amp;\u0026amp; overlayEntries.isNotEmpty) { overlayEntries.first.opaque = opaque; } } 可以看到，在TransitionRoute的install方法中添加了动画状态监听，看下 _handleStatusChanged 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void _handleStatusChanged(AnimationStatus status) { switch (status) { case AnimationStatus.completed: // 动画完成 if (overlayEntries.isNotEmpty) { overlayEntries.first.opaque = opaque; } _performanceModeRequestHandle?.dispose(); _performanceModeRequestHandle = null; case AnimationStatus.forward: case AnimationStatus.reverse: // 动画正向/反向执行 if (overlayEntries.isNotEmpty) { overlayEntries.first.opaque = false; } _performanceModeRequestHandle ??= SchedulerBinding.instance .requestPerformanceMode(ui.DartPerformanceMode.latency); case AnimationStatus.dismissed: // 动画未开始 // We might still be an active route if a subclass is controlling the // transition and hits the dismissed status. For example, the iOS // back gesture drives this animation to the dismissed status before // removing the route and disposing it. if (!isActive) { navigator!.finalizeRoute(this); _popFinalized = true; _performanceModeRequestHandle?.dispose(); _performanceModeRequestHandle = null; } } } 当 _RouteEntry 的handlePush方法执行时，会执行route.didPush()，看下Route子类TransitionRoute的didPush方法，可以看到，动画开始正向执行。\n1 2 3 4 5 6 7 8 @override TickerFuture didPush() { assert(_controller != null, \u0026#39;$runtimeType.didPush called before calling install() or after calling dispose().\u0026#39;); assert(!_transitionCompleter.isCompleted, \u0026#39;Cannot reuse a $runtimeType after disposing it.\u0026#39;); super.didPush(); // 动画开始正向执行 return _controller!.forward(); } 那么，_handleStatusChanged 方法就会被回调，一开始动画状态为AnimationStatus.forward时，会设置overlayEntries.first.opaque = false。此处overlayEntries正是createOverlayEntries方法创建，前面讲过有两层，一层是新布局屏障，一层是新布局页面，那么这里就是将新布局屏障OverlayEntry的opaque设置为false。\n看下OverlayEntry的成员变量opaque，在OverlayEntry的构造方法中，如果不设置opaque，它默认为false。\n之前讲ModalRoute的createOverlayEntries方法时，它内部创建了两个OverlayEntry，可以发现它们都没设置opaque，也就是opaque默认为false。\n因而 _opaque 相同值会被拦截，不会执行下面的 _didChangeEntryOpacity 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class OverlayEntry implements Listenable { OverlayEntry({ required this.builder, // opaque默认为false bool opaque = false, bool maintainState = false, }) : _opaque = opaque, _maintainState = maintainState; bool get opaque =\u0026gt; _opaque; bool _opaque; set opaque(bool value) { assert(!_disposedByOwner); // _opaque相同值会被拦截 if (_opaque == value) { return; } _opaque = value; // _didChangeEntryOpacity方法中会执行setState方法 _overlay?._didChangeEntryOpacity(); } } 2、当handlePush方法执行完后，就会执行到overlay的rearrange方法，此时会触发setState方法，然后第一次执行build方法。在build方法中会倒序遍历 _entries，新布局页面OverlayEntry是第一个被遍历到，根布局屏障OverlayEntry是最后一个被遍历到，那么children的最后一个是根布局屏障OverlayEntry。\n之前讲了，新布局屏障OverlayEntry的opaque设置为false，所以当倒序遍历 _entries 时，遇到opaque为false时，onstage不会被修改为false，因此走的都是 if (onstage) 逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @override Widget build(BuildContext context) { // 该列表在添加到树之前先向后填充，然后在下面反转。 // This list is filled backwards and then reversed below before // it is added to the tree. final List\u0026lt;_OverlayEntryWidget\u0026gt; children = \u0026lt;_OverlayEntryWidget\u0026gt;[]; // onstage表示是否在舞台上，也就是我们自己的页面 bool onstage = true; int onstageCount = 0; // 倒序遍历_entries // 注意：只有onstage或maintainState的情况，Route在内存中才会被保留下来 for (final OverlayEntry entry in _entries.reversed) { if (onstage) { onstageCount += 1; children.add(_OverlayEntryWidget( key: entry._key, overlayState: this, entry: entry, )); // opaque表示该OverlayEntry是否遮挡整个Overlay // 如果某个OverlayEntry声称是不透明的，那么为了提高效率，覆盖层将跳过该OverlayEntry下方的构建OverlayEntry，除非它们设置了maintainState // 当一条不透明Route的入口过渡完成后，该不透明Route后面的Route将不再被构建，以节省资源。 if (entry.opaque) { onstage = false; } } else if (entry.maintainState) { // maintainState表示Route处于非活动状态时是否应保留在内存中。 // 如果MaterialPageRoute设置了maintainState为true，那么该Route将被维护，以便在下一个Route弹出时，它持有的下一个Route的任何future都将正确解析。 // 如果没有必要，可以将其设置为false，以允许框架在Route的widget层次结构不可见时完全丢弃它，当下次返回到上一个页面时会重新创建，也就是build方法会被触发。 children.add(_OverlayEntryWidget( key: entry._key, overlayState: this, entry: entry, tickerEnabled: false, )); } } // 到这里第一次build方法时，children变为[新页面（有屏障），根布局（有屏障）]，但是第二次build方法时，children变为[新页面（有屏障），根布局（无屏障）]，根布局屏障因为maintainState为false，所以被干掉了 // _Theater是Stack的特殊版本，不会布局和渲染第一个skipCount children。 // 第一个skipCount children被认为是“offstage（不在舞台，即幕后）” return _Theater( skipCount: children.length - onstageCount, clipBehavior: widget.clipBehavior, // 再次反转List，传入的children变为[根布局(无屏障)，新页面（有屏障）] children: children.reversed.toList(growable: false), ); } 3、等到动画状态变为AnimationStatus.completed时，会设置overlayEntries.first.opaque = opaque，将TransitionRoute的成员变量opaque赋值给新布局屏障OverlayEntry的opaque，因为子类PageRoute重写了opaque并赋值为true，那么，新布局屏障OverlayEntry的opaque为true。\n此时 _opaque 的值不相同，就会执行 _overlay?._didChangeEntryOpacity()，再次触发OverlayState的setState方法，接着build方法执行。\n4、此时build方法执行，因为新布局屏障OverlayEntry的opaque为true，当倒序遍历 _entries 时，遇到第一个opaque为true时，onstage会被修改为false，因此后续不再走 if (onstage) 逻辑，而是走 else if (entry.maintainState) 逻辑，根布局屏障因为maintainState为false，所以被干掉了。\n此时整个页面的情况如下。\n3.3、Navigator的pop方法 1 2 3 4 @optionalTypeArgs static void pop\u0026lt;T extends Object?\u0026gt;(BuildContext context, [ T? result ]) { Navigator.of(context).pop\u0026lt;T\u0026gt;(result); } Navigator的of方法前面讲过了，看下NavigatorState的pop方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @optionalTypeArgs void pop\u0026lt;T extends Object?\u0026gt;([ T? result ]) { ... // 获取_history中满足isPresentPredicate条件的最后一个元素（此处条件为present，也就是Route是存在的） final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate); // pageBased之前说过，和声明式相关，这里不会讲 if (entry.pageBased) { ... } else { // 所以执行这里 entry.pop\u0026lt;T\u0026gt;(result); assert (entry.currentState == _RouteLifecycle.pop); } // 此时currentState为_RouteLifecycle.pop，所以执行_flushHistoryUpdates，注意rearrangeOverlay为false if (entry.currentState == _RouteLifecycle.pop) { _flushHistoryUpdates(rearrangeOverlay: false); } ... } 看下 _RouteEntry 的pop方法。\n1 2 3 4 5 6 7 8 9 Object? pendingResult; void pop\u0026lt;T\u0026gt;(T? result) { assert(isPresent); // 将result保存为成员变量pendingResult，以备后续使用 pendingResult = result; // 修改currentState为_RouteLifecycle.pop currentState = _RouteLifecycle.pop; } 再看下NavigatorState的 _flushHistoryUpdates 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 void _flushHistoryUpdates({bool rearrangeOverlay = true}) { assert(_debugLocked \u0026amp;\u0026amp; !_debugUpdatingPage); _flushingHistory = true; int index = _history.length - 1; _RouteEntry? next; _RouteEntry? entry = _history[index]; _RouteEntry? previous = index \u0026gt; 0 ? _history[index - 1] : null; bool canRemoveOrAdd = false; // Whether there is a fully opaque route on top to silently remove or add route underneath. Route\u0026lt;dynamic\u0026gt;? poppedRoute; // The route that should trigger didPopNext on the top active route. bool seenTopActiveRoute = false; // Whether we\u0026#39;ve seen the route that would get didPopNext. final List\u0026lt;_RouteEntry\u0026gt; toBeDisposed = \u0026lt;_RouteEntry\u0026gt;[]; while (index \u0026gt;= 0) { switch (entry!.currentState) { case ... case _RouteLifecycle.pop: // 执行了_RouteEntry的handlePop方法 if (!entry.handlePop( navigator: this, previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route)){ assert(entry.currentState == _RouteLifecycle.idle); continue; } if (!seenTopActiveRoute) { if (poppedRoute != null) { entry.handleDidPopNext(poppedRoute); } poppedRoute = entry.route; } _observedRouteDeletions.add( _NavigatorPopObservation(entry.route, _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route), ); if (entry.currentState == _RouteLifecycle.dispose) { // The pop finished synchronously. This can happen if transition // duration is zero. continue; } assert(entry.currentState == _RouteLifecycle.popping); canRemoveOrAdd = true; case ... } index -= 1; next = entry; entry = previous; previous = index \u0026gt; 0 ? _history[index - 1] : null; } ... // 因为传入的rearrangeOverlay为false，所以这里不会执行 if (rearrangeOverlay) { overlay?.rearrange(_allRouteOverlayEntries); } ... } 看下 _RouteEntry的handlePop方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool handlePop({ required NavigatorState navigator, required Route\u0026lt;dynamic\u0026gt;? previousPresent }) { assert(navigator._debugLocked); assert(route._navigator == navigator); currentState = _RouteLifecycle.popping; // 此时状态不是isCompleted，这里不会执行 if (route._popCompleter.isCompleted) { // This is a page-based route popped through the Navigator.pop. The // didPop should have been called. No further action is needed. assert(pageBased); assert(pendingResult == null); return true; } // 执行Route的didPop方法，返回true if (!route.didPop(pendingResult)) { currentState = _RouteLifecycle.idle; return false; } // 将pendingResult置空，释放资源 pendingResult = null; // 最后返回true return true; } 看下Route的didPop方法，此时会先执行子类TransitionRoute的didPop方法。\n1 2 3 4 5 6 7 8 9 10 @override bool didPop(T? result) { assert(_controller != null, \u0026#39;$runtimeType.didPop called before calling install() or after calling dispose().\u0026#39;); assert(!_transitionCompleter.isCompleted, \u0026#39;Cannot reuse a $runtimeType after disposing it.\u0026#39;); _result = result; // 动画反向执行 _controller!.reverse(); // 执行父类的didPop方法 return super.didPop(result); } 看下父类OverlayRoute的didPop方法。\n1 2 3 4 5 6 7 8 9 10 11 12 @override bool didPop(T? result) { // 执行父类的didPop方法 final bool returnValue = super.didPop(result); assert(returnValue); // 此处finishedWhenPopped为false不会执行 if (finishedWhenPopped) { navigator!.finalizeRoute(this); } // 这里是父类didPop方法的返回值 return returnValue; } 看下父类Route的didPop方法。\n1 2 3 4 5 6 @mustCallSuper bool didPop(T? result) { // 执行了didComplete方法 didComplete(result); return true; } 看下Route的didComplete方法。\n1 2 3 4 5 6 7 8 9 // 当弹出此路由时（请参阅Navigator.pop ），如果未指定结果或结果为null，则将使用此值。 T? get currentResult =\u0026gt; null; @protected @mustCallSuper void didComplete(T? result) { // 将result结果返回给await push()方法 _popCompleter.complete(result ?? currentResult); } 前面TransitionRoute的didPop方法中执行了 _controller!.reverse() ，这里是启动了反向动画，那么TransitionRoute的 _handleStatusChanged 方法将会监听动画状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void _handleStatusChanged(AnimationStatus status) { switch (status) { case AnimationStatus.completed: ... case AnimationStatus.forward: case AnimationStatus.reverse: ... case AnimationStatus.dismissed: // 动画未开始 // We might still be an active route if a subclass is controlling the // transition and hits the dismissed status. For example, the iOS // back gesture drives this animation to the dismissed status before // removing the route and disposing it. // navigator上是否有该路由，此处是栈顶，必须有 if (!isActive) { navigator!.finalizeRoute(this); _popFinalized = true; _performanceModeRequestHandle?.dispose(); _performanceModeRequestHandle = null; } } } 再看下Navigator的finalizeRoute方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void finalizeRoute(Route\u0026lt;dynamic\u0026gt; route) { ... final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route)); final _RouteEntry entry = _history[index]; ... // 此处将currentState修改为_RouteLifecycle.dispose entry.finalize(); // 如果 pop 同步完成，则可以在 _flushHistoryUpdates 期间调用 FinalizeRoute。 // finalizeRoute can be called during _flushHistoryUpdates if a pop // finishes synchronously. if (!_flushingHistory) { // 再次执行_flushHistoryUpdates方法，rearrangeOverlay为false _flushHistoryUpdates(rearrangeOverlay: false); } assert(() { _debugLocked = wasDebugLocked!; return true; }()); } 看下NavigatorState的 _flushHistoryUpdates 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void _flushHistoryUpdates({bool rearrangeOverlay = true}) { assert(_debugLocked \u0026amp;\u0026amp; !_debugUpdatingPage); _flushingHistory = true; int index = _history.length - 1; _RouteEntry? next; _RouteEntry? entry = _history[index]; _RouteEntry? previous = index \u0026gt; 0 ? _history[index - 1] : null; bool canRemoveOrAdd = false; // Whether there is a fully opaque route on top to silently remove or add route underneath. Route\u0026lt;dynamic\u0026gt;? poppedRoute; // The route that should trigger didPopNext on the top active route. bool seenTopActiveRoute = false; // Whether we\u0026#39;ve seen the route that would get didPopNext. final List\u0026lt;_RouteEntry\u0026gt; toBeDisposed = \u0026lt;_RouteEntry\u0026gt;[]; while (index \u0026gt;= 0) { switch (entry!.currentState) { case ... case _RouteLifecycle.dispose: // Delay disposal until didChangeNext/didChangePrevious have been sent. // 将要删除的_RouteEntry添加进toBeDisposed toBeDisposed.add(_history.removeAt(index)); entry = next; case ... } index -= 1; next = entry; entry = previous; previous = index \u0026gt; 0 ? _history[index - 1] : null; } ... // Lastly, removes the overlay entries of all marked entries and disposes // them. for (final _RouteEntry entry in toBeDisposed) { // 执行_disposeRouteEntry方法，注意graceful传入了true _disposeRouteEntry(entry, graceful: true); } // 传入的rearrangeOverlay为false，此处不会执行 if (rearrangeOverlay) { overlay?.rearrange(_allRouteOverlayEntries); } ... } 看下NavigatorState的 _disposeRouteEntry 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) { // 遍历删除当前_RouteEntry所关联Route的所有overlayEntry for (final OverlayEntry overlayEntry in entry.route.overlayEntries) { overlayEntry.remove(); } if (graceful) { // 主要是执行route.dispose()，主要工作是销毁动画资源，以及遍历Route中的_overlayEntries，进行OverlayEntry资源清除 entry.dispose(); } else { entry.forcedDispose(); } } 看下OverlayEntry的remove方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void remove() { assert(_overlay != null); assert(!_disposedByOwner); final OverlayState overlay = _overlay!; _overlay = null; if (!overlay.mounted) { return; } // 在overlay的_entries中，删除当前的OverlayEntry overlay._entries.remove(this); if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) { SchedulerBinding.instance.addPostFrameCallback((Duration duration) { overlay._markDirty(); }); } else { // 执行overlay的_markDirty方法 overlay._markDirty(); } } 看下OverlayState的 _markDirty 方法，可以看到，实际上还是执行了setState方法来更新Overlay中的Widget。\n1 2 3 4 5 void _markDirty() { if (mounted) { setState(() {}); } } 3.4、根布局MaterialApp的home之创建 先来回顾一下根Navigator的声明地方，它是在 _WidgetsAppState 的build方法中声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 如果 window.defaultRouteName 不是 \u0026#39;/\u0026#39;，我们应该假设它是通过 `setInitialRoute` 有意设置的，并且应该覆盖 [widget.initialRoute] 中的任何内容。 // If window.defaultRouteName isn\u0026#39;t \u0026#39;/\u0026#39;, we should assume it was set // intentionally via `setInitialRoute`, and should override whatever is in // [widget.initialRoute]. // 如果特定平台的初始路由不是\u0026#39;/\u0026#39;时，以特定平台的初始路由为准。 // 如果特定平台的初始路由是\u0026#39;/\u0026#39;时，以Flutter中的initialRoute为准，但是如果Flutter中的initialRoute为null，那么依然以特定平台的初始路由为准，也就是\u0026#39;/\u0026#39;。 String get _initialRouteName =\u0026gt; WidgetsBinding.instance.platformDispatcher.defaultRouteName != Navigator.defaultRouteName ? WidgetsBinding.instance.platformDispatcher.defaultRouteName : widget.initialRoute ?? WidgetsBinding.instance.platformDispatcher.defaultRouteName; @override Widget build(BuildContext context) { Widget? routing; if (_usesRouterWithDelegates) { ... } else if (_usesNavigator) { assert(_navigator != null); routing = FocusScope( debugLabel: \u0026#39;Navigator Scope\u0026#39;, autofocus: true, child: Navigator( clipBehavior: Clip.none, restorationScopeId: \u0026#39;nav\u0026#39;, key: _navigator, // 此处调用成员变量_initialRouteName initialRoute: _initialRouteName, // 此处会调用_onGenerateRoute方法，后面会讲 onGenerateRoute: _onGenerateRoute, // 如果外部没传入onGenerateInitialRoutes，那么就会调用Navigator的defaultGenerateInitialRoutes方法，后面会讲 onGenerateInitialRoutes: widget.onGenerateInitialRoutes == null ? Navigator.defaultGenerateInitialRoutes : (NavigatorState navigator, String initialRouteName) { return widget.onGenerateInitialRoutes!(initialRouteName); }, // 此处会调用_onUnknownRoute方法，后面会讲 onUnknownRoute: _onUnknownRoute, observers: widget.navigatorObservers!, reportsRouteUpdateToEngine: true, ), ); } else if (_usesRouterWithConfig) { ... } return RootRestorationScope( restorationId: widget.restorationScopeId, child: ..., ); } 首先会执行NavigatorState的didChangeDependencies方法。\n1 2 3 4 5 6 7 8 9 @override void didChangeDependencies() { // 执行父类的didChangeDependencies方法 super.didChangeDependencies(); _updateHeroController(HeroControllerScope.maybeOf(context)); for (final _RouteEntry entry in _history) { entry.route.changedExternalState(); } } 因为NavigatorState混入了RestorationMixin，所以执行了RestorationMixin的didChangeDependencies方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @override void didChangeDependencies() { super.didChangeDependencies(); final RestorationBucket? oldBucket = _bucket; final bool needsRestore = restorePending; _currentParent = RestorationScope.maybeOf(context); final bool didReplaceBucket = _updateBucketIfNecessary(parent: _currentParent, restorePending: needsRestore); if (needsRestore) { // 执行这里 _doRestore(oldBucket); } if (didReplaceBucket) { assert(oldBucket != _bucket); oldBucket?.dispose(); } } 在RestorationMixin的didChangeDependencies方法中，执行了 _doRestore 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 void _doRestore(RestorationBucket? oldBucket) { assert(() { _debugPropertiesWaitingForReregistration = _properties.keys.toList(); return true; }()); // 执行这里 restoreState(oldBucket, _firstRestorePending); _firstRestorePending = false; ... } 在RestorationMixin的 _doRestore 方法中，执行了restoreState方法，这是一个空实现，由子类NavigatorState实现，看下NavigatorState的restoreState方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @override void restoreState(RestorationBucket? oldBucket, bool initialRestore) { registerForRestoration(_rawNextPagelessRestorationScopeId, \u0026#39;id\u0026#39;); registerForRestoration(_serializableHistory, \u0026#39;history\u0026#39;); // 删除旧历史记录中的所有内容并清除overlay。 // Delete everything in the old history and clear the overlay. _forcedDisposeAllRouteEntries(); assert(_history.isEmpty); // _overlayKey延迟到这里才创建 _overlayKey = GlobalKey\u0026lt;OverlayState\u0026gt;(); // 从恢复数据填充新历史记录。 // 此处因为是根布局初始化，所以没有数据可恢复，_history添加了个寂寞 // Populate the new history from restoration data. _history.addAll(_serializableHistory.restoreEntriesForPage(null, this)); // 这是声明式的范畴，不会讲 for (final Page\u0026lt;dynamic\u0026gt; page in widget.pages) { final _RouteEntry entry = _RouteEntry( page.createRoute(context), pageBased: true, initialState: _RouteLifecycle.add, ); assert( entry.route.settings == page, \u0026#39;The settings getter of a page-based Route must return a Page object. \u0026#39; \u0026#39;Please set the settings to the Page in the Page.createRoute method.\u0026#39;, ); _history.add(entry); _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this)); } // 如果没有什么可恢复的，我们需要处理初始路由。 // 所以执行这里 // If there was nothing to restore, we need to process the initial route. if (!_serializableHistory.hasData) { // 获取传入的initialRoute String? initialRoute = widget.initialRoute; // widget.pages为空，说明采用命令式方案 if (widget.pages.isEmpty) { // 如果传入的initialRoute为null，取默认值为\u0026#39;/\u0026#39;，否则不变 // 本示例中是没有设置initialRoute的，所以取默认值为\u0026#39;/\u0026#39; initialRoute = initialRoute ?? Navigator.defaultRouteName; } if (initialRoute != null) { // 将onGenerateInitialRoutes返回的List\u0026lt;Route\u0026gt;转换为List\u0026lt;_RouteEntry\u0026gt;，然后添加进_history中 _history.addAll( widget.onGenerateInitialRoutes( this, // 如果传入的initialRoute为null，取默认值为\u0026#39;/\u0026#39; widget.initialRoute ?? Navigator.defaultRouteName, ).map((Route\u0026lt;dynamic\u0026gt; route) =\u0026gt; _RouteEntry( route, // 表示非声明式 pageBased: false, // 初始状态为_RouteLifecycle.add initialState: _RouteLifecycle.add, restorationInformation: route.settings.name != null ? _RestorationInformation.named( name: route.settings.name!, arguments: null, restorationScopeId: _nextPagelessRestorationScopeId, ) : null, ), ), ); } } ... // 最后执行_flushHistoryUpdates方法，之前讲过该方法会调用setState来刷新UI _flushHistoryUpdates(); assert(() { _debugLocked = false; return true; }()); } 之前讲过，如果外部没传入onGenerateInitialRoutes，那么就会调用Navigator的defaultGenerateInitialRoutes方法，本示例的确没传入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // 此处传入的initialRouteName为：如果传入的initialRoute为null，取默认值为\u0026#39;/\u0026#39; // 本示例没有设置initialRoute，所以取默认值为\u0026#39;/\u0026#39; static List\u0026lt;Route\u0026lt;dynamic\u0026gt;\u0026gt; defaultGenerateInitialRoutes(NavigatorState navigator, String initialRouteName) { // 创建一个List\u0026lt;Route\u0026gt; final List\u0026lt;Route\u0026lt;dynamic\u0026gt;?\u0026gt; result = \u0026lt;Route\u0026lt;dynamic\u0026gt;?\u0026gt;[]; // 如果initialRouteName以\u0026#39;/\u0026#39;开始，并且字符串长度大于1时 if (initialRouteName.startsWith(\u0026#39;/\u0026#39;) \u0026amp;\u0026amp; initialRouteName.length \u0026gt; 1) { // 截取\u0026#39;/\u0026#39;之后的字符串作为initialRouteName，比如/A/B/C变为A/B/C initialRouteName = initialRouteName.substring(1); // strip leading \u0026#39;/\u0026#39; ... // 执行navigator的_routeNamed方法创建Route，添加进result，这里的第一个Route命名为\u0026#39;/\u0026#39; // 此处添加进来的Route就是home了 result.add(navigator._routeNamed\u0026lt;dynamic\u0026gt;(Navigator.defaultRouteName, arguments: null, allowNull: true)); // 如果你的initialRouteName是这种形式：a/b/c，那么根据\u0026#39;/\u0026#39;进行分解[a, b, c] final List\u0026lt;String\u0026gt; routeParts = initialRouteName.split(\u0026#39;/\u0026#39;); if (initialRouteName.isNotEmpty) { String routeName = \u0026#39;\u0026#39;; for (final String part in routeParts) { // routeName变为这种形式：/a , /a/b，/a/b/c routeName += \u0026#39;/$part\u0026#39;; ... // 执行navigator的_routeNamed方法创建Route，添加进result result.add(navigator._routeNamed\u0026lt;dynamic\u0026gt;(routeName, arguments: null, allowNull: true)); } } // 如果List\u0026lt;Route\u0026gt;中最后一个元素为null，报错 // 如果你没有配置路由表，那么是找不到/a , /a/b，/a/b/c这些路由的，所以返回为null if (result.last == null) { ... // 清空List\u0026lt;Route\u0026gt; result.clear(); } } else if (initialRouteName != Navigator.defaultRouteName) { // 如果initialRouteName不是\u0026#39;/\u0026#39;，那么我们尝试使用allowNull:true来获取它，这样如果失败，我们就会回退到\u0026#39;/\u0026#39;（没有allowNull:true，见下文）。 // 如果initialRouteName不存在于路由表，那么Route会返回null // If initialRouteName wasn\u0026#39;t \u0026#39;/\u0026#39;, then we try to get it with allowNull:true, so that if that fails, // we fall back to \u0026#39;/\u0026#39; (without allowNull:true, see below). result.add(navigator._routeNamed\u0026lt;dynamic\u0026gt;(initialRouteName, arguments: null, allowNull: true)); } // 空路由可能是由于initialRouteName中的间隙造成的 // Null route might be a result of gap in initialRouteName // // 例如，routes = [\u0026#39;A\u0026#39;, \u0026#39;A/B/C\u0026#39;], 且initialRouteName = \u0026#39;A/B/C\u0026#39; 这应导致 result = [\u0026#39;A\u0026#39;, null,\u0026#39;A/B/C\u0026#39;]，其中 \u0026#39;A/B\u0026#39; 生成null。在本例中，我们要过滤掉 null 并返回 result = [\u0026#39;A\u0026#39;, \u0026#39;A/B/C\u0026#39;]。 // For example, routes = [\u0026#39;A\u0026#39;, \u0026#39;A/B/C\u0026#39;], and initialRouteName = \u0026#39;A/B/C\u0026#39; // This should result in result = [\u0026#39;A\u0026#39;, null,\u0026#39;A/B/C\u0026#39;] where \u0026#39;A/B\u0026#39; produces // the null. In this case, we want to filter out the null and return // result = [\u0026#39;A\u0026#39;, \u0026#39;A/B/C\u0026#39;]. // 当解析initialRouteName为A/B/C时，A/B在路由表中没有配置，就会造成Route为null，这里要移除List\u0026lt;Route\u0026gt;中null的情况 result.removeWhere((Route\u0026lt;dynamic\u0026gt;? route) =\u0026gt; route == null); // 如果List\u0026lt;Route\u0026gt;依然为空 if (result.isEmpty) { // 执行navigator的_routeNamed方法创建Route，添加进result，name为\u0026#39;/\u0026#39; // 本示例会执行这里，此处添加进来的Route就是home了 result.add(navigator._routeNamed\u0026lt;dynamic\u0026gt;(Navigator.defaultRouteName, arguments: null)); } return result.cast\u0026lt;Route\u0026lt;dynamic\u0026gt;\u0026gt;(); } 看下NavigatorState的 _routeNamed 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 Route\u0026lt;T?\u0026gt;? _routeNamed\u0026lt;T\u0026gt;(String name, { required Object? arguments, bool allowNull = false }) { assert(!_debugLocked); // 如果allowNull为true，并且外部没设置onGenerateRoute时，Route直接返回null // 当然在本示例中，根布局内部已有Navigator，会有一个默认的_onGenerateRoute方法，这里不会执行 // 如果你是自己添加的Navigator，就需要考虑onGenerateRoute为null的情况 if (allowNull \u0026amp;\u0026amp; widget.onGenerateRoute == null) { return null; } assert(() { if (widget.onGenerateRoute == null) { throw FlutterError( \u0026#39;Navigator.onGenerateRoute was null, but the route named \u0026#34;$name\u0026#34; was referenced.\\n\u0026#39; \u0026#39;To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or \u0026#39; \u0026#39;pushNamedAndRemoveUntil), the Navigator must be provided with an \u0026#39; \u0026#39;onGenerateRoute handler.\\n\u0026#39; \u0026#39;The Navigator was:\\n\u0026#39; \u0026#39; $this\u0026#39;, ); } return true; }()); final RouteSettings settings = RouteSettings( name: name, arguments: arguments, ); // 执行外部传入的onGenerateRoute方法，这里调用了默认的_onGenerateRoute方法 Route\u0026lt;T?\u0026gt;? route = widget.onGenerateRoute!(settings) as Route\u0026lt;T?\u0026gt;?; // 如果Route为null，并且allowNull为false if (route == null \u0026amp;\u0026amp; !allowNull) { assert(() { if (widget.onUnknownRoute == null) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Navigator.onGenerateRoute returned null when requested to build route \u0026#34;$name\u0026#34;.\u0026#39;), ErrorDescription( \u0026#39;The onGenerateRoute callback must never return null, unless an onUnknownRoute \u0026#39; \u0026#39;callback is provided as well.\u0026#39;, ), DiagnosticsProperty\u0026lt;NavigatorState\u0026gt;(\u0026#39;The Navigator was\u0026#39;, this, style: DiagnosticsTreeStyle.errorProperty), ]); } return true; }()); // 执行外部传入的onUnknownRoute方法，这里调用了默认的_onUnknownRoute方法 route = widget.onUnknownRoute!(settings) as Route\u0026lt;T?\u0026gt;?; assert(() { if (route == null) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Navigator.onUnknownRoute returned null when requested to build route \u0026#34;$name\u0026#34;.\u0026#39;), ErrorDescription(\u0026#39;The onUnknownRoute callback must never return null.\u0026#39;), DiagnosticsProperty\u0026lt;NavigatorState\u0026gt;(\u0026#39;The Navigator was\u0026#39;, this, style: DiagnosticsTreeStyle.errorProperty), ]); } return true; }()); } assert(route != null || allowNull); return route; } 看下 _WidgetsAppState的 _onGenerateRoute 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Route\u0026lt;dynamic\u0026gt;? _onGenerateRoute(RouteSettings settings) { final String? name = settings.name; // 如果你的Route的name是\u0026#39;/\u0026#39;，那么包装widget.home为WidgetBuilder // 如果你的Route的name不是\u0026#39;/\u0026#39;或者widget.home为空，那么从路由表中获取name对应的WidgetBuilder final WidgetBuilder? pageContentBuilder = name == Navigator.defaultRouteName \u0026amp;\u0026amp; widget.home != null ? (BuildContext context) =\u0026gt; widget.home! : widget.routes![name]; if (pageContentBuilder != null) { assert( widget.pageRouteBuilder != null, \u0026#39;The default onGenerateRoute handler for WidgetsApp must have a \u0026#39; \u0026#39;pageRouteBuilder set if the home or routes properties are set.\u0026#39;, ); // 在_MaterialAppState中，WidgetsApp传入的pageRouteBuilder实际上是创建了MaterialPageRoute final Route\u0026lt;dynamic\u0026gt; route = widget.pageRouteBuilder!\u0026lt;dynamic\u0026gt;( settings, pageContentBuilder, ); return route; } // 如果你的Route的name不是\u0026#39;/\u0026#39;并且路由表也没有配置该name，就会执行这里 if (widget.onGenerateRoute != null) { return widget.onGenerateRoute!(settings); } // 如果没有设置onGenerateRoute兜底，最后Route返回null return null; } 看下 _WidgetsAppState的 _onUnknownRoute 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Route\u0026lt;dynamic\u0026gt; _onUnknownRoute(RouteSettings settings) { assert(() { if (widget.onUnknownRoute == null) { throw FlutterError( \u0026#39;Could not find a generator for route $settings in the $runtimeType.\\n\u0026#39; \u0026#39;Make sure your root app widget has provided a way to generate \\n\u0026#39; \u0026#39;this route.\\n\u0026#39; \u0026#39;Generators for routes are searched for in the following order:\\n\u0026#39; \u0026#39; 1. For the \u0026#34;/\u0026#34; route, the \u0026#34;home\u0026#34; property, if non-null, is used.\\n\u0026#39; \u0026#39; 2. Otherwise, the \u0026#34;routes\u0026#34; table is used, if it has an entry for \u0026#39; \u0026#39;the route.\\n\u0026#39; \u0026#39; 3. Otherwise, onGenerateRoute is called. It should return a \u0026#39; \u0026#39;non-null value for any valid route not handled by \u0026#34;home\u0026#34; and \u0026#34;routes\u0026#34;.\\n\u0026#39; \u0026#39; 4. Finally if all else fails onUnknownRoute is called.\\n\u0026#39; \u0026#39;Unfortunately, onUnknownRoute was not set.\u0026#39;, ); } return true; }()); // 执行外部传入的onUnknownRoute方法 final Route\u0026lt;dynamic\u0026gt;? result = widget.onUnknownRoute!(settings); assert(() { if (result == null) { throw FlutterError( \u0026#39;The onUnknownRoute callback returned null.\\n\u0026#39; \u0026#39;When the $runtimeType requested the route $settings from its \u0026#39; \u0026#39;onUnknownRoute callback, the callback returned null. Such callbacks \u0026#39; \u0026#39;must never return null.\u0026#39;, ); } return true; }()); return result!; } 3.5、Navigator的pushNamed方法 1 2 3 4 5 6 7 @optionalTypeArgs Future\u0026lt;T?\u0026gt; pushNamed\u0026lt;T extends Object?\u0026gt;( String routeName, { Object? arguments, }) { return push\u0026lt;T?\u0026gt;(_routeNamed\u0026lt;T\u0026gt;(routeName, arguments: arguments)!); } _routeNamed 方法返回一个Route对象，push方法和之前一样的逻辑，这里就不分析了，至于其它的Navigator的方法相信你也能举一反三。\n","date":"2023-11-19T09:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bnavigator%E5%91%BD%E4%BB%A4%E5%BC%8F/","section":"post","tags":null,"title":"解读Flutter源码之Navigator（命令式）"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在之前解读Flutter源码之Listener一文中，我们已经知道Listener用来监听原始指针事件，它的事件处理流程分为命中测试-事件分发-事件清理三部分。\n而本文所讲的GestureDetector，它的内部实际上是对Listener的进一步封装，用以识别语义化的手势。相较于Listener，GestureDetector还会涉及手势冲突，那么相应地就需要了解如何去解决手势冲突。\n二、什么是GestureDetector？ 遇事不决，先来看下GestureDetector的注释\u0026amp;部分源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 /// 检测手势的widget。 /// A widget that detects gestures. /// /// 尝试识别与其非空回调相对应的手势。 /// Attempts to recognize gestures that correspond to its non-null callbacks. /// /// 如果此widget有一个child，它将遵循该child的大小调整行为。 /// 如果它没有child，它就会成长以适应parent。 /// If this widget has a child, it defers to that child for its sizing behavior. /// If it does not have a child, it grows to fit the parent instead. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=WhVXkCFPmK4} /// /// 默认情况下，具有不可见子项的 GestureDetector 会忽略触摸；这种行为可以通过[行为]来控制。 /// By default a GestureDetector with an invisible child ignores touches; /// this behavior can be controlled with [behavior]. /// /// GestureDetector 还侦听辅助功能事件并将它们映射到回调。 /// 要忽略辅助功能事件，请将 [excludeFromSemantics] 设置为 true。 /// GestureDetector also listens for accessibility events and maps /// them to the callbacks. To ignore accessibility events, set /// [excludeFromSemantics] to true. /// /// See \u0026lt;http://flutter.dev/gestures/\u0026gt; for additional information. /// /// Material design应用程序通常会对触摸做出反应，并产生墨水飞溅效果。 /// [InkWell] 类实现了此效果，并且可以用来代替 [GestureDetector] 来处理点击。 /// Material design applications typically react to touches with ink splash /// effects. The [InkWell] class implements this effect and can be used in place /// of a [GestureDetector] for handling taps. /// /// {@tool dartpad} /// 此示例包含一个包裹在 [GestureDetector] 中的黑灯泡。 /// 通过设置 `_lights` 字段，当点击“打开灯”按钮时，灯泡会变成黄色，而当点击“关闭灯”时，灯泡会再次关闭。 /// This example contains a black light bulb wrapped in a [GestureDetector]. It /// turns the light bulb yellow when the \u0026#34;TURN LIGHT ON\u0026#34; button is tapped by /// setting the `_lights` field, and off again when \u0026#34;TURN LIGHT OFF\u0026#34; is tapped. /// /// ** See code in examples/api/lib/widgets/gesture_detector/gesture_detector.0.dart ** /// {@end-tool} /// /// {@tool dartpad} /// 此示例使用 [Container] 包装 [GestureDetector]，用于检测点击。 /// This example uses a [Container] that wraps a [GestureDetector] widget which /// detects a tap. /// /// 由于 [GestureDetector] 没有child，因此它采用其父项的大小，从而使周围 [Container] 的整个区域都可单击。 /// 点击时，[Container] 通过设置 `_color` 字段变成黄色。再次点击时，它会变回白色。 /// Since the [GestureDetector] does not have a child, it takes on the size of its /// parent, making the entire area of the surrounding [Container] clickable. When /// tapped, the [Container] turns yellow by setting the `_color` field. When /// tapped again, it goes back to white. /// /// ** See code in examples/api/lib/widgets/gesture_detector/gesture_detector.1.dart ** /// {@end-tool} /// /// ### 故障排除 /// ### Troubleshooting /// /// 为什么我的父 [GestureDetector.onTap] 方法没有被调用？ /// Why isn\u0026#39;t my parent [GestureDetector.onTap] method called? /// /// 给定具有 onTap 回调的父 [GestureDetector] 和也定义 onTap 回调的子 GestureDetector，当点击内部 GestureDetector 时，两个 GestureDetector 都会向手势区域发送 [GestureRecognizer]。 /// 这是因为指针坐标位于两个手势检测器的范围内。 /// 在这种情况下，子 GestureDetector 获胜，因为它是第一个进入竞技场的，解决了先到先得的问题。 /// 子级的 onTap 被调用，而父级的 onTap 则没有，因为手势已被消耗。 /// Given a parent [GestureDetector] with an onTap callback, and a child /// GestureDetector that also defines an onTap callback, when the inner /// GestureDetector is tapped, both GestureDetectors send a [GestureRecognizer] /// into the gesture arena. This is because the pointer coordinates are within the /// bounds of both GestureDetectors. The child GestureDetector wins in this /// scenario because it was the first to enter the arena, resolving as first come, /// first served. The child onTap is called, and the parent\u0026#39;s is not as the gesture has /// been consumed. /// For more information on gesture disambiguation see: /// [Gesture disambiguation](https://docs.flutter.dev/development/ui/advanced/gestures#gesture-disambiguation). /// /// 将 [GestureDetector.behavior] 设置为 [HitTestBehavior.opaque] 或 [HitTestBehavior.translucent] 对父子关系没有影响： /// 两个 GestureDetector 都将 GestureRecognizer 发送到手势竞技场，只有一个获胜。 /// Setting [GestureDetector.behavior] to [HitTestBehavior.opaque] /// or [HitTestBehavior.translucent] has no impact on parent-child relationships: /// both GestureDetectors send a GestureRecognizer into the gesture arena, only one wins. /// /// 一些回调（例如 onTapDown）可以在识别器赢得竞技场之前触发，而其它回调（例如 onTapCancel）即使在失去竞技场时也会触发。 /// 因此，上例中的父检测器可能会调用它的一些回调，即使它在竞技场中失败。 /// Some callbacks (e.g. onTapDown) can fire before a recognizer wins the arena, /// and others (e.g. onTapCancel) fire even when it loses the arena. Therefore, /// the parent detector in the example above may call some of its callbacks even /// though it loses in the arena. /// /// {@tool dartpad} /// 此示例使用包装绿色 [Container] 的 [GestureDetector] 和包装黄色容器的第二个 GestureDetector。 /// 第二个 GestureDetector 是绿色 Container 的子级。 /// 两个 GestureDetector 都定义了 onTap 回调。当调用回调时，它会向相应的容器添加红色边框。 /// This example uses a [GestureDetector] that wraps a green [Container] and a second /// GestureDetector that wraps a yellow Container. The second GestureDetector is /// a child of the green Container. /// Both GestureDetectors define an onTap callback. When the callback is called it /// adds a red border to the corresponding Container. /// /// 当点击绿色容器时，它的父 GestureDetector 进入手势区域。 /// 它获胜是因为没有竞争的 GestureDetector 并且绿色容器显示红色边框。 /// When the green Container is tapped, it\u0026#39;s parent GestureDetector enters /// the gesture arena. It wins because there is no competing GestureDetector and /// the green Container shows a red border. /// 当点击黄色容器时，它的父 GestureDetector 进入手势区域。 /// 包裹绿色容器的 GestureDetector 也进入手势区域（指针事件坐标位于两个 GestureDetector 边界内）。 /// 包裹黄色容器的 GestureDetector 获胜，因为它是第一个进入竞技场的检测器。 /// When the yellow Container is tapped, it\u0026#39;s parent GestureDetector enters /// the gesture arena. The GestureDetector that wraps the green Container also /// enters the gesture arena (the pointer events coordinates are inside both /// GestureDetectors bounds). The GestureDetector that wraps the yellow Container /// wins because it was the first detector to enter the arena. /// /// 此示例将 [debugPrintGestureArenaDiagnostics] 设置为 true。该标志打印有关手势区域的有用信息。 /// This example sets [debugPrintGestureArenaDiagnostics] to true. /// This flag prints useful information about gesture arenas. /// /// 将 [GestureDetector.behavior] 属性更改为 [HitTestBehavior.translucent] 或 [HitTestBehavior.opaque] 没有影响：两个 GestureDetector 都将 [GestureRecognizer] 发送到手势区域，只有一个获胜。 /// Changing the [GestureDetector.behavior] property to [HitTestBehavior.translucent] /// or [HitTestBehavior.opaque] has no impact: both GestureDetectors send a [GestureRecognizer] /// into the gesture arena, only one wins. /// /// ** See code in examples/api/lib/widgets/gesture_detector/gesture_detector.2.dart ** /// {@end-tool} /// /// ## 调试 /// ## Debugging /// /// 要查看 [GestureDetector] 的命中测试框有多大以进行调试，请将 [debugPaintPointersEnabled] 设置为 true。 /// To see how large the hit test box of a [GestureDetector] is for debugging /// purposes, set [debugPaintPointersEnabled] to true. class GestureDetector extends StatelessWidget { GestureDetector({ super.key, this.child, this.onTapDown, this.onTapUp, this.onTap, this.onTapCancel, this.onSecondaryTap, this.onSecondaryTapDown, this.onSecondaryTapUp, this.onSecondaryTapCancel, this.onTertiaryTapDown, this.onTertiaryTapUp, this.onTertiaryTapCancel, this.onDoubleTapDown, this.onDoubleTap, this.onDoubleTapCancel, this.onLongPressDown, this.onLongPressCancel, this.onLongPress, this.onLongPressStart, this.onLongPressMoveUpdate, this.onLongPressUp, this.onLongPressEnd, this.onSecondaryLongPressDown, this.onSecondaryLongPressCancel, this.onSecondaryLongPress, this.onSecondaryLongPressStart, this.onSecondaryLongPressMoveUpdate, this.onSecondaryLongPressUp, this.onSecondaryLongPressEnd, this.onTertiaryLongPressDown, this.onTertiaryLongPressCancel, this.onTertiaryLongPress, this.onTertiaryLongPressStart, this.onTertiaryLongPressMoveUpdate, this.onTertiaryLongPressUp, this.onTertiaryLongPressEnd, this.onVerticalDragDown, this.onVerticalDragStart, this.onVerticalDragUpdate, this.onVerticalDragEnd, this.onVerticalDragCancel, this.onHorizontalDragDown, this.onHorizontalDragStart, this.onHorizontalDragUpdate, this.onHorizontalDragEnd, this.onHorizontalDragCancel, this.onForcePressStart, this.onForcePressPeak, this.onForcePressUpdate, this.onForcePressEnd, this.onPanDown, this.onPanStart, this.onPanUpdate, this.onPanEnd, this.onPanCancel, this.onScaleStart, this.onScaleUpdate, this.onScaleEnd, this.behavior, this.excludeFromSemantics = false, this.dragStartBehavior = DragStartBehavior.start, this.trackpadScrollCausesScale = false, this.trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor, this.supportedDevices, }) : assert(() { final bool haveVerticalDrag = onVerticalDragStart != null || onVerticalDragUpdate != null || onVerticalDragEnd != null; final bool haveHorizontalDrag = onHorizontalDragStart != null || onHorizontalDragUpdate != null || onHorizontalDragEnd != null; final bool havePan = onPanStart != null || onPanUpdate != null || onPanEnd != null; final bool haveScale = onScaleStart != null || onScaleUpdate != null || onScaleEnd != null; if (havePan || haveScale) { if (havePan \u0026amp;\u0026amp; haveScale) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Incorrect GestureDetector arguments.\u0026#39;), ErrorDescription( \u0026#39;Having both a pan gesture recognizer and a scale gesture recognizer is redundant; scale is a superset of pan.\u0026#39;, ), ErrorHint(\u0026#39;Just use the scale gesture recognizer.\u0026#39;), ]); } final String recognizer = havePan ? \u0026#39;pan\u0026#39; : \u0026#39;scale\u0026#39;; if (haveVerticalDrag \u0026amp;\u0026amp; haveHorizontalDrag) { throw FlutterError( \u0026#39;Incorrect GestureDetector arguments.\\n\u0026#39; \u0026#39;Simultaneously having a vertical drag gesture recognizer, a horizontal drag gesture recognizer, and a $recognizer gesture recognizer \u0026#39; \u0026#39;will result in the $recognizer gesture recognizer being ignored, since the other two will catch all drags.\u0026#39;, ); } } return true; }()); } 可以看到，GestureDetector是一个StatelessWidget，当你传入了非空回调，那么它会尝试识别与其非空回调相对应的手势。在注释中，GestureDetector也为开发者提供了好几个示例，这里就不分析了，感兴趣的可以自行研究。\nGestureDetector设计了丰富的手势监听回调，这里列出几个较为常见的。\nGestureDetector回调 说明 onTap 发生了对主按钮的点击。当点击手势获胜时会触发此操作。如果点击手势没有成功，则会调用onTapCancel onTapDown 可能导致点击主按钮的指针已接触到屏幕的特定位置。即使尚未选择获胜手势，也会在短暂的超时后调用此方法。如果点击手势获胜，将调用onTapUp ，否则将调用onTapCancel onTapUp 将触发主按钮点击的指针已停止在特定位置接触屏幕。如果点击手势获胜，则会在onTap之前立即触发。如果点击手势没有成功，则会调用onTapCancel onTapCancel 先前触发onTapDown的指针最终不会导致点击。如果点击手势未获胜，则在onTapDown之后调用，而不是onTapUp和onTap onDoubleTap 用户在同一位置快速连续点击主按钮两次 onDoubleTapDown 可能导致双击的指针已接触屏幕的特定位置。在第二次点击的向下事件后立即触发。如果用户完成双击并且手势获胜，则在此回调之后将调用onDoubleTap。否则， onDoubleTapCancel将在此回调后调用 onDoubleTapCancel 之前触发onDoubleTapDown的指针最终不会导致双击 onLongPress 当识别到主按钮的长按手势时调用。当指针长时间与屏幕同一位置保持接触时触发。这相当于（并在之后立即调用） onLongPressStart。两者之间的唯一区别是此回调不包含指针最初接触屏幕的位置的详细信息。 onLongPressDown 指针已通过主按钮接触屏幕，这可能是长按的开始。这在指针向下事件后触发。如果用户完成长按，并且该手势获胜，则在此回调后将调用onLongPressStart。否则， onLongPressCancel将在该回调之后被调用 onLongPressUp 触发主按钮长按的指针已停止接触屏幕。这相当于（并在之后立即调用） onLongPressEnd。两者之间的唯一区别是，此回调不包含指针停止接触屏幕时的状态详细信息 onLongPressCancel 先前触发onLongPressDown的指针最终不会导致长按。如果先前已触发onLongPressDown则一旦手势丢失，就会触发此操作。如果用户完成了长按，并且手势获胜，则调​​用onLongPressStart和onLongPress。 onLongPressStart 当识别到主按钮的长按手势时调用。当指针长时间与屏幕同一位置保持接触时触发。这相当于（并在之前调用） onLongPress。两者之间的唯一区别是，此回调包含指针最初接触屏幕的位置的详细信息，而onLongPress则不包含 onLongPressMoveUpdate 长按主按钮后，指针已被拖动移动 onLongPressEnd 触发主按钮长按的指针已停止接触屏幕。这相当于（并在之前调用） onLongPressUp。两者之间的唯一区别是，此回调包含指针停止接触屏幕时的状态详细信息，而onLongPressUp则不包含 onVerticalDragDown 指针已通过主按钮接触屏幕，并且可能开始垂直移动 onVerticalDragStart 指针已通过主按钮接触屏幕并开始垂直移动 onVerticalDragUpdate 通过主按钮与屏幕接触并垂直移动的指针已沿垂直方向移动 onVerticalDragEnd 之前通过主按钮与屏幕接触并垂直移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 onVerticalDragCancel 之前触发onVerticalDragDown的指针没有完成 onHorizontalDragDown 指针已通过主按钮接触屏幕，并且可能开始水平移动 onHorizontalDragStart 指针已通过主按钮接触屏幕并开始水平移动 onHorizontalDragUpdate 通过主按钮与屏幕接触并水平移动的指针已沿水平方向移动 onHorizontalDragEnd 之前通过主按钮与屏幕接触并水平移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 onHorizontalDragCancel 先前触发onHorizontalDragDown的指针未完成 onPanDown 指针已通过主按钮接触屏幕并可能开始移动 onPanStart 指针已与主按钮接触到屏幕并开始移动 onPanUpdate 通过主按钮与屏幕接触并移动的指针已再次移动 onPanEnd 之前通过主按钮与屏幕接触并移动的指针不再与屏幕接触，并且在停止接触屏幕时以特定速度移动 onPanCancel 先前触发onPanDown的指针未完成 \u0026hellip; \u0026hellip; 有的回调包含了指针最初接触屏幕的位置的详细信息，例如onTapDown\u0026amp;onDoubleTapDown回调，TapDownDetails是GestureTapDownCallback的详细信息。\nTapDownDetails属性 说明 globalPosition 指针接触屏幕的全局位置 kind 发起事件的设备类型 localPosition 指针接触屏幕的本地位置 三、GestureDetector示例 为了便于分析，在GestureDetector示例中丢弃了runApp方法带来的一个View结构（在实际项目中不能这样做），具体分析看解读Flutter源码之runApp一文。\n程序运行起来后，通过Flutter Inspector查看Widget层次结构如下所示。\n对应的代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void main() { // 输出手势竞技场的相关日志，用于跟踪手势竞争的执行逻辑 debugPrintGestureArenaDiagnostics = true; _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return GestureDetector( child: GestureDetector( child: const ColoredBox(color: Colors.blueAccent), onTap: () =\u0026gt; debugPrint(\u0026#39;inner onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;inner onTapCancel\u0026#39;), ), onTap: () =\u0026gt; debugPrint(\u0026#39;outer onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;outer onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;outer onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;outer onTapCancel\u0026#39;), ); } } 当在屏幕上点击时，打印的日志如下：\n1 2 3 I/flutter (22965): inner onTapDown I/flutter (22965): inner onTapUp I/flutter (22965): inner onTap 从日志可以知道，为什么父GestureDetector的onTapDown等回调方法没有被调用呢？这里先给出大概的答案，后面再结合源码进行详细分析。\n给定具有onTapDown回调的父GestureDetector和也定义了onTapDown回调的子 GestureDetector，当点击内部GestureDetector时，两个GestureDetector都会向手势区域发送GestureRecognizer，这是因为指针坐标位于两个手势检测器的范围内。\n在这种情况下，子GestureDetector获胜，因为它是第一个进入竞技场的，解决了先到先得的问题。因此，子级的onTapDown被调用，而父级的onTapDown则没有，因为手势已被消耗。\n四、源码分析 4.1、GestureDetector的build方法 看下GestureDetector的build方法，可以发现它通过GestureRecognizerFactory工厂类定义了GestureRecognizer的创建方法 _constructor 与初始化方法 _initializer，然后把新创建的GestureRecognizerFactoryWithHandlers实例放入gestures这个Map中保存。\n当GestureRecognizerFactoryWithHandlers执行初始化方法时，GestureRecognizer就会持有外部传入的回调方法，例如TapGestureRecognizer持有onTapDown回调方法。\n最后，build方法返回了RawGestureDetector组件，gestures也作为参数传入了RawGestureDetector组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @override Widget build(BuildContext context) { final Map\u0026lt;Type, GestureRecognizerFactory\u0026gt; gestures = \u0026lt;Type, GestureRecognizerFactory\u0026gt;{}; final DeviceGestureSettings? gestureSettings = MediaQuery.maybeGestureSettingsOf(context); if (onTapDown != null || onTapUp != null || onTap != null || onTapCancel != null || onSecondaryTap != null || onSecondaryTapDown != null || onSecondaryTapUp != null || onSecondaryTapCancel != null|| onTertiaryTapDown != null || onTertiaryTapUp != null || onTertiaryTapCancel != null ) { // GestureRecognizerFactoryWithHandlers是GestureRecognizerFactory子类，所以可以赋值 gestures[TapGestureRecognizer] = GestureRecognizerFactoryWithHandlers\u0026lt;TapGestureRecognizer\u0026gt;( () =\u0026gt; TapGestureRecognizer(debugOwner: this, supportedDevices: supportedDevices), (TapGestureRecognizer instance) { // TapGestureRecognizer持有了外部传入的回调方法实例，例如*onTapDown*方法 instance ..onTapDown = onTapDown ..onTapUp = onTapUp ..onTap = onTap ..onTapCancel = onTapCancel ..onSecondaryTap = onSecondaryTap ..onSecondaryTapDown = onSecondaryTapDown ..onSecondaryTapUp = onSecondaryTapUp ..onSecondaryTapCancel = onSecondaryTapCancel ..onTertiaryTapDown = onTertiaryTapDown ..onTertiaryTapUp = onTertiaryTapUp ..onTertiaryTapCancel = onTertiaryTapCancel ..gestureSettings = gestureSettings ..supportedDevices = supportedDevices; }, ); } ... // 返回RawGestureDetector组件，gestures作为参数传入 return RawGestureDetector( gestures: gestures, behavior: behavior, excludeFromSemantics: excludeFromSemantics, child: child, ); } RawGestureDetector是一个StatefulWidget，它创建了RawGestureDetectorState，看下该State的initState方法。\n可以发现，在initState方法中执行了 _syncAll 方法，传入了GestureDetector的build方法中创建的gestures集合。\n1 2 3 4 5 6 7 8 9 10 11 12 class RawGestureDetectorState extends State\u0026lt;RawGestureDetector\u0026gt; { // 定义手势识别器Map集合 Map\u0026lt;Type, GestureRecognizer\u0026gt;? _recognizers = const \u0026lt;Type, GestureRecognizer\u0026gt;{}; SemanticsGestureDelegate? _semantics; @override void initState() { super.initState(); _semantics = widget.semantics ?? _DefaultSemanticsGestureDelegate(this); _syncAll(widget.gestures); } } 看下RawGestureDetectorState的 _syncAll 方法，它会将gestures转换为手势识别器集合 _recognizers。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void _syncAll(Map\u0026lt;Type, GestureRecognizerFactory\u0026gt; gestures) { assert(_recognizers != null); // 将_recognizers赋值给局部变量oldRecognizers final Map\u0026lt;Type, GestureRecognizer\u0026gt; oldRecognizers = _recognizers!; // 创建一个新的_recognizers _recognizers = \u0026lt;Type, GestureRecognizer\u0026gt;{}; // 遍历gestures的keys，这里的type就是GestureRecognizer了 for (final Type type in gestures.keys) { assert(gestures[type] != null); assert(gestures[type]!._debugAssertTypeMatches(type)); assert(!_recognizers!.containsKey(type)); // 如果oldRecognizers中存在该GestureRecognizer，则直接赋值即可 // 如果oldRecognizers中不存在该GestureRecognizer，那么调用GestureRecognizerFactoryWithHandlers的constructor方法创建一个新的GestureRecognizer _recognizers![type] = oldRecognizers[type] ?? gestures[type]!.constructor(); assert(_recognizers![type].runtimeType == type, \u0026#39;GestureRecognizerFactory of type $type created a GestureRecognizer of type ${_recognizers![type].runtimeType}. The GestureRecognizerFactory must be specialized with the type of the class that it returns from its constructor method.\u0026#39;); // 执行GestureRecognizerFactoryWithHandlers的initializer方法，此处initializer方法会对外部传入的回调进行赋值操作，例如instance..onTapDown = onTapDown gestures[type]!.initializer(_recognizers![type]!); } // 遍历oldRecognizers的keys，如果_recognizers不包含该type，也就是不包含某个GestureRecognizer了，那么执行该GestureRecognizer的dispose方法，从而做一些资源释放的工作。 for (final Type type in oldRecognizers.keys) { if (!_recognizers!.containsKey(type)) { oldRecognizers[type]!.dispose(); } } } 看下该RawGestureDetectorState的build方法，可以发现GestureDetector的内部其实是对Listener进行了 _GestureSemantics 一层包装。\n我们知道，当事件分发时，就会遍历HitTestResult，然后调用每一个节点（RenderObject）的handleEvent方法。在前面的GestureDetector示例中，此时HitTestResult中 _path 的情况如下。\n对于GestureDetector示例中的内部GestureDetector，它内部的Listener作为第二个HitTestTarget被执行了handleEvent方法，最终会执行 _handlePointerDown 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @override Widget build(BuildContext context) { Widget result = Listener( // 执行_handlePointerDown方法 onPointerDown: _handlePointerDown, onPointerPanZoomStart: _handlePointerPanZoomStart, behavior: widget.behavior ?? _defaultBehavior, child: widget.child, ); if (!widget.excludeFromSemantics) { result = _GestureSemantics( behavior: widget.behavior ?? _defaultBehavior, assignSemantics: _updateSemanticsForRenderObject, child: result, ); } return result; } 4.2、RawGestureDetectorState的 _handlePointerDown 方法 看下RawGestureDetectorState的 _handlePointerDown 方法，可以发现它对 _recognizers 进行了遍历，执行所有GestureRecognizer的addPointer方法，并把PointerDownEvent作为参数传入了addPointer方法。\n1 2 3 4 5 6 void _handlePointerDown(PointerDownEvent event) { assert(_recognizers != null); for (final GestureRecognizer recognizer in _recognizers!.values) { recognizer.addPointer(event); } } 看下GestureRecognizer的addPointer方法，执行isPointerAllowed方法进行if语句判断，用来检查该识别器是否允许跟踪指针。\n如果if语句判断为真，那么执行addAllowedPointer方法，注册一个已被检查为手势识别器允许的新指针。\n否则，执行handleNonAllowedPointer方法，处理此识别器不允许添加的指针，GestureRecognizer子类可以重写此方法并拒绝手势。\n1 2 3 4 5 6 7 8 9 10 11 12 void addPointer(PointerDownEvent event) { // 保存指针ID和它们来自的设备类型之间的映射 _pointerToKind[event.pointer] = event.kind; // 分析一 if (isPointerAllowed(event)) { // 分析二 addAllowedPointer(event); } else { // 分析三 handleNonAllowedPointer(event); } } 分析一：\n前面我们看GestureDetector的build方法时就知道，对于onTapDown、onTapUp、onTap与onTapCancel这几个回调，它所创建的手势识别器为TapGestureRecognizer。\n而TapGestureRecognizer实现了isPointerAllowed方法，所以看下TapGestureRecognizer的isPointerAllowed方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @override bool isPointerAllowed(PointerDownEvent event) { switch (event.buttons) { case kPrimaryButton: // 满足kPrimaryButton条件，但是示例中回调均不为null if (onTapDown == null \u0026amp;\u0026amp; onTap == null \u0026amp;\u0026amp; onTapUp == null \u0026amp;\u0026amp; onTapCancel == null) { return false; } case kSecondaryButton: if (onSecondaryTap == null \u0026amp;\u0026amp; onSecondaryTapDown == null \u0026amp;\u0026amp; onSecondaryTapUp == null \u0026amp;\u0026amp; onSecondaryTapCancel == null) { return false; } case kTertiaryButton: if (onTertiaryTapDown == null \u0026amp;\u0026amp; onTertiaryTapUp == null \u0026amp;\u0026amp; onTertiaryTapCancel == null) { return false; } default: return false; } // 因此，执行了父类的isPointerAllowed方法 return super.isPointerAllowed(event); } TapGestureRecognizer的isPointerAllowed方法也是执行了父类的isPointerAllowed方法，看下GestureRecognizer的isPointerAllowed方法。\n因为supportedDevices是通过GestureDetector的构造方法传入，而我们没有传入，所以supportedDevices为null，那么isPointerAllowed方法返回true，因此，会继续执行分析二。\n1 2 3 4 5 6 7 8 Set\u0026lt;PointerDeviceKind\u0026gt;? supportedDevices; @protected bool isPointerAllowed(PointerDownEvent event) { return (supportedDevices == null || supportedDevices!.contains(event.kind)) \u0026amp;\u0026amp; _allowedButtonsFilter(event.buttons); } 分析二：\naddAllowedPointer方法在GestureRecognizer是空实现，该方法由GestureRecognizer的子类实现，那么去看下TapGestureRecognizer的addAllowedPointer方法实现。\n但是发现TapGestureRecognizer并没有重写该方法，那么看下它的父类BaseTapGestureRecognizer的addAllowedPointer方法实现。\n可以看到，在BaseTapGestureRecognizer的addAllowedPointer方法中，最后又执行了父类的addAllowedPointer方法，也就是执行了PrimaryPointerGestureRecognizer的addAllowedPointer方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @override void addAllowedPointer(PointerDownEvent event) { // 此时state为GestureRecognizerState.ready，这是在父类PrimaryPointerGestureRecognizer中成员变量_state的初始赋值，表示识别器已准备好开始识别手势 if (state == GestureRecognizerState.ready) { // 如果之前的手势区域中没有结果，我们将忽略它们并准备接受新的指针。 // If there is no result in the previous gesture arena, // we ignore them and prepare to accept a new pointer. // 此时_down为null，_up为null，所以不会执行_reset方法去重置变量状态 if (_down != null \u0026amp;\u0026amp; _up != null) { assert(_down!.pointer == _up!.pointer); _reset(); } assert(_down == null \u0026amp;\u0026amp; _up == null); // 必须在此方法中指定“_down”而不是“handlePrimaryPointer”，因为“acceptGesture”可能会在“handlePrimaryPointer”之前调用，后者依赖“_down”来调用“handleTapDown”。 // `_down` must be assigned in this method instead of `handlePrimaryPointer`, // because `acceptGesture` might be called before `handlePrimaryPointer`, // which relies on `_down` to call `handleTapDown`. _down = event; } if (_down != null) { // 当指针向下（即由于移动）时此点击手势被拒绝时，当添加另一个允许的指针时，会发生这种情况，在这种情况下，所有指针都将被忽略。 // `_down` 为 null 意味着 _reset() 已被调用，因为它总是在第一个允许的 down 事件中设置，并且除了 Reset() 之外不会被清除， // This happens when this tap gesture has been rejected while the pointer // is down (i.e. due to movement), when another allowed pointer is added, // in which case all pointers are ignored. The `_down` being null // means that _reset() has been called, since it is always set at the // first allowed down event and will not be cleared except for reset(), super.addAllowedPointer(event); } } 看下PrimaryPointerGestureRecognizer的addAllowedPointer方法，首先执行了父类OneSequenceGestureRecognizer的addAllowedPointer方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @override void addAllowedPointer(PointerDownEvent event) { // 执行父类的addAllowedPointer方法 super.addAllowedPointer(event); if (state == GestureRecognizerState.ready) { // 修改_state位possible，表示到目前为止看到的指针事件序列与识别器尝试识别的手势一致，但该手势尚未被明确接受 _state = GestureRecognizerState.possible; // 该识别器正在跟踪的主指针的ID // 如果此识别器不再跟踪任何指针，则此字段保存此识别器最近跟踪的主指针的ID。 // 这使得识别器能够在调用acceptGesture或rejectGesture时知道它最近跟踪哪个指针 _primaryPointer = event.pointer; // 主指针接触屏幕的位置，仅当该识别器正在跟踪至少一个指针时，该值才为非空 _initialPosition = OffsetPair(local: event.localPosition, global: event.position); // deadline在BaseTapGestureRecognizer构造方法中调用父类的构造方法时传入了 // 对于轻击屏幕，它的值是固定的，为kPressTimeout，等于Duration(milliseconds: 100)，此时它表示如果怀疑该手势是轻击，则轻击手势发送 onTapDown 之前必须经过的时间 // 对于长按屏幕，它的值不是固定的，可以自定义，不传入时默认值为kLongPressTimeout，等于Duration(milliseconds: 500)，此时它表示长按手势尝试获胜之前的时间。 // 当然我们示例中肯定是轻击屏幕，所以这里会执行 if (deadline != null) { // 如果非空，则识别器将在开始跟踪主指针后经过此时间量后调用didExceedDeadline 。 // 如果主指针在截止deadline之前被接受、拒绝，或者所有指针都已启动或取消，则不会调用didExceedDeadline // 我们示例中，如果轻击超时了，就会执行didExceedDeadlineWithEvent方法， // 在didExceedDeadlineWithEvent方法中，最终会执行handleTapDown方法回调给外部GestureDetector，也就是点击超时时也会触发onTapDown回调。 // didExceedDeadlineWithEvent源码这里不讲解了，可自行查看 _timer = Timer(deadline!, () =\u0026gt; didExceedDeadlineWithEvent(event)); } } } 看下OneSequenceGestureRecognizer的addAllowedPointer方法，执行了startTrackingPointer方法。\n1 2 3 4 5 @override @protected void addAllowedPointer(PointerDownEvent event) { startTrackingPointer(event.pointer, event.transform); } 此处startTrackingPointer方法由OneSequenceGestureRecognizer的子类BaseTapGestureRecognizer去实现，看下BaseTapGestureRecognizer的startTrackingPointer方法。\n可以看到，在BaseTapGestureRecognizer的startTrackingPointer方法中，又执行了父类OneSequenceGestureRecognizer的startTrackingPointer方法。\n1 2 3 4 5 6 7 8 9 @override @protected void startTrackingPointer(int pointer, [Matrix4? transform]) { // 当 _down 为空时，识别器不应该跟踪任何指针，因为在这种状态下调用 _checkDown 会抛出异常。 // The recognizer should never track any pointers when `_down` is null, // because calling `_checkDown` in this state will throw exception. assert(_down != null); super.startTrackingPointer(pointer, transform); } 看下OneSequenceGestureRecognizer的startTrackingPointer方法，执行了GestureBinding中成员变量pointerRouter的addRoute方法，将路由添加到路由表。\n然后执行 _addPointerToArena 方法，将新成员（例如手势识别器）添加到竞技场。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final Map\u0026lt;int, GestureArenaEntry\u0026gt; _entries = \u0026lt;int, GestureArenaEntry\u0026gt;{}; final Set\u0026lt;int\u0026gt; _trackedPointers = HashSet\u0026lt;int\u0026gt;(); // 导致与给定指针 D相关的事件被路由到此识别器。 // 指针事件根据transform进行转换，然后传递给handleEvent。transform参数的值通常从PointerDownEvent.transform获取，以将事件从全局坐标空间转换到事件接收者的坐标空间。如果不需要转换，它可能为空。 // 使用stopTrackingPointer删除此函数添加的路由。 // 此方法还会将此识别器（或其team ，如果它非空）添加到指定指针的手势区域。 // 这是由OneSequenceGestureRecognizer.addAllowedPointer调用的。 @protected void startTrackingPointer(int pointer, [Matrix4? transform]) { // 将路由添加到路由表 GestureBinding.instance.pointerRouter.addRoute(pointer, handleEvent, transform); // 将指针添加到追踪指针Set集合 _trackedPointers.add(pointer); // TODO(goderbauer): Enable assert after recognizers properly clean up their defunct `_entries`, see https://github.com/flutter/flutter/issues/117356. // assert(!_entries.containsKey(pointer)); // 将新成员（例如手势识别器）添加到竞技场 // 给定的GestureArenaMember（手势识别器）可以在多个具有不同指针id的区域中拥有多个条目。 // 将返回的GestureArenaEntry存入Map集合中 _entries[pointer] = _addPointerToArena(pointer); } 看下PointerRouter的addRoute方法，可以发现pointer与路由表routes相关联，并且路由表的条目让OneSequenceGestureRecognizer的handleEvent方法与PointerDownEvent中的transform进行了关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // _routeMap以pointer作为Key，Map\u0026lt;PointerRoute, Matrix4?\u0026gt;作为Value final Map\u0026lt;int, Map\u0026lt;PointerRoute, Matrix4?\u0026gt;\u0026gt; _routeMap = \u0026lt;int, Map\u0026lt;PointerRoute, Matrix4?\u0026gt;\u0026gt;{}; void addRoute(int pointer, PointerRoute route, [Matrix4? transform]) { // 如果_routeMap中存在该值为pointer的Key，那么返回它的Value，也就是一个Map // 否则，以该pointer为Key，空的Map为Value，创建一个新的Key-Value对存入_routeMap中，最后返回它的Value，也就是一个空的Map final Map\u0026lt;PointerRoute, Matrix4?\u0026gt; routes = _routeMap.putIfAbsent( pointer, () =\u0026gt; \u0026lt;PointerRoute, Matrix4?\u0026gt;{}, ); assert(!routes.containsKey(route)); // 再把PointerDownEvent中的transform存入该routes中，Key为route，也就是handleEvent方法 // 这里已经将OneSequenceGestureRecognizer的handleEvent方法与PointerDownEvent中的transform进行了关联，不过handleEvent方法由OneSequenceGestureRecognizer的子类实现 routes[route] = transform; } 再看下OneSequenceGestureRecognizer的 _addPointerToArena 方法，执行了GestureBinding中成员变量gestureArena的add方法，将新成员（例如手势识别器）添加到竞技场。\n1 2 3 4 5 6 7 8 9 10 GestureArenaEntry _addPointerToArena(int pointer) { // 该识别器所属的团队（如果有）。 // 如果team为null，则此识别器直接在GestureArenaManager中竞争，将一系列指针事件识别为手势。如果team不为空，则该识别器在竞技场中与同一团队的其它识别器一起竞争。 // 仅当团队未参加竞技场时，才能将识别器分配给该团队。例如，将识别器分配给团队的常见时间是在创建识别器后不久。 if (_team != null) { return _team!.add(pointer, this); } // 将新成员（例如手势识别器）添加到竞技场 return GestureBinding.instance.gestureArena.add(pointer, this); } 看下GestureArenaManager的add方法，可以发现pointer与手势竞技场 _GestureArena 相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // _arenas以pointer作为Key，_GestureArena作为Value final Map\u0026lt;int, _GestureArena\u0026gt; _arenas = \u0026lt;int, _GestureArena\u0026gt;{}; /// Adds a new member (e.g., gesture recognizer) to the arena. GestureArenaEntry add(int pointer, GestureArenaMember member) { // 如果_arenas中存在该值为pointer的Key，那么返回它的Value，也就是一个_GestureArena // 否则，以该pointer为Key，新的_GestureArena为Value，创建一个新的Key-Value对存入_arenas中，最后返回它的Value，也就是一个新的_GestureArena final _GestureArena state = _arenas.putIfAbsent(pointer, () { assert(_debugLogDiagnostic(pointer, \u0026#39;★ Opening new gesture arena.\u0026#39;)); return _GestureArena(); }); // 将GestureArenaMember添加到_GestureArena中的成员变量members，它是一个List // 此处的GestureArenaMember其实是我们的识别器 state.add(member); assert(_debugLogDiagnostic(pointer, \u0026#39;Adding: $member\u0026#39;)); // 最后返回GestureArenaEntry对象 return GestureArenaEntry._(this, pointer, member); } 分析三：\n回到GestureRecognizer的addPointer方法，看下handleNonAllowedPointer方法，它用来处理此识别器不允许添加的指针，子类可以重写此方法并拒绝手势。\n一般情况下，handleNonAllowedPointer方法不会执行。对于TapGestureRecognizer来说，如果一个回调（例如onTapDown）都不传入GestureDetector，或者传入的supportedDevices和系统识别出来的输入设备的类型不一致，那么isPointerAllowed方法就会返回false，所以会执行handleNonAllowedPointer方法。\n可以发现，在GestureRecognizer中handleNonAllowedPointer方法是一个空实现，由GestureRecognizer的子类去实现，那么看下PrimaryPointerGestureRecognizer的handleNonAllowedPointer方法，最后执行了父类的handleNonAllowedPointer方法。\n1 2 3 4 5 6 7 @override void handleNonAllowedPointer(PointerDownEvent event) { // 该指针是通过赢得竞技场而被接受还是由调用acceptGesture的子类定义。 if (!_gestureAccepted) { super.handleNonAllowedPointer(event); } } 看下OneSequenceGestureRecognizer的handleNonAllowedPointer方法，执行了resolve方法，传入的状态是GestureDisposition.rejected。\nresolve方法也是可以被重写的，它由子类BaseTapGestureRecognizer去实现。\n1 2 3 4 5 6 7 @override @protected void handleNonAllowedPointer(PointerDownEvent event) { // 使用给定的配置解决此识别器参与每个手势领域的问题 // 这里传入了GestureDisposition.rejected，说明该手势被拒绝作为对用户输入的解释 resolve(GestureDisposition.rejected); } 看下BaseTapGestureRecognizer的resolve方法，最后执行了父类的resolve方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @override void resolve(GestureDisposition disposition) { if (_wonArenaForPrimaryPointer \u0026amp;\u0026amp; disposition == GestureDisposition.rejected) { // 如果手势被取消，就会发生这种情况。例如，当指针超过触摸斜率时，按钮已改变，或者识别器被布置。 // This can happen if the gesture has been canceled. For example, when // the pointer has exceeded the touch slop, the buttons have been changed, // or if the recognizer is disposed. assert(_sentTapDown); // 之前触发过handleTapDown的指针最终不会导致点击 // 如果之前已触发过handleTapDown ，则一旦手势失去区域，就会触发此操作 _checkCancel(null, \u0026#39;spontaneous\u0026#39;); // 重置成员变量的状态 _reset(); } super.resolve(disposition); } 看下OneSequenceGestureRecognizer的resolve方法，这里disposition传入的是GestureDisposition.rejected，执行所有GestureArenaEntry的resolve方法。\n1 2 3 4 5 6 7 8 9 10 11 @protected @mustCallSuper void resolve(GestureDisposition disposition) { // 当然了，如果之前没调用startTrackingPointer方法的话，_entries就为空，那么localEntries也为空 final List\u0026lt;GestureArenaEntry\u0026gt; localEntries = List\u0026lt;GestureArenaEntry\u0026gt;.of(_entries.values); _entries.clear(); // 如果localEntries为空，此处不会执行 for (final GestureArenaEntry entry in localEntries) { entry.resolve(disposition); } } 看下GestureArenaEntry的resolve方法，可以看到，执行了GestureArenaManager的 _resolve 方法，该方法表示拒绝或接受手势识别器。\n前面一路传过来的disposition为GestureDisposition.rejected，说明要拒绝手势识别器。\n1 2 3 4 5 final GestureArenaManager _arena; void resolve(GestureDisposition disposition) { _arena._resolve(_pointer, _member, disposition); } 4.3、GestureBinding的handleEvent方法 之前讲过，WidgetsFlutterBinding也命中测试了，由于它是最后被添加到HitTestResult中的，所以在事件分发阶段WidgetsFlutterBinding的handleEvent会在最后被调用，只是WidgetsFlutterBinding没有重写handleEvent方法，这里是调用了混入GestureBinding的handleEvent方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override // from HitTestTarget void handleEvent(PointerEvent event, HitTestEntry entry) { // 分析一 pointerRouter.route(event); if (event is PointerDownEvent || event is PointerPanZoomStartEvent) { // 分析二 gestureArena.close(event.pointer); } else if (event is PointerUpEvent || event is PointerPanZoomEndEvent) { // 分析三 gestureArena.sweep(event.pointer); } else if (event is PointerSignalEvent) { pointerSignalResolver.resolve(event); } } 4.3.1、PointerDownEvent事件分发 分析一：\n在PointerRouter的route方法中，执行了 _dispatchEventToRoutes 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void route(PointerEvent event) { // 取出每个pointer对应的路由表，每个路由表都关联了所有手势识别器的handleEvent方法 final Map\u0026lt;PointerRoute, Matrix4?\u0026gt;? routes = _routeMap[event.pointer]; // 拷贝一份_globalRoutes，这个是全局路由相关的，本示例这里不涉及 final Map\u0026lt;PointerRoute, Matrix4?\u0026gt; copiedGlobalRoutes = Map\u0026lt;PointerRoute, Matrix4?\u0026gt;.of(_globalRoutes); if (routes != null) { // 执行handleEvent方法 _dispatchEventToRoutes( event, routes, Map\u0026lt;PointerRoute, Matrix4?\u0026gt;.of(routes), ); } // 这个是全局路由相关的，本示例这里不涉及 _dispatchEventToRoutes(event, _globalRoutes, copiedGlobalRoutes); } 看下PointerRouter的 _dispatchEventToRoutes 方法，遍历了路由表，执行 _dispatch 方法。\n1 2 3 4 5 6 7 8 9 10 11 void _dispatchEventToRoutes( PointerEvent event, Map\u0026lt;PointerRoute, Matrix4?\u0026gt; referenceRoutes, Map\u0026lt;PointerRoute, Matrix4?\u0026gt; copiedRoutes, ) { copiedRoutes.forEach((PointerRoute route, Matrix4? transform) { if (referenceRoutes.containsKey(route)) { _dispatch(event, route, transform); } }); } 看下PointerRouter的 _dispatch 方法，可以发现，执行了route方法，此处PointerRoute其实是OneSequenceGestureRecognizer的startTrackingPointer方法中通过调用GestureBinding的成员变量pointerRouter的addRoute方法传入的handleEvent方法。\n不过OneSequenceGestureRecognizer的handleEvent方法是一个空实现，它由子类PrimaryPointerGestureRecognizer来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @pragma(\u0026#39;vm:notify-debugger-on-exception\u0026#39;) void _dispatch(PointerEvent event, PointerRoute route, Matrix4? transform) { try { event = event.transformed(transform); // 执行手势识别器的handleEvent方法 route(event); } catch (exception, stack) { InformationCollector? collector; assert(() { collector = () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;PointerRouter\u0026gt;(\u0026#39;router\u0026#39;, this, level: DiagnosticLevel.debug), DiagnosticsProperty\u0026lt;PointerRoute\u0026gt;(\u0026#39;route\u0026#39;, route, level: DiagnosticLevel.debug), DiagnosticsProperty\u0026lt;PointerEvent\u0026gt;(\u0026#39;event\u0026#39;, event, level: DiagnosticLevel.debug), ]; return true; }()); FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: \u0026#39;gesture library\u0026#39;, context: ErrorDescription(\u0026#39;while routing a pointer event\u0026#39;), informationCollector: collector, )); } } 看下PrimaryPointerGestureRecognizer的handleEvent方法，可以发现执行了handlePrimaryPointer方法，该方法由子类BaseTapGestureRecognizer去实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @override void handleEvent(PointerEvent event) { assert(state != GestureRecognizerState.ready); if (state == GestureRecognizerState.possible \u0026amp;\u0026amp; event.pointer == primaryPointer) { final bool isPreAcceptSlopPastTolerance = !_gestureAccepted \u0026amp;\u0026amp; preAcceptSlopTolerance != null \u0026amp;\u0026amp; _getGlobalDistance(event) \u0026gt; preAcceptSlopTolerance!; final bool isPostAcceptSlopPastTolerance = _gestureAccepted \u0026amp;\u0026amp; postAcceptSlopTolerance != null \u0026amp;\u0026amp; _getGlobalDistance(event) \u0026gt; postAcceptSlopTolerance!; if (event is PointerMoveEvent \u0026amp;\u0026amp; (isPreAcceptSlopPastTolerance || isPostAcceptSlopPastTolerance)) { resolve(GestureDisposition.rejected); stopTrackingPointer(primaryPointer!); } else { // 因为先是分发PointerDownEvent，所以执行这里 handlePrimaryPointer(event); } } stopTrackingIfPointerNoLongerDown(event); } 看下BaseTapGestureRecognizer的handlePrimaryPointer方法，可以看到，该方法内部并没有对PointerDownEvent事件进行处理，所以整个 pointerRouter.route(event) 相当于没执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @override void handlePrimaryPointer(PointerEvent event) { if (event is PointerUpEvent) { _up = event; _checkUp(); } else if (event is PointerCancelEvent) { resolve(GestureDisposition.rejected); if (_sentTapDown) { _checkCancel(event, \u0026#39;\u0026#39;); } _reset(); } else if (event.buttons != _down!.buttons) { // 此处buttons相等，不满足条件 resolve(GestureDisposition.rejected); stopTrackingPointer(primaryPointer!); } } 分析二：\n如果event是PointerDownEvent，那么就会执行GestureArenaManager的close方法，在该方法中执行了 _tryToResolveArena 方法。\n1 2 3 4 5 6 7 8 9 void close(int pointer) { final _GestureArena? state = _arenas[pointer]; if (state == null) { return; // This arena either never existed or has been resolved. } state.isOpen = false; assert(_debugLogDiagnostic(pointer, \u0026#39;Closing\u0026#39;, state)); _tryToResolveArena(pointer, state); } 看下GestureArenaManager的 _tryToResolveArena 方法，执行了 _resolveByDefault 方法，在该方法中，此时state.members的数量为2，也就是两个TapGestureRecognizer手势识别器，并且此时还没有获胜者，所以state.eagerWinner为null，整个 _tryToResolveArena 方法相当于没执行。\n那么，*gestureArena.close(event.pointer)*也相当于没执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 void _tryToResolveArena(int pointer, _GestureArena state) { assert(_arenas[pointer] == state); assert(!state.isOpen); if (state.members.length == 1) { scheduleMicrotask(() =\u0026gt; _resolveByDefault(pointer, state)); } else if (state.members.isEmpty) { _arenas.remove(pointer); assert(_debugLogDiagnostic(pointer, \u0026#39;Arena empty.\u0026#39;)); } else if (state.eagerWinner != null) { assert(_debugLogDiagnostic(pointer, \u0026#39;Eager winner: ${state.eagerWinner}\u0026#39;)); _resolveInFavorOf(pointer, state, state.eagerWinner!); } } 4.3.2、PointerUpEvent事件分发 分析一：\n在PointerRouter的route方法中，执行了 _dispatchEventToRoutes 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void route(PointerEvent event) { // 取出每个pointer对应的路由表，每个路由表都关联了所有手势识别器的handleEvent方法 final Map\u0026lt;PointerRoute, Matrix4?\u0026gt;? routes = _routeMap[event.pointer]; // 拷贝一份_globalRoutes，这个是全局路由相关的，本示例这里不涉及 final Map\u0026lt;PointerRoute, Matrix4?\u0026gt; copiedGlobalRoutes = Map\u0026lt;PointerRoute, Matrix4?\u0026gt;.of(_globalRoutes); if (routes != null) { // 执行handleEvent方法 _dispatchEventToRoutes( event, routes, Map\u0026lt;PointerRoute, Matrix4?\u0026gt;.of(routes), ); } // 这个是全局路由相关的，本示例这里不涉及 _dispatchEventToRoutes(event, _globalRoutes, copiedGlobalRoutes); } 看下PointerRouter的 _dispatchEventToRoutes 方法，遍历了路由表，执行 _dispatch 方法。\n1 2 3 4 5 6 7 8 9 10 11 void _dispatchEventToRoutes( PointerEvent event, Map\u0026lt;PointerRoute, Matrix4?\u0026gt; referenceRoutes, Map\u0026lt;PointerRoute, Matrix4?\u0026gt; copiedRoutes, ) { copiedRoutes.forEach((PointerRoute route, Matrix4? transform) { if (referenceRoutes.containsKey(route)) { _dispatch(event, route, transform); } }); } 看下PointerRouter的 _dispatch 方法，可以发现，执行了route方法，此处PointerRoute其实是OneSequenceGestureRecognizer的startTrackingPointer方法中通过调用GestureBinding的成员变量pointerRouter的addRoute方法传入的handleEvent方法。\n不过OneSequenceGestureRecognizer的handleEvent方法是一个空实现，它由子类PrimaryPointerGestureRecognizer来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @pragma(\u0026#39;vm:notify-debugger-on-exception\u0026#39;) void _dispatch(PointerEvent event, PointerRoute route, Matrix4? transform) { try { event = event.transformed(transform); route(event); } catch (exception, stack) { InformationCollector? collector; assert(() { collector = () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;PointerRouter\u0026gt;(\u0026#39;router\u0026#39;, this, level: DiagnosticLevel.debug), DiagnosticsProperty\u0026lt;PointerRoute\u0026gt;(\u0026#39;route\u0026#39;, route, level: DiagnosticLevel.debug), DiagnosticsProperty\u0026lt;PointerEvent\u0026gt;(\u0026#39;event\u0026#39;, event, level: DiagnosticLevel.debug), ]; return true; }()); FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: \u0026#39;gesture library\u0026#39;, context: ErrorDescription(\u0026#39;while routing a pointer event\u0026#39;), informationCollector: collector, )); } } 看下PrimaryPointerGestureRecognizer的handleEvent方法，可以发现执行了handlePrimaryPointer方法，该方法由子类BaseTapGestureRecognizer去实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @override void handleEvent(PointerEvent event) { assert(state != GestureRecognizerState.ready); if (state == GestureRecognizerState.possible \u0026amp;\u0026amp; event.pointer == primaryPointer) { final bool isPreAcceptSlopPastTolerance = !_gestureAccepted \u0026amp;\u0026amp; preAcceptSlopTolerance != null \u0026amp;\u0026amp; _getGlobalDistance(event) \u0026gt; preAcceptSlopTolerance!; final bool isPostAcceptSlopPastTolerance = _gestureAccepted \u0026amp;\u0026amp; postAcceptSlopTolerance != null \u0026amp;\u0026amp; _getGlobalDistance(event) \u0026gt; postAcceptSlopTolerance!; if (event is PointerMoveEvent \u0026amp;\u0026amp; (isPreAcceptSlopPastTolerance || isPostAcceptSlopPastTolerance)) { resolve(GestureDisposition.rejected); stopTrackingPointer(primaryPointer!); } else { handlePrimaryPointer(event); } } stopTrackingIfPointerNoLongerDown(event); } 看下BaseTapGestureRecognizer的handlePrimaryPointer方法，此时event的类型为PointerUpEvent，所以执行 _checkUp 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @override void handlePrimaryPointer(PointerEvent event) { if (event is PointerUpEvent) { _up = event; _checkUp(); } else if (event is PointerCancelEvent) { resolve(GestureDisposition.rejected); if (_sentTapDown) { _checkCancel(event, \u0026#39;\u0026#39;); } _reset(); } else if (event.buttons != _down!.buttons) { resolve(GestureDisposition.rejected); stopTrackingPointer(primaryPointer!); } } 看下BaseTapGestureRecognizer的 _checkUp 方法，此时是没有获胜者的，所以 _wonArenaForPrimaryPointer为false，那么 _checkUp 方法就会return，不会继续向下执行，所以整个 pointerRouter.route(event) 相当于没执行。\n1 2 3 4 5 6 7 8 void _checkUp() { if (!_wonArenaForPrimaryPointer || _up == null) { return; } assert(_up!.pointer == _down!.pointer); handleTapUp(down: _down!, up: _up!); _reset(); } 分析三：\n如果event是PointerUpEvent，那么就会执行GestureArenaManager的sweep方法，在该方法中，执行了List中第一个手势识别器的acceptGesture方法，让其它手势识别器执行rejectGesture方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 强制解决竞技场，让第一个成员获胜。 void sweep(int pointer) { final _GestureArena? state = _arenas[pointer]; if (state == null) { return; // This arena either never existed or has been resolved. } assert(!state.isOpen); if (state.isHeld) { state.hasPendingSweep = true; assert(_debugLogDiagnostic(pointer, \u0026#39;Delaying sweep\u0026#39;, state)); return; // This arena is being held for a long-lived member. } assert(_debugLogDiagnostic(pointer, \u0026#39;Sweeping\u0026#39;, state)); _arenas.remove(pointer); if (state.members.isNotEmpty) { // First member wins. assert(_debugLogDiagnostic(pointer, \u0026#39;Winner: ${state.members.first}\u0026#39;)); state.members.first.acceptGesture(pointer); // Give all the other members the bad news. for (int i = 1; i \u0026lt; state.members.length; i++) { state.members[i].rejectGesture(pointer); } } } 看下BaseTapGestureRecognizer的acceptGesture方法，可以看到，执行了父类的acceptGesture方法，然后执行了 _checkDown与 _checkUp 方法。\n1 2 3 4 5 6 7 8 9 @override void acceptGesture(int pointer) { super.acceptGesture(pointer); if (pointer == primaryPointer) { _checkDown(); _wonArenaForPrimaryPointer = true; _checkUp(); } } 看下PrimaryPointerGestureRecognizer的acceptGesture方法，可以看到，做了一下清理工作。\n1 2 3 4 5 6 7 @override void acceptGesture(int pointer) { if (pointer == primaryPointer) { _stopTimer(); _gestureAccepted = true; } } 看下BaseTapGestureRecognizer的 _checkDown 方法，执行了handleTapDown方法。\n1 2 3 4 5 6 7 void _checkDown() { if (_sentTapDown) { return; } handleTapDown(down: _down!); _sentTapDown = true; } 看下BaseTapGestureRecognizer的handleTapDown方法，该方法由子类TapGestureRecognizer实现。可以看到，调用了invokeCallback方法去调用外部GestureDetector传入的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @protected @override void handleTapDown({required PointerDownEvent down}) { final TapDownDetails details = TapDownDetails( globalPosition: down.position, localPosition: down.localPosition, kind: getKindForPointer(down.pointer), ); switch (down.buttons) { case kPrimaryButton: if (onTapDown != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onTapDown\u0026#39;, () =\u0026gt; onTapDown!(details)); } case kSecondaryButton: if (onSecondaryTapDown != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onSecondaryTapDown\u0026#39;, () =\u0026gt; onSecondaryTapDown!(details)); } case kTertiaryButton: if (onTertiaryTapDown != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onTertiaryTapDown\u0026#39;, () =\u0026gt; onTertiaryTapDown!(details)); } default: } } 看下BaseTapGestureRecognizer的 _checkUp 方法，执行了handleTapUp方法。\n1 2 3 4 5 6 7 8 void _checkUp() { if (!_wonArenaForPrimaryPointer || _up == null) { return; } assert(_up!.pointer == _down!.pointer); handleTapUp(down: _down!, up: _up!); _reset(); } 看下BaseTapGestureRecognizer的handleTapUp方法，该方法由子类TapGestureRecognizer实现。可以看到，调用了invokeCallback方法去调用外部GestureDetector传入的回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @protected @override void handleTapUp({ required PointerDownEvent down, required PointerUpEvent up}) { final TapUpDetails details = TapUpDetails( kind: up.kind, globalPosition: up.position, localPosition: up.localPosition, ); switch (down.buttons) { case kPrimaryButton: if (onTapUp != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onTapUp\u0026#39;, () =\u0026gt; onTapUp!(details)); } if (onTap != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onTap\u0026#39;, onTap!); } case kSecondaryButton: if (onSecondaryTapUp != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onSecondaryTapUp\u0026#39;, () =\u0026gt; onSecondaryTapUp!(details)); } if (onSecondaryTap != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onSecondaryTap\u0026#39;, () =\u0026gt; onSecondaryTap!()); } case kTertiaryButton: if (onTertiaryTapUp != null) { invokeCallback\u0026lt;void\u0026gt;(\u0026#39;onTertiaryTapUp\u0026#39;, () =\u0026gt; onTertiaryTapUp!(details)); } default: } } 五、同一个GestureDetector多种手势之间的冲突 前面所讲的GestureDetector示例属于多个GestureDetector之间的手势竞争，由于手势竞争最终只有一个胜出者，所以，当我们通过一个GestureDetector监听多种手势时，也可能会产生冲突。例如下面这个例子，同时监听轻击事件与双击事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return GestureDetector( child: const ColoredBox(color: Colors.blueAccent), onTap: () =\u0026gt; debugPrint(\u0026#39;onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;onTapCancel\u0026#39;), onDoubleTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;onDoubleTapDown\u0026#39;), ); } } 程序运行起来后双击界面，日志打印如下:\n1 I/flutter ( 8036): onDoubleTapDown 可以发现没有打印Tap相关的日志，因为双击包含两次间隔时间很短连续轻点击，第一次点击时执行了 _registerFirstTap 方法，开启间隔时间计时（这个值为kDoubleTapTimeout，相较于第一次轻点击会有200ms的延迟），并且通过执行GestureArenaManager的hold方法来防止竞技场被扫荡。通常，在所有其它PointerUpEvent处理完成后，会在竞技场中通过sweep选择获胜者。\n相当于不给第一次轻点击获胜的机会，然后在没超过间隔时间内再次轻点击时，就完成了双击，此时双击手势已有完整的语义。接着就会调用 _registerSecondTap 方法宣称获得胜利。\n这点通过Flutter内部手势竞技场的日志打印也可以看出来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 I/flutter ( 8794): Gesture arena 1 ❙ ★ Opening new gesture arena. I/flutter ( 8794): Gesture arena 1 ❙ Adding: TapGestureRecognizer#15e11(debugOwner: GestureDetector, state: ready, button: 1) I/flutter ( 8794): Gesture arena 1 ❙ Adding: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) I/flutter ( 8794): Gesture arena 1 ❙ Closing with 2 members. I/flutter ( 8794): Gesture arena 1 ❙ Holding with 2 members. I/flutter ( 8794): Gesture arena 1 ❙ Delaying sweep with 2 members. I/flutter ( 8794): Gesture arena 2 ❙ ★ Opening new gesture arena. I/flutter ( 8794): Gesture arena 2 ❙ Adding: TapGestureRecognizer#15e11(debugOwner: GestureDetector, state: ready, button: 1) I/flutter ( 8794): onDoubleTapDown I/flutter ( 8794): Gesture arena 2 ❙ Adding: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) I/flutter ( 8794): Gesture arena 2 ❙ Closing with 2 members. I/flutter ( 8794): Gesture arena 1 ❙ Accepting: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) I/flutter ( 8794): Gesture arena 1 ❙ Self-declared winner: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) I/flutter ( 8794): Gesture arena 2 ❙ Accepting: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) I/flutter ( 8794): Gesture arena 2 ❙ Self-declared winner: DoubleTapGestureRecognizer#c0988(debugOwner: GestureDetector) 六、解决手势冲突 手势是对原始指针的语义化的识别，手势冲突只是手势级别的，也就是说只会在组件树中的多个 GestureDetector之间才有冲突的场景，如果压根就没有使用GestureDetector则不存在所谓的冲突，因为每一个节点都能收到事件，只是在GestureDetector中为了识别语义，它会去决定哪些子节点应该忽略事件，哪些节点应该生效。\n解决手势冲突的方法有两种：\n1、使用Listener。这相当于跳出了手势识别那套规则。\n2、通过自定义手势识别器（Recognizer）。\n6.1、通过Listener解决手势冲突 通过Listener解决手势冲突的原因是竞争只是针对手势的，而Listener是监听原始指针事件，原始指针事件并非语义话的手势，所以根本不会走手势竞争的逻辑，所以也就不会相互影响。拿上面两个GestureDetector嵌套的例子来说，通过Listener的解决方式为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return Listener( child: GestureDetector( child: const ColoredBox(color: Colors.blueAccent), onTap: () =\u0026gt; debugPrint(\u0026#39;inner onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;inner onTapCancel\u0026#39;), ), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;outer onPointerDown\u0026#39;), onPointerUp: (PointerUpEvent event) =\u0026gt; debugPrint(\u0026#39;outer onPointerUp\u0026#39;), onPointerCancel: (PointerCancelEvent event) =\u0026gt; debugPrint(\u0026#39;outer onPointerCancel\u0026#39;), ); } } 代码很简单，只需将GestureDetector换位Listener即可，可以两个都换，也可以只换一个。可以看见，通过Listener直接识别原始指针事件来解决冲突的方法很简单，因此，当遇到手势冲突时，我们应该优先考虑Listener。\n6.2、通过自定义手势识别器Recognizer解决手势冲突 自定义手势识别器的方式比较麻烦，原理是当确定手势竞争胜出者时，会调用胜出者的acceptGesture方法，表示“宣布成功”，然后会调用其它手势识别其的rejectGesture方法，表示“宣布失败”。\n既然如此，我们可以自定义手势识别器（Recognizer），然后去重写它的rejectGesture方法：在里面调用acceptGesture方法，这就相当于它失败是强制将它也变成竞争的成功者了，这样它的回调也就会执行。\n我们先自定义tap手势识别器（Recognizer）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return customGestureDetector( child: GestureDetector( child: const ColoredBox(color: Colors.blueAccent), onTap: () =\u0026gt; debugPrint(\u0026#39;inner onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;inner onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;inner onTapCancel\u0026#39;), ), onTap: () =\u0026gt; debugPrint(\u0026#39;outer onTap\u0026#39;), onTapDown: (TapDownDetails details) =\u0026gt; debugPrint(\u0026#39;outer onTapDown\u0026#39;), onTapUp: (TapUpDetails details) =\u0026gt; debugPrint(\u0026#39;outer onTapUp\u0026#39;), onTapCancel: () =\u0026gt; debugPrint(\u0026#39;outer onTapCancel\u0026#39;), ); } } class CustomTapGestureRecognizer extends TapGestureRecognizer { @override void rejectGesture(int pointer) { // 宣布成功 acceptGesture(pointer); // NOTE：这里保留了后续清理操作，只是不知有无隐患 super.rejectGesture(pointer); } } /// 创建一个新的GestureDetector，用我们自定义的TapGestureRecognizer替换默认的 RawGestureDetector customGestureDetector({ GestureTapCallback? onTap, GestureTapDownCallback? onTapDown, GestureTapUpCallback? onTapUp, GestureTapCancelCallback? onTapCancel, Widget? child, }) { return RawGestureDetector( gestures: { CustomTapGestureRecognizer: GestureRecognizerFactoryWithHandlers\u0026lt;CustomTapGestureRecognizer\u0026gt;( () =\u0026gt; CustomTapGestureRecognizer(), (CustomTapGestureRecognizer instance) { instance ..onTap = onTap ..onTapDown = onTapDown ..onTapUp = onTapUp ..onTapCancel = onTapCancel; }, ) }, child: child, ); } 程序运行起来，轻点击后日志打印如下：\n1 2 3 4 5 6 I/flutter ( 9224): inner onTapDown I/flutter ( 9224): inner onTapUp I/flutter ( 9224): inner onTap I/flutter ( 9224): outer onTapDown I/flutter ( 9224): outer onTapUp I/flutter ( 9224): outer onTap 这样就OK了，需要注意，这个例子同时说明了一次手势处理过程也是可以有多个胜出者的。\n七、总结 1、每一个手势识别器GestureRecognizer都是一个“竞争者”（GestureArenaMember），当发生指针事件时，它们都要在“竞技场”去竞争本次事件的处理权，默认情况最终只有一个“竞争者”会胜出(win)。\n2、GestureRecognizer的handleEvent中会识别手势，如果发生了某个手势，竞争者可以宣布自己是否胜出，一旦有一个竞争者胜出，竞技场管理者（GestureArenaManager）就会通知其他竞争者失败。\n3、胜出者的acceptGesture会被调用，其余失败者的rejectGesture将会被调用。\n","date":"2023-11-14T09:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bgesturedetector/","section":"post","tags":null,"title":"解读Flutter源码之GestureDetector"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、什么是Listener？ Listener可以用来监听原始指针事件（Raw Pointer Event，在移动设备上通常为触摸事件），先来看下它的注释\u0026amp;部分源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 /// 调用回调以响应常见指针事件的widget /// A widget that calls callbacks in response to common pointer events. /// /// 它侦听可以构造手势的事件，例如按下、移动、然后释放或取消指针时 /// It listens to events that can construct gestures, such as when the /// pointer is pressed, moved, then released or canceled. /// /// 它不侦听鼠标独有的事件，例如当鼠标进入、退出或悬停某个区域而不按下任何按钮时。对于这些事件，请使用MouseRegion /// It does not listen to events that are exclusive to mouse, such as when the /// mouse enters, exits or hovers a region without pressing any buttons. For /// these events, use [MouseRegion]. /// /// 考虑使用GestureDetector监听更高级别的手势，而不是监听原始指针事件 /// Rather than listening for raw pointer events, consider listening for /// higher-level gestures using [GestureDetector]. class Listener extends SingleChildRenderObjectWidget { const Listener({ super.key, this.onPointerDown, this.onPointerMove, this.onPointerUp, this.onPointerHover, this.onPointerCancel, this.onPointerPanZoomStart, this.onPointerPanZoomUpdate, this.onPointerPanZoomEnd, this.onPointerSignal, this.behavior = HitTestBehavior.deferToChild, super.child, }); final PointerDownEventListener? onPointerDown; final PointerMoveEventListener? onPointerMove; final PointerUpEventListener? onPointerUp; final PointerHoverEventListener? onPointerHover; final PointerCancelEventListener? onPointerCancel; final PointerPanZoomStartEventListener? onPointerPanZoomStart; final PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate; final PointerPanZoomEndEventListener? onPointerPanZoomEnd; final PointerSignalEventListener? onPointerSignal; final HitTestBehavior behavior; @override RenderPointerListener createRenderObject(BuildContext context) { return RenderPointerListener( onPointerDown: onPointerDown, onPointerMove: onPointerMove, onPointerUp: onPointerUp, onPointerHover: onPointerHover, onPointerCancel: onPointerCancel, onPointerPanZoomStart: onPointerPanZoomStart, onPointerPanZoomUpdate: onPointerPanZoomUpdate, onPointerPanZoomEnd: onPointerPanZoomEnd, onPointerSignal: onPointerSignal, behavior: behavior, ); } @override void updateRenderObject(BuildContext context, RenderPointerListener renderObject) { renderObject ..onPointerDown = onPointerDown ..onPointerMove = onPointerMove ..onPointerUp = onPointerUp ..onPointerHover = onPointerHover ..onPointerCancel = onPointerCancel ..onPointerPanZoomStart = onPointerPanZoomStart ..onPointerPanZoomUpdate = onPointerPanZoomUpdate ..onPointerPanZoomEnd = onPointerPanZoomEnd ..onPointerSignal = onPointerSignal ..behavior = behavior; } } 可以看到，Listener的代码并不多，它继承自SingleChildRenderObjectWidget，所创建的RenderObject为RenderPointerListener。\nListener中包含了许多原始指针事件的监听回调，这里列出几个较为常见的。\nListener回调 说明 PointerDownEventListener 当指针接触屏幕（对于触摸指针）或在此Widget的位置按下其按钮（对于鼠标指针）时调用 PointerMoveEventListener 当触发onPointerDown的指针改变位置时调用 PointerUpEventListener 当触发onPointerDown的指针不再与屏幕接触时调用 PointerCancelEventListener 当触发onPointerDown的指针的输入不再定向到该接收器时调用。 \u0026hellip; \u0026hellip; 当触发指针事件时，监听回调的入参PointerDownEvent、 PointerMoveEvent、 PointerUpEvent与PointerCancelEvent均是PointerEvent的子类。\nPointerEvent类是触摸、手写笔或鼠标事件的基类，它包含了很多属性，这里列出几个较为常见的。\n属性 说明 kind 为其生成事件的输入设备的类型 position 指针位置的坐标，以全局坐标空间中的逻辑像素为单位 delta 自上次PointerMoveEvent或PointerHoverEvent以来指针移动的距离（以逻辑像素为单位）。对于down、up和cancel事件，该值始终为 0.0 pressure 表示触摸的压力。该值是一个范围从 0.0（表示没有可辨别压力的触摸）到 1.0（表示具有“正常”压力的触摸）的数字，并且可能超过 1.0（表示有更强的触摸）。对于不检测压力的设备（例如鼠标），返回 1.0 orientation 检测到的物体的方向角，以弧度为单位。 transform 用于将该事件从全局坐标空间变换到事件接收者的坐标空间的变换。该值影响localPosition和localDelta返回的内容。如果该值为空，则将其视为恒等变换 localPosition 根据transform将position变换到事件接收者的本地坐标系中。如果此事件尚未转换，则按原样返回position \u0026hellip; \u0026hellip; 除此之外，Listener还有一个behavior参数需要注意一下，它的作用是决定子组件如何响应命中测试，如果不传入该参数，默认值为HitTestBehavior.deferToChild，关于behavior的分析本文后面会讲。\n二、Listener示例 为了便于分析，在Listener示例中丢弃了runApp方法带来的一个View结构（在实际项目中不能这样做），具体分析看解读Flutter源码之runApp一文。\n程序运行起来后，通过Flutter Inspector查看Widget层次结构如下所示。\n对应的代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void main() { _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return Listener( child: const ColoredBox(color: Colors.blueAccent), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;$event\u0026#39;), onPointerMove: (PointerMoveEvent event) =\u0026gt; debugPrint(\u0026#39;$event\u0026#39;), onPointerUp: (PointerUpEvent event) =\u0026gt; debugPrint(\u0026#39;$event\u0026#39;), onPointerCancel: (PointerCancelEvent event) =\u0026gt; debugPrint(\u0026#39;$event\u0026#39;), ); } } 当在屏幕上触摸时，打印的日志如下：\n1 2 3 4 I/flutter (26592): _TransformedPointerDownEvent#ec489(position: Offset(152.4, 615.2)) I/flutter (26592): _TransformedPointerMoveEvent#27677(position: Offset(155.0, 615.2)) I/flutter (26592): _TransformedPointerMoveEvent#7e2ef(position: Offset(157.7, 615.2)) I/flutter (26592): _TransformedPointerUpEvent#fd843(position: Offset(157.7, 615.2)) 从日志可以知道，在移动端各个平台或UI系统的原始指针事件模型基本都是一致，即：一次完整的事件分为三个阶段：手指按下、手指移动、和手指抬起。\n三、源码分析 3.1、_dispatchPointerDataPacket方法 当特定平台的原始指针事件模型（例如Android的MotionEvent）转换\u0026amp;流转到Flutter的Engine层时，Engine层就会通过 _dispatchPointerDataPacket 方法回调到Flutter的framework层，此时的原始指针事件模型已被转换为ByteData。\n1 2 3 4 5 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart @pragma(\u0026#39;vm:entry-point\u0026#39;) void _dispatchPointerDataPacket(ByteData packet) { PlatformDispatcher.instance._dispatchPointerDataPacket(packet); } 看下PlatformDispatcher的成员方法 _dispatchPointerDataPacket，可以发现如果onPointerDataPacket回调不为null，那么就会调用 _invoke1 方法，并且将onPointerDataPacket回调作为参数传入了 _invoke1 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 PointerDataPacketCallback? get onPointerDataPacket =\u0026gt; _onPointerDataPacket; PointerDataPacketCallback? _onPointerDataPacket; Zone _onPointerDataPacketZone = Zone.root; set onPointerDataPacket(PointerDataPacketCallback? callback) { _onPointerDataPacket = callback; _onPointerDataPacketZone = Zone.current; } // Called from the engine, via hooks.dart void _dispatchPointerDataPacket(ByteData packet) { if (onPointerDataPacket != null) { _invoke1\u0026lt;PointerDataPacket\u0026gt;( // 传入PointerDataPacketCallback回调 onPointerDataPacket, _onPointerDataPacketZone, _unpackPointerDataPacket(packet), ); } } 来看下PointerDataPacketCallback回调的声明，可以发现此时接收的参数为PointerDataPacket，说明原始指针事件模型已由ByteData转换为PointerDataPacket，这是在 _invoke1 方法中完成的。\n1 typedef PointerDataPacketCallback = void Function(PointerDataPacket packet); 跟踪下 _invoke1 方法的源码，可以发现调用了callback并且传入了arg参数，此时PointerDataPacket为arg，而arg则是 _unpackPointerDataPacket(packet) 方法进行传入的，说明原始指针事件模型ByteData转换为PointerDataPacket是通过 _unpackPointerDataPacket 方法。\n1 2 3 4 5 6 7 8 9 10 11 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart void _invoke1\u0026lt;A\u0026gt;(void Function(A a)? callback, Zone zone, A arg) { if (callback == null) { return; } if (identical(zone, Zone.current)) { callback(arg); } else { zone.runUnaryGuarded\u0026lt;A\u0026gt;(callback, arg); } } OK，回到 _dispatchPointerDataPacket 方法，那么PointerDataPacketCallback回调的实例是在哪里创建的呢？\n答案是在GestureBinding的initInstances方法中创建的，看下它的源码，可以发现将 _handlePointerDataPacket 方法赋值给了platformDispatcher的onPointerDataPacket回调。\n1 2 3 4 5 6 7 8 mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget { @override void initInstances() { super.initInstances(); _instance = this; platformDispatcher.onPointerDataPacket = _handlePointerDataPacket; } } 继续跟踪下GestureBinding的 _handlePointerDataPacket 方法的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 final Queue\u0026lt;PointerEvent\u0026gt; _pendingPointerEvents = Queue\u0026lt;PointerEvent\u0026gt;(); void _handlePointerDataPacket(ui.PointerDataPacket packet) { // 我们将指针数据转换为逻辑像素，以便例如触摸斜率可以以与设备无关的方式定义。 // We convert pointer data to logical pixels so that e.g. the touch slop can be // defined in a device-independent manner. try { _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, _devicePixelRatioForView)); // lockEvents当前是否正在锁定事件。绑定触发事件的子类应该首先检查它，如果设置了，则对事件进行排队而不是触发它们。调用unlocked时应刷新事件。 // 主要用于非用户交互时间，例如允许reassembleApplication在遍历树时阻止输入（部分异步执行），或者锁定事件，以便触摸事件等在预定帧完成之前不会自行插入。 if (!locked) { _flushPointerEventQueue(); } } catch (error, stack) { FlutterError.reportError(FlutterErrorDetails( exception: error, stack: stack, library: \u0026#39;gestures library\u0026#39;, context: ErrorDescription(\u0026#39;while handling a pointer data packet\u0026#39;), )); } } 可以看到，在GestureBinding的 _handlePointerDataPacket 方法中，将PointerDataPacket转换为了PointerEvent，添加进 _pendingPointerEvents 队列中，然后执行了 _flushPointerEventQueue 方法。\n1 2 3 4 5 6 7 void _flushPointerEventQueue() { assert(!locked); while (_pendingPointerEvents.isNotEmpty) { handlePointerEvent(_pendingPointerEvents.removeFirst()); } } 在GestureBinding的 _flushPointerEventQueue 方法中，while循环遍历 _pendingPointerEvents 队列，执行handlePointerEvent方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 将事件分派到通过对其位置进行命中测试找到的目标。 void handlePointerEvent(PointerEvent event) { assert(!locked); if (resamplingEnabled) { _resampler.addOrDispatch(event); _resampler.sample(samplingOffset, _samplingClock); return; } // Stop resampler if resampling is not enabled. This is a no-op if // resampling was never enabled. _resampler.stop(); _handlePointerEventImmediately(event); } 在GestureBinding的handlePointerEvent方法中，执行了 _handlePointerEventImmediately 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void _handlePointerEventImmediately(PointerEvent event) { HitTestResult? hitTestResult; if (event is PointerDownEvent || event is PointerSignalEvent || event is PointerHoverEvent || event is PointerPanZoomStartEvent) { assert(!_hitTests.containsKey(event.pointer), \u0026#39;Pointer of ${event.toString(minLevel: DiagnosticLevel.debug)} unexpectedly has a HitTestResult associated with it.\u0026#39;); // 分析一 hitTestResult = HitTestResult(); hitTestInView(hitTestResult, event.position, event.viewId); if (event is PointerDownEvent || event is PointerPanZoomStartEvent) { _hitTests[event.pointer] = hitTestResult; } assert(() { if (debugPrintHitTestResults) { debugPrint(\u0026#39;${event.toString(minLevel: DiagnosticLevel.debug)}: $hitTestResult\u0026#39;); } return true; }()); } else if (event is PointerUpEvent || event is PointerCancelEvent || event is PointerPanZoomEndEvent) { // 分析二 hitTestResult = _hitTests.remove(event.pointer); } else if (event.down || event is PointerPanZoomUpdateEvent) { // 因为指针向下时发生的事件（例如 [PointerMoveEvent]）应该分派到其初始 PointerDownEvent 所在的相同位置，所以我们希望重用指针向下时找到的路径，而不是每次都进行命中检测是时候我们得到这样的事件了。 // Because events that occur with the pointer down (like // [PointerMoveEvent]s) should be dispatched to the same place that their // initial PointerDownEvent was, we want to re-use the path we found when // the pointer went down, rather than do hit detection each time we get // such an event. // 分析三 hitTestResult = _hitTests[event.pointer]; } assert(() { if (debugPrintMouseHoverEvents \u0026amp;\u0026amp; event is PointerHoverEvent) { debugPrint(\u0026#39;$event\u0026#39;); } return true; }()); // 分析四 if (hitTestResult != null || event is PointerAddedEvent || event is PointerRemovedEvent) { dispatchEvent(event, hitTestResult); } } 分析一： 如果event的类型为PointerDownEvent，就会创建一个HitTestResult，用来记录执行命中测试的结果。\n然后执行hitTestInView方法进行命中测试，最后确保event的类型为PointerDownEvent时，将HitTestResult保存在 _hitTests这个Map中。\n分析二： 如果event的类型为PointerUpEvent，或者event的类型为PointerCancelEvent时，从 _hitTests 这个Map中移除此次命中测试的结果。\n分析三： 此处event.down表示设置指针当前是否向下。对于触摸和手写笔指针，这意味着物体（手指、笔）与输 入表面接触。对于鼠标来说，这意味着按下了按钮。\n如果是相同的指针向下位置，那么其实可以复用之前的命中测试结果，所以从直接从 _hitTests 这个Map中取出hitTestResult即可。\n分析四： 如果hitTestResult不为null时，执行dispatchEvent方法将事件发送到给定HitTestResult条目中的每个HitTestTarget，也就是进行事件分发。\n3.2、命中测试（Hit Test） 3.2.1、什么是命中测试？ 由分析一可以知道，如果event的类型为PointerDownEvent，也就是当指针按下时，Flutter会对应用程序执行命中测试（执行hitTestInView方法），作用是为了确定指针与屏幕接触的位置存在哪些组件（Widget）。\n然后指针按下事件以及该指针的后续事件将被分发到由命中测试发现的最内部的组件，也就是从那里开始，事件会在组件树中向上冒泡。\n这些事件会从最内部的组件开始，沿着组件树中根组件路径的方向，分发给沿途所有命中测试的组件，注意：Flutter中没有机制取消或停止“冒泡”过程。\n我们需要知道，命中测试的逻辑都在RenderObject中，而并非在Widget或Element中。\n3.2.2、RenderObject单个子节点的命中测试过程（Listener示例） 接着上面分析一，可以知道执行了GestureBinding的hitTestInView方法，又因为RendererBinding是GestureBinding的子类，并且重写了hitTestInView方法，所以这里会执行RendererBinding的hitTestInView方法。\n1 2 3 4 5 6 7 8 9 10 11 12 @override void hitTestInView(HitTestResult result, Offset position, int viewId) { // Currently Flutter only supports one view, the implicit view `renderView`. // TODO(dkwingsmt): After Flutter supports multi-view, look up the correct // render view for the ID. // https://github.com/flutter/flutter/issues/121573 assert(viewId == _implicitViewId, \u0026#39;Unexpected view ID $viewId (expecting implicit view ID $_implicitViewId)\u0026#39;); assert(viewId == renderView.flutterView.viewId); renderView.hitTest(result, position: position); super.hitTestInView(result, position, viewId); } 可以看到，当发生指针事件时，Flutter会从根节点RenderView开始调用它hitTest方法，然后调用super.hitTestInView执行父类GestureBinding的hitTestInView方法。\n1 2 3 4 5 6 7 8 // 确定哪些HitTestTarget对象位于指定视图中的给定位置 @override // from HitTestable void hitTestInView(HitTestResult result, Offset position, int viewId) { // 这里创建了一个HitTestEntry实例，传入this，此处this指的是WidgetsFlutterBinding，这个看runApp方法就可以知道 // 然后把HitTestEntry实例添加进HitTestResult保存，该HitTestEntry实例在List中是最后一个位置 // 这里添加进来和手势识别GestureDetector相关，看它的handleEvent方法，这里本文先不讲 result.add(HitTestEntry(this)); } 先回到根节点RenderView的hitTest方法，看下它的源码，可以发现执行了child的hitTest方法，最后把根节点RenderView添加进了HitTestResult中。那么，这里child是谁呢？很显然，就是示例中的RenderPointerListener。\n1 2 3 4 5 6 7 bool hitTest(HitTestResult result, { required Offset position }) { if (child != null) { child!.hitTest(BoxHitTestResult.wrap(result), position: position); } result.add(HitTestEntry(this)); return true; } 继续看下RenderPointerListener的hitTest方法，又因为RenderPointerListener继承自RenderProxyBoxWithHitTestBehavior，而RenderPointerListener没有重写hitTest方法，所以看下RenderProxyBoxWithHitTestBehavior的hitTest方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 确定位于给定位置的渲染对象集 @override bool hitTest(BoxHitTestResult result, { required Offset position }) { bool hitTarget = false; // 判断事件的触发位置是否位于组件范围内 if (size.contains(position)) { hitTarget = hitTestChildren(result, position: position) || hitTestSelf(position); if (hitTarget || behavior == HitTestBehavior.translucent) { result.add(BoxHitTestEntry(this, position)); } } return hitTarget; } 在RenderProxyBoxWithHitTestBehavior的hitTest方法中，先执行了hitTestChildren方法，这个方法定义在RenderProxyBoxWithHitTestBehavior的父类RenderProxyBox，它所混入的RenderProxyBoxMixin中。\n看下RenderProxyBoxMixin的hitTestChildren方法。\n1 2 3 4 @override bool hitTestChildren(BoxHitTestResult result, { required Offset position }) { return child?.hitTest(result, position: position) ?? false; } 在RenderProxyBoxMixin的hitTestChildren方法中，又执行了child的hitTest方法。那么，这里child是谁呢？很显然，就是示例中的 _RenderColoredBox。\n而 _RenderColoredBox 继承自RenderProxyBoxWithHitTestBehavior，自身并没有重写hitTest方法，所以执行了RenderProxyBoxWithHitTestBehavior的hitTest方法。\n看到这里，已经知道hitTest方法是一个不断调用子节点hitTest方法的递归过程了。很明显，对于 _RenderColoredBox来说是命中测试的，所以返回true，_RenderColoredBox会被添加进HitTestResult列表。\n之后对于RenderPointerListener来说也是命中测试的，因为它的hitTestChildren方法返回true，RenderPointerListener会被添加进HitTestResult列表。\n注意：一个对象是否可以响应事件，取决于在其对命中测试过程中是否被添加到了HitTestResult列表，如果没有被添加进去，则后续的事件分发将不会分发给自己。\n此时，HitTestResult列表中保存的命中测试的RenderObject如下所示。\n3.2.3、RenderObject多个子节点的命中测试过程 如果一个渲染对象有多个子节点，则命中测试逻辑为：如果任意一个子节点通过了命中测试或者当前节点“强行声明”自己通过了命中测试，则当前节点会通过命中测试。\n以Row为例，它的RenderObject为RenderFlex，RenderFlex重写了父类RenderBox的hitTestChildren方法。\n1 2 3 4 @override bool hitTestChildren(BoxHitTestResult result, { required Offset position }) { return defaultHitTestChildren(result, position: position); } 在RenderFlex的hitTestChildren方法中，执行了RenderBoxContainerDefaultsMixin的defaultHitTestChildren方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool defaultHitTestChildren(BoxHitTestResult result, { required Offset position }) { // 遍历所有子组件（子节点从后向前遍历） ChildType? child = lastChild; while (child != null) { // The x, y parameters have the top left of the node\u0026#39;s box as the origin. final ParentDataType childParentData = child.parentData! as ParentDataType; // 子组件的hitTest方法的返回值 final bool isHit = result.addWithPaintOffset( offset: childParentData.offset, position: position, hitTest: (BoxHitTestResult result, Offset transformed) { assert(transformed == position - childParentData.offset); // 调用子组件的hitTest方法 return child!.hitTest(result, position: transformed); }, ); // 一旦有一个子节点的 hitTest() 方法返回 true，则终止遍历，直接返回true if (isHit) { return true; } child = childParentData.previousSibling; } return false; } 再看下BoxHitTestResult的addWithPaintOffset方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bool addWithPaintOffset({ required Offset? offset, required Offset position, required BoxHitTest hitTest, }) { final Offset transformedPosition = offset == null ? position : position - offset; if (offset != null) { pushOffset(-offset); } // 子组件的hitTest方法的返回值 final bool isHit = hitTest(this, transformedPosition); if (offset != null) { popTransform(); } return isHit; } 通过上面源码可以发现，这里的while循环遍历中提供了一种中断机制，遍历过程中只要有子节点的hitTest()返回了true时，就会终止子节点遍历，这意味着该子节点前面的兄弟节点将没有机会通过命中测试。注意，兄弟节点的遍历倒序的。\n此时，父节点也会通过命中测试。因为子节点hitTest()返回了true导父节点hitTestChildren也会返回true，最终会导致父节点的hitTest返回true，父节点被添加到HitTestResult中。\n但是，当子节点的hitTest()返回了false时，继续遍历该子节点前面的兄弟节点，对它们进行命中测试，如果所有子节点都返回false时，则父节点会调用自身的hitTestSelf方法，如果该方法也返回 false，则父节点就会被认为没有通过命中测试。\n到这里会有两个疑问：\n1、为什么兄弟节点的遍历要倒序？\n兄弟节点一般不会重叠，而一旦发生重叠的话（比如在Stack布局中，兄弟组件的布局会重叠），往往是后面的组件会在前面组件之上，点击时应该是后面的组件会响应事件，而前面被遮住的组件不能响应，所以命中测试应该优先对后面的节点进行测试，因为一旦通过测试，就不会再继续遍历了。如果我们按照正向遍历，则会出现被遮住的组件能响应事件，而位于上面的组件反而不能，这明显不符合预期。\n2、为什么要制定这个while循环遍历中断呢？\n为了兼容一些重叠布局，如上面说的Stack布局。如果我们想让位于底部的组件也能响应事件，就得有一种机制，能让我们确保即使找到了一个节点，也不应该终止遍历，也就是说所有的子组件的hitTest方法都必须返回false。Flutter中可以通过HitTestBehavior来实现这个过程，这个本文后面会讲。\n如果hitTestSelf返回true，则无论子节点中是否有通过命中测试的节点，当前节点自身都会被添加到HitTestResult中。\n3.3、事件分发 回到GestureBinding的 _handlePointerEventImmediately ，看下分析四，执行了dispatchEvent方法，事件分发就相对简单了，遍历HitTestResult，调用每一个节点的 handleEvent方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @override // from HitTestDispatcher @pragma(\u0026#39;vm:notify-debugger-on-exception\u0026#39;) void dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) { assert(!locked); // No hit test information implies that this is a [PointerAddedEvent] or // [PointerRemovedEvent]. These events are specially routed here; other // events will be routed through the `handleEvent` below. if (hitTestResult == null) { assert(event is PointerAddedEvent || event is PointerRemovedEvent); try { pointerRouter.route(event); } catch (exception, stack) { FlutterError.reportError(FlutterErrorDetailsForPointerEventDispatcher( exception: exception, stack: stack, library: \u0026#39;gesture library\u0026#39;, context: ErrorDescription(\u0026#39;while dispatching a non-hit-tested pointer event\u0026#39;), event: event, informationCollector: () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;PointerEvent\u0026gt;(\u0026#39;Event\u0026#39;, event, style: DiagnosticsTreeStyle.errorProperty), ], )); } return; } for (final HitTestEntry entry in hitTestResult.path) { try { entry.target.handleEvent(event.transformed(entry.transform), entry); } catch (exception, stack) { FlutterError.reportError(FlutterErrorDetailsForPointerEventDispatcher( exception: exception, stack: stack, library: \u0026#39;gesture library\u0026#39;, context: ErrorDescription(\u0026#39;while dispatching a pointer event\u0026#39;), event: event, hitTestEntry: entry, informationCollector: () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;PointerEvent\u0026gt;(\u0026#39;Event\u0026#39;, event, style: DiagnosticsTreeStyle.errorProperty), DiagnosticsProperty\u0026lt;HitTestTarget\u0026gt;(\u0026#39;Target\u0026#39;, entry.target, style: DiagnosticsTreeStyle.errorProperty), ], )); } } } 这里以Listener的渲染对象RenderPointerListener为例，看下它的handleEvent方法，可以看到，最终是根据event的类型，来执行不同的事件回调。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @override void handleEvent(PointerEvent event, HitTestEntry entry) { assert(debugHandleEvent(event, entry)); if (event is PointerDownEvent) { return onPointerDown?.call(event); } if (event is PointerMoveEvent) { return onPointerMove?.call(event); } if (event is PointerUpEvent) { return onPointerUp?.call(event); } if (event is PointerHoverEvent) { return onPointerHover?.call(event); } if (event is PointerCancelEvent) { return onPointerCancel?.call(event); } if (event is PointerPanZoomStartEvent) { return onPointerPanZoomStart?.call(event); } if (event is PointerPanZoomUpdateEvent) { return onPointerPanZoomUpdate?.call(event); } if (event is PointerPanZoomEndEvent) { return onPointerPanZoomEnd?.call(event); } if (event is PointerSignalEvent) { return onPointerSignal?.call(event); } } 3.4、事件清理 回到GestureBinding的 _handlePointerEventImmediately ，看下分析二，可以发现，如果是PointerUpEvent或者PointerCancelEvent，那么从 _hitTests 里移除该hitTestResult，同时会返回当前的hitTestResult，继续分发这个事件，但是也代表这次事件流结束了。\n1 2 3 4 else if (event is PointerUpEvent || event is PointerCancelEvent || event is PointerPanZoomEndEvent) { // 分析二 hitTestResult = _hitTests.remove(event.pointer); } 3.5、HitTestBehavior 之前提到Listener组件有一个behavior参数，默认值为HitTestBehavior.deferToChild。那这个参数在哪里用到呢？\n我们知道，Listener组件的渲染对象RenderPointerListener继承了RenderProxyBoxWithHitTestBehavior类。\n在RenderProxyBoxWithHitTestBehavior的hitTest方法以及hitTestSelf方法中就有用到behavior参数，它的取值会影响Listener的命中测试结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override bool hitTest(BoxHitTestResult result, { required Offset position }) { bool hitTarget = false; if (size.contains(position)) { hitTarget = hitTestChildren(result, position: position) || hitTestSelf(position); if (hitTarget || behavior == HitTestBehavior.translucent) { result.add(BoxHitTestEntry(this, position)); } } return hitTarget; } @override bool hitTestSelf(Offset position) =\u0026gt; behavior == HitTestBehavior.opaque; 来看下HitTestBehavior的取值。\nHitTestBehavior取值 说明 deferToChild 仅当其子级之一被命中测试击中时，遵从其子级的目标才会在其范围内接收事件 opaque 不透明目标可以通过命中测试命中，导致它们既接收其边界内的事件，又阻止视觉上位于其后面的目标也接收事件 translucent 半透明目标既接收其边界内的事件，又允许其后方的目标也接收事件 它有三个取值，我们结合hitTest实现来分析一下不同取值的作用：\n1、behavior为deferToChild时，hitTestSelf返回false，当前组件是否能通过命中测试完全取决于hitTestChildren的返回值。也就是说只要有一个子节点通过命中测试，则当前组件便会通过命中测试。\n2、behavior为opaque时，hitTestSelf返回true，hitTarget值始终为true，当前组件通过命中测试。\n3、behavior为translucent时，hitTestSelf返回false，hitTarget值此时取决于hitTestChildren的返回值，但是无论hitTarget值是什么，当前节点都会被添加到 HitTestResult中。\n注意，behavior为opaque和translucent时当前组件都会通过命中测试，它们的区别是 hitTest() 的返回值（hitTarget）可能不同，所以它们的区别就看hitTest() 的返回值会影响什么，这个前面已经讲过。\n一般情况下，只有Listener的子节点hitTest返回false时两者才有区别，这种场景不好找，这里只能强行制造一个场景，看下opaque和translucent体现的差异情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( home: Stack( children: [ _createWidget(1), _createWidget(2), ], ), ); } Widget _createWidget(int index) { return Listener( behavior: HitTestBehavior.translucent, // 放开此行，点击会同时输出 2 和 1 // behavior: HitTestBehavior.opaque, // 放开此行，点击只会输出 2 onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;$index\u0026#39;), child: const SizedBox.expand(), ); } } 因为SizedBox的渲染对象为RenderConstrainedBox，而RenderConstrainedBox的间接父类是RenderBox，所以hitTest、hitTestChildren以及hitTestSelf方法实现均在RenderBox中。\n可以看到hitTestChildren与hitTestSelf均返回false，所以它的hitTest方法也就返回false，说明SizedBox没有命中测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 bool hitTest(BoxHitTestResult result, { required Offset position }) { assert(() { if (!hasSize) { if (debugNeedsLayout) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot hit test a render box that has never been laid out.\u0026#39;), describeForError(\u0026#39;The hitTest() method was called on this RenderBox\u0026#39;), ErrorDescription( \u0026#34;Unfortunately, this object\u0026#39;s geometry is not known at this time, \u0026#34; \u0026#39;probably because it has never been laid out. \u0026#39; \u0026#39;This means it cannot be accurately hit-tested.\u0026#39;, ), ErrorHint( \u0026#39;If you are trying \u0026#39; \u0026#39;to perform a hit test during the layout phase itself, make sure \u0026#39; \u0026#34;you only hit test nodes that have completed layout (e.g. the node\u0026#39;s \u0026#34; \u0026#39;children, after their layout() method has been called).\u0026#39;, ), ]); } throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot hit test a render box with no size.\u0026#39;), describeForError(\u0026#39;The hitTest() method was called on this RenderBox\u0026#39;), ErrorDescription( \u0026#39;Although this node is not marked as needing layout, \u0026#39; \u0026#39;its size is not set.\u0026#39;, ), ErrorHint( \u0026#39;A RenderBox object must have an \u0026#39; \u0026#39;explicit size before it can be hit-tested. Make sure \u0026#39; \u0026#39;that the RenderBox in question sets its size during layout.\u0026#39;, ), ]); } return true; }()); if (_size!.contains(position)) { if (hitTestChildren(result, position: position) || hitTestSelf(position)) { result.add(BoxHitTestEntry(this, position)); return true; } } return false; } @protected bool hitTestSelf(Offset position) =\u0026gt; false; @protected bool hitTestChildren(BoxHitTestResult result, { required Offset position }) =\u0026gt; false; 在来看下Listener的渲染对象RenderPointerListener，RenderPointerListener的父类为RenderProxyBoxWithHitTestBehavior，它重写了hitTest以及hitTestSelf方法。\n因为SizedBox没有命中测试，所以hitTestChildren方法返回false，现在看hitTestSelf方法，可以发现hitTestSelf方法返回behavior == HitTestBehavior.opaque。\n如果behavior为opaque，那么hitTestSelf返回返回true，hitTest方法也就返回true，所以while循环倒叙遍历时，第二个Listener命中测试，然后中断while循环，此时点击只会输出2。\n如果behavior为translucent，那么hitTestSelf返回返回false，hitTest方法也就返回false，所以没有中断while循环，并且两个Listener均命中测试，此时点击只会输出2，1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @override bool hitTest(BoxHitTestResult result, { required Offset position }) { bool hitTarget = false; if (size.contains(position)) { hitTarget = hitTestChildren(result, position: position) || hitTestSelf(position); if (hitTarget || behavior == HitTestBehavior.translucent) { result.add(BoxHitTestEntry(this, position)); } } return hitTarget; } @override bool hitTestSelf(Offset position) =\u0026gt; behavior == HitTestBehavior.opaque; 四、扩展 4.1、AbsorbPointer 假如我们不想让某个子树响应PointerEvent的话，我们可以使用AbsorbPointer，它有一个absorbing参数，默认值为true（下面示例不传入），表示是否在命中测试期间吸收指针。例如下面这个例子就只会打印“outer down”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return Listener( child: AbsorbPointer( child: Listener( child: const ColoredBox(color: Colors.blueAccent), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;inner down\u0026#39;), ), ), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;outer down\u0026#39;), ); } } 来看下AbsorbPointer的渲染对象RenderAbsorbPointer，它重写hitTest方法。可以看到，absorbing默认值为true时，走的是size.contains(position)逻辑，也就是不再递归执行子节点的命中测试，所以AbsorbPointer内部的Listener无法响应事件。\n1 2 3 4 5 6 @override bool hitTest(BoxHitTestResult result, { required Offset position }) { return absorbing ? size.contains(position) : super.hitTest(result, position: position); } 4.2、IgnorePointer 除了AbsorbPointer可以不让某个子树响应事件，IgnorePointer也具备该功能。它有一个ignoring参数，默认值为true（下面示例不传入），表示在命中测试期间是否忽略此Widget。例如下面这个例子就什么也不打印了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return Listener( child: IgnorePointer( child: Listener( child: const ColoredBox(color: Colors.blueAccent), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;inner down\u0026#39;), ), ), onPointerDown: (PointerDownEvent event) =\u0026gt; debugPrint(\u0026#39;outer down\u0026#39;), ); } } 来看下IgnorePointer的渲染对象RenderIgnorePointer，它重写hitTest方法。可以看到，ignoring默认值为true时，hitTest方法返回false，所以IgnorePointer内部的Listener无法响应事件，而且也会导致外部Listener的hitTestChildren方法返回false，导致外部Listener也不能命中测试。\n1 2 3 4 @override bool hitTest(BoxHitTestResult result, { required Offset position }) { return !ignoring \u0026amp;\u0026amp; super.hitTest(result, position: position); } 五、总结 Flutter事件处理流程主要分3步：\n1、命中测试：当手指按下时，触发PointerDownEvent事件，按照深度优先遍历当前渲染（render object）树，对每一个渲染对象进行“命中测试”（hit test），如果命中测试通过，则该渲染对象会被添加到一个HitTestResult列表当中。\n2、事件分发：命中测试完毕后，会遍历HitTestResult列表，调用每一个渲染对象的事件处理方法（handleEvent）来处理PointerDownEvent事件，该过程称为“事件分发”（event dispatch）。随后当手指移动时，便会分发PointerMoveEvent事件。\n3、事件清理：当手指抬（PointerUpEvent）起或事件取消时（PointerCancelEvent），会先对相应的事件进行分发，分发完毕后会清空HitTestResult列表。\n","date":"2023-11-11T09:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Blistener/","section":"post","tags":null,"title":"解读Flutter源码之Listener"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在之前解读Flutter源码之InheritedWidget一文中，我们已知晓，在Widget多层嵌套的情况下，将数据从父级Widget传递给子级Widget时，采用InheritedWidget的方式非常好用。\n但是，如果传递方向是反过来的情况下，也就是变为从子级Widget向父级Widget传递数据，那么依然可以选择从InheritedWidget传入Listener的方式来实现。\n例如，还是之前的计数器示例，只不过添加多一个“Post”按钮来触发子级Widget向父级Widget传递数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyParent( counter: _counter, listener: (String result) =\u0026gt; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(result))), child: const MyChild(), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; final ValueChanged\u0026lt;String\u0026gt; listener; const MyParent({ super.key, required this.counter, required this.listener, required super.child, }); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ElevatedButton( onPressed: () =\u0026gt; MyParent.of(context).listener(\u0026#39;Hello World!\u0026#39;), child: const Text(\u0026#39;Post\u0026#39;), ), ], ), ); } } 程序运行起来后，效果如下：\n另外，Flutter的NotificationListener（通知监听）为我们提供了一个更优雅的方式去实现上面的效果，并且功能更强大，可以传递给多个父级Widget处理。\n二、什么是通知监听？ 关于NotificationListener（通知监听），在Flutter官网中是找不到它的详细介绍的，而且NotificationListener的代码注释也非常少，先来看下它的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// 一个监听在树上冒泡的Notification的widget /// A widget that listens for [Notification]s bubbling up the tree. /// /// 仅当Notifications的runtimeType是T的子类型时，才会触发onNotification回调。 /// Notifications will trigger the [onNotification] callback only if their /// [runtimeType] is a subtype of `T`. /// /// 要发送通知，请使用Notification.dispatch方法。 /// To dispatch notifications, use the [Notification.dispatch] method. class NotificationListener\u0026lt;T extends Notification\u0026gt; extends ProxyWidget { const NotificationListener({ super.key, required super.child, this.onNotification, }); /// 当适当类型的通知到达树中的此位置时调用。 /// Called when a notification of the appropriate type arrives at this /// location in the tree. /// /// 返回 true 取消通知冒泡。返回 false 以允许通知继续分派给更远的祖先 /// Return true to cancel the notification bubbling. Return false to /// allow the notification to continue to be dispatched to further ancestors. /// /// 通知的发送时间有所不同。主要有两种可能性：帧之间的分发和布局期间的分发 /// Notifications vary in terms of when they are dispatched. There are two /// main possibilities: dispatch between frames, and dispatch during layout. /// /// 对于在布局期间分派的通知（例如从LayoutChangedNotification继承的通知），调用State.setState来响应通知为时已晚（根据定义，布局当前发生在后代中，因为通知会在树中冒泡）。 /// 对于依赖于布局的小部件，请考虑使用LayoutBuilder /// For notifications that dispatch during layout, such as those that inherit /// from [LayoutChangedNotification], it is too late to call [State.setState] /// in response to the notification (as layout is currently happening in a /// descendant, by definition, since notifications bubble up the tree). For /// widgets that depend on layout, consider a [LayoutBuilder] instead. final NotificationListenerCallback\u0026lt;T\u0026gt;? onNotification; @override Element createElement() { return _NotificationElement\u0026lt;T\u0026gt;(this); } } 可以发现，上面NotificationListener的注释是描述得不够详细的，下面结合它的注释\u0026amp;笔者的观点总结一下它的特性。\n1、与InheritedWidget一样，NotificationListener同样继承自ProxyWidget，ProxyWidget用来提供了一个子Widget，而不是构建一个新的Widget。\n2、NotificationListener可以指定一个泛型T，该泛型T必须是Notification的子类。注意：当显式指定泛型T时，如ScrollUpdateNotification，NotificationListener便只会接收ScrollUpdateNotification类型的通知。\n3、NotificationListener需要传入一个onNotification参数，它的类型是NotificationListenerCallback，如果返回true时就会取消通知冒泡，否则允许通知继续分派给更远的祖先。\n4、通知是Flutter中一个重要的机制，在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父级Widget都可以通过NotificationListener来监听通知。因此，Flutter中将这种由子级Widget向父级Widget的传递通知的机制称为通知冒泡（Notification Bubbling）。\n5、通知冒泡和用户触摸事件（Listener）是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。\n6、Flutter中很多地方使用了通知，如下面将要介绍的PageView示例，它所创建的 _PageViewState 的build方法中就使用了NotificationListener监听滚动通知来实现onPageChanged功能，看下build方法源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @override Widget build(BuildContext context) { final AxisDirection axisDirection = _getDirection(context); final ScrollPhysics physics = _ForceImplicitScrollPhysics( allowImplicitScrolling: widget.allowImplicitScrolling, ).applyTo( widget.pageSnapping ? _kPagePhysics.applyTo(widget.physics ?? widget.scrollBehavior?.getScrollPhysics(context)) : widget.physics ?? widget.scrollBehavior?.getScrollPhysics(context), ); return NotificationListener\u0026lt;ScrollNotification\u0026gt;( onNotification: (ScrollNotification notification) { // 监听滚动通知 if (notification.depth == 0 \u0026amp;\u0026amp; widget.onPageChanged != null \u0026amp;\u0026amp; notification is ScrollUpdateNotification) { final PageMetrics metrics = notification.metrics as PageMetrics; // 获取当前页码 final int currentPage = metrics.page!.round(); if (currentPage != _lastReportedPage) { _lastReportedPage = currentPage; // 实现onPageChanged回调 widget.onPageChanged!(currentPage); } } return false; }, child: Scrollable( dragStartBehavior: widget.dragStartBehavior, axisDirection: axisDirection, controller: widget.controller, physics: physics, restorationId: widget.restorationId, scrollBehavior: widget.scrollBehavior ?? ScrollConfiguration.of(context).copyWith(scrollbars: false), viewportBuilder: (BuildContext context, ViewportOffset position) { return Viewport( // TODO(dnfield): we should provide a way to set cacheExtent // independent of implicit scrolling: // https://github.com/flutter/flutter/issues/45632 cacheExtent: widget.allowImplicitScrolling ? 1.0 : 0.0, cacheExtentStyle: CacheExtentStyle.viewport, axisDirection: axisDirection, offset: position, clipBehavior: widget.clipBehavior, slivers: \u0026lt;Widget\u0026gt;[ SliverFillViewport( viewportFraction: widget.controller.viewportFraction, delegate: widget.childrenDelegate, padEnds: widget.padEnds, ), ], ); }, ), ); } 这里给出了NotificationListener的部分特性，主要是想让大家对NotificationListener有一个初级认知。\n三、通知监听示例 在下面示例中，将通过NotificationListener来监听PageView的滚动通知的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;PageView滚动通知监听\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _widgets = [ const ColoredBox(color: Colors.redAccent), const ColoredBox(color: Colors.greenAccent), const ColoredBox(color: Colors.blueAccent), ]; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: NotificationListener( onNotification: (notification) { switch (notification.runtimeType) { case ScrollStartNotification: debugPrint(\u0026#39;开始滚动\u0026#39;); break; case ScrollUpdateNotification: debugPrint(\u0026#39;正在滚动\u0026#39;); break; case ScrollEndNotification: debugPrint(\u0026#39;滚动停止\u0026#39;); break; case OverscrollNotification: debugPrint(\u0026#39;滚动到边界\u0026#39;); break; case UserScrollNotification: debugPrint(\u0026#39;用户滚动\u0026#39;); break; } return false; }, child: PageView.builder( itemCount: _widgets.length, itemBuilder: (context, index) =\u0026gt; _widgets[index], ), ), ); } } 程序运行起来后，效果如下：\n当滑动PageView时，上面这5个通知均会输出相应的日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... I/flutter (21018): 开始滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 正在滚动 ... I/flutter (21018): 正在滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 滚动停止 I/flutter (21018): 用户滚动 I/flutter (21018): 开始滚动 I/flutter (21018): 用户滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 滚动到边界 I/flutter (21018): 滚动到边界 ... I/flutter (21018): 滚动到边界 I/flutter (21018): 滚动停止 I/flutter (21018): 用户滚动 通过查看它们的源码可以发现它们均继承自ScrollNotification类，并且不同类型的通知会包含不同的信息，比如ScrollUpdateNotification就有一个scrollDelta属性，它记录了移动的位移等。\n通知 说明 ScrollStartNotification Scrollable小部件已开始滚动的通知 ScrollUpdateNotification Scrollable小部件已更改其滚动位置的通知 ScrollEndNotification Scrollable小部件已停止滚动的通知 OverscrollNotification Scrollable小部件尚未更改其滚动位置，因为更改会导致其滚动位置超出其滚动范围的通知 UserScrollNotification 用户已更改滚动ScrollDirection或已停止滚动的通知 除了上面提到的和滚动相关的通知，还有一些其它的通知，例如KeepAliveNotification等，这些其它的通知和特定的功能相关。\n四、分析通知源码 4.1、通知节点树的形成 当你使用NotificationListener这个Widget时，它所关联的Element为 _NotificationElement，对于每个 _NotificationElement 来说，它会持有一个父通知节点 _NotificationNode（上一个 _NotificationElement 所创建的通知节点）。\n那么，在Element树的背后就会形成一颗通知节点树，来看下源码，了解下这颗通知节点树是怎么形成的。\n通知节点树形成的关键在于attachNotificationTree方法，那么它是在哪里执行的？\n当新创建的Element第一次添加到树中时，就会执行mount方法，在mount方法中会执行attachNotificationTree方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @mustCallSuper void mount(Element? parent, Object? newSlot) { assert(_lifecycleState == _ElementLifecycle.initial); assert(_parent == null); assert(parent == null || parent._lifecycleState == _ElementLifecycle.active); assert(slot == null); _parent = parent; _slot = newSlot; _lifecycleState = _ElementLifecycle.active; _depth = _parent != null ? _parent!.depth + 1 : 1; if (parent != null) { // Only assign ownership if the parent is non-null. If parent is null // (the root node), the owner should have already been assigned. // See RootRenderObjectElement.assignOwner(). _owner = parent.owner; } assert(owner != null); final Key? key = widget.key; if (key is GlobalKey) { owner!._registerGlobalKey(key, this); } _updateInheritance(); // 创建通知节点 attachNotificationTree(); } 以及在Element的activate方法中触发，也就是当先前停用的Element重新合并到Element树中时，也会执行attachNotificationTree方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @mustCallSuper void activate() { assert(_lifecycleState == _ElementLifecycle.inactive); assert(owner != null); final bool hadDependencies = (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) || _hadUnsatisfiedDependencies; _lifecycleState = _ElementLifecycle.active; // We unregistered our dependencies in deactivate, but never cleared the list. // Since we\u0026#39;re going to be reused, let\u0026#39;s clear our list now. _dependencies?.clear(); _hadUnsatisfiedDependencies = false; _updateInheritance(); // 创建通知节点 attachNotificationTree(); if (_dirty) { owner!.scheduleBuildFor(this); } if (hadDependencies) { didChangeDependencies(); } } 看下Element的attachNotificationTree方法，对于在mount第一个 _NotificationElement 之前的Element来说，它的通知节点为null。\n1 2 3 4 5 6 7 Element? _parent; _NotificationNode? _notificationTree; @protected void attachNotificationTree() { _notificationTree = _parent?._notificationTree; } 另外，attachNotificationTree方法会被子类NotifiableElementMixin重写，而且NotificationListener所关联的 _NotificationElement 会混入NotifiableElementMixin。\n因此，对于 _NotificationElement 来说，它会创建一个新的通知节点 _NotificationNode，看下NotifiableElementMixin的attachNotificationTree方法源码就知道。\n1 2 3 4 5 6 7 mixin NotifiableElementMixin on Element { @override void attachNotificationTree() { _notificationTree = _NotificationNode(_parent?._notificationTree, this); } } 再看下 _NotificationNode 源码可以发现， _NotificationNode 会持有父组件的 _NotificationNode（上一个 _NotificationElement 所创建的通知节点），也就是对应于parent参数，以及持有当前 _NotificationElement 所混入NotifiableElementMixin实例，也就是对应于current参数。\n1 2 3 4 5 6 class _NotificationNode { _NotificationNode(this.parent, this.current); NotifiableElementMixin? current; _NotificationNode? parent; } 总结：当Element执行mount方法挂载，如果遇到第一个_NotificationElement时，就会为其创建一个_NotificationNode通知节点，该通知节点会持有上一个_NotificationElement所创建的通知节点，注意此时之前Element的通知节点均为null，所以该通知节点持有的上一个_NotificationElement所创建的通知节点为null。之后的Element继续执行mount方法挂载，这些Element持有的通知节点依然是第一个_NotificationElement所创建的通知节点。如果遇到第二个_NotificationElement时，就会为其创建一个_NotificationNode通知节点，该通知节点会持有上一个_NotificationElement所创建的通知节点，也就是第一个_NotificationElement所创建的通知节点，如此往复形成一颗通知节点树。\n4.2、触发通知分发的过程 以上面PageView为例，之前看过它的build方法实现，内部会构建一个Scrollable，Scrollable是一个StatefulWidget，它所创建的State为ScrollableState。\n在ScrollableState中，有一个 _updatePosition 方法，来看下它的源码，发现它会执行 _effectiveScrollController.createScrollPosition 来创建一个ScrollPosition。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 仅在肯定会触发重建的地方调用此方法 // Only call this from places that will definitely trigger a rebuild. void _updatePosition() { _configuration = widget.scrollBehavior ?? ScrollConfiguration.of(context); _physics = _configuration.getScrollPhysics(context); if (widget.physics != null) { _physics = widget.physics!.applyTo(_physics); } else if (widget.scrollBehavior != null) { _physics = widget.scrollBehavior!.getScrollPhysics(context).applyTo(_physics); } final ScrollPosition? oldPosition = _position; if (oldPosition != null) { _effectiveScrollController.detach(oldPosition); // It\u0026#39;s important that we not dispose the old position until after the // viewport has had a chance to unregister its listeners from the old // position. So, schedule a microtask to do it. scheduleMicrotask(oldPosition.dispose); } // 创建一个ScrollPosition _position = _effectiveScrollController.createScrollPosition(_physics!, this, oldPosition); assert(_position != null); // 将ScrollPosition添加到ScrollController中的_positions中保存 _effectiveScrollController.attach(position); } 看下ScrollController的createScrollPosition方法，这个方法有子类PageController实现，发现它内部创建了一个 _PagePosition 实例。\n1 2 3 4 5 6 7 8 9 10 11 @override ScrollPosition createScrollPosition(ScrollPhysics physics, ScrollContext context, ScrollPosition? oldPosition) { return _PagePosition( physics: physics, context: context, initialPage: initialPage, keepPage: keepPage, viewportFraction: viewportFraction, oldPosition: oldPosition, ); } 通过跟踪 _PagePosition 的源码，可以发现它继承自ScrollPositionWithSingleContext，而ScrollPositionWithSingleContext又继承自ScrollPosition。\n在ScrollPosition中，定义了几个通知分发的方法，供子类 _PagePosition 调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // NOTIFICATION DISPATCH /// Called by [beginActivity] to report when an activity has started. void didStartScroll() { activity!.dispatchScrollStartNotification(copyWith(), context.notificationContext); } /// Called by [setPixels] to report a change to the [pixels] position. void didUpdateScrollPositionBy(double delta) { activity!.dispatchScrollUpdateNotification(copyWith(), context.notificationContext!, delta); } /// Called by [beginActivity] to report when an activity has ended. /// /// This also saves the scroll offset using [saveScrollOffset]. void didEndScroll() { activity!.dispatchScrollEndNotification(copyWith(), context.notificationContext!); saveOffset(); if (keepScrollOffset) { saveScrollOffset(); } } /// Called by [setPixels] to report overscroll when an attempt is made to /// change the [pixels] position. Overscroll is the amount of change that was /// not applied to the [pixels] value. void didOverscrollBy(double value) { assert(activity!.isScrolling); activity!.dispatchOverscrollNotification(copyWith(), context.notificationContext!, value); } /// Dispatches a notification that the [userScrollDirection] has changed. /// /// Subclasses should call this function when they change [userScrollDirection]. void didUpdateScrollDirection(ScrollDirection direction) { UserScrollNotification(metrics: copyWith(), context: context.notificationContext!, direction: direction).dispatch(context.notificationContext); } /// Dispatches a notification that the [ScrollMetrics] have changed. void didUpdateScrollMetrics() { assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks); assert(_haveScheduledUpdateNotification); _haveScheduledUpdateNotification = false; if (context.notificationContext != null) { ScrollMetricsNotification(metrics: copyWith(), context: context.notificationContext!).dispatch(context.notificationContext); } } 当PageController调用jumpToPage方法时，就会执行 _PagePosition 的jumpTo方法。\n1 2 3 4 5 6 7 8 9 void jumpToPage(int page) { final _PagePosition position = this.position as _PagePosition; if (position._cachedPage != null) { position._cachedPage = page.toDouble(); return; } position.jumpTo(position.getPixelsFromPage(page.toDouble())); } 因为ScrollPosition定义了jumpTo抽象方法，由子类来实现，所以看下 _PagePosition 的jumpTo方法，但是跟踪源码后发现 _PagePosition 并没有实现jumpTo方法，所以看下它的父类ScrollPositionWithSingleContext的jumpTo方法。\n1 2 3 4 5 6 7 8 9 10 11 12 @override void jumpTo(double value) { goIdle(); if (pixels != value) { final double oldPixels = pixels; forcePixels(value); didStartScroll(); didUpdateScrollPositionBy(pixels - oldPixels); didEndScroll(); } goBallistic(0.0); } 可以发现，在ScrollPositionWithSingleContext的jumpTo方法中，调用它的父类ScrollPosition的一些方法，它们是didStartScroll、didUpdateScrollPositionBy以及didEndScroll，之前讲过这几个方法是用来分发通知的。\n这里以didStartScroll方法为例，看下它的源码，执行了ScrollActivity的dispatchScrollStartNotification方法。\n1 2 3 void didStartScroll() { activity!.dispatchScrollStartNotification(copyWith(), context.notificationContext); } 看下ScrollActivity的dispatchScrollStartNotification方法，可以看到，执行了ScrollStartNotification的dispatch方法。\n1 2 3 void dispatchScrollStartNotification(ScrollMetrics metrics, BuildContext? context) { ScrollStartNotification(metrics: metrics, context: context).dispatch(context); } 4.2、通知分发 看下ScrollStartNotification的dispatch方法，因为ScrollStartNotification的终极父类是Notification，所以执行的是Notification的dispatch方法。\n在Notification的dispatch方法中，执行BuildContext的dispatchNotification方法，并把当前Notification实例，也就是ScrollStartNotification作为参数传入了dispatchNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class Notification { /// Abstract const constructor. This constructor enables subclasses to provide /// const constructors so that they can be used in const expressions. const Notification(); /// Start bubbling this notification at the given build context. /// /// The notification will be delivered to any [NotificationListener] widgets /// with the appropriate type parameters that are ancestors of the given /// [BuildContext]. If the [BuildContext] is null, the notification is not /// dispatched. void dispatch(BuildContext? target) { target?.dispatchNotification(this); } } 因为BuildContext只是一个句柄，所以看下它的实现类Element的dispatchNotification方法。可以看到，执行了 _notificationTree 的dispatchNotification方法。\n1 2 3 4 5 6 _NotificationNode? _notificationTree; @override void dispatchNotification(Notification notification) { _notificationTree?.dispatchNotification(notification); } 看下 _NotificationNode的dispatchNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class _NotificationNode { _NotificationNode(this.parent, this.current); NotifiableElementMixin? current; _NotificationNode? parent; void dispatchNotification(Notification notification) { // 分析1 if (current?.onNotification(notification) ?? true) { return; } // 分析2 parent?.dispatchNotification(notification); } } 分析1 这里分2种情况：\n1、如果current为空，说明通知分发已完成，这时直接return，不执行分析2。\n2、如果current不为空，说明通知分发正在进行中，可以发现调用了NotifiableElementMixin的onNotification方法，而 _NotificationElement 混入了NotifiableElementMixin，所以实际上调用了 _NotificationElement 的onNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 class _NotificationElement\u0026lt;T extends Notification\u0026gt; extends ProxyElement with NotifiableElementMixin { _NotificationElement(NotificationListener\u0026lt;T\u0026gt; super.widget); @override bool onNotification(Notification notification) { final NotificationListener\u0026lt;T\u0026gt; listener = widget as NotificationListener\u0026lt;T\u0026gt;; if (listener.onNotification != null \u0026amp;\u0026amp; notification is T) { return listener.onNotification!(notification); } return false; } } 此处widget指的是NotificationListener，如果NotificationListener传入了onNotification回调并且notification是泛型T以及泛型T的子类时，就会通过调用listener.onNotification回调出去。\n关于 _NotificationElement 的onNotification方法返回值有3种情况：\n1、如果NotificationListener没有传入了onNotification回调，那么 _NotificationElement的onNotification就会返回false，此时会执行 _NotificationNode的dispatchNotification方法中的分析2部分。\n2、如果NotificationListener传入了onNotification回调，并且该方法返回false，同样会执行 _NotificationNode 的dispatchNotification方法中的分析2部分。\n3、如果NotificationListener传入了onNotification回调，并且该方法返回true，则不会执行 _NotificationNode的dispatchNotification方法中的分析2部分。\n分析2 执行了parent?.dispatchNotification，也就是继续向上分发通知。\n五、自定义通知 从源码分析中可以知道，通知分发是调用Notification的dispatch方法，那我们可以自定义一个Notification来进行分发。\n这里还是改造之前的计数器示例，实现与在InheritedWidget中传入Listener的方式的同等效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: NotificationListener\u0026lt;MyNotification\u0026gt;( onNotification: (MyNotification notification) { ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(notification.msg))); return false; }, child: MyParent( counter: _counter, child: const MyChild(), ), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; const MyParent({ super.key, required this.counter, required super.child, }); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ElevatedButton( onPressed: () =\u0026gt; MyNotification(msg: \u0026#39;Hello World!\u0026#39;).dispatch(context), child: const Text(\u0026#39;Post\u0026#39;), ), ], ), ); } } class MyNotification extends Notification { final String msg; MyNotification({required this.msg}); } ","date":"2023-11-07T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bnotificationlistener/","section":"post","tags":null,"title":"解读Flutter源码之NotificationListener"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 如果你开发的App失去了交互动画，那么这将是一件很难想象的事情，此时它的体验必然一言难尽，用户会为它贴上“傻快”、“生硬”、“粗糙”等标签，从而你将不得不丢失一部分用户。\n因此，精心设计的动画会使UI更生动，它有助于提升App更精巧的外观和感觉，从而改善用户体验。\n在Flutter的Material Widgets中，这些Widgets均自带其设计规范中定义的标准动画效果，能让各种动画效果的实现变得容易，当然了，你也可以定制这些效果。\n二、动画概览 在Flutter中，创建动画可以有多种不同实现方式。那么，究竟哪种才是最适合你的呢？可以参考下面的决策树，它将帮助你挑选实现Flutter动画的正确方式。\n2.1、动画的实现方式 按照动画的实现方式来分类，可以分为隐式动画与显式动画。\n隐式动画 所有隐式动画均扩展了ImplicitlyAnimatedWidget类。你可以使用内置的隐式动画，例如AnimatedContainer、AnimatedAlign等，这些是最简单的动画。如果内置的隐式动画不能够满足你的需求，你也可以使用TweenAnimationBuilder创建一个自定义的隐式动画。\n显式动画 所谓显式动画，就是需要手动控制，而不是让框架控制。你可以使用内置的其中一个显式动画类来实现，例如ScaleTransition、RotationTransition等。如果内置的显式动画不能够满足你的需求，你也可以使用AnimatedBuilder或AnimatedWidget创建一个自定义的显式动画。\n当然了，不管隐式动画还是显式动画，它们也只是对底层Animation的一个封装，只是封装后的使用自由度不太相同罢了。\n2.2、动画的类型 按照动画的类型来分类，可以分为补间动画与基于物理动画。\n补间动画 补间动画是“介于两者之间”的缩写。在补间动画中，定义了起点和终点以及时间轴，再定义过渡时间和速度的曲线，然后框架会计算如何从起点过渡到终点。\n基于物理动画 在基于物理基础的动画中，动作是模拟真实世界的行为来进行建模的。举个例子，当您抛球时，球落地的时间和位置取决于抛出的速度和距离地面的高度。类似地，附在弹簧上的球和附在绳子上的球掉落（和反弹）方式是不一样的。\n2.3、预置动画 预置动画指的是pub.dev上的animations库中所包含的动画，它是由Flutter官方提供的。这个库包含了以下内置常用模式： Container变换、共享轴变化、渐变穿透和渐变变换。\n2.4、常见的动画模式 常见的动画模式包括列表或网格动画、共享元素转换、交织动画等。\n列表或网格动画 这种模式用于在列表或网格中添加或删除元素。\n共享元素转换 在这个模式中，用户从页面中选择一个元素，通常是图像，然后UI会在新页面中为指定元素添加动画，并生成更多细节。在Flutter中，您可以通过Hero组件轻松实现路径（页面）间的共享元素转换动画。\n例如，下面这两种风格的Hero动画：\n1、当改变位置和大小时，Hero从一页飞至另一页。\n2、Hero的边界改变形状由圆变方，同时从一页飞至另一页。\n为什么要将这种可飞行的共享组件称为Hero（英雄），有一种说法是说美国文化中的超人是可以飞的，那是美国人心中的大英雄，还有漫威中的超级英雄基本上都是会飞的，所以Flutter开发人员就对这种“会飞的Widget”就起了一个富有浪漫主义的名字Hero。当然这种说法并非官方解释，但却很有意思。\n交织动画 将复杂的动画分解成较小的动作，其中一些动作被延迟，分解后的这些小动画可以是连续的，也可以部分或完全重叠。例如：有一个柱状图，需要在高度增长的同时改变颜色，等到增长到最大高度后，我们需要在X轴上平移一段距离。\n使用交织动画需要注意以下几点：\n1、要创建交织动画，需要使用多个动画对象（Animation）\n2、一个AnimationController控制所有的动画对象\n3、给每一个动画对象指定时间间隔（Interval）\nOK，动画总览讲解完毕，最后再给出一张动画总览的思维导图。\n三、动画基础 在任何系统的UI框架中，动画的实现原理都是相同的，即在一段时间内，快速地多次改变UI外观；由于人眼会产生视觉暂留，所以最终看到的就是一个“连续”的动画，这和电影的原理是一样的。\nFlutter中对动画进行了抽象，主要涉及Animation、Curve、Controller、Tween这四个角色，它们一起配合来完成一个完整动画，下面来一一介绍它们。\n3.1、Animation 1、在Flutter中，动画对象Animation无法获取屏幕上显示的内容，它与渲染或 build() 方法无关。\n2、Animation是一个已知当前值value和状态status（已完成或已解除）的抽象类，其中一个比较常见的Animation类型是 Animation\u0026lt;double\u0026gt;。\n3、动画还可以插入除double以外的类型，比如Animation\u0026lt;Color\u0026gt;或者Animation\u0026lt;Size\u0026gt;。\n4、一个Animation对象在一段时间内，持续生成介于两个值之间的插入值。这个Animation对象输出的可能是直线，曲线，阶梯函数，或者任何自定义的映射，这由Curve来决定。\n5、根据Animation对象的不同控制方式，它可以反向运行，或者中途切换方向。\n6、在动画的每一帧中，我们可以通过Animation对象的value属性获取动画的当前值。\n3.1.1、动画通知 一个Animation对象可以有不止一个Listener和StatusListener，用addListener() 和addStatusListener() 来定义。\n当动画值改变时调用Listener。Listener最常用的操作是调用 setState() 进行重建。\n当一个动画开始，结束，前进或后退时，会调用StatusListener，用AnimationStatus来定义。\n3.2、Curve CurvedAnimation定义动画进程为非线性曲线。\n1 2 final CurvedAnimation curve = CurvedAnimation(parent: controller, curve: Curves.easeIn); CurvedAnimation和AnimationController（下面介绍）都是Animation\u0026lt;double\u0026gt;类型。CurvedAnimation可以通过包装AnimationController和Curve生成一个新的动画对象，我们正是通过这种方式来将动画和动画执行的曲线关联起来的。\nCurves类中定义了很多常用曲线。\nCurves曲线 动画过程 linear 线性动画曲线 decelerate 变化率开始快速然后减速的曲线 ease 快速加速、缓慢结束的立方动画曲线 easeIn 缓慢开始并快速结束的立方动画曲线 easeOut 快速开始并缓慢结束的立方动画曲线 easeInOut 一条立方动画曲线，缓慢开始，加速，然后缓慢结束 bounceIn 幅度不断增长的振荡曲线 bounceOut 一条先增大后减小幅度的振荡曲线 bounceInOut 一条先增大后减小幅度的振荡曲线 \u0026hellip; \u0026hellip; 如果内置的Curves曲线不能满足你的要求，你也可以自定义Curves曲线。例如：\n1 2 3 4 5 6 import \u0026#39;dart:math\u0026#39;; class ShakeCurve extends Curve { @override double transform(double t) =\u0026gt; sin(t * pi * 2); } 3.3、AnimationController AnimationController是个特殊的Animation对象，每当硬件准备新帧时，它都会生成一个新值。默认情况下，AnimationController在给定期间内会线性生成从 0.0 到 1.0 的数字。例如，这段代码创建了一个动画对象，但是没有启动运行。\n1 2 3 4 final AnimationController controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); AnimationController生成数字的区间可以通过lowerBound和upperBound来指定，如：\n1 2 3 4 5 6 final AnimationController controller = AnimationController( duration: const Duration(milliseconds: 2000), lowerBound: 10.0, upperBound: 20.0, vsync: this ); AnimationController源自于Animation\u0026lt;double\u0026gt;，所以可以用在任何需要Animation对象的地方。但是AnimationController还有其它方法控制动画，例如：forward() 方法可以启动正向动画，reverse() 可以启动反向动画。\n在动画开始执行后开始生成动画帧，屏幕每刷新一次就是一个动画帧，在动画的每一帧，会随着根据动画的曲线来生成当前的动画值（Animation.value），然后根据当前的动画值去构建UI，当所有动画帧依次触发时，动画值会依次改变，所以构建的UI也会依次变化，所以最终我们可以看到一个完成的动画。\n创建AnimationController的同时，也赋予了一个vsync参数。vsync的存在防止后台动画消耗不必要的资源。您可以通过添加SingleTickerProviderStateMixin到类定义，将有状态的对象用作vsync。\n注意：在一些情况下，一个位置可能会超过AnimationController的 0.0-1.0 的范围。例如，fling() 函数可以根据我们手指滑动（甩出）的速度(velocity)、力量(force)等来模拟一个手指甩出动画，因此它的动画值可以在[0.0，1.0]范围之外。即使AnimationController在范围内，CurvedAnimation也可能会出现超出 0.0-1.0 范围的情况。根据所选曲线的不同，CurvedAnimation的输出范围可能会超过输入。举个例子，弹性曲线（比如Curves.elasticIn）会明显超出或低于默认范围。\n3.4、Tween 在默认情况下，AnimationController对象的范围是 0.0-0.1。如果需要不同的范围或者不同的数据类型，可以使用Tween配置动画来插入不同的范围或数据类型。例如下面的示例中，Tween的范围是 -200 到 0.0。\n1 final Tween doubleTween = Tween\u0026lt;double\u0026gt;(begin: -200.0, end: 0.0); Tween是无状态的对象，只有begin和end。Tween的这种单一用途用来定义从输入范围到输出范围的映射。输入范围一般为 0.0-1.0，但这并不是必须的。\nTween源自Animatable\u0026lt;T\u0026gt;，而不是Animation\u0026lt;T\u0026gt;。像动画这样的可动画元素不必重复输出。例如，ColorTween指定了两种颜色之间的过程。\n1 2 final Tween colorTween = ColorTween(begin: Colors.transparent, end: Colors.black54); Tween对象不存储任何状态。而是提供evaluate(Animation\u0026lt;double\u0026gt; animation)方法，将映射函数应用于动画当前值。Animation对象的当前值可以在.value方法中找到。evaluate方法还执行一些内部处理内容，比如确保当动画值在 0.0 和1.0 时分别返回起始点和终点。\n3.4.1、Tween.animate 要使用Tween对象，请在Tween调用animate()，传入控制器对象。例如，下面的代码在 500 ms 的进程中生成 0-255 范围内的整数值。\n1 2 3 AnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); Animation\u0026lt;int\u0026gt; alpha = IntTween(begin: 0, end: 255).animate(controller); 注意：animate() 方法会返回一个Animation，而不是Animatable。\n下面的示例展示了一个控制器，一个曲线，和一个Tween。\n1 2 3 4 5 AnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); final Animation\u0026lt;double\u0026gt; curve = CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation\u0026lt;int\u0026gt; alpha = IntTween(begin: 0, end: 255).animate(curve); 四、动画示例 现有一需求，点击scale按钮，可以将一个Icon变大或缩小，并且中途还可以调转动画的方向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;动画演示\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: const MyWidget(), ); } } class MyWidget extends StatefulWidget { const MyWidget({super.key}); @override State\u0026lt;MyWidget\u0026gt; createState() =\u0026gt; _MyWidgetState(); } class _MyWidgetState extends State\u0026lt;MyWidget\u0026gt; with SingleTickerProviderStateMixin { late AnimationController _animationController; late Animation\u0026lt;double\u0026gt; _animation; @override void initState() { super.initState(); _animationController = AnimationController( vsync: this, duration: const Duration(seconds: 1), reverseDuration: const Duration(seconds: 1), ); _animation = CurvedAnimation( parent: _animationController, curve: Curves.easeIn, reverseCurve: Curves.bounceIn, ); _animation = Tween(begin: 200.0, end: 300.0).animate(_animation) ..addListener(() { setState(() { }); }); } void _scale() { if (_animation.status == AnimationStatus.completed || _animation.status == AnimationStatus.forward) { _animationController.reverse(); } else if (_animation.status == AnimationStatus.dismissed || _animation.status == AnimationStatus.reverse) { _animationController.forward(); } } @override void dispose() { super.dispose(); _animationController.dispose(); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Icon( Icons.account_circle, size: _animation.value, ), OutlinedButton( onPressed: _scale, child: const Text(\u0026#39;scale\u0026#39;), ) ], ), ); } } 程序运行起来后，UI效果为：\n五、分析动画源码 5.1、_animationController.forward() 从动画的启动方法入手，也就是AnimationController的forward方法，看下它的源码。\n1 2 3 4 5 6 7 8 9 TickerFuture forward({ double? from }) { // 指定动画方向为正向 _direction = _AnimationDirection.forward; // 因为没有传入from，所以这里为null，此处不会执行 if (from != null) { value = from; } return _animateToInternal(upperBound); } 在AnimationController的forward方法中，执行了 _animateToInternal 方法，这里传入了upperBound，它是该动画被视为完成的值。\nupperBound是在AnimationController的构造方法中传入，只是本示例中没有传入，所以取的是默认值为 1.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimationController extends Animation\u0026lt;double\u0026gt; with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin { AnimationController({ double? value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, // 默认值 this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, required TickerProvider vsync, }) : assert(upperBound \u0026gt;= lowerBound), _direction = _AnimationDirection.forward { _ticker = vsync.createTicker(_tick); _internalSetValue(value ?? lowerBound); } } 继续跟踪AnimationController的 _animateToInternal 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 TickerFuture _animateToInternal(double target, { Duration? duration, Curve curve = Curves.linear }) { double scale = 1.0; /// SemanticsBinding.instance.disableAnimations用来判断该平台是否要求禁用或简化动画。 /// 可通过设置debugSemanticsDisableAnimations可以覆盖此设置以进行测试或调试 /// 例如： /// /// ```dart /// import \u0026#39;package:flutter/rendering.dart\u0026#39;; /// /// void main() { /// // debugSemanticsDisableAnimations = true; /// runApp(const MyApp()); /// } /// ``` /// 本示例中很明显没有禁用动画，所以此处不执行，scale的值仍然为1.0 if (SemanticsBinding.instance.disableAnimations) { switch (animationBehavior) { case AnimationBehavior.normal: // 由于该框架无法处理零持续时间动画，因此我们以正常持续时间的 5% 运行它，以将大多数动画限制为单帧。 // 理想情况下，框架将能够处理零持续时间动画，但是，如果不延迟至少一帧，永久重复动画的常见模式可能会导致无限循环。 // Since the framework cannot handle zero duration animations, we run it at 5% of the normal // duration to limit most animations to a single frame. // Ideally, the framework would be able to handle zero duration animations, however, the common // pattern of an eternally repeating animation might cause an endless loop if it weren\u0026#39;t delayed // for at least one frame. scale = 0.05; case AnimationBehavior.preserve: break; } } // simulationDuration是模拟持续时间，但是由于duration参数没有传入，所以simulationDuration为null Duration? simulationDuration = duration; // 因为simulationDuration为null，所以此处执行 if (simulationDuration == null) { assert(!(this.duration == null \u0026amp;\u0026amp; _direction == _AnimationDirection.forward)); assert(!(this.duration == null \u0026amp;\u0026amp; _direction == _AnimationDirection.reverse \u0026amp;\u0026amp; reverseDuration == null)); // 获取动画的范围，因为在AnimationController构造方法中，upperBound与lowerBound参数均没传入，所以都是取默认值，upperBound为1.0，lowerBound为0.0，那么此处range为1.0 final double range = upperBound - lowerBound; // range.isFinite是判断range这个数字是否是有限的。 // 唯一的非有限数是 NaN 值、正无穷大和负无穷大。所有整数都是有限的。 // 所有数字都满足isInfinite、isFinite和isNaN之一 // 因为range为1.0，所以range.isFinite是true // 因为target为传入的upperBound，所以它的值为1.0，_value默认值为0.0，所以remainingFraction的最终计算结果为1.0，也就是动画的执行进度剩余百分比 final double remainingFraction = range.isFinite ? (target - _value).abs() / range : 1.0; // 如果动画方向为反向并且反向动画时间reverseDuration（此处reverseDuration也就是AnimationController构造方法传入的reverseDuration）不为null， // 那么directionDuration为反向动画时间，否则为正向动画时间duration（此处duration也就是AnimationController构造方法传入的duration） // 在前面的forward方法中，_direction已经被赋值为_AnimationDirection.forward，所以这里directionDuration为this.duration，也就是1s final Duration directionDuration = (_direction == _AnimationDirection.reverse \u0026amp;\u0026amp; reverseDuration != null) ? reverseDuration! : this.duration!; // 那么最终计算后的simulationDuration模拟持续时间为1s simulationDuration = directionDuration * remainingFraction; } else if (target == value) { // Already at target, don\u0026#39;t animate. simulationDuration = Duration.zero; } // 停止运行该动画。这不会触发任何通知。动画停止在当前状态。 stop(); // 因为simulationDuration为1s，所以这里不执行 if (simulationDuration == Duration.zero) { if (value != target) { _value = clampDouble(target, lowerBound, upperBound); notifyListeners(); } _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.completed : AnimationStatus.dismissed; _checkStatusChanged(); return TickerFuture.complete(); } assert(simulationDuration \u0026gt; Duration.zero); assert(!isAnimating); // 执行_startSimulation方法，并且创建_InterpolationSimulation实例并作为参数传入该方法 return _startSimulation(_InterpolationSimulation(_value, target, simulationDuration, curve, scale)); } 在AnimationController的 _animateToInternal 方法中，执行了 _startSimulation 方法，并且创建 _InterpolationSimulation 实例并作为参数传入该方法。\n继续跟踪AnimationController的 _startSimulation 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TickerFuture _startSimulation(Simulation simulation) { assert(!isAnimating); // 将前面创建的_InterpolationSimulation实例赋值给成员变量_simulation _simulation = simulation; // 初始化动画上一帧的时间，动画还没开始，所以为0 _lastElapsedDuration = Duration.zero; // 计算_value，也就是外部使用的_animation.value // clampDouble主要对simulation.x(0.0)这个结果做了大小限制（lowerBound \u0026lt;= 结果 \u0026lt;= upperBound） // 此处执行的是_InterpolationSimulation的x方法，_value的最终计算结果为0.0 _value = clampDouble(simulation.x(0.0), lowerBound, upperBound); // 启动Ticker，每个动画帧均会调用一次回调，这个等下再分析 final TickerFuture result = _ticker!.start(); // 因为_direction为_AnimationDirection.forward，所以此时_status状态为AnimationStatus.forward _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.forward : AnimationStatus.reverse; // 调用所有状态监听器 _checkStatusChanged(); // 最后将TickerFuture返回，但是本示例中没用到，这里就不讲解了 return result; } 关于simulation.x(0.0)，这里分析下，它执行了 _InterpolationSimulation 的x方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // _InterpolationSimulation的作用就是将Engine层返回的每一帧时间转换为[0.0, 1.0]范围的数值 class _InterpolationSimulation extends Simulation { // _begin传入的是_value，它的值为0.0 // _end传入的是target，它的值为1.0 // duration传入的是simulationDuration，它的值为1s // _curve传入的是curve，它的值为Curves.linear // scale传入的是scale，它的值为1.0 _InterpolationSimulation(this._begin, this._end, Duration duration, this._curve, double scale) : assert(duration.inMicroseconds \u0026gt; 0), // duration.inMicroseconds表示获取微秒数，所以1s的微秒数为1000000，microsecondsPerSecond表示每秒的微秒数 // 结合传入的参数值，那么_durationInSeconds最终的计算结果为1s _durationInSeconds = (duration.inMicroseconds * scale) / Duration.microsecondsPerSecond; final double _durationInSeconds; final double _begin; final double _end; final Curve _curve; @override double x(double timeInSeconds) { // 外部调用simulation.x(0.0)时传入0.0，所以此处timeInSeconds为0.0，所以t最终的计算结果为0 final double t = clampDouble(timeInSeconds / _durationInSeconds, 0.0, 1.0); // 因为t为0，所以执行这里，返回_begin，它的值为0.0 if (t == 0.0) { return _begin; } else if (t == 1.0) { return _end; } else { return _begin + (_end - _begin) * _curve.transform(t); } } } 关于 _checkStatusChanged 方法，这里分析下。\n1 2 3 4 5 6 7 8 9 10 11 12 AnimationStatus _lastReportedStatus = AnimationStatus.dismissed; void _checkStatusChanged() { // 因为在_startSimulation方法中，_status已经被赋值为AnimationStatus.forward，所以这里将成员变量_status赋值给status，那么此时newStatus的值为AnimationStatus.forward final AnimationStatus newStatus = status; // _lastReportedStatus的默认值为AnimationStatus.dismissed，所以if判断不相等，此处执行 if (_lastReportedStatus != newStatus) { _lastReportedStatus = newStatus; // 将newStatus通知给所有已注册的状态监听器 notifyStatusListeners(newStatus); } } 因为AnimationController混入了AnimationLocalStatusListenersMixin，所以这里的notifyStatusListeners方法执行的是AnimationLocalStatusListenersMixin的notifyStatusListeners方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void notifyStatusListeners(AnimationStatus status) { final List\u0026lt;AnimationStatusListener\u0026gt; localListeners = _statusListeners.toList(growable: false); for (final AnimationStatusListener listener in localListeners) { try { // 遍历所有AnimationStatusListener，将status回调出去 if (_statusListeners.contains(listener)) { listener(status); } } catch (exception, stack) { InformationCollector? collector; assert(() { collector = () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;AnimationLocalStatusListenersMixin\u0026gt;( \u0026#39;The $runtimeType notifying status listeners was\u0026#39;, this, style: DiagnosticsTreeStyle.errorProperty, ), ]; return true; }()); FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: \u0026#39;animation library\u0026#39;, context: ErrorDescription(\u0026#39;while notifying status listeners for $runtimeType\u0026#39;), informationCollector: collector, )); } } } 先回到 _startSimulation 方法上来，其实整个 _startSimulation 方法的重点是_ticker!.start()，因为它启动了动画，那么 _ticker 是什么？又在哪创建的？\n5.2、AnimationController的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimationController extends Animation\u0026lt;double\u0026gt; with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin { AnimationController({ double? value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, required TickerProvider vsync, }) : assert(upperBound \u0026gt;= lowerBound), _direction = _AnimationDirection.forward { // 此处执行了TickerProvider的createTicker方法 _ticker = vsync.createTicker(_tick); _internalSetValue(value ?? lowerBound); } } 在AnimationController的构造方法中，执行了vsync.createTicker(_tick)这行代码，也就是执行了TickerProvider的createTicker方法，而createTicker方法需要传入的参数是一个TickerCallback，这里传入的实参为AnimationController的 _tick 方法。\n在本示例中，vsync参数传入的是this，即混入的SingleTickerProviderStateMixin，它是专门用来提供和管理单个Ticker。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class _MyWidgetState extends State\u0026lt;MyWidget\u0026gt; with SingleTickerProviderStateMixin { late AnimationController _animationController; late Animation\u0026lt;double\u0026gt; _animation; @override void initState() { super.initState(); _animationController = AnimationController( // 传入this，即混入的SingleTickerProviderStateMixin vsync: this, duration: const Duration(seconds: 1), reverseDuration: const Duration(seconds: 1), ); } } 因此，vsync.createTicker实际上执行了SingleTickerProviderStateMixin的createTicker方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 mixin SingleTickerProviderStateMixin\u0026lt;T extends StatefulWidget\u0026gt; on State\u0026lt;T\u0026gt; implements TickerProvider { Ticker? _ticker; @override Ticker createTicker(TickerCallback onTick) { assert(() { if (_ticker == null) { return true; } throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;$runtimeType is a SingleTickerProviderStateMixin but multiple tickers were created.\u0026#39;), ErrorDescription(\u0026#39;A SingleTickerProviderStateMixin can only be used as a TickerProvider once.\u0026#39;), ErrorHint( \u0026#39;If a State is used for multiple AnimationController objects, or if it is passed to other \u0026#39; \u0026#39;objects and those objects might use it more than one time in total, then instead of \u0026#39; \u0026#39;mixing in a SingleTickerProviderStateMixin, use a regular TickerProviderStateMixin.\u0026#39;, ), ]); }()); // 这里创建了Ticker实例并赋值给成员变量_ticker // 此处Ticker构造方法传入的参数onTick，它的实例是AnimationController的_tick方法。 _ticker = Ticker(onTick, debugLabel: kDebugMode ? \u0026#39;created by ${describeIdentity(this)}\u0026#39; : null); _updateTickerModeNotifier(); _updateTicker(); // Sets _ticker.mute correctly. // 把Ticker实例返回 return _ticker!; } } 当 _startSimulation 方法执行了 _ticker!.start() 时，就会执行上面创建的 _ticker 的start方法，跟踪下Ticker的start方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 TickerFuture start() { assert(() { if (isActive) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;A ticker was started twice.\u0026#39;), ErrorDescription(\u0026#39;A ticker that is already active cannot be started again without first stopping it.\u0026#39;), describeForError(\u0026#39;The affected ticker was\u0026#39;), ]); } return true; }()); assert(_startTime == null); // 此处创建了一个TickerFuture对象，表示正在进行的Ticker序列的对象。 // Ticker.start方法返回一个TickerFuture。如果使用Ticker.stop停止Ticker ，并将canceled参数设置为 false（默认值），则TickerFuture将成功完成。 // 如果Ticker在未停止的情况下被处置，或者如果在canceled设置为 true 的情况下停止，则此 Future 将永远不会完成 _future = TickerFuture._(); // shouldScheduleTick表示是否应该安排一个tick // 不应安排tick的原因包括： // 1、已经为下一帧安排了一个tick // 2、ticker未激活（尚未调用start） // 3、ticker没有在ticking，例如因为它被muted （请参阅isTicking ） // 通过断点调试来看，此处shouldScheduleTick为true，所以执行了scheduleTick方法。 if (shouldScheduleTick) { scheduleTick(); } // schedulerPhase表示调度程序当前运行的阶段，通过断点调试来看，SchedulerBinding.instance.schedulerPhase.index的值为0， // 也就是schedulerPhase所处状态为idle，所以SchedulerBinding.instance.schedulerPhase.index \u0026gt; SchedulerPhase.idle.index不满足，不会执行这里代码 if (SchedulerBinding.instance.schedulerPhase.index \u0026gt; SchedulerPhase.idle.index \u0026amp;\u0026amp; SchedulerBinding.instance.schedulerPhase.index \u0026lt; SchedulerPhase.postFrameCallbacks.index) { _startTime = SchedulerBinding.instance.currentFrameTimeStamp; } // 返回一个TickerFuture对象，此处的返回就是forward方法的返回值 return _future!; } 在Ticker的start方法中，执行了scheduleTick方法，跟踪看看。\n1 2 3 4 5 6 7 // scheduleTick方法的作用是为下一帧安排一个tick void scheduleTick({ bool rescheduling = false }) { assert(!scheduled); assert(shouldScheduleTick); // 执行了SchedulerBinding的scheduleFrameCallback方法，该方法需要传入一个FrameCallback实例，该实例就是Ticker的_tick方法。 _animationId = SchedulerBinding.instance.scheduleFrameCallback(_tick, rescheduling: rescheduling); } 先看下SchedulerBinding的scheduleFrameCallback方法。\n1 2 3 4 5 6 7 8 9 10 int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) { // 执行了scheduleFrame方法。调用dart:ui.PlatformDispatcher.scheduleFrame来安排新帧 // 调用此函数后，引擎将（最终）调用handleBeginFrame scheduleFrame(); // 下一帧回调实例的Id，此处+1 _nextFrameCallbackId += 1; // 将callback包装成_FrameCallbackEntry对象，存入瞬态回调Map集合_transientCallbacks中 _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling); return _nextFrameCallbackId; } 看下SchedulerBinding的scheduleFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void scheduleFrame() { if (_hasScheduledFrame || !framesEnabled) { return; } assert(() { if (debugPrintScheduleFrameStacks) { debugPrintStack(label: \u0026#39;scheduleFrame() called. Current phase is $schedulerPhase.\u0026#39;); } return true; }()); // 执行ensureFrameCallbacksRegistered方法，确保PlatformDispatcher.onBeginFrame和PlatformDispatcher.onDrawFrame的回调已注册 ensureFrameCallbacksRegistered(); // 执行platformDispatcher的scheduleFrame，请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调 platformDispatcher.scheduleFrame(); _hasScheduledFrame = true; } 看下ensureFrameCallbacksRegistered方法。\n1 2 3 4 5 6 7 @protected void ensureFrameCallbacksRegistered() { // 为platformDispatcher的onBeginFrame注册回调，这里具体实现是_handleBeginFrame方法 platformDispatcher.onBeginFrame ??= _handleBeginFrame; // 为platformDispatcher的onDrawFrame注册回调，这里具体实现是_handleDrawFrame方法 platformDispatcher.onDrawFrame ??= _handleDrawFrame; } 再看下platformDispatcher.scheduleFrame()，这里是external修饰，说明调用了Engine层的方法了，它在不同平台有不同实现。\n1 2 3 4 5 // 请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调。 void scheduleFrame() =\u0026gt; _scheduleFrame(); @Native\u0026lt;Void Function()\u0026gt;(symbol: \u0026#39;PlatformConfigurationNativeApi::ScheduleFrame\u0026#39;) external static void _scheduleFrame(); 这里就不深入底层实现了，不过可以猜测，在Android中应该是调用了Choreographer注册了Vysnc信号监听，然后再回调给Flutter，具体留给你们去验证了。\n等到Engine层处理完成，将会回调给Framework层的 _beginFrame 方法，在 _beginFrame 方法中执行了PlatformDispatcher的 _beginFrame 方法。\n1 2 3 4 5 @pragma(\u0026#39;vm:entry-point\u0026#39;) void _beginFrame(int microseconds, int frameNumber) { PlatformDispatcher.instance._beginFrame(microseconds); PlatformDispatcher.instance._updateFrameData(frameNumber); } 在PlatformDispatcher的 _beginFrame 方法中，执行了 _invoke1 方法，第一个参数传入的是onBeginFrame回调，这个就是之前讲过的SchedulerBinding的ensureFrameCallbacksRegistered方法中注册的回调。\n1 2 3 4 5 6 7 8 void _beginFrame(int microseconds) { _invoke1\u0026lt;Duration\u0026gt;( // 此处传入onBeginFrame onBeginFrame, _onBeginFrameZone, Duration(microseconds: microseconds), ); } 来看下 _invoke1 方法，执行了callback()，也就是调用了onBeginFrame的回调引用，那么就会触发SchedulerBinding的 _handleBeginFrame 方法。\n1 2 3 4 5 6 7 8 9 10 11 void _invoke1\u0026lt;A\u0026gt;(void Function(A a)? callback, Zone zone, A arg) { if (callback == null) { return; } if (identical(zone, Zone.current)) { // 此处调用外部方法引用，传入参数是arg，也就是一个Duration，这个时间是每一帧的时间 callback(arg); } else { zone.runUnaryGuarded\u0026lt;A\u0026gt;(callback, arg); } } 继续看SchedulerBinding的 _handleBeginFrame 方法，执行了handleBeginFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void handleBeginFrame(Duration? rawTimeStamp) { _frameTimelineTask?.start(\u0026#39;Frame\u0026#39;); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) { _lastRawTimeStamp = rawTimeStamp; } assert(() { _debugFrameNumber += 1; if (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) { final StringBuffer frameTimeStampDescription = StringBuffer(); if (rawTimeStamp != null) { _debugDescribeTimeStamp(_currentFrameTimeStamp!, frameTimeStampDescription); } else { frameTimeStampDescription.write(\u0026#39;(warm-up frame)\u0026#39;); } _debugBanner = \u0026#39;▄▄▄▄▄▄▄▄ Frame ${_debugFrameNumber.toString().padRight(7)} ${frameTimeStampDescription.toString().padLeft(18)} ▄▄▄▄▄▄▄▄\u0026#39;; if (debugPrintBeginFrameBanner) { debugPrint(_debugBanner); } } return true; }()); assert(schedulerPhase == SchedulerPhase.idle); _hasScheduledFrame = false; try { // TRANSIENT FRAME CALLBACKS _frameTimelineTask?.start(\u0026#39;Animate\u0026#39;); _schedulerPhase = SchedulerPhase.transientCallbacks; final Map\u0026lt;int, _FrameCallbackEntry\u0026gt; callbacks = _transientCallbacks; _transientCallbacks = \u0026lt;int, _FrameCallbackEntry\u0026gt;{}; // 此处遍历执行_transientCallbacks，也就是传入的Ticker的_tick方法实例 callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) { _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp!, callbackEntry.debugStack); } }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 看下Ticker的 _tick 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void _tick(Duration timeStamp) { assert(isTicking); assert(scheduled); _animationId = null; _startTime ??= timeStamp; // 执行了SingleTickerProviderStateMixin的createTicker方法中传入的onTick参数 // 也就是执行了AnimationController构造方法中的vsync.createTicker(_tick)传入的_tick方法实例 _onTick(timeStamp - _startTime!); // The onTick callback may have scheduled another tick already, for // example by calling stop then start again. if (shouldScheduleTick) { scheduleTick(rescheduling: true); } } 看下AnimationController的 _tick 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // elapsed是Engine层返回的每一帧时间Duration，每一帧的时间都不一样 void _tick(Duration elapsed) { _lastElapsedDuration = elapsed; // 将拿到的每一帧的时间单位改为秒 final double elapsedInSeconds = elapsed.inMicroseconds.toDouble() / Duration.microsecondsPerSecond; assert(elapsedInSeconds \u0026gt;= 0.0); // 执行clampDouble方法获取_value，此时的_value依然是_simulation控制，也就是_InterpolationSimulation实例 _value = clampDouble(_simulation!.x(elapsedInSeconds), lowerBound, upperBound); // 等到elapsedInSeconds时间达到我们设定的动画时间Duration，也就是本示例中的1s，表示动画执行完成 if (_simulation!.isDone(elapsedInSeconds)) { // 如果_direction是_AnimationDirection.forward，更改_status为AnimationStatus.completed，否则改为AnimationStatus.dismissed _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.completed : AnimationStatus.dismissed; // 停止当前动画，移除当前瞬态帧回调，那么_tick方法就不会被再回调执行 stop(canceled: false); } // 执行notifyListeners方法，通知所有listeners回调 notifyListeners(); // 执行_checkStatusChanged，通知所有status listeners回调 _checkStatusChanged(); } 至此，forward方法完成了第一帧动画的初始操作，可以说它启动了动画。等到在addListener方法中执行setState方法时，就会触发下一轮 _tick 方法的执行以及build方法的执行，这样一帧一帧执行直到动画完成。\n关于setState方法的分析参考解读Flutter源码之setState一文。\n5.3、_animation.value 通过 _animation.value 最初拿到的是AnimationController的 _value，也就是上面 _tick 方法中计算出来的 _value，为什么这么说呢？看下面分析就知道了。\n在本示例中，CurvedAnimation的构造方法将 _animationController 作为参数传了进去。\n1 2 3 4 5 6 _animation = CurvedAnimation( // 传入_animationController parent: _animationController, curve: Curves.easeIn, reverseCurve: Curves.bounceIn, ); 可以发现CurvedAnimation混入了AnimationWithParentMixin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CurvedAnimation extends Animation\u0026lt;double\u0026gt; with AnimationWithParentMixin\u0026lt;double\u0026gt; { CurvedAnimation({ required this.parent, required this.curve, this.reverseCurve, }) { // 根据_animationController的初始状态，更新Curved曲线的方向 _updateCurveDirection(parent.status); // 给_animationController注册状态监听，用来更新后续Curved曲线的方向 parent.addStatusListener(_updateCurveDirection); } @override final Animation\u0026lt;double\u0026gt; parent; } 看下AnimationWithParentMixin，可以发现此时的listeners管理以及status依然是转发给parent处理，也就是还是由AnimationController来管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 mixin AnimationWithParentMixin\u0026lt;T\u0026gt; { Animation\u0026lt;T\u0026gt; get parent; void addListener(VoidCallback listener) =\u0026gt; parent.addListener(listener); void removeListener(VoidCallback listener) =\u0026gt; parent.removeListener(listener); void addStatusListener(AnimationStatusListener listener) =\u0026gt; parent.addStatusListener(listener); void removeStatusListener(AnimationStatusListener listener) =\u0026gt; parent.removeStatusListener(listener); AnimationStatus get status =\u0026gt; parent.status; } 但是，CurvedAnimation重写了AnimationController成员变量value，可以看到在value中拿到parent.value后，执行了 activeCurve.transform(t) 进行转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @override double get value { // 获取Curves曲线的方向 final Curve? activeCurve = _useForwardCurve ? curve : reverseCurve; // 获取AnimationController的value值，这个值之前由simulation计算得来 final double t = parent.value; if (activeCurve == null) { return t; } // 控制动画范围 if (t == 0.0 || t == 1.0) { assert(() { final double transformedValue = activeCurve.transform(t); final double roundedTransformedValue = transformedValue.round().toDouble(); if (roundedTransformedValue != t) { throw FlutterError( \u0026#39;Invalid curve endpoint at $t.\\n\u0026#39; \u0026#39;Curves must map 0.0 to near zero and 1.0 to near one but \u0026#39; \u0026#39;${activeCurve.runtimeType} mapped $t to $transformedValue, which \u0026#39; \u0026#39;is near $roundedTransformedValue.\u0026#39;, ); } return true; }()); return t; } // 执行Curve转换 return activeCurve.transform(t); } 这里执行了Curve的父类ParametricCurve的transform方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class Curve extends ParametricCurve\u0026lt;double\u0026gt; { const Curve(); @override double transform(double t) { // 控制动画范围 if (t == 0.0 || t == 1.0) { return t; } // 执行父类ParametricCurve的transform方法 return super.transform(t); } } 在ParametricCurve的transform方法中，执行了transformInternal方法，该方法由子类实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class ParametricCurve\u0026lt;T\u0026gt; { const ParametricCurve(); T transform(double t) { assert(t \u0026gt;= 0.0 \u0026amp;\u0026amp; t \u0026lt;= 1.0, \u0026#39;parametric value $t is outside of [0, 1] range.\u0026#39;); // 执行transformInternal方法 return transformInternal(t); } @protected T transformInternal(double t) { throw UnimplementedError(); } } 在本示例中，对于动画的方向是正向的，CurvedAnimation构造方法中传入的子类是Curves.easeIn；对于动画的方向是反向的，CurvedAnimation构造方法中传入的子类是Curves.bounceIn。因为本示例只讲解forward方法，所以这里只以Curves.easeIn为例讲解，看下源码。\n1 static const Cubic easeIn = Cubic(0.42, 0.0, 1.0, 1.0); 看下Cubic实现的transformInternal方法。它是返回点t处的曲线值。但是给定的参数值t将介于 0.0 和 1.0 之间（包含 0.0 和 1.0），那和我们实际Widget的参数映射还是不一致，比如本示例中Icon的size参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @override double transformInternal(double t) { double start = 0.0; double end = 1.0; while (true) { final double midpoint = (start + end) / 2; final double estimate = _evaluateCubic(a, c, midpoint); if ((t - estimate).abs() \u0026lt; _cubicErrorBound) { return _evaluateCubic(b, d, midpoint); } if (estimate \u0026lt; t) { start = midpoint; } else { end = midpoint; } } } 想要和我们实际Widget的参数映射一致，就需要讲到Tween了，看下本示例中的实现。\n1 _animation = Tween(begin: 200.0, end: 300.0).animate(_animation) 看下Tween的animate方法，方法参数传入了上一步创建的CurvedAnimation，返回的是 _AnimatedEvaluation 实例。\n1 2 3 Animation\u0026lt;T\u0026gt; animate(Animation\u0026lt;double\u0026gt; parent) { return _AnimatedEvaluation\u0026lt;T\u0026gt;(parent, this); } 看下 _AnimatedEvaluation实现。\n1 2 3 4 5 6 7 8 9 10 11 class _AnimatedEvaluation\u0026lt;T\u0026gt; extends Animation\u0026lt;T\u0026gt; with AnimationWithParentMixin\u0026lt;double\u0026gt; { _AnimatedEvaluation(this.parent, this._evaluatable); @override final Animation\u0026lt;double\u0026gt; parent; final Animatable\u0026lt;T\u0026gt; _evaluatable; @override T get value =\u0026gt; _evaluatable.evaluate(parent); } 可以看到 _AnimatedEvaluation 继承自Animation，和CurvedAnimation一样混入了AnimationWithParentMixin，此时的listeners管理以及status是转发给parent处理，也就是CurvedAnimation。\n而且 _AnimatedEvaluation 重写了AnimationController成员变量value，当执行 _animation.value时就会调用该value。可以看到在value中执行了 _evaluatable.evaluate(parent) 进行转换。\n_evaluatable 就是 _AnimatedEvaluation 构造方法传入进来的this，指的是Tween实例，又因为Tween继承自Animatable，看下Animatable的evaluate方法。\n1 2 3 4 5 6 abstract class Animatable\u0026lt;T\u0026gt; { T transform(double t); T evaluate(Animation\u0026lt;double\u0026gt; animation) =\u0026gt; transform(animation.value); } 可以看到啊，在Animatable的evaluate方法中，执行了transform方法，传入的是animation.value，实际上就拿到了CurvedAnimation的value，这个方法由子类实现，现在看下Tween的transform方法。\n1 2 3 4 5 6 7 8 9 10 @override T transform(double t) { if (t == 0.0) { return begin as T; } if (t == 1.0) { return end as T; } return lerp(t); } 在Tween的transform方法中，执行了lerp方法进行Widget参数映射到[0.0, 1.0]范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @protected T lerp(double t) { assert(begin != null); assert(end != null); assert(() { // Assertions that attempt to catch common cases of tweening types // that do not conform to the Tween requirements. dynamic result; try { // ignore: avoid_dynamic_calls result = (begin as dynamic) + ((end as dynamic) - (begin as dynamic)) * t; result as T; return true; } on NoSuchMethodError { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot lerp between \u0026#34;$begin\u0026#34; and \u0026#34;$end\u0026#34;.\u0026#39;), ErrorDescription( \u0026#39;The type ${begin.runtimeType} might not fully implement `+`, `-`, and/or `*`. \u0026#39; \u0026#39;See \u0026#34;Types with special considerations\u0026#34; at https://api.flutter.dev/flutter/animation/Tween-class.html \u0026#39; \u0026#39;for more information.\u0026#39;, ), if (begin is Color || end is Color) ErrorHint(\u0026#39;To lerp colors, consider ColorTween instead.\u0026#39;) else if (begin is Rect || end is Rect) ErrorHint(\u0026#39;To lerp rects, consider RectTween instead.\u0026#39;) else ErrorHint( \u0026#39;There may be a dedicated \u0026#34;${begin.runtimeType}Tween\u0026#34; for this type, \u0026#39; \u0026#39;or you may need to create one.\u0026#39;, ), ]); } on TypeError { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot lerp between \u0026#34;$begin\u0026#34; and \u0026#34;$end\u0026#34;.\u0026#39;), ErrorDescription( \u0026#39;The type ${begin.runtimeType} returned a ${result.runtimeType} after \u0026#39; \u0026#39;multiplication with a double value. \u0026#39; \u0026#39;See \u0026#34;Types with special considerations\u0026#34; at https://api.flutter.dev/flutter/animation/Tween-class.html \u0026#39; \u0026#39;for more information.\u0026#39;, ), if (begin is int || end is int) ErrorHint(\u0026#39;To lerp int values, consider IntTween or StepTween instead.\u0026#39;) else ErrorHint( \u0026#39;There may be a dedicated \u0026#34;${begin.runtimeType}Tween\u0026#34; for this type, \u0026#39; \u0026#39;or you may need to create one.\u0026#39;, ), ]); } }()); // ignore: avoid_dynamic_calls return (begin as dynamic) + ((end as dynamic) - (begin as dynamic)) * t as T; } 关于lerp方法，这里插一嘴，因为Tween的子类很多，所以lerp方法可以由Tween的子类去实现，例如Tween的子类SizeTween，看下SizeTween的lerp方法。\n1 2 3 4 5 6 7 class SizeTween extends Tween\u0026lt;Size?\u0026gt; { SizeTween({ super.begin, super.end }); @override Size? lerp(double t) =\u0026gt; Size.lerp(begin, end, t); } 可以发现SizeTween的lerp方法，它是调用了Size的lerp方法。除了Size之外，还有很多类也重写了lerp方法，比如Color，BorderRadius，Border等等，它们分别对应的是ColorTween，BorderRadiusTween，BorderTween。\n总结一下本示例中 _animation.value 的执行过程：\n当外部调用_animation.value时，就会执行Tween中的value，在Tween的value中就会执行CurvedAnimation中的value，在CurvedAnimation的value中就会执行AnimationController的value。\n所以说 _animation.value 的执行是一个向上转发，向下执行的过程。\n六、动画总结 当执行forward方法时，就会启动动画，此时只是执行了动画的第一帧，然后就会触发addListener的回调，在addListener的回调中，执行了setState方法。\n接着又会触发addListener的回调与build方法的执行，这样就形成了递归执行的过程，在这个过程中，通过引用 _animation.value 可以拿到每一帧的值，这个值是经过了simulation模拟计算将每一帧时间转换为[0.0，1.0]范围，在[0.0，1.0]范围内也经过了Curve曲线速度的转换，最后再通过Tween映射为具体的Widget的参数范围。\n每次build方法执行时，_animation.value 的值会重新计算，从而改变Widget参数完成整个动画过程。\n","date":"2023-11-04T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Banimation/","section":"post","tags":null,"title":"解读Flutter源码之Animation"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widget就会发生重建，而子Widget可通过构造方法传入父Widget的状态，然后在build方法中使用该状态即可。\n例如下面这个计数器示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyChild(counter: _counter), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyChild extends StatelessWidget { final int counter; const MyChild({super.key, required this.counter}); @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Text( \u0026#39;$counter\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ); } } 程序运行UI效果为：\n点击FloatingActionButton时日志打印如下：\n1 I/flutter ( 7101): build 但是，如果考虑到父Widget与子Widget之间嵌套很深的情况时，上面的方案其实就不是那么好使了，因为状态的传递需要通过子Widget的构造方法一层一层地传入，这样维护起来非常麻烦且不够优雅，那么Flutter官方有提供什么解决办法呢？是有的，它就是InheritedWidget。\n二、什么是InheritedWidget？ 遇事不决，先看InheritedWidget的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 /// 有效地沿树传播信息的widgets的基类。 /// Base class for widgets that efficiently propagate information down the tree. /// /// 要从构建上下文获取特定类型的inherited widget的最近实例，请使用BuildContext.dependOnInheritedWidgetOfExactType。 /// To obtain the nearest instance of a particular type of inherited widget from /// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType]. /// /// 当以这种方式引用Inherited widgets时，当Inherited widgets本身更改状态时，将导致使用者重建。 /// Inherited widgets, when referenced in this way, will cause the consumer to /// rebuild when the inherited widget itself changes state. /// /// 以下是名为FrogColor的inherited widget的骨架 /// The following is a skeleton of an inherited widget called `FrogColor`: /// /// ```dart /// class FrogColor extends InheritedWidget { /// const FrogColor({ /// super.key, /// required this.color, /// required super.child, /// }); /// /// final Color color; /// /// static FrogColor? maybeOf(BuildContext context) { /// return context.dependOnInheritedWidgetOfExactType\u0026lt;FrogColor\u0026gt;(); /// } /// /// static FrogColor of(BuildContext context) { /// final FrogColor? result = maybeOf(context); /// assert(result != null, \u0026#39;No FrogColor found in context\u0026#39;); /// return result!; /// } /// /// @override /// bool updateShouldNotify(FrogColor oldWidget) =\u0026gt; color != oldWidget.color; /// } /// ``` /// {@end-tool} /// /// ## 实现“of”和“maybeOf”方法 /// ## Implementing the `of` and `maybeOf` methods /// /// 约定是在InheritedWidget上提供两个静态方法of和maybeOf ，它们调用BuildContext.dependOnInheritedWidgetOfExactType。 /// 这允许类定义自己的后备逻辑，以防范围内没有widget /// The convention is to provide two static methods, `of` and `maybeOf`, on the /// [InheritedWidget] which call /// [BuildContext.dependOnInheritedWidgetOfExactType]. This allows the class to /// define its own fallback logic in case there isn\u0026#39;t a widget in scope. /// /// `of` 方法通常返回一个不可为 null 的实例，并在未找到 [InheritedWidget] 时断言，而 `maybeOf` 方法则返回一个可为 null 的实例，并在未找到 [InheritedWidget] 时返回 null。 /// “of”方法通常通过内部调用“maybeOf”来实现。 /// The `of` method typically returns a non-nullable instance and asserts if the /// [InheritedWidget] isn\u0026#39;t found, and the `maybeOf` method returns a nullable /// instance, and returns null if the [InheritedWidget] isn\u0026#39;t found. The `of` /// method is typically implemented by calling `maybeOf` internally. /// /// 有时，“of”和“maybeOf”方法返回一些数据，而不是inherited widget本身；例如，在这种情况下，它可能返回一个 [Color] 而不是“FrogColor”小部件。 /// Sometimes, the `of` and `maybeOf` methods return some data rather than the /// inherited widget itself; for example, in this case it could have returned a /// [Color] instead of the `FrogColor` widget. /// /// 有时，inherited widget是另一个类的实现细节，因此是私有的。 /// 在这种情况下，“of”和“maybeOf”方法通常在公共类上实现。 /// 例如，[Theme]被实现为[StatelessWidget]，它构建了一个私有inherited widget； [Theme.of] 使用 [BuildContext.dependOnInheritedWidgetOfExactType] 查找inherited widget，然后返回其中的 [ThemeData]。 /// Occasionally, the inherited widget is an implementation detail of another /// class, and is therefore private. The `of` and `maybeOf` methods in that case /// are typically implemented on the public class instead. For example, [Theme] /// is implemented as a [StatelessWidget] that builds a private inherited /// widget; [Theme.of] looks for that private inherited widget using /// [BuildContext.dependOnInheritedWidgetOfExactType] and then returns the /// [ThemeData] inside it. /// /// ## 调用“of”或“maybeOf”方法 /// ## Calling the `of` or `maybeOf` methods /// /// 使用“of”或“maybeOf”方法时，“context”必须是 [InheritedWidget] 的后代，这意味着它必须位于树中 [InheritedWidget]“下方”。 /// When using the `of` or `maybeOf` methods, the `context` must be a descendant /// of the [InheritedWidget], meaning it must be \u0026#34;below\u0026#34; the [InheritedWidget] /// in the tree. /// /// 在此示例中，使用的“context”是来自 [Builder] 的context，它是“FrogColor” widget的子级，因此这是可行的。 /// In this example, the `context` used is the one from the [Builder], which is /// a child of the `FrogColor` widget, so this works. /// /// ```dart /// // continuing from previous example... /// class MyPage extends StatelessWidget { /// const MyPage({super.key}); /// /// @override /// Widget build(BuildContext context) { /// return Scaffold( /// body: FrogColor( /// color: Colors.green, /// child: Builder( /// builder: (BuildContext innerContext) { /// return Text( /// \u0026#39;Hello Frog\u0026#39;, /// style: TextStyle(color: FrogColor.of(innerContext).color), /// ); /// }, /// ), /// ), /// ); /// } /// } /// ``` /// 在此示例中，使用的“context”是来自“MyOtherPage” widget的上下文，该widget是“FrogColor”widget的父级，因此这不起作用，并且会在调用“FrogColor.of”时断言。 /// In this example, the `context` used is the one from the `MyOtherPage` /// widget, which is a parent of the `FrogColor` widget, so this does not work, /// and will assert when `FrogColor.of` is called. /// /// ```dart /// // continuing from previous example... /// /// class MyOtherPage extends StatelessWidget { /// const MyOtherPage({super.key}); /// /// @override /// Widget build(BuildContext context) { /// return Scaffold( /// body: FrogColor( /// color: Colors.green, /// child: Text( /// \u0026#39;Hello Frog\u0026#39;, /// style: TextStyle(color: FrogColor.of(context).color), /// ), /// ), /// ); /// } /// } /// ``` 可以看到，注释详细地描述了InheritedWidget的特性以及贴心地给出了相应的示例，根据InheritedWidget的注释，可以总结下它的特性：\n1、InheritedWidget是沿着Widget树传播信息的基类。\n2、可以使用BuildContext.dependOnInheritedWidgetOfExactType获取特定类型的InheritedWidget的最近实例。\n3、当InheritedWidget本身更改状态时，将导致使用者重建。\n4、使用of或maybeOf方法时，context必须是InheritedWidget的后代，这意味着它必须位于树中InheritedWidget下方。\n5、\u0026hellip;\n这里给出了InheritedWidget的部分特性，主要是想让大家对InheritedWidget有一个初级认知。\n继续看下InheritedWidget的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 abstract class InheritedWidget extends ProxyWidget { const InheritedWidget({ super.key, required super.child }); @override InheritedElement createElement() =\u0026gt; InheritedElement(this); /// 框架是否应该通知继承自此widget的widgets /// Whether the framework should notify widgets that inherit from this widget. /// /// 当这个widget被重建时，有时我们需要重建从这个widget继承的widgets，但有时我们不需要。 /// 例如，如果这个widget保存的数据与“oldWidget”保存的数据相同，那么我们不需要重建继承“oldWidget”保存数据的widgets。 /// When this widget is rebuilt, sometimes we need to rebuild the widgets that /// inherit from this widget but sometimes we do not. For example, if the data /// held by this widget is the same as the data held by `oldWidget`, then we /// do not need to rebuild the widgets that inherited the data held by /// `oldWidget`. /// /// 框架通过使用先前占据树中此位置的widget作为参数来调用此函数来区分这些情况。 /// 保证给定的widget与该对象具有相同的 [runtimeType]。 /// The framework distinguishes these cases by calling this function with the /// widget that previously occupied this location in the tree as an argument. /// The given widget is guaranteed to have the same [runtimeType] as this /// object. @protected bool updateShouldNotify(covariant InheritedWidget oldWidget); } 可以发现，InheritedWidget继承自ProxyWidget，InheritedWidget的构造方法需要传入一个child，createElement方法返回了一个InheritedElement实例，并且在父类ProxyWidget的基础上新增了一个updateShouldNotify方法，从该方法的注释也可以了解到，它用于判断是否应该通知继承InheritedWidget的Widget。\n三、InheritedWidget示例演示 使用InheritedWidget改造之前的计数器示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyParent( counter: _counter, child: const MyChild(), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; const MyParent({super.key, required this.counter, required super.child}); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ); } } 程序运行UI效果和之前的计数器示例一样，可以参考上面gif图。\n在InheritedWidget示例中，点击FloatingActionButton时日志打印如下：\n1 2 I/flutter ( 7101): didChangeDependencies I/flutter ( 7101): build 在上面的InheritedWidget示例中，可以发现存在3个疑点：\n1、对于之前的计数器示例，每次点击FloatingActionButton时仅会触发build方法，而对于InheritedWidget示例，如果目标子Widget是StatefulWidget，那么还会触发State的didChangeDependencies方法，这是为什么呢？\n2、如果把InheritedWidget示例中const MyChild()的const修饰去掉，会发生什么？\n3、我们知道，子Widget通过MyParent.of方法获取InheritedWidget的实例，使用的是context的dependOnInheritedWidgetOfExactType方法，除此之外还有一个getInheritedWidgetOfExactType方法也可以获取InheritedWidget的实例，那这两个方法之间有什么区别？\n关于这3个疑点，等下分析源码时再进行讲解。\n四、分析InheritedWidget源码 4.1、InheritedElement注册阶段 程序启动后，当执行到MyChild关联的State的build方法时，就会调用MyParent.of方法，而InheritedElement注册阶段在于context的dependOnInheritedWidgetOfExactType方法，具体实现在Element，点击进去看下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @override T? dependOnInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;({Object? aspect}) { assert(_debugCheckStateIsActiveForAncestorLookup()); // 分析1 final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T]; // 分析2 if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } // 分析3 _hadUnsatisfiedDependencies = true; return null; } 分析1：这里涉及Element的成员变量_inheritedElements，代码如下：\n1 PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt;? _inheritedElements; 可以看到_inheritedElements的类型是PersistentHashMap，它是一个键值对的集合，其中Key为Type，这里的Type为InheritedWidget或InheritedWidget的子类，Value为InheritedElement。\n在分析1中，首先判断_inheritedElements == null，如果不为null，那么以InheritedWidget类型为Key获取InheritedElement。\n那么_inheritedElements是在哪里赋值的？对于非InheritedElement来说，它是在Element的_updateInheritance()方法中赋值，看下它的源码。\n1 2 3 4 void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); _inheritedElements = _parent?._inheritedElements; } 而对于InheritedElement来说，它是在InheritedElement的_updateInheritance()方法中赋值，看下它的源码。\n1 2 3 4 5 6 7 @override void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); final PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt; incomingWidgets = _parent?._inheritedElements ?? const PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt;.empty(); _inheritedElements = incomingWidgets.put(widget.runtimeType, this); } 可以看到，如果父类的_inheritedElements为null，那么就会创建一个空的PersistentHashMap实例，赋值给局部变量incomingWidgets，然后以InheritedWidget的runtimeType为Key，把当前的InheritedElement作为Value存入该HashMap中。\n那么_updateInheritance()方法是在哪里触发的？它是在Element的mount方法中触发的，也就是当InheritedElement添加到Element树时，就会将InheritedElement存入到这个_inheritedElements。\n以及在Element的activate方法中触发的，也就是当InheritedElement重新合并到Element树时，就会将InheritedElement存入到这个_inheritedElements。\n现在知道了为什么通过dependOnInheritedWidgetOfExactType方法能够获取距离目标子Widget最近的一个InheritedWidget子类的实例了？\n因为InheritedWidget子类的runtimeType作为Key是唯一的，对于相同类型的Key，每次添加InheritedElement进_inheritedElements这个HashMap时会覆盖掉之前的InheritedElement。\n分析2：如果以InheritedWidget类型为Key从HashMap中获取的InheritedElement不为null，那么就会执行dependOnInheritedElement方法，看下它的源码。\n1 2 3 4 5 6 7 @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) { _dependencies ??= HashSet\u0026lt;InheritedElement\u0026gt;(); _dependencies!.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget as InheritedWidget; } 这里涉及Element的成员变量_dependencies，代码如下：\n1 Set\u0026lt;InheritedElement\u0026gt;? _dependencies; 可以看到_dependencies的类型是HashSet，用来存放InheritedElement，为什么用一个Set集合来存放这些InheritedElement呢？\n因为当前Element（比如MyChild所关联的StatefulElement）所依赖的InheritedWidget可能不值一个，并且比如多次调用MyParent.of时，Set确保同一个InheritedElement只能添加一次。\n在dependOnInheritedElement方法中，如果_dependencies为null，就会创建一个空的HashSet，然后把从_inheritedElements![T]获取的ancestor存入该HashSet。\n紧接着执行ancestor（也就是InheritedElement）的updateDependencies方法。\n1 2 3 4 @protected void updateDependencies(Element dependent, Object? aspect) { setDependencies(dependent, null); } 在InheritedElement的updateDependencies方法中，执行了setDependencies方法。\n1 2 3 4 @protected void setDependencies(Element dependent, Object? value) { _dependents[dependent] = value; } 这里涉及InheritedElement的成员变量_dependents，代码如下：\n1 final Map\u0026lt;Element, Object?\u0026gt; _dependents = HashMap\u0026lt;Element, Object?\u0026gt;(); 可以看到_dependents的类型是HashMap，也就是一个键值对的集合，其中Key为Element，Value为Object。\n将当前Element（此处是MyChild所关联的StatefulElement）作为Key，此时value为null，存入了该HashMap。\n目前所讲源码中涉及了3个集合_inheritedElements、_dependencies、_dependents，它们之间的关系如下图。\n分析3：回到dependOnInheritedWidgetOfExactType方法，如果_inheritedElements == null成立，那么该方法返回null，表示查找不到指定类型的InheritedWidget。\n到这里先解释下之前的疑点3：\n我们知道，子Widget通过MyParent.of方法获取InheritedWidget的实例，使用的是context的dependOnInheritedWidgetOfExactType方法，除此之外还有一个getInheritedWidgetOfExactType方法也可以获取InheritedWidget的实例，那这两个方法之间有什么区别？\n看下getInheritedWidgetOfExactType方法源码。\n1 2 3 4 5 6 7 8 9 10 11 @override T? getInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;() { return getElementForInheritedWidgetOfExactType\u0026lt;T\u0026gt;()?.widget as T?; } @override InheritedElement? getElementForInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;() { assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T]; return ancestor; } 可以看到，相比于dependOnInheritedWidgetOfExactType方法，是少了InheritedElement注册部分，所以如果InheritedWidget的状态发生改变，是无法通知子Widget进行重建的。\n1 2 3 if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } 4.2、InheritedElement通知更新阶段 当点击FloatingActionButton时，就会执行setState方法，那么示例中_MyPageState的build方法就会执行。\n关于setState方法的分析请参考解读Flutter源码之setState一文，InheritedElement通知更新阶段从BuildOwner的buildScope方法开始讲起。\n在BuildOwner的buildScope方法的While循环中，当前正在执行element.rebuild()方法，此处element正是MyPage所关联的StatefulElement，注意BuildOwner中的一个布尔值成员变量_scheduledFlushDirtyElements，因为While循环还没执行完，所以不会执行到finally语句（它在finally语句中修改为false），所以布尔值为true，OK，知道这些信息就行。\n从MyPage的重建一直到MyParent的重建，中间嵌套太多层了，这部分不会进行讲解，而是从MyParent的重建开始讲起。\n当执行到MyParent的重建时，就会执行Element的updateChild方法，因为MyParent不是const修饰，所以每次都会创建一个MyParent新实例，那么 if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)是不成立的，就会执行下面的else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，这里MyParent是没有传入Key的，所以满足else if条件。\n接着执行child.update(newWidget)，也就是执行Element的update方法。\n又因为MyParent所关联的Element为InheritedElement，而InheritedElement的父类为ProxyElement，所以执行了ProxyElement的update方法。\n1 2 3 4 5 6 7 8 9 @override void update(ProxyWidget newWidget) { final ProxyWidget oldWidget = widget as ProxyWidget; assert(widget != newWidget); super.update(newWidget); assert(widget == newWidget); updated(oldWidget); rebuild(force: true); } 在ProxyElement的update方法中，一共做了3件事情：\n1、执行super.update(newWidget)，更新InheritedElement所关联的Widget，也就是MyParent。\n2、执行updated(oldWidget)方法，这里是执行了InheritedElement的updated方法，看下它的源码。\n1 2 3 4 5 6 @override void updated(InheritedWidget oldWidget) { if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) { super.updated(oldWidget); } } 在InheritedElement的updated方法中，先执行updateShouldNotify方法，也就是我们在MyParent中实现的方法，用于判断是否应该通知继承InheritedWidget的Widget。\n如果updateShouldNotify方法返回true，那么执行super.updated(oldWidget)，也就是执行父类ProxyElement的updated方法。\n1 2 3 4 @protected void updated(covariant ProxyWidget oldWidget) { notifyClients(oldWidget); } 在ProxyElement的updated方法中，执行了notifyClients方法，这个方法由子类实现，这里看InheritedElement的notifyClients方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @override void notifyClients(InheritedWidget oldWidget) { assert(_debugCheckOwnerBuildTargetExists(\u0026#39;notifyClients\u0026#39;)); for (final Element dependent in _dependents.keys) { assert(() { // check that it really is our descendant Element? ancestor = dependent._parent; while (ancestor != this \u0026amp;\u0026amp; ancestor != null) { ancestor = ancestor._parent; } return ancestor == this; }()); // check that it really depends on us assert(dependent._dependencies!.contains(this)); notifyDependent(oldWidget, dependent); } } 在InheritedElement的notifyClients方法中，for循环遍历了_dependents的keys，然后在for循环中执行了notifyDependent方法。\n1 2 3 4 @protected void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) { dependent.didChangeDependencies(); } 在InheritedElement的notifyDependent方法中，执行了Element的didChangeDependencies方法。因为之前注册的就是我们自己的MyChild所关联的StatefulElement，所以执行的StatefulElement的didChangeDependencies方法。\n1 2 3 4 5 @override void didChangeDependencies() { super.didChangeDependencies(); _didChangeDependencies = true; } 在StatefulElement的didChangeDependencies方法中，执行了super.didChangeDependencies()，也就是执行了父类Element的didChangeDependencies方法，然后把_didChangeDependencies赋值为true。\n1 2 3 4 5 6 @mustCallSuper void didChangeDependencies() { assert(_lifecycleState == _ElementLifecycle.active); // otherwise markNeedsBuild is a no-op assert(_debugCheckOwnerBuildTargetExists(\u0026#39;didChangeDependencies\u0026#39;)); markNeedsBuild(); } 在Element的didChangeDependencies方法中，执行了Element的markNeedsBuild方法，markNeedsBuild方法是老朋友了，它会将Element标记为脏并将其添加到Widget的全局列表中以在下一帧中重建，这里的Element指MyChild所关联的StatefulElement。\n在Element的markNeedsBuild方法中，执行了BuildOwner的scheduleBuildFor方法。\n在BuildOwner的scheduleBuildFor方法中，执行if (!_scheduledFlushDirtyElements \u0026amp;\u0026amp; onBuildScheduled != null)，还记得之前讲的成员变量_scheduledFlushDirtyElements的值为true吗，这是因为MyParent及其子Widget还没重建完成。\n所以if条件不成立，onBuildScheduled!()不会执行，这里只是把MyChild所关联的StatefulElement添加进_dirtyElements。\n整体上看MyPage的重建已经包括了MyChild的重建，所以这里MyChild的重建是不需要单独放在下一帧去处理了，还是放在_MyPageState最初执行setState时的那一帧进行重建。\n此时需要While循环处理的_dirtyElements如下。\n3、回到ProxyElement的update方法中，接着执行rebuild(force: true)，也就是执行Element的rebuild方法，这个方法是老朋友了，在它的内部会执行performRebuild方法。\n因为ComponentElement为ProxyElement的父类，所以这里执行了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，执行了MyParent所关联的Element的build方法，也就是ProxyElement的build方法，这个build方法就是用来构建MyChild这个Widget的。\n在ComponentElement的performRebuild方法中，接着执行了Element的updateChild方法。因为MyChild使用const修饰，它相当于一个常量，所以满足if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，然后直接返回之前的Element，也就是MyParent所关联的Element。\n到这里就解释了之前的疑点2：\n如果把InheritedWidget示例中const MyChild()的const修饰去掉，会发生什么？\nOK，回到最初在_MyPageState中执行setState方法时，它会触发BuildOwner的buildScope方法，在第一轮While循环中，任务是重建MyPage，现在已经循环完了，然后index+1。\n下面进入第二轮While循环来重建MyChild，执行了Element的rebuild方法。\n之前讲过，在Element的rebuild方法中会执行performRebuild方法，此时执行的就是StatefulElement的performRebuild方法。\n1 2 3 4 5 6 7 8 @override void performRebuild() { if (_didChangeDependencies) { state.didChangeDependencies(); _didChangeDependencies = false; } super.performRebuild(); } 因为之前_didChangeDependencies已经赋值为true，所以这里执行了state.didChangeDependencies()，触发了State的didChangeDependencies方法。\n到这里就解释了之前的疑点1：\n对于之前的计数器示例，每次点击FloatingActionButton时仅会触发build方法，而对于InheritedWidget示例，如果目标子Widget是StatefulWidget，那么还会触发State的didChangeDependencies方法，这是为什么呢？\n接着执行super.performRebuild()，调用父类ComponentElement的performRebuild方法，这个方法也是老朋友了，最终会触发MyChild的build方法。\n4.3、InheritedElement取消注册阶段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @mustCallSuper void deactivate() { assert(_lifecycleState == _ElementLifecycle.active); assert(_widget != null); // Use the private property to avoid a CastError during hot reload. if (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) { for (final InheritedElement dependency in _dependencies!) { dependency._dependents.remove(this); } // 为了方便起见，我们实际上并没有清除此处的列表，尽管它不再代表我们注册的内容。 // 如果我们永远不会被重用，那也没关系。 // 如果这样做，那么我们将在 activate() 中清除该列表。 // 这样做的好处是，它允许 Element 的 activate() 实现根据我们这里是否有依赖关系来决定是否重建。 // For expediency, we don\u0026#39;t actually clear the list here, even though it\u0026#39;s // no longer representative of what we are registered with. If we never // get re-used, it doesn\u0026#39;t matter. If we do, then we\u0026#39;ll clear the list in // activate(). The benefit of this is that it allows Element\u0026#39;s activate() // implementation to decide whether to rebuild based on whether we had // dependencies here. } _inheritedElements = null; _lifecycleState = _ElementLifecycle.inactive; } InheritedElement取消注册是在Element的deactivate方法，比如当MyChild所关联的Element（也就是StatefulElement）执行了deactivate方法，如果_dependencies不为null且不为空，那么将当前Element从InheritedElement的_dependents中移除。\n下次在InheritedElement的notifyClients方法中for循环遍历_dependents的keys时，就无法再通知MyChild所关联的Element。\n1 2 3 4 5 6 @override void notifyClients(InheritedWidget oldWidget) { for (final Element dependent in _dependents.keys) { notifyDependent(oldWidget, dependent); } } 然后执行_inheritedElements = null，把_inheritedElements也置为null。\n但是，_dependencies在deactivate方法中是没有被清除的，通过deactivate方法中的注释可以知道，如果Element永远不会被重用，那也没关系。\n可以之后在activate方法中清除该列表，这样做的好处是，它允许Element的activate方法实现根据我们这里是否有依赖关系来决定是否重建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @mustCallSuper void activate() { assert(_lifecycleState == _ElementLifecycle.inactive); assert(owner != null); // 是否有依赖关系 final bool hadDependencies = (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) || _hadUnsatisfiedDependencies; _lifecycleState = _ElementLifecycle.active; // 我们在 deactivate 中注销了我们的依赖项，但从未清除过列表 // We unregistered our dependencies in deactivate, but never cleared the list. // 由于我们将被重用，所以现在让我们清除我们的列表。 // Since we\u0026#39;re going to be reused, let\u0026#39;s clear our list now. _dependencies?.clear(); _hadUnsatisfiedDependencies = false; _updateInheritance(); attachNotificationTree(); if (_dirty) { owner!.scheduleBuildFor(this); } // 如果有有依赖关系，执行didChangeDependencies进行重建 if (hadDependencies) { didChangeDependencies(); } } 五、InheritedWidget扩展 除了上面讲的InheritedWidget，其实InheritedWidget还存在一些特定的子类，如下图。\n5.1、InheritedModel介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 /// 一种 [InheritedWidget]，旨在用作模型的基类，其依赖项可能仅依赖于整个模型的一部分或“方面”。 /// An [InheritedWidget] that\u0026#39;s intended to be used as the base class for models /// whose dependents may only depend on one part or \u0026#34;aspect\u0026#34; of the overall /// model. /// /// 当inherited widget根据 [InheritedWidget.updateShouldNotify] 发生更改时，inherited widget的依赖项将无条件重建。 /// 此widget类似，只是依赖项不会无条件重建。 /// An inherited widget\u0026#39;s dependents are unconditionally rebuilt when the /// inherited widget changes per [InheritedWidget.updateShouldNotify]. This /// widget is similar except that dependents aren\u0026#39;t rebuilt unconditionally. /// /// 依赖于 [InheritedModel] 的Widgets用一个值来限定其依赖关系，该值指示它们所依赖的模型的“方面”。 /// 当重建模型时，依赖项也将被重建，但前提是模型中存在与它们提供的方面相对应的更改。 /// Widgets that depend on an [InheritedModel] qualify their dependence with a /// value that indicates what \u0026#34;aspect\u0026#34; of the model they depend on. When the /// model is rebuilt, dependents will also be rebuilt, but only if there was a /// change in the model that corresponds to the aspect they provided. /// /// 类型参数“T”是模型方面对象的类型。 /// The type parameter `T` is the type of the model aspect objects. /// /// Widgets使用静态方法创建对 [InheritedModel] 的依赖：[InheritedModel.inheritFrom]。 /// 此方法的“context”参数定义模型更改时将重建的子树。 /// 通常，“inheritFrom”方法是从特定于模型的静态“maybeOf”或“of”方法调用的，这是许多查找事物的 Flutter 框架类中存在的约定。例如： /// Widgets create a dependency on an [InheritedModel] with a static method: /// [InheritedModel.inheritFrom]. This method\u0026#39;s `context` parameter defines the /// subtree that will be rebuilt when the model changes. Typically the /// `inheritFrom` method is called from a model-specific static `maybeOf` or /// `of` methods, a convention that is present in many Flutter framework classes /// which look things up. For example: /// /// ```dart /// class MyModel extends InheritedModel\u0026lt;String\u0026gt; { /// const MyModel({super.key, required super.child}); /// /// // ... /// static MyModel? maybeOf(BuildContext context, [String? aspect]) { /// return InheritedModel.inheritFrom\u0026lt;MyModel\u0026gt;(context, aspect: aspect); /// } /// /// // ... /// static MyModel of(BuildContext context, [String? aspect]) { /// final MyModel? result = maybeOf(context, aspect); /// assert(result != null, \u0026#39;Unable to find an instance of MyModel...\u0026#39;); /// return result!; /// } /// } /// ``` /// /// 调用 `MyModel.of(context, \u0026#39;foo\u0026#39;)` 或 `MyModel.maybeOf(context, \u0026#39;foo\u0026#39;)` 意味着仅当 `MyModel` 的 `foo` aspect发生更改时才应该重建 `context`。 /// 如果“aspect”为空，则模型支持所有aspects。 /// Calling `MyModel.of(context, \u0026#39;foo\u0026#39;)` or `MyModel.maybeOf(context, /// \u0026#39;foo\u0026#39;)` means that `context` should only be rebuilt when the `foo` aspect of /// `MyModel` changes. If the `aspect` is null, then the model supports all /// aspects. /// /// {@tool snippet} /// 重建inherited model时， [updateShouldNotify] 和 [updateShouldNotifyDependent] 方法用于决定应该重建什么。 /// 如果 [updateShouldNotify] 返回 true，则针对每个依赖项及其依赖的aspect对象集测试inherited model的 [updateShouldNotifyDependent] 方法。 /// [updateShouldNotify Dependent] 方法必须将aspectj依赖项集与模型本身的更改进行比较。例如： /// When the inherited model is rebuilt the [updateShouldNotify] and /// [updateShouldNotifyDependent] methods are used to decide what should be /// rebuilt. If [updateShouldNotify] returns true, then the inherited model\u0026#39;s /// [updateShouldNotifyDependent] method is tested for each dependent and the /// set of aspect objects it depends on. The [updateShouldNotifyDependent] /// method must compare the set of aspect dependencies with the changes in the /// model itself. For example: /// /// ```dart /// class ABModel extends InheritedModel\u0026lt;String\u0026gt; { /// const ABModel({ /// super.key, /// this.a, /// this.b, /// required super.child, /// }); /// /// final int? a; /// final int? b; /// /// @override /// bool updateShouldNotify(ABModel oldWidget) { /// return a != oldWidget.a || b != oldWidget.b; /// } /// /// @override /// bool updateShouldNotifyDependent(ABModel oldWidget, Set\u0026lt;String\u0026gt; dependencies) { /// return (a != oldWidget.a \u0026amp;\u0026amp; dependencies.contains(\u0026#39;a\u0026#39;)) /// || (b != oldWidget.b \u0026amp;\u0026amp; dependencies.contains(\u0026#39;b\u0026#39;)); /// } /// /// // ... /// } /// ``` /// {@end-tool} /// /// 在前面的示例中，[updateShouldNotify Dependent] 检查的依赖项只是传递给“dependOnInheritedWidgetOfExactType”的aspect字符串。 /// 它们被表示为一个 [Set]，因为一个 Widget 可以依赖于模型的多个aspect。 /// 如果一个widget依赖于模型但没有指定某个aspect，那么模型中的更改将导致widget无条件地重建。 /// In the previous example the dependencies checked by /// [updateShouldNotifyDependent] are just the aspect strings passed to /// `dependOnInheritedWidgetOfExactType`. They\u0026#39;re represented as a [Set] because /// one Widget can depend on more than one aspect of the model. If a widget /// depends on the model but doesn\u0026#39;t specify an aspect, then changes in the /// model will cause the widget to be rebuilt unconditionally. /// /// {@tool dartpad} /// 此示例演示如何实现 [InheritedModel] 以基于合格的依赖关系重建widget。 /// 当点击“调整logo”按钮时，仅重建logo widget，而背景widget不受影响。 /// This example shows how to implement [InheritedModel] to rebuild a widget /// based on a qualified dependence. When tapped on the \u0026#34;Resize Logo\u0026#34; button /// only the logo widget is rebuilt while the background widget remains /// unaffected. /// /// ** See code in examples/api/lib/widgets/inherited_model/inherited_model.0.dart ** abstract class InheritedModel\u0026lt;T\u0026gt; extends InheritedWidget 通过InheritedModel的注释可以知道，InheritedModel相比于InheritedWidget可以更细粒度地控制依赖于InheritedModel的子Widget的重建。\n还有一点，我们经常用的媒体查询MediaQuery也是继承自InheritedModel。\n5.2、InheritedNotifier介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /// [Listenable] [notifier] 的inherited widget，当触发 [notifier] 时更新其依赖项。 /// An inherited widget for a [Listenable] [notifier], which updates its /// dependencies when the [notifier] is triggered. /// /// 这是 [InheritedWidget] 的变体，专门用于 [Listenable] 的子类，例如 [ChangeNotifier] 或 [ValueNotifier]。 /// This is a variant of [InheritedWidget], specialized for subclasses of /// [Listenable], such as [ChangeNotifier] or [ValueNotifier]. /// /// 每当[notifier]发送通知或每当[notifier]的身份发生变化时，依赖项都会收到通知。 /// Dependents are notified whenever the [notifier] sends notifications, or /// whenever the identity of the [notifier] changes. /// /// 多个通知被合并，因此即使 [notifier] 在两帧之间触发多次，依赖项也仅重建一次。 /// Multiple notifications are coalesced, so that dependents only rebuild once /// even if the [notifier] fires multiple times between two frames. /// /// 通常，该类是一个类的子类，该类提供一个“of”静态方法，该方法使用该类调用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// Typically this class is subclassed with a class that provides an `of` static /// method that calls [BuildContext.dependOnInheritedWidgetOfExactType] with that /// class. /// /// [updateShouldNotify] 方法也可以被重写，以在 [notifier] 本身发生更改的情况下更改逻辑。 /// 如果 [notifier] 发生更改，则使用旧的 [notifier] 调用 [updateShouldNotify] 方法。 /// 当它返回 true 时，依赖项被标记为需要在该框架中重建。 /// The [updateShouldNotify] method may also be overridden, to change the logic /// in the cases where [notifier] itself is changed. The [updateShouldNotify] /// method is called with the old [notifier] in the case of the [notifier] being /// changed. When it returns true, the dependents are marked as needing to be /// rebuilt this frame. /// /// {@tool dartpad} /// 此示例显示了三个旋转方块，它们使用祖先 [InheritedNotifier] (`SpinModel`) 上的notifier的值来进行旋转。 /// [InheritedNotifier] 不需要了解子级，并且 `notifier` 参数不需要是动画控制器，它可以是任何实现 [Listenable] 的东西（如 [ChangeNotifier]）。 /// This example shows three spinning squares that use the value of the notifier /// on an ancestor [InheritedNotifier] (`SpinModel`) to give them their /// rotation. The [InheritedNotifier] doesn\u0026#39;t need to know about the children, /// and the `notifier` argument doesn\u0026#39;t need to be an animation controller, it /// can be anything that implements [Listenable] (like a [ChangeNotifier]). /// /// `SpinModel` 类可以轻松地侦听另一个 [Listenable] 对象（例如，保留输入或数据模型值的值的单独对象），并从中获取值。 /// 后代也不需要拥有 [InheritedNotifier] 的实例即可使用它，他们只需要知道他们的祖先中有一个实例即可。 /// 这有助于将widgets与其模型解耦。 /// The `SpinModel` class could just as easily listen to another object (say, a /// separate object that keeps the value of an input or data model value) that /// is a [Listenable], and get the value from that. The descendants also don\u0026#39;t /// need to have an instance of the [InheritedNotifier] in order to use it, they /// just need to know that there is one in their ancestry. This can help with /// decoupling widgets from their models. /// /// ** See code in examples/api/lib/widgets/inherited_notifier/inherited_notifier.0.dart ** /// {@end-tool} abstract class InheritedNotifier\u0026lt;T extends Listenable\u0026gt; extends InheritedWidget 通过InheritedNotifier的注释可以知道，它需要和Listenable一起使用，当触发 notifier时会更新其依赖项。\n5.3、InheritedTheme介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// 一个 [InheritedWidget]，定义 [child] 子树所依赖的视觉属性，例如颜色和文本样式。 /// An [InheritedWidget] that defines visual properties like colors /// and text styles, which the [child]\u0026#39;s subtree depends on. /// /// [captureAll] 和 [CapturedThemes.wrap] 使用 [wrap] 方法来构造一个widget，该widget将把子项包装在widget树的指定部分中存在的所有inherited themes中。 /// The [wrap] method is used by [captureAll] and [CapturedThemes.wrap] to /// construct a widget that will wrap a child in all of the inherited themes /// which are present in a specified part of the widget tree. /// /// 在与其内置环境不同的上下文中显示的widget，就像新路由或overlay的内容一样，将能够看到它所构建的上下文的祖先inherited themes。 /// A widget that\u0026#39;s shown in a different context from the one it\u0026#39;s built in, /// like the contents of a new route or an overlay, will be able to see the /// ancestor inherited themes of the context it was built in. /// /// {@tool dartpad} /// 此示例演示了如何使用 InheritedTheme.capture() 来使用inherited themes来包装新route的内容，这些主题在构建route时存在，但在实际显示route时不存在。 /// This example demonstrates how `InheritedTheme.capture()` can be used /// to wrap the contents of a new route with the inherited themes that /// are present when the route was built - but are not present when route /// is actually shown. /// /// 如果相同的代码在没有 `InheritedTheme.capture() 的情况下运行，则新route的 Text widget将继承“omething must be wrong”反馈文本样式，而不是 MyApp 中定义的默认文本样式。 /// If the same code is run without `InheritedTheme.capture(), the /// new route\u0026#39;s Text widget will inherit the \u0026#34;something must be wrong\u0026#34; /// fallback text style, rather than the default text style defined in MyApp. /// /// ** See code in examples/api/lib/widgets/inherited_theme/inherited_theme.0.dart ** /// {@end-tool} abstract class InheritedTheme extends InheritedWidget 通过InheritedTheme的注释可以知道，它和主题相关联，比如经常用的Theme.of()，它底层会通过dependOnInheritedWidgetOfExactType方法查询_InheritedTheme实例，而_InheritedTheme继承自InheritedTheme。\n","date":"2023-10-31T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Binheritedwidget/","section":"post","tags":null,"title":"解读Flutter源码之InheritedWidget"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、Key是什么？ 在Flutter中，Key的使用是很常见的，就以Scaffold这个Widget来说，当人们使用它的Drawer功能时，必然会涉及openDrawer与closeDrawer这两个行为，它们的具体方法实现定义在ScaffoldState中，可通过如下API调用：\n1 Scaffold.of(context).openDrawer(); // or Scaffold.of(context).closeDrawer(); 不妨点进去看下ScaffoldState中的openDrawer与closeDrawer这两个方法的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 final GlobalKey\u0026lt;DrawerControllerState\u0026gt; _drawerKey = GlobalKey\u0026lt;DrawerControllerState\u0026gt;(); void openDrawer() { if (_endDrawerKey.currentState != null \u0026amp;\u0026amp; _endDrawerOpened.value) { _endDrawerKey.currentState!.close(); } _drawerKey.currentState?.open(); } void closeDrawer() { if (hasDrawer \u0026amp;\u0026amp; isDrawerOpen) { _drawerKey.currentState!.close(); } } 可以发现，它们均使用了_drawerKey这一个GlobalKey来获取currentState，也就是获取了DrawerControllerState实例，然后再调用该实例的open或close方法。\n那么，正如标题所言，Key是什么？还是那句话：遇事不决，先看注释。Key作为参数定义在Widget的构造方法中，默认值为null，也就是使用Widget时可以不传，来看下Widget中关于Key的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @immutable abstract class Widget extends DiagnosticableTree { /// Initializes [key] for subclasses. const Widget({ this.key }); /// 控制一个widget如何替换树中的另一个widget。 /// Controls how one widget replaces another widget in the tree. /// /// 如果两个widgets的 [runtimeType] 和 [key] 属性分别为 [operator==]，则新widget通过更新底层element来替换旧widget（即，通过使用新widget调用 [Element.update] ）。 /// 否则，旧element将从树中删除，新的widget将创建出element，并将新element插入到树中。 /// If the [runtimeType] and [key] properties of the two widgets are /// [operator==], respectively, then the new widget replaces the old widget by /// updating the underlying element (i.e., by calling [Element.update] with the /// new widget). Otherwise, the old element is removed from the tree, the new /// widget is inflated into an element, and the new element is inserted into the /// tree. /// /// 此外，使用 [GlobalKey] 作为widget的 [key] 允许element在树中移动（更改父级）而不会丢失状态。 /// 当找到一个新的widget（其key和type与同一位置的前一个widget不匹配），但在前一帧的树中的其它位置有一个具有相同global key的widget时，该widget的element将移动到新地点。 /// In addition, using a [GlobalKey] as the widget\u0026#39;s [key] allows the element /// to be moved around the tree (changing parent) without losing state. When a /// new widget is found (its key and type do not match a previous widget in /// the same location), but there was a widget with that same global key /// elsewhere in the tree in the previous frame, then that widget\u0026#39;s element is /// moved to the new location. /// /// 通常，作为另一个widget的唯一child的widget不需要显式key。 /// Generally, a widget that is the only child of another widget does not need /// an explicit key. final Key? key; } 再点击进去看下Key本身的一个注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// [Key] 是 [Widget]、[Element] 和 [SemanticsNode] 的标识符。 /// A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s. /// /// 如果新的widget的key与与该element关联的当前widget的key相同，则该新widget将仅用于更新现有element。 /// A new widget will only be used to update an existing element if its key is /// the same as the key of the current widget associated with the element. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc} /// /// Key在具有相同父级的 [Element] 中必须是唯一的。 /// Keys must be unique amongst the [Element]s with the same parent. /// /// [Key] 的子类应该是 [LocalKey] 或 [GlobalKey] 的子类。 /// Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey]. @immutable abstract class Key { } 结合上面Widget中对Key的注释以及Key本身的一个注释，总结下Key的特性：\n1、Key用于控制一个Widget如何替换树中的另一个Widget。\n2、如果两个Widget的runtimeType和key属性分别为相等，则新Widget通过更新底层Element来替换旧Widget；否则旧Element将从树中删除，新的Widget将创建出Element，并将新Element插入到树中。\n3、使用GlobalKey作为Widget的key允许Element在树中移动（更改父级）而不会丢失状态。\n4、Key在具有相同父级的Element中必须是唯一的。\n5、\u0026hellip;\n这里给出了Key的部分特性，主要是想让大家对Key有一个初级认知。\n二、3个小示例之问题 在分析Key的原理之前，先看个“删除中间色块”的小示例。\n现有一需求：设计一个通用的色块Widget，然后在屏幕中横向摆放三个不同颜色的色块Widget，当点击FloatingActionButton按钮时会删除中间色块。\n2.1、示例1 基于StatelessWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在build方法中进行Color初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;小示例\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatelessBox(colorValue: ColorValue.redAccent), const StatelessBox(colorValue: ColorValue.greenAccent), const StatelessBox(colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatelessBox extends StatelessWidget { final ColorValue colorValue; const StatelessBox({super.key, required this.colorValue}); Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { Color color = _getColor(colorValue); debugPrint(\u0026#34;build: $color\u0026#34;); return Container( width: 100, height: 100, color: color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，日志打印如下：\n1 I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff448aff)) 总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、蓝，虽然程序运行效果与预期效果相同，但是还是存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么日志打印是蓝色？\n2、为什么红色块自身的build方法不会触发？\n3、\u0026hellip;\n2.2、示例2 基于StatefulWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在initState方法中进行Color初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatefulBox(colorValue: ColorValue.redAccent), const StatefulBox(colorValue: ColorValue.greenAccent), const StatefulBox(colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatefulBox extends StatefulWidget { final ColorValue colorValue; const StatefulBox({super.key, required this.colorValue}); @override State\u0026lt;StatefulBox\u0026gt; createState() =\u0026gt; _StatefulBoxState(); } class _StatefulBoxState extends State\u0026lt;StatefulBox\u0026gt; { late Color _color; @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); _color = _getColor(widget.colorValue); } Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build: $_color\u0026#39;); return Container( width: 100, height: 100, color: _color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 4 5 6 I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，日志打印如下：\n1 I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) 总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、绿，很明显程序运行效果与预期效果不相同，因此存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么删除的是蓝色块？\n2、为什么日志打印是绿色？\n3、为什么红色块自身的build方法不会触发？\n4、\u0026hellip;\n2.3、示例3 基于StatefulWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在initState方法中进行Color初始化，最后在使用色块Widget时给它传入一个Key。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatefulBox(key: ValueKey(1), colorValue: ColorValue.redAccent), const StatefulBox(key: ValueKey(2), colorValue: ColorValue.greenAccent), const StatefulBox(key: ValueKey(3), colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatefulBox extends StatefulWidget { final ColorValue colorValue; const StatefulBox({super.key, required this.colorValue}); @override State\u0026lt;StatefulBox\u0026gt; createState() =\u0026gt; _StatefulBoxState(); } class _StatefulBoxState extends State\u0026lt;StatefulBox\u0026gt; { late Color _color; @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); _color = _getColor(widget.colorValue); } Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build: $_color\u0026#39;); return Container( width: 100, height: 100, color: _color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 4 5 6 I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，无日志输出。\n总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、蓝，虽然程序运行效果与预期效果相同，但还是存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么在使用色块Widget时给它传入一个Key，程序运行效果相比示例2就又变得正常了？\n2、为什么点击FloatingActionButton按钮后无日志输出？\n3、\u0026hellip;\n看了上面3个小示例的演示，笔者想问它们的运行结果是在你的预料之中还是预料之外？\nOK，不管怎样，接下来分析这3个小示例的执行原理之后谜底就会揭开。\n三、3个小示例之执行原理 3.1、分析示例1 当点击FloatingActionButton按钮后，会执行setState方法，关于setState方法的分析可参考解读Flutter源码之setState一文。\n此处setState方法会先触发Scaffold的重建，Scaffold的重建也会触发其子Widget的重建，然后子Widget的重建也会触发其子Widget的重建，有点像“核裂变的链式反应”，直到所有子Widget均完成重建。\n因为从Scaffold的重建一直到Row的重建，中间实在嵌套太多层了，很不方便分析，所以这里只从Row的父组件KeyedSubtree开始讲起。\n当KeyedSubtree重建完成之后（即KeyedSubtree的父组件_BodyBuilder的build方法已执行），就会执行Element的rebuild方法，在Element的rebuild方法中，接着执行了Element的performRebuild方法，又因为KeyedSubtree是StatelessWidget的子类，所以执行的是ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，执行了KeyedSubtree的build方法重建了Row，然后执行了Element的updateChild方法。\n在Element的updateChild方法中，虽然重建后的Row实例与之前的Row实例不同，但它们的runtimeType是一样的以及key均为null，所以执行了Element的update方法进行Row及其所有子Widget的更新。\n又因为Row是MultiChildRenderObjectWidget的子类，所以执行的是MultiChildRenderObjectElement的update方法来进行Row及其所有子Widget的更新，以上描述所涉及的方法调用栈如下。\n跟踪下MultiChildRenderObjectElement的update方法的源码，可以发现在update方法中，执行了updateChildren方法。\n1 2 3 4 5 6 7 8 9 @override void update(MultiChildRenderObjectWidget newWidget) { super.update(newWidget); final MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget as MultiChildRenderObjectWidget; assert(widget == newWidget); assert(!debugChildrenHaveDuplicateKeys(widget, multiChildRenderObjectWidget.children)); _children = updateChildren(_children, multiChildRenderObjectWidget.children, forgottenChildren: _forgottenChildren); _forgottenChildren.clear(); } 为了方便本文后续的描述，笔者会把重建后的Row叫新Row，而之前的Row就变为旧Row。\nOK，现在解释下updateChildren方法的参数：\noldChildren：它是一个List\u0026lt;Element\u0026gt;，在本示例中，用来存放旧Row中所有子Widget所关联的Element，此处传入的是_children。 newWidgets：它是一个List\u0026lt;Widget\u0026gt;，用来存放新Row中所有子Widget，此处传入的是multiChildRenderObjectWidget.children。 因为删除了中间的绿色块Widget，所以相比初始时的三个色块Widget，现在只剩下红色块Widget与最后一个蓝色块Widget。\nforgottenChildren：一个可选的命名参数，它是一个Set\u0026lt;Element\u0026gt;?，用来存放旧Row中传入了GlobalKey的子Widget所关联的Element，主要作用是避免重复遍历_children来删除子节点的O(n^2) 工作，此处传入的是_forgottenChildren。 在本示例中，因为旧Row中所有子Widget都没有用到GlobalKey，所以_forgottenChildren为空。\nslots：一个可选的命名参数，它是一个List\u0026lt;Object?\u0026gt;?，用来存放旧Row中所有子Widget所关联的槽位，用于定义该子级在其父级子级列表中的位置，因为此处没有传入，所以为null。 多插一嘴，虽然此处没有传入为null，但是旧Row中所有子Widget所关联的槽位还是存在的，这在MultiChildRenderObjectElement的mount方法中已经为旧Row中所有子Widget分配了槽位。\n此时，旧Row中所有子Widget所关联的槽位如下。\nOK，继续跟踪Element的updateChildren方法的源码，可以发现updateChildren方法的源码是比较长的，所以本文会对updateChildren方法的源码拆分为十部分，并且结合示例只讲解被执行到的那部分源码。\n3.1.1、分析第一部分 1 2 3 4 5 6 7 8 9 Element? replaceWithNullIfForgotten(Element child) { return forgottenChildren != null \u0026amp;\u0026amp; forgottenChildren.contains(child) ? null : child; } Object? slotFor(int newChildIndex, Element? previousChild) { return slots != null ? slots[newChildIndex] : IndexedSlot\u0026lt;Element?\u0026gt;(newChildIndex, previousChild); } 在updateChildren方法一开始，就定义了两个局部方法，来分析下：\nreplaceWithNullIfForgotten()：如果旧Row中存在传入了GlobalKey的子Widget，那么该子Widget所关联的Element就需要被过滤掉而不进行处理，避免后续遍历时导致Element被移除，这种情况下会返回null，否则返回传入的child本身。\nslotFor()：获取新Row中newChildIndex索引位置的槽位，之前讲过updateChildren方法并没有传入slots，所以这里会为每个Element创建一个新槽位IndexedSlot。\n3.1.2、分析第二部分 1 2 3 4 5 6 7 8 int newChildrenTop = 0; int oldChildrenTop = 0; int newChildrenBottom = newWidgets.length - 1; int oldChildrenBottom = oldChildren.length - 1; final List\u0026lt;Element\u0026gt; newChildren = List\u0026lt;Element\u0026gt;.filled(newWidgets.length, _NullElement.instance); Element? previousChild; 在updateChildren方法中，定义了几个局部变量，来分析下：\n局部变量 说明 newChildrenTop 遍历newWidgets时的起始位置，从0开始 oldChildrenTop 遍历oldChildren时的起始位置，从0开始 newChildrenBottom 遍历newWidgets时的结束位置，结束位置为newWidgets.length - 1 oldChildrenBottom 遍历oldChildren时的结束位置，结束位置为oldChildren.length - 1 newChildren 它是一个List\u0026lt;Element\u0026gt;，用来存放新Row中所有子Widget所关联的Element previousChild 新Row中子Widget所关联的槽位指向的前一个Element 3.1.3、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 更新列表顶部 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 这个While循环的工作原理是从列表顶部开始更新，也就是从旧Row中第一个子Widget所关联的Element与新Row中第一个子Widget开始往后遍历，判断新旧Widget是否同一个Widget（判断条件是Widget的runtimeType与key），如果是则更新Element所持有的旧Widget为新Widget，否则break退出该While循环。\n当Element更新旧Widget成功时，newChildrenTop与oldChildrenTop就会+1，如果遍历过程中出现Element不能更新旧Widget，那么break退出该While循环，此时newChildrenTop与oldChildrenTop恰好记录了Element不能更新旧Widget时的位置索引。\n3.1.3.1、第一轮循环 第一轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为0，而oldChildrenBottom为2，newChildrenBottom为1，所以满足While循环判断进入循环体。\n分析一：\n1 2 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; 获取oldChild：在本例中，旧Row中所有子Widget都没有传入GlobalKey，所以replaceWithNullIfForgotten()返回的是传入的child本身，也就是oldChildren[0]，它是旧Row中第一个子Widget所关联的Element。 获取newWidget：获取新Row中第一个子Widget。 分析二：\n1 2 3 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } 由分析一可以知道，oldChild == null是不成立的，所以执行了Widget.canUpdate()，来看下canUpdate方法。\n1 2 3 4 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType \u0026amp;\u0026amp; oldWidget.key == newWidget.key; } 可以知道，canUpdate方法中比较了runtimeType与key，也就是比较了旧Row中第一个Widget与新Row中第一个Widget的runtimeType与key，因为两者均没传入key，所以key默认为null，那么比较的就是runtimeType了，而两者的runtimeType均为StatelessBox，所以canUpdate方法返回true，并不会执行break跳出While循环。\n分析三：\n1 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; 执行了Element的updateChild方法，那么updateChild方法是用来干嘛的？\nupdateChild方法使用给定的新配置更新给定的child，它是widgets系统的核心，每次我们根据更新的配置添加、更新或删除child时都会调用它。\n来看下updateChild方法的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } else { deactivateChild(child); newChild = inflateWidget(newWidget, newSlot); } } else { newChild = inflateWidget(newWidget, newSlot); } return newChild; } 这里总结下updateChild方法的工作逻辑：\nnewWidget == null newWidget != null child == null 返回null 返回新的Element child != null 旧的child被移除, 返回null 如果可能，更新旧child，返回child或新的Element 在本示例中，updateChild方法的第一个参数传入了旧Row中第一个Widget所关联的Element，第二个参数传入了新Row中第一个Widget，第三个参数是新Row中第一个Widget所关联的槽位。\n来看下第一轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } } return newChild; } 在updateChild方法中，因为传入的参数child与newWidget都不为null，所以执行到if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，可以看到child.widget == newWidget比较的是两个Widget是否相等，而Widget对==操作符进行了重写，比较的是两者的引用。\n1 2 3 4 // Widget @override @nonVirtual bool operator ==(Object other) =\u0026gt; super == other; Row的children列表是定义为_MyPageState的一个成员变量_boxes，当移除中间色块Widget时，第一个色块Widget的引用在列表中还是没发生变化，所以if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)是成立的，然后进入另一个if判断if (child.slot != newSlot)。\n之前讲过newSlot是在slotFor()局部方法中新创建的，而child.slot是在MultiChildRenderObjectElement的mount方法中创建的，所以这两个slot不是同一个实例。\n但是，这里!=比较的并不是两者的slot引用，因为IndexedSlot重载了==操作符，它们比较的是IndexedSlot构造方法中传入的参数值，相当于执行了equals()，可以看下IndexedSlot的部分源码。\n1 2 3 4 5 6 7 8 9 10 // IndexedSlot @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is IndexedSlot \u0026amp;\u0026amp; index == other.index \u0026amp;\u0026amp; value == other.value; } 可以知道，此时这两个IndexedSlot中参数值的比较是相等的，因而if判断if (child.slot != newSlot)是不成立的，不会执行updateSlotForChild()。\n然后执行newChild = child，直接将旧Row中第一个Widget所关联的Element返回，那么updateChild方法执行完成。\n分析四：\n1 2 3 4 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; 把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，进入第二轮While循环判断。\n3.1.3.2、第二轮循环 第二轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为1，而oldChildrenBottom为2，newChildrenBottom为1，所以满足While循环判断进入循环体。\n分析一、分析二与之前一样，先是获取oldChild与newWidget，然后继续执行updateChild方法。\n分析三：\n在本示例中，updateChild方法的第一个参数传入了旧Row中第二个Widget所关联的Element，第二个参数传入了新Row中第二个Widget，第三个参数是新Row中第二个Widget所关联的槽位。\n来看下第二轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } } return newChild; } 在updateChild方法中，因为传入的参数child与newWidget都不为null，所以执行到if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)。\n但是，此时child.widget == newWidget是不成立的，为什么呢？\n因为child.widget是旧Row中第二个Widget，而newWidget是新Row中第二个子Widget（它其实对应了旧Row中第三个Widget），所以相当于旧Row中第二个Widget与第三个Widget进行比较，很显然这两个引用是不相等的。\n接着执行else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，对于Widget.canUpdate()，之前讲过如果Row的子Widget没有传入key，那么比较的就是runtimeType，很显然两者的runtimeType都是StatelessBox，所以if判断else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))成立，然后进入另一个if判断if (child.slot != newSlot)。\n之前讲过IndexedSlot重写了操作符==，内部比较的是构造方法传入的参数值，相当于执行equals()，所以此时这两个slot依然相等，if判断if (child.slot != newSlot)不成立。\n接着继续执行child.update(newWidget)方法，又因为child的类型为StatelessElement，所以执行了StatelessElement的update方法。\n可以发现，在update方法中先是执行了super.update(newWidget)，也就是执行了Element的update方法，将newWidget赋值给旧Row中第二个Widget所关联的Element，换句话说，旧Row中第二个Widget所关联的Element持有了旧Row中第三个Widget。\n然后在update方法中还执行了rebuild方法，这会重建旧Row中第三个Widget，执行旧Row中第三个Widget的build方法。\nOK，我们回到这个if判断else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，最后执行了newChild = child，将旧Row中第二个Widget所关联的Element返回了。\n分析四：\n1 2 3 4 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; 把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，进入第三轮While循环判断。\n3.1.3.3、第三轮循环 第三轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为2，而oldChildrenBottom为2，newChildrenBottom为1，所以不满足While循环判断。\n3.1.4、分析第五部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 扫描列表中间的老孩子 // Scan the old children in the middle of the list. final bool haveOldChildren = oldChildrenTop \u0026lt;= oldChildrenBottom; Map\u0026lt;Key, Element\u0026gt;? oldKeyedChildren; if (haveOldChildren) { oldKeyedChildren = \u0026lt;Key, Element\u0026gt;{}; while (oldChildrenTop \u0026lt;= oldChildrenBottom) { final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); if (oldChild != null) { if (oldChild.widget.key != null) { oldKeyedChildren[oldChild.widget.key!] = oldChild; } else { deactivateChild(oldChild); } } oldChildrenTop += 1; } } 第五部分的工作原理是扫描列表中间的老孩子，也就是扫描oldChildrenTop与oldChildrenBottom之间的旧Widget所关联的Element。\n换句话说就是处理之前列表中间那些无法更新旧Widget为新Widget的Element，如果该Element之前关联的旧Widget传入了key，那么就会把该Element存入一个Map中，否则就会执行deactivateChild方法移除该Element。\n可以发现，有一个bool类型的局部变量haveOldChildren，它的判断条件是oldChildrenTop \u0026lt;= oldChildrenBottom，因为此时oldChildrenTop为2，oldChildrenBottom为2，那么haveOldChildren为true，满足if判断if (haveOldChildren)。\n然后执行While循环判断 while (oldChildrenTop \u0026lt;= oldChildrenBottom)，这里的While循环判断条件与haveOldChildren的判断条件一样的，所以满足While循环判断而进入循环体。\n在While循环体中，获取oldChild，此时的oldChild是旧Row中第三个子Widget所关联的Element。\n因为旧Row中所有子Widget都没有传入Key，并且旧Row中第三个子Widget所关联的Element在新Row中是找不到子Widget去关联的，所以执行deactivateChild方法把旧Row中第三个子Widget所关联的Element移除。\nOK，继续跟踪Element的updateChildren方法源码时，发现后面第六、七、八、九部分都不满足相应的判断条件，所以这几部分都没有执行到，这里就不分析了。\n3.1.5、分析第十部分 直接将newChildren返回，那么updateChildren方法就执行完毕了，意味着Row所关联的MultiChildRenderObjectElement也就更新了_children。\n该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例1中的疑问了：\n1、为什么日志打印是蓝色？ 因为旧Row中第二个子Widget所关联的Element，它对绿色块Widget的持有关系发生了变化，由最初持有了绿色块Widget变为持有了蓝色块Widget，并且触发了蓝色块Widget的build方法，所以日志打印是蓝色。\n2、为什么红色块自身的build方法不会触发？ 因为旧Row中第一个子Widget所关联的Element，它对红色块Widget的持有关系没有发生变化。\n3.2、分析示例2 与示例1中的颜色块StatelessBox不同，示例2中的颜色块StatefulBox是一个StatefulWidget，它的颜色值_color是在initState方法中初始化的。\n我们知道，Element的生命周期比Widget长，而State是在StatefulElement的构造方法中创建的，在此之后，StatefulElement与State便互相持有对方引用，所以State的生命周期也会比Widget长。\n这说明旧Row中子Widget所关联的Element，尽管它对Widget的持有关系发生了变化，也不会影响State中已初始化过的数据（这里指_color），除非State重新创建一个新实例。\n前面有了示例1的详细分析过程为基础，下面分析示例2时不会再从头开始分析，而是分析与示例1不同的部分。\n3.2.1、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 3.2.1.1、第二轮循环 在第二轮While循环中，执行了updateChild方法，此时第一个参数child为旧Row中第二个子Widget所关联的Element，第二个参数newWidget为新Row中的第二个Widget，也是旧Row中第三个子Widget。\n来看下第二轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } } return newChild; } 执行else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，因为Row的所有子Widget均没有传入Key，所以else if判断成立。\n然后执行child.update(newWidget)方法，又因为child的类型为StatefulElement，所以执行了StatefulElement的update方法。\n在StatefulElement的update方法中，一共做了4件事情：\n1、执行super.update(newWidget)，也就是执行了Element的update方法，将newWidget赋值给旧Row中第二个Widget所关联的Element，换句话说，旧Row中第二个Widget所关联的Element持有了旧Row中第三个Widget。\n2、执行state._widget = widget as StatefulWidget，旧Row中第二个Widget所关联的Element，它所持有的State也更新了_widget，也就是State持有了旧Row中第三个Widget。\n3、执行state.didUpdateWidget(oldWidget)，触发了State的didUpdateWidget方法，传入的实参也就是旧Row中第二个Widget。\n4、执行rebuild方法，触发了旧Row中第三个Widget的重建。\n示例2与示例1的不同之处已经讲完，该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例2中的疑问了：\n1、为什么删除的是蓝色块？ 因为旧Row中第二个子Widget所关联的Element，它对绿色块Widget的持有关系发生了变化，由最初持有了绿色块Widget变为持有了蓝色块Widget，并且触发了所关联State的build方法。但是因为该Element所关联的State中_color值一直为绿色没发生变化，所以当执行build方法时读取到的颜色值还是绿色，打印的日志也就为绿色了，这就导致了看起来像是删除了蓝色块。\n2、为什么日志打印是绿色？ 解释与问题1相同。\n3、为什么红色块自身的build方法不会触发？ 因为旧Row中第一个子Widget所关联的Element，它对红色块Widget的持有关系没有发生变化。\n那么，有什么修复办法吗？\n方法1 可以重写State的didUpdateWidget方法，然后对_color进行重新赋值，因为此时的State已经引用了蓝色块_widget。\n1 2 3 4 5 @override void didUpdateWidget(covariant StatefulBox oldWidget) { super.didUpdateWidget(oldWidget); _color = _getColor(widget.colorValue); } 方法2 也就是示例3中的给StatefulBox传入一个Key就行。\n3.3、分析示例3 前面有了示例1与示例2的详细分析过程为基础，下面分析示例3时不会再从头开始分析，而是分析与示例2不同的部分。\n3.3.1、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 3.3.1.1、第二轮循环 在第二轮While循环中，看下分析二这里的源码，此时oldChild为旧Row中第二个子Widget所关联的Element，newWidget为新Row中的第二个Widget，也是旧Row中第三个子Widget。\n执行if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))，因为oldChild不为null，所以看下if后半段Widget.canUpdate()。\n因为旧Row中所有子Widget均传入了Key，所以比较的就不止Widget的runtimeType了了，还需要比较key，很明显两者的runtimeType均为StatefulBox，那么剩下的就是比较两者的Key了， 此时oldChild.widget的Key为ValueKey(2)，newWidget的Key为ValueKey(3)。\n一般情况下，Key之间的==操作符是比较两者的引用，但是呢，ValueKey重写了==操作符，比较的是ValueKey构造方法传入的参数，相当于执行了equals()方法，看下ValueKey的这部分源码。\n1 2 3 4 5 6 7 8 9 // ValueKey @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ValueKey\u0026lt;T\u0026gt; \u0026amp;\u0026amp; other.value == value; } 当ValueKey(2)与ValueKey(3)比较时，很明显2 != 3，因此Widget.canUpdate()返回false，if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))条件成立，执行了break退出While循环。\n3.3.2、分析第四部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 扫描列表底部 // Scan the bottom of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析1 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]); final Widget newWidget = newWidgets[newChildrenBottom]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析2 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析3 oldChildrenBottom -= 1; newChildrenBottom -= 1; } 这个While循环的工作原理是扫描列表底部，也就是从旧Row中第3个子Widget所关联的Element与新Row中第二个子Widget开始往前遍历，判断新旧Widget是否同一个Widget（判断条件是Widget的runtimeType与key），如果不是则break退出该While循环，此时，newChildrenTop与oldChildrenTop恰好就记录了旧Row中子Widget所关联的Element不能够找到所关联的新Row中子Widget时的位置索引。\n否则，当旧Row中子Widget所关联的Element能够找到所关联的新Row中子Widget时，newChildrenTop与oldChildrenTop就会-1。\n3.3.2.1、第一轮循环 在分析第四部分中，此时oldChildrenTop与newChildrenTop均为1，oldChildrenBottom为2，newChildrenBottom为1，满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))进入循环体中。\n分析1：获取oldChild，它是旧Row中第三个Widget所关联的Element。获取newWidget，它是新Row中第二个Widget，也就是旧Row中第三个Widget。\n分析2：执行Widget.canUpdate()，此时oldChild.widget与newWidget所指的都是旧Row中第三个Widget，所以Widget.canUpdate()成立返回true，不会执行break跳出While循环。\n分析3：执行oldChildrenBottom -= 1与newChildrenBottom -= 1，此时oldChildrenTop与newChildrenTop均为1，oldChildrenBottom为1，newChildrenBottom为0。\n3.3.2.2、第二轮循环 在进入下一轮While循环时，不满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))。\n3.3.3、分析第五部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 扫描列表中间的老孩子 // Scan the old children in the middle of the list. final bool haveOldChildren = oldChildrenTop \u0026lt;= oldChildrenBottom; Map\u0026lt;Key, Element\u0026gt;? oldKeyedChildren; if (haveOldChildren) { oldKeyedChildren = \u0026lt;Key, Element\u0026gt;{}; while (oldChildrenTop \u0026lt;= oldChildrenBottom) { final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); if (oldChild != null) { if (oldChild.widget.key != null) { oldKeyedChildren[oldChild.widget.key!] = oldChild; } else { deactivateChild(oldChild); } } oldChildrenTop += 1; } } 3.3.3.1、第一轮循环 在分析第五部分中，此时oldChildrenTop与oldChildrenBottom均为1，所以haveOldChildren为true。\n执行while (oldChildrenTop \u0026lt;= oldChildrenBottom)，此处条件与haveOldChildren的条件相同，所以满足While判断的。\n然后获取oldChild，它是旧Row中第二个Widget所关联的Element。因为Row中所有子Widget都有传入Key，所以满足if (oldChild.widget.key != null)。\n这里是将旧Row中第二个Widget所关联的Element存入到了一个Map里。接着执行oldChildrenTop += 1，此时oldChildrenTop为2。\n3.3.3.2、第二轮循环 在进入下一轮While循环时，不满足while (oldChildrenTop \u0026lt;= oldChildrenBottom)。\n3.3.4、分析第七部分 1 2 3 4 // 我们已经扫描了整个列表 // We\u0026#39;ve scanned the whole list. newChildrenBottom = newWidgets.length - 1; oldChildrenBottom = oldChildren.length - 1; 整个列表的扫描工作完成后，重置newChildrenBottom与oldChildrenBottom，此时oldChildrenBottom为2，newChildrenBottom为1。\n3.3.5、分析第八部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 更新列表底部 // Update the bottom of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析1 final Element oldChild = oldChildren[oldChildrenTop]; assert(replaceWithNullIfForgotten(oldChild) != null); assert(oldChild._lifecycleState == _ElementLifecycle.active); final Widget newWidget = newWidgets[newChildrenTop]; assert(Widget.canUpdate(oldChild.widget, newWidget)); // 分析2 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); assert(oldChild == newChild || oldChild._lifecycleState != _ElementLifecycle.active); // 分析3 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 这个While循环的工作原理是从列表底部开始更新，也就是从旧Row中第三个子Widget所关联的Element与新Row中第二个子Widget开始往后遍历，更新Element所持有的旧Widget为新Widget，为什么能这么干呢？这时因为之前扫描列表底部时已经记录了旧Row中子Widget所关联的Element能够找到所关联的新Row中子Widget时的位置索引，该位置索引之后的Element均能更新旧Widget为新Widget。\n当Element更新旧Widget成功时，newChildrenTop与oldChildrenTop就会+1。\n3.3.5.1、第一轮循环 此时oldChildrenTop为2，newChildrenTop为1，oldChildrenBottom为2，newChildrenBottom为1。满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))进入循环体。\n分析1：获取oldChild，它是旧Row中第三个Widget所关联的Element。获取newWidget，它是新Row中第二个Widget，也就是旧Row中第三个Widget。\n分析2：执行Element的updateChild方法，下面是会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } } return newChild; } 因为比较的两者都是旧Row中第三个子Widget，所以满足if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，最后执行newChild = child把旧Row中第三个子Widget所关联的Element返回。\n分析四：把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，此时oldChildrenTop为3，newChildrenTop为2，oldChildrenBottom为2，newChildrenBottom为1。\n3.3.5.2、第二轮循环 在进入下一轮While循环时不满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))。\n3.3.6、分析第九部分 1 2 3 4 5 6 7 8 9 // 从旧列表中清除任何剩余的中间节点 // Clean up any of the remaining middle nodes from the old list. if (haveOldChildren \u0026amp;\u0026amp; oldKeyedChildren!.isNotEmpty) { for (final Element oldChild in oldKeyedChildren.values) { if (forgottenChildren == null || !forgottenChildren.contains(oldChild)) { deactivateChild(oldChild); } } } 这里的原理是遍历oldKeyedChildren这个Map，它是第五部分中扫描列表中间的老孩子得出的Map，除了传入GlobalKey的子Widget所关联的Element，其它一律移除，因为新Row中没有子Widget与之关联了。\n这里是把之前存入Map的旧Row中第二个Widget所关联的Element执行deactivateChild方法移除。\n3.3.7、分析第十部分 直接将newChildren返回，那么updateChildren方法就执行完毕了，意味着Row所关联的MultiChildRenderObjectElement也就更新了_children。\n示例3与示例2的不同之处已经讲完，该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例3中的疑问了：\n1、为什么在使用色块Widget时给它传入一个Key，程序运行效果相比示例2就又变得正常了？ 因为旧Row中子Widget所关联的Element，该Element是持有Widget引用的，可以根据Widget的Key去与新Row中子Widget的Key进行配对，如果Key配对成功，那么就会更新该Element所持有的Widget为新Row中子Widget。如果Key配对失败，并且该Widget没有设置GlobalKey，那么该Widget所关联的Element则会被移除。\n2、为什么点击FloatingActionButton按钮后无日志输出？ 因为Element根据Widget的Key来匹配更新Widget，Widget的引用是一直存在的，走的是if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，所以不会执行child.update(newWidget)，也就不会执行State的build方法，所以无日志输出。\n四、Key的分类 根据作用域的不同，可以将Key分为GlobalKey与LocalKey。LocalKey还可以进一步分为ValueKey、ObjectKey与UniqueKey。\n4.1、GlobalKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /// 在整个应用程序中唯一的key。 /// A key that is unique across the entire app. /// /// Global keys唯一标识elements。Global keys提供对与这些elements关联的其它对象的访问，例如 [BuildContext]。 /// 对于 [StatefulWidget]，global keys还提供对 [State] 的访问。 /// Global keys uniquely identify elements. Global keys provide access to other /// objects that are associated with those elements, such as [BuildContext]. /// For [StatefulWidget]s, global keys also provide access to [State]. /// /// 当具有global keys的Widgets从树中的一个位置移动到树中的另一位置时，它们会重新设置其子树的父级。 /// 为了重新设置其子树的父级，widget必须在其从树中旧位置删除的同一动画帧中到达其在树中的新位置。 /// Widgets that have global keys reparent their subtrees when they are moved /// from one location in the tree to another location in the tree. In order to /// reparent its subtree, a widget must arrive at its new location in the tree /// in the same animation frame in which it was removed from its old location in /// the tree. /// /// 使用global key重新设置 [Element] 的父级相对昂贵，因为此操作将触发对关联的 [State] 及其所有后代的 [State.deactivate] 调用；然后强制重建所有依赖于 [InheritedWidget] 的widgets。 /// Reparenting an [Element] using a global key is relatively expensive, as /// this operation will trigger a call to [State.deactivate] on the associated /// [State] and all of its descendants; then force all widgets that depends /// on an [InheritedWidget] to rebuild. /// /// 如果您不需要上面列出的任何功能，请考虑使用 [Key]、[ValueKey]、[ObjectKey] 或 [UniqueKey]。 /// If you don\u0026#39;t need any of the features listed above, consider using a [Key], /// [ValueKey], [ObjectKey], or [UniqueKey] instead. /// /// 您不能同时在树中包含具有相同global key的两个widgets。尝试这样做将在运行时断言。 /// You cannot simultaneously include two widgets in the tree with the same /// global key. Attempting to do so will assert at runtime. /// /// ## 陷阱 /// ## Pitfalls /// /// 不应在每次构建时重新创建 GlobalKeys。例如，它们通常应该是 [State] 对象拥有的长期对象。 /// GlobalKeys should not be re-created on every build. They should usually be /// long-lived objects owned by a [State] object, for example. /// /// 在每次构建时创建新的GlobalKey将丢弃与旧key关联的子树的状态，并为新key创建一个新的子树。 /// 除了损害性能之外，这还可能导致子树中的widgets出现意外行为。 /// 例如，子树中的 [GestureDetector] 将无法跟踪正在进行的手势，因为它将在每次构建时重新创建。 /// Creating a new GlobalKey on every build will throw away the state of the /// subtree associated with the old key and create a new fresh subtree for the /// new key. Besides harming performance, this can also cause unexpected /// behavior in widgets in the subtree. For example, a [GestureDetector] in the /// subtree will be unable to track ongoing gestures since it will be recreated /// on each build. /// /// 相反，一个好的做法是让 State 对象拥有 GlobalKey，并在 build 方法之外实例化它，例如在 [State.initState] 中。 /// Instead, a good practice is to let a State object own the GlobalKey, and /// instantiate it outside the build method, such as in [State.initState]. @optionalTypeArgs abstract class GlobalKey\u0026lt;T extends State\u0026lt;StatefulWidget\u0026gt;\u0026gt; extends Key { factory GlobalKey({ String? debugLabel }) =\u0026gt; LabeledGlobalKey\u0026lt;T\u0026gt;(debugLabel); const GlobalKey.constructor() : super.empty(); Element? get _currentElement =\u0026gt; WidgetsBinding.instance.buildOwner!._globalKeyRegistry[this]; /// 具有此key的widget在其中构建的build context。 /// The build context in which the widget with this key builds. /// /// 如果树中没有与此global key匹配的widget，则当前上下文为null。 /// The current context is null if there is no widget in the tree that matches /// this global key. BuildContext? get currentContext =\u0026gt; _currentElement; /// 树中当前具有此global key的widget。 /// The widget in the tree that currently has this global key. /// /// 如果树中没有与此global key匹配的widget，则当前widget为空。 /// The current widget is null if there is no widget in the tree that matches /// this global key. Widget? get currentWidget =\u0026gt; _currentElement?.widget; /// 树中当前具有此global key的widget的State /// The [State] for the widget in the tree that currently has this global key. /// /// 如果 (1) 树中没有与此global key匹配的widget，(2) 该widget不是 [StatefulWidget]，或者关联的 [State] 对象不是 `T` 的子类型，则当前state为null。 /// The current state is null if (1) there is no widget in the tree that /// matches this global key, (2) that widget is not a [StatefulWidget], or the /// associated [State] object is not a subtype of `T`. T? get currentState { final Element? element = _currentElement; if (element is StatefulElement) { final StatefulElement statefulElement = element; final State state = statefulElement.state; if (state is T) { return state; } } return null; } } 结合上面GlobalKey的注释以及源码，总结下GlobalKey的特性：\n1、GlobalKey是在整个应用程序中唯一的Key，也就是不能给多个Widget传入同一个GlobalKey实例。\n2、GlobalKey唯一标识Element。GlobalKey提供对与这些Element关联的其它对象的访问，例如currentContext、currentWidget与currentState。\n3、不应在每次构建时重新创建GlobalKey，而是在build方法之外实例化它。\n4、使用GlobalKey重新设置Element的父级相对昂贵，因为此操作将触发对关联的State及其所有后代的State.deactivate调用；然后强制重建所有依赖于InheritedWidget的Widget。\n5、\u0026hellip;\n看下GlobalKey在Flutter源码中的体现过程。\nGlobalKey注册与取消注册 在BuildOwner中有一个Map，用来存放GlobalKey与Element这样的键值对，并且提供了_registerGlobalKey与_unregisterGlobalKey方法对GlobalKey注册与取消注册。\n1 2 3 4 5 6 7 8 9 10 11 12 // BuildOwner final Map\u0026lt;GlobalKey, Element\u0026gt; _globalKeyRegistry = \u0026lt;GlobalKey, Element\u0026gt;{}; void _registerGlobalKey(GlobalKey key, Element element) { _globalKeyRegistry[key] = element; } void _unregisterGlobalKey(GlobalKey key, Element element) { if (_globalKeyRegistry[key] == element) { _globalKeyRegistry.remove(key); } } 那么，它是在哪执行GlobalKey注册与取消注册？\n可以看到，GlobalKey注册是在Element的mount方法中触发的，GlobalKey取消注册是在Element的unmount方法中触发的。\n重新将不活跃的Element合并到树中 在Element的inflateWidget方法中，一共做了3件事情：\n1、执行_retakeInactiveElement方法，通过GlobalKey重新获取不活跃的Element。\n在_retakeInactiveElement方法中，执行了parent.forgetChild，表示从Element的子级列表中删除给定的子级，为该子级在Element树中的其它位置重用做好准备。\n在前面讲Row时，它所关联的Element是MultiChildRenderObjectElement，在MultiChildRenderObjectElement的forgetChild方法中，会把当前不活跃的Element添加进_forgottenChildren中。\n1 2 3 4 5 6 7 @override void forgetChild(Element child) { assert(_children.contains(child)); assert(!_forgottenChildren.contains(child)); _forgottenChildren.add(child); super.forgetChild(child); } 在_retakeInactiveElement方法中，继续执行了parent.deactivateChild，将给定元素移动到非活动元素列表，并将其渲染对象从渲染树中分离。\n2、执行newChild._activateWithParent，让Element从“非活动”生命周期状态转换为“活动”生命周期状态，这里会执行Element的activate方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void _activateWithParent(Element parent, Object? newSlot) { assert(_lifecycleState == _ElementLifecycle.inactive); _parent = parent; _updateDepth(_parent!.depth); _activateRecursively(this); attachRenderObject(newSlot); assert(_lifecycleState == _ElementLifecycle.active); } static void _activateRecursively(Element element) { assert(element._lifecycleState == _ElementLifecycle.inactive); element.activate(); assert(element._lifecycleState == _ElementLifecycle.active); element.visitChildren(_activateRecursively); } 3、执行updateChild，更新Element对Widget的引用关系。\n到此，这个Element就复用完成。\n4.2、LocalKey 1 2 3 4 5 6 7 8 9 10 /// 不是 [GlobalKey] 的key。 /// A key that is not a [GlobalKey]. /// /// Keys在具有相同父级的 [Element] 中必须是唯一的。相比之下，[GlobalKey] 在整个应用程序中必须是唯一的。 /// Keys must be unique amongst the [Element]s with the same parent. By /// contrast, [GlobalKey]s must be unique across the entire app. abstract class LocalKey extends Key { const LocalKey() : super.empty(); } 结合上面LocalKey的注释以及源码，总结下LocalKey的特性：在同一级别的Widget中，LocalKey具有唯一性。\n4.2.1、ValueKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /// 使用特定类型的值来标识自身的key。 /// A key that uses a value of a particular type to identify itself. /// /// 当且仅当它们的值为 [operator==] 时，[ValueKey\u0026lt;T\u0026gt;] 才等于另一个 [ValueKey\u0026lt;T\u0026gt;]。 /// A [ValueKey\u0026lt;T\u0026gt;] is equal to another [ValueKey\u0026lt;T\u0026gt;] if, and only if, their /// values are [operator==]. /// /// 可以对此类进行子类化，以创建与碰巧使用相同值的其它value keys不同的value keys。 /// 如果子类是私有的，这会导致value key类型不能与其它源的keys发生冲突，这可能很有用，例如，如果这些keys被用作与另一个widget提供的keys相同范围内的后备。 /// This class can be subclassed to create value keys that will not be equal to /// other value keys that happen to use the same value. If the subclass is /// private, this results in a value key type that cannot collide with keys from /// other sources, which could be useful, for example, if the keys are being /// used as fallbacks in the same scope as keys supplied from another widget. class ValueKey\u0026lt;T\u0026gt; extends LocalKey { /// Creates a key that delegates its [operator==] to the given value. const ValueKey(this.value); /// The value to which this key delegates its [operator==] final T value; @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ValueKey\u0026lt;T\u0026gt; \u0026amp;\u0026amp; other.value == value; } @override int get hashCode =\u0026gt; Object.hash(runtimeType, value); @override String toString() { final String valueString = T == String ? \u0026#34;\u0026lt;\u0026#39;$value\u0026#39;\u0026gt;\u0026#34; : \u0026#39;\u0026lt;$value\u0026gt;\u0026#39;; // The crazy on the next line is a workaround for // https://github.com/dart-lang/sdk/issues/33297 if (runtimeType == _TypeLiteral\u0026lt;ValueKey\u0026lt;T\u0026gt;\u0026gt;().type) { return \u0026#39;[$valueString]\u0026#39;; } return \u0026#39;[$T $valueString]\u0026#39;; } } 之前讲过，ValueKey的==比较相当于equals()方法。\n4.2.2、ObjectKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 一个key，它从用作其值的对象中获取其标识。 /// A key that takes its identity from the object used as its value. /// /// 用于将widget的标识与用于生成该widget的对象的标识联系起来。 /// Used to tie the identity of a widget to the identity of an object used to /// generate that widget. class ObjectKey extends LocalKey { /// Creates a key that uses [identical] on [value] for its [operator==]. const ObjectKey(this.value); /// The object whose identity is used by this key\u0026#39;s [operator==]. final Object? value; @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ObjectKey \u0026amp;\u0026amp; identical(other.value, value); } @override int get hashCode =\u0026gt; Object.hash(runtimeType, identityHashCode(value)); @override String toString() { if (runtimeType == ObjectKey) { return \u0026#39;[${describeIdentity(value)}]\u0026#39;; } return \u0026#39;[${objectRuntimeType(this, \u0026#39;ObjectKey\u0026#39;)} ${describeIdentity(value)}]\u0026#39;; } } 与ValueKey不同，ObjectKey重写了==操作符，内部调用的是identical方法来比较，而identical方法是用来检查两个对象引用是否指向同一个对象，所以ObjectKey的==比较的是引用。\n4.2.3、UniqueKey 1 2 3 4 5 6 7 8 9 10 11 12 13 /// 一个只等于它本身的key。 /// A key that is only equal to itself. /// /// 这不能使用const构造函数创建，因为这意味着所有实例化的keys都是同一个实例，因此不是唯一的。 /// This cannot be created with a const constructor because that implies that /// all instantiated keys would be the same instance and therefore not be unique. class UniqueKey extends LocalKey { UniqueKey(); @override String toString() =\u0026gt; \u0026#39;[#${shortHash(this)}]\u0026#39;; } ","date":"2023-10-27T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bkey/","section":"post","tags":null,"title":"解读Flutter源码之Key"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文解读Flutter源码之StatefulWidget\u0026amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。\n因此，本文将会深入分析setState方法的源码。\n二、setState方法的特性 在分析setState源码之前，一起再回顾下setState方法的一些特性：\n1、setState方法用于通知框架该对象的内部状态已更改\n2、setState方法提供的回调是同步调用，它不能返回future（也就是不能用async），因为如果是异步调用的话，就会不清楚状态何时实际被设置\n3、通常，建议setState方法仅用于包装对状态的实际更改，而不是与更改相关的任何计算。例如，这里build方法使用的_counter被递增，然后更改被写入磁盘，但只有_counter++被包装在setState方法中。\n1 2 3 4 5 6 7 8 Future\u0026lt;void\u0026gt; _incrementCounter() async { setState(() { _counter++; }); Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package final String dirName = directory.path; await File(\u0026#39;$dirName/counter.txt\u0026#39;).writeAsString(\u0026#39;$_counter\u0026#39;); } 4、在框架调用dispose之后调用setState方法是错误的，可以通过检查mounted属性是否为true来判断调用该方法是否合法。\n三、分析setState方法的源码 setState方法在Flutter中属于用得比较频繁的一个方法，当页面UI状态需要发生改变时，调用setState方法就可以触发页面UI状态的更新，那么setState方法是如何做到的，一起看下它的源码：\n可以看到，在setState方法中，调用了外部传入的回调实例fn，类型为VoidCallback。疑问：为什么要将fn的返回值强转为Object？因为需要在断言中判断fn的返回值类型是否是Future，如果是则抛出异常。\n然后执行了_element的markNeedsBuild方法，这里的_element指的是当前State实例所持有的StatefulElement引用。当然了，StatefulElement与ComponentElement内部都没有markNeedsBuild方法，所以执行的是Element的markNeedsBuild方法。\n先看下markNeedsBuild方法的注释。\n1 2 3 4 5 6 7 8 9 /// 将element标记为脏并将其添加到widgets的全局列表中以在下一帧中重建 /// Marks the element as dirty and adds it to the global list of widgets to /// rebuild in the next frame. /// /// 由于在一帧中两次构建一个element是低效的，应用程序和widgets应该被构造为仅在帧开始之前的事件处理程序期间而不是在构建本身期间将widgets标记为脏。 /// Since it is inefficient to build an element twice in one frame, /// applications and widgets should be structured so as to only mark /// widgets dirty during event handlers before the frame begins, not during /// the build itself. 再看下markNeedsBuild方法的源码。\n在markNeedsBuild方法中，可以注意到有一个成员变量dirty，如果dirty为true则会return返回，之后的逻辑就不走了，先看下成员变量dirty的注释。\n1 2 3 4 5 6 7 8 9 /// 如果element已被标记为需要重建，则返回true。 /// Returns true if the element has been marked as needing rebuilding. /// /// 当element首次创建且调用markNeedsBuild之后，该标志为true。该标志在performRebuild实现中重置为false。 /// The flag is true when the element is first created and after /// [markNeedsBuild] has been called. The flag is reset to false in the /// [performRebuild] implementation. bool get dirty =\u0026gt; _dirty; bool _dirty = true; 从成员变量dirty的注释中可以知道，如果一个element已被标记为需要重建，_dirty就会在markNeedsBuild方法中被标记为true，当执行Element的performRebuild方法时，_dirty会重置为false。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// 导致widget自行更新。 /// Cause the widget to update itself. /// /// 进行适当的检查后由 [rebuild] 调用 /// Called by [rebuild] after the appropriate checks have been made. /// /// 基本实现仅清除dirty标志。 /// The base implementation only clears the [dirty] flag. @protected @mustCallSuper void performRebuild() { _dirty = false; } 我们知道，如果执行到了performRebuild方法，意味着即将执行State的build方法。因此，在执行performRebuild方法之前，连续调用多次setState方法，第二次之后其实都是多余的，因为此时dirty为true，return返回会忽略掉之后的逻辑，只有dirty为false时，调用setState方法才能触发页面UI状态的更新。\nOK，继续看下owner!.scheduleBuildFor(this)这行代码，执行的是BuildOwner的scheduleBuildFor方法，传入this，表示当前需要重建的element引用，那么这里的owner是在哪里创建的呢？\n1 2 3 4 5 /// 管理该element生命周期的对象 /// The object that manages the lifecycle of this element. @override BuildOwner? get owner =\u0026gt; _owner; BuildOwner? _owner; 关于BuildOwner的由来，在之前文章讲runApp分析中有提到，它是在七大binding之一WidgetsBinding的initInstances方法中进行BuildOwner初始化，执行的是BuildOwner构造方法。\n然后在WidgetsBinding的attachRootWidget方法中，将BuildOwner实例作为参数传入了刚创建的RenderObjectToWidgetAdapter实例的attachToRenderTree方法中。\n然后在RenderObjectToWidgetAdapter的attachToRenderTree方法中执行了createElement方法，创建了RenderObjectToWidgetElement实例，接着执行了该Element实例的assignOwner方法，传入了BuildOwner引用。\n因为RenderObjectToWidgetElement没有assignOwner方法，所以执行的是混入的RootElementMixin的assignOwner方法，然后将传入的BuildOwner引用赋值给RootElementMixin的父类Element的成员变量_owner，那么Element就持有了最初创建的BuildOwner引用。\n那么为什么Element的子类可以获取到BuildOwner引用？那是因为在Element的mount方法中，对成员变量_owner进行了重新赋值，实际上就是将最初创建的BuildOwner引用一层一层往下传递给Element的子类了，所以Element的子类可以获取到BuildOwner引用。\nOK，关于BuildOwner的由来已经知晓了，我们回到owner!.scheduleBuildFor(this)这行代码，这里执行了BuildOwner的scheduleBuildFor方法。\n在scheduleBuildFor方法中，涉及了四个变量：Element的成员变量_inDirtyList、BuildOwner的成员变量_dirtyElementsNeedsResorting、BuildOwner的成员变量_scheduledFlushDirtyElements、BuildOwner的成员变量_dirtyElements以及BuildOwner的成员变量onBuildScheduled，下面一一分析这五个变量。\nElement的成员变量_inDirtyList 1 2 3 4 // 这是否在owner._dirtyElements中。这用于知道当element重新激活时我们是否应该将其添加回列表中。 // Whether this is in owner._dirtyElements. This is used to know whether we // should be adding the element back into the list when it\u0026#39;s reactivated. bool _inDirtyList = false; 在scheduleBuildFor方法中，如果该Element已经在_dirtyElements列表中，那么直接return返回，后续的逻辑不再执行；\n在scheduleBuildFor方法中，如果该Element不在_dirtyElements列表中，那么将该Element放入到_dirtyElements列表中，然后将_inDirtyList赋值为true；\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），重新将所有Element的_inDirtyList赋值为false。\nBuildOwner的成员变量_dirtyElementsNeedsResorting 1 2 3 4 5 6 7 8 9 10 11 /// 由于在构建过程中更多elements变脏，_dirtyElements是否需要再次排序 /// Whether [_dirtyElements] need to be sorted again as a result of more /// elements becoming dirty during the build. /// /// 这对于保留Element._sort定义的排序顺序是必要的 /// This is necessary to preserve the sort order defined by [Element._sort]. /// /// 当buildScope未主动重建widget树时，该字段设置为null。 /// This field is set to null when [buildScope] is not actively rebuilding /// the widget tree. bool? _dirtyElementsNeedsResorting; 在scheduleBuildFor方法中，如果该Element已经在_dirtyElements列表中，那么_dirtyElementsNeedsResorting赋值为true，表明_dirtyElements中的Element需要再次排序；\n其它情况_dirtyElementsNeedsResorting为false，也就是不需要再次排序；\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），_dirtyElementsNeedsResorting会赋值为null。\nBuildOwner的成员变量_scheduledFlushDirtyElements _scheduledFlushDirtyElements用来控制是否触发onBuildScheduled回调，相当于控制了是否执行_dirtyElements列表中所有Element的重建。\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），_scheduledFlushDirtyElements会赋值为false。\nBuildOwner的成员变量_dirtyElements _dirtyElements列表用来添加需要重建的Element，后续会循环遍历该列表，执行所有Element的rebuild方法进行重建。\n一般情况下，在你的State中点击按钮调用setState方法时，就会把当前State所持有的Element添加进该列表。但是，按钮Widget点击事件后面可能还有它自身的setState，这样就会产生多个需要重建的Element，它们也会被添加进该列表，所以就需要对_dirtyElements进行depth深度排序。\nBuildOwner的成员变量onBuildScheduled 1 2 3 4 /// 当第一个可构建element被标记为脏时，在每个构建过程中调用 /// Called on each build pass when the first buildable element is marked /// dirty. VoidCallback? onBuildScheduled; onBuildScheduled回调的赋值是在WidgetsBinding的initInstances方法中，执行了WidgetsBinding的_handleBuildScheduled方法。\n在WidgetsBinding的_handleBuildScheduled方法中，执行了SchedulerBinding的ensureVisualUpdate方法。\n在SchedulerBinding的ensureVisualUpdate方法中，一开始schedulerPhase的状态为SchedulerPhase.idle，所以会执行scheduleFrame方法安排新帧，从注释可以知道，调用此方法可确保最终调用handleDrawFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// 如果该对象当前未生成帧，则使用 [scheduleFrame] 安排新帧。 /// Schedules a new frame using [scheduleFrame] if this object is not /// currently producing a frame. /// /// 调用此方法可确保最终调用 [handleDrawFrame]，除非它已经在进行中。 /// Calling this method ensures that [handleDrawFrame] will eventually be /// called, unless it\u0026#39;s already in progress. /// /// 如果 [schedulerPhase] 是 [SchedulerPhase.transientCallbacks] 或 [SchedulerPhase.midFrameMicrotasks]（因为在这种情况下已经准备好帧） /// 或 [SchedulerPhase.persistentCallbacks]（因为在这种情况下正在主动渲染帧），则这不起作用）。 /// 如果 [schedulerPhase] 是 [SchedulerPhase.idle]（在帧之间）或 [SchedulerPhase.postFrameCallbacks]（在帧之后），它将调度一个帧。 /// This has no effect if [schedulerPhase] is /// [SchedulerPhase.transientCallbacks] or [SchedulerPhase.midFrameMicrotasks] /// (because a frame is already being prepared in that case), or /// [SchedulerPhase.persistentCallbacks] (because a frame is actively being /// rendered in that case). It will schedule a frame if the [schedulerPhase] /// is [SchedulerPhase.idle] (in between frames) or /// [SchedulerPhase.postFrameCallbacks] (after a frame). void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } 看下SchedulerPhase的几种状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /// SchedulerBinding在SchedulerBinding.handleBeginFrame期间经历的各个阶段。 /// The various phases that a [SchedulerBinding] goes through during /// [SchedulerBinding.handleBeginFrame]. /// /// 这是由SchedulerBinding.schedulerPhase公开的 /// This is exposed by [SchedulerBinding.schedulerPhase]. /// /// 该枚举的值按照与阶段发生的顺序相同的顺序排序，因此可以将它们的相对索引值相互比较 /// The values of this enum are ordered in the same order as the phases occur, /// so their relative index values can be compared to each other. enum SchedulerPhase { /// 没有正在处理的帧。任务（由SchedulerBinding.scheduleTask调度）、微任务（由scheduleMicrotask调度）、 /// Timer回调、事件处理程序（例如，来自用户输入）和其它回调（例如，来自Future、 Stream等）可能正在执行。 /// No frame is being processed. Tasks (scheduled by /// [SchedulerBinding.scheduleTask]), microtasks (scheduled by /// [scheduleMicrotask]), [Timer] callbacks, event handlers (e.g. from user /// input), and other callbacks (e.g. from [Future]s, [Stream]s, and the like) /// may be executing. idle, /// 瞬态回调（由SchedulerBinding.scheduleFrameCallback调度）当前正在执行。 /// The transient callbacks (scheduled by /// [SchedulerBinding.scheduleFrameCallback]) are currently executing. /// /// 通常，这些回调处理将对象更新为新的动画状态 /// Typically, these callbacks handle updating objects to new animation /// states. /// /// See [SchedulerBinding.handleBeginFrame]. transientCallbacks, /// 当前正在执行处理瞬态回调期间安排的微任务。 /// Microtasks scheduled during the processing of transient callbacks are /// current executing. /// /// 例如，这可能包括来自在transientCallbacks阶段解析的future的回调 /// This may include, for instance, callbacks from futures resolved during the /// [transientCallbacks] phase. midFrameMicrotasks, /// 持久回调（由SchedulerBinding.addPersistentFrameCallback调度）当前正在执行 /// The persistent callbacks (scheduled by /// [SchedulerBinding.addPersistentFrameCallback]) are currently executing. /// /// 通常，这是构建/布局/绘制管道。 /// Typically, this is the build/layout/paint pipeline. See /// [WidgetsBinding.drawFrame] and [SchedulerBinding.handleDrawFrame]. persistentCallbacks, /// 帧后回调（由SchedulerBinding.addPostFrameCallback调度）当前正在执行 /// The post-frame callbacks (scheduled by /// [SchedulerBinding.addPostFrameCallback]) are currently executing. /// /// 通常，这些回调处理下一帧的清理和工作安排 /// Typically, these callbacks handle cleanup and scheduling of work for the /// next frame. /// /// See [SchedulerBinding.handleDrawFrame]. postFrameCallbacks, } 继续看下SchedulerBinding的scheduleFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// 如有必要，通过调用dart:ui.PlatformDispatcher.scheduleFrame来安排新帧。 /// If necessary, schedules a new frame by calling /// [dart:ui.PlatformDispatcher.scheduleFrame]. /// /// 调用此函数后，引擎将（最终）调用handleBeginFrame 。 （此调用可能会延迟，例如，如果设备的屏幕关闭，则通常会延迟，直到屏幕打开并且应用程序可见。） /// 在一个帧期间调用此函数会强制调度另一个帧，即使当前帧已尚未完成。 /// After this is called, the engine will (eventually) call /// [handleBeginFrame]. (This call might be delayed, e.g. if the device\u0026#39;s /// screen is turned off it will typically be delayed until the screen is on /// and the application is visible.) Calling this during a frame forces /// another frame to be scheduled, even if the current frame has not yet /// completed. /// /// 当操作系统提供的“Vsync”信号触发时，调度帧就会得到服务。 “Vsync”信号或垂直同步信号在历史上与显示器刷新相关，当时硬件在显示器更新之间物理地垂直移动电子束。 /// 现代硬件的操作在某种程度上更加微妙和复杂，但概念性的“Vsync”刷新信号继续用于指示应用程序何时应更新其渲染 /// Scheduled frames are serviced when triggered by a \u0026#34;Vsync\u0026#34; signal provided /// by the operating system. The \u0026#34;Vsync\u0026#34; signal, or vertical synchronization /// signal, was historically related to the display refresh, at a time when /// hardware physically moved a beam of electrons vertically between updates /// of the display. The operation of contemporary hardware is somewhat more /// subtle and complicated, but the conceptual \u0026#34;Vsync\u0026#34; refresh signal continue /// to be used to indicate when applications should update their rendering. 在SchedulerBinding的scheduleFrame方法中，做了两件事情：\n调用SchedulerBinding的ensureFrameCallbacksRegistered方法 注册了PlatformDispatcher.onBeginFrame与PlatformDispatcher.onDrawFrame两个回调。\n当Vsync信号到来时，onBeginFrame与onDrawFrame都会从Engine层回调，其中onBeginFrame主要用来处理动画相关，onDrawFrame主要用来处理页面构建、布局、绘制相关。\n本文只讲onDrawFrame回调后的逻辑。\n1 2 3 4 5 6 7 8 /// 确保PlatformDispatcher.onBeginFrame和PlatformDispatcher.onDrawFrame的回调已注册。 /// Ensures callbacks for [PlatformDispatcher.onBeginFrame] and /// [PlatformDispatcher.onDrawFrame] are registered. @protected void ensureFrameCallbacksRegistered() { platformDispatcher.onBeginFrame ??= _handleBeginFrame; platformDispatcher.onDrawFrame ??= _handleDrawFrame; } 执行platformDispatcher.scheduleFrame() 1 2 3 4 5 6 7 /// 请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调。 /// Requests that, at the next appropriate opportunity, the [onBeginFrame] and /// [onDrawFrame] callbacks be invoked. void scheduleFrame() =\u0026gt; _scheduleFrame(); @Native\u0026lt;Void Function()\u0026gt;(symbol: \u0026#39;PlatformConfigurationNativeApi::ScheduleFrame\u0026#39;) external static void _scheduleFrame(); 可以看到，platformDispatcher.scheduleFrame() 调用的是_scheduleFrame方法，它已经是底层方法了，这里就不深入底层实现了，不过可以猜测，在Android中应该是调用了Choreographer注册了Vysnc信号监听，然后再回调给Flutter，具体留给你们去验证了。\n等到Engine层处理完成，将会回调Framework层的_drawFrame方法，在_drawFrame方法中执行了PlatformDispatcher的_drawFrame方法。\n1 2 3 4 5 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart @pragma(\u0026#39;vm:entry-point\u0026#39;) void _drawFrame() { PlatformDispatcher.instance._drawFrame(); } 在PlatformDispatcher的_drawFrame方法中，执行了_invoke方法，第一个参数传入的是onDrawFrame回调，这个就是之前讲过的SchedulerBinding的ensureFrameCallbacksRegistered方法中注册的回调。\n1 2 3 4 // Called from the engine, via hooks.dart void _drawFrame() { _invoke(onDrawFrame, _onDrawFrameZone); } 来看下_invoke方法，执行了callback()，也就是调用了onDrawFrame的回调引用，那么就会触发SchedulerBinding的_handleDrawFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart /// Invokes [callback] inside the given [zone]. void _invoke(void Function()? callback, Zone zone) { if (callback == null) { return; } if (identical(zone, Zone.current)) { callback(); } else { zone.runGuarded(callback); } } 继续看SchedulerBinding的_handleDrawFrame方法，执行了handleDrawFrame方法。\n先看下handleDrawFrame方法的注释。\n1 2 3 4 5 6 7 8 /// 由引擎调用以产生新的帧 /// Called by the engine to produce a new frame. /// /// 该方法在handleBeginFrame之后立即调用。它调用addPersistentFrameCallback注册的所有回调（通常驱动渲染管道），然后调用addPostFrameCallback注册的回调 /// This method is called immediately after [handleBeginFrame]. It calls all /// the callbacks registered by [addPersistentFrameCallback], which typically /// drive the rendering pipeline, and then calls the callbacks registered by /// [addPostFrameCallback]. 再看下handleDrawFrame方法的源码，它会遍历_persistentCallbacks这个List，然后执行_invokeFrameCallback方法。\n在_invokeFrameCallback方法中，实际上是直接调用callback，也就是_persistentCallbacks中的FrameCallback。\n那么这些FrameCallback是在哪里被添加进_persistentCallbacks这个List？\n实际上是在RendererBinding的initInstances方法中执行了addPersistentFrameCallback方法添加进来，具体实现是_handlePersistentFrameCallback方法。\n在RendererBinding的_handlePersistentFrameCallback方法中，执行了drawFrame方法。\n1 2 3 4 void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); _scheduleMouseTrackerUpdate(); } RendererBinding的drawFrame方法被子类WidgetsBinding实现，在WidgetsBinding的drawFrame方法中，执行了buildOwner!.buildScope(rootElement!);。\n在BuildOwner的buildScope方法中，对_dirtyElements进行了depth深度排序，遍历过程中从depth深度值为最小的Element开始处理，也就是优先处理越接近根布局的Element，然后执行Element的rebuild方法完成Element的重建。\n在Element的rebuild方法中，后续执行了performRebuild方法，这个方法我们太熟悉了，之后的过程就不讲解了，最终会触发build方法的执行，完成相关Widget的重建。\n在WidgetsBinding的drawFrame方法中，执行了buildOwner!.buildScope(rootElement!)之后，就会执行super.drawFrame()，也就是调用父类RendererBinding的drawFrame方法。该方法意味着在重新构建渲染树之后就是真正的渲染开始了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /// 泵送渲染管道以生成帧 /// Pump the rendering pipeline to generate a frame. /// /// 该方法由handleDrawFrame调用，当需要布局和绘制框架时，该方法本身由引擎自动调用。 /// This method is called by [handleDrawFrame], which itself is called /// automatically by the engine when it is time to lay out and paint a frame. /// /// 每个帧由以下阶段组成： /// Each frame consists of the following phases: /// /// 1.动画阶段：在PlatformDispatcher.onBeginFrame中注册的handleBeginFrame方法按注册顺序调用在scheduleFrameCallback中注册的所有瞬态帧回调。 /// 这包括驱动AnimationController对象的所有Ticker实例，这意味着所有活动的Animation对象此时都会勾选。 /// 1. The animation phase: The [handleBeginFrame] method, which is registered /// with [PlatformDispatcher.onBeginFrame], invokes all the transient frame /// callbacks registered with [scheduleFrameCallback], in registration order. /// This includes all the [Ticker] instances that are driving /// [AnimationController] objects, which means all of the active [Animation] /// objects tick at this point. /// /// 2. 微任务：[handleBeginFrame] 返回后，由瞬态帧回调调度的任何微任务都会开始运行。 /// 这通常包括来自完成此帧的 [Ticker] 和 [AnimationController] 的 future 回调。 /// 2. Microtasks: After [handleBeginFrame] returns, any microtasks that got /// scheduled by transient frame callbacks get to run. This typically includes /// callbacks for futures from [Ticker]s and [AnimationController]s that /// completed this frame. /// /// 在 [handleBeginFrame] 之后，调用在 [dart:ui.PlatformDispatcher.onDrawFrame] 中注册的 [handleDrawFrame]， /// 它会调用所有持久帧回调，其中最值得注意的是这个方法 [drawFrame]，其执行过程如下如下： /// After [handleBeginFrame], [handleDrawFrame], which is registered with /// [dart:ui.PlatformDispatcher.onDrawFrame], is called, which invokes all the /// persistent frame callbacks, of which the most notable is this method, /// [drawFrame], which proceeds as follows: /// /// 3. 布局阶段：系统中所有脏的[RenderObject]都被布局 /// 3. The layout phase: All the dirty [RenderObject]s in the system are laid /// out (see [RenderObject.performLayout]). See [RenderObject.markNeedsLayout] /// for further details on marking an object dirty for layout. /// /// 4. 合成位阶段：更新任何脏 [RenderObject] 对象上的合成位。 /// 4. The compositing bits phase: The compositing bits on any dirty /// [RenderObject] objects are updated. See /// [RenderObject.markNeedsCompositingBitsUpdate]. /// /// 5. 绘制阶段：系统中所有脏的[RenderObject]都被重新绘制（参见[RenderObject.paint]）。这会生成[图层]树。 /// 5. The paint phase: All the dirty [RenderObject]s in the system are /// repainted (see [RenderObject.paint]). This generates the [Layer] tree. See /// [RenderObject.markNeedsPaint] for further details on marking an object /// dirty for paint. /// /// 6. 合成阶段：将图层树变成【场景】并发送到GPU。 /// 6. The compositing phase: The layer tree is turned into a [Scene] and /// sent to the GPU. /// /// 7. 语义阶段：系统中所有脏的[RenderObject]都更新了它们的语义。这会生成 [SemanticsNode] 树。 /// 7. The semantics phase: All the dirty [RenderObject]s in the system have /// their semantics updated. This generates the [SemanticsNode] tree. See /// [RenderObject.markNeedsSemanticsUpdate] for further details on marking an /// object dirty for semantics. /// /// For more details on steps 3-7, see [PipelineOwner]. /// /// 8. 最终确定阶段：[drawFrame] 返回后，[handleDrawFrame] 调用帧后回调（在 [addPostFrameCallback] 中注册）。 /// 8. The finalization phase: After [drawFrame] returns, [handleDrawFrame] /// then invokes post-frame callbacks (registered with [addPostFrameCallback]). /// /// 某些绑定（例如，[WidgetsBinding]）会向此列表添加额外的步骤（例如，请参阅[WidgetsBinding.drawFrame]）。 /// Some bindings (for example, the [WidgetsBinding]) add extra steps to this /// list (for example, see [WidgetsBinding.drawFrame]). // // When editing the above, also update widgets/binding.dart\u0026#39;s copy. @protected void drawFrame() { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } ","date":"2023-10-21T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/","section":"post","tags":null,"title":"解读Flutter源码之setState"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。\n因此，本文将会深入分析StatefulWidget的源码\u0026amp;State的生命周期。\n二、分析StatefulWidget源码 看一个类的源码，最先入手方向应该是它的注释，因为官方document也是通过代码注释生成的，所以先看下StatefulWidget的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 /// 一个具有可变状态的widget /// A widget that has mutable state. /// /// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。 /// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。 /// State is information that (1) can be read synchronously when the widget is /// built and (2) might change during the lifetime of the widget. It is the /// responsibility of the widget implementer to ensure that the [State] is /// promptly notified when such state changes, using [State.setState]. /// /// 一个stateful widget是“通过构建更具体地描述用户界面的其它widgets的一个星座”来描述用户界面的一部分的一个widget。 /// 构建过程递归地继续，直到用户界面的描述完全具体（例如，完全由 [RenderObjectWidget]s 组成，它描述具体的 [RenderObject]s）。 /// A stateful widget is a widget that describes part of the user interface by /// building a constellation of other widgets that describe the user interface /// more concretely. The building process continues recursively until the /// description of the user interface is fully concrete (e.g., consists /// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s). /// /// 当您描述的用户界面部分可以动态更改时，Stateful widgets非常有用，例如由于具有内部时钟驱动状态，或取决于某些系统状态。 /// 对于仅依赖于对象本身的配置信息和widget在其中填充的 [BuildContext] 的组合，请考虑使用 [StatelessWidget]。 /// Stateful widgets are useful when the part of the user interface you are /// describing can change dynamically, e.g. due to having an internal /// clock-driven state, or depending on some system state. For compositions that /// depend only on the configuration information in the object itself and the /// [BuildContext] in which the widget is inflated, consider using /// [StatelessWidget]. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=AqCMFXEmf3w} /// /// [StatefulWidget] 实例本身是不可变的，并将其可变状态存储在由 [createState] 方法创建的单独 [State] 对象中， /// 或者存储在 [State] 订阅的对象中，例如 [Stream] 或 [ChangeNotifier] 对象，其引用存储在 [StatefulWidget] 本身的final字段中。 /// [StatefulWidget] instances themselves are immutable and store their mutable /// state either in separate [State] objects that are created by the /// [createState] method, or in objects to which that [State] subscribes, for /// example [Stream] or [ChangeNotifier] objects, to which references are stored /// in final fields on the [StatefulWidget] itself. /// /// 每当框架填充 [StatefulWidget] 时，框架都会调用 [createState]，这意味着如果该widget已插入树中的多个位置，则多个 [State] 对象可能与同一个 [StatefulWidget] 关联。 /// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [createState] 来创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。 /// The framework calls [createState] whenever it inflates a /// [StatefulWidget], which means that multiple [State] objects might be /// associated with the same [StatefulWidget] if that widget has been inserted /// into the tree in multiple places. Similarly, if a [StatefulWidget] is /// removed from the tree and later inserted in to the tree again, the framework /// will call [createState] again to create a fresh [State] object, simplifying /// the lifecycle of [State] objects. /// /// 如果 [StatefulWidget] 的创建者使用 [GlobalKey] 作为其 [key]，那么当它从树中的一个位置移动到另一个位置时，[StatefulWidget] 会保留相同的 [State] 对象。 /// 由于具有 [GlobalKey] 的widget最多可在树中的一个位置使用，因此使用 [GlobalKey] 的widget最多具有一个关联element。 /// 当将具有全局键的widget从树中的一个位置移动到另一个位置时，框架利用此属性，将与该widget相关联的（唯一）子树从旧位置移植到新位置（而不是在新位置重新创建子树）。 /// 与 [StatefulWidget] 关联的 [State] 对象与子树的其余部分一起嫁接，这意味着 [State] 对象在新位置重用（而不是重新创建）。 /// 但是，为了符合嫁接的条件，必须将widget插入到从旧位置删除的同一动画帧中的新位置。 /// A [StatefulWidget] keeps the same [State] object when moving from one /// location in the tree to another if its creator used a [GlobalKey] for its /// [key]. Because a widget with a [GlobalKey] can be used in at most one /// location in the tree, a widget that uses a [GlobalKey] has at most one /// associated element. The framework takes advantage of this property when /// moving a widget with a global key from one location in the tree to another /// by grafting the (unique) subtree associated with that widget from the old /// location to the new location (instead of recreating the subtree at the new /// location). The [State] objects associated with [StatefulWidget] are grafted /// along with the rest of the subtree, which means the [State] object is reused /// (instead of being recreated) in the new location. However, in order to be /// eligible for grafting, the widget must be inserted into the new location in /// the same animation frame in which it was removed from the old location. /// /// 性能考虑 /// ## Performance considerations /// /// [StatefulWidget]s 有两个主要类别。 /// There are two primary categories of [StatefulWidget]s. /// /// 第一类是在[State.initState]中分配资源并在[State.dispose]中处理资源，但不依赖于[InheritedWidget]s或调用[State.setState]。 /// 此类widgets通常在应用程序或页面的根部使用，并通过 [ChangeNotifier]、[Stream] 或其它此类对象与子widget进行通信。 /// 遵循这种模式的Stateful widgets相对便宜（就 CPU 和 GPU 周期而言），因为它们构建一次就不再更新。因此，他们可以有一些复杂和深入的构建方法。 /// The first is one which allocates resources in [State.initState] and disposes /// of them in [State.dispose], but which does not depend on [InheritedWidget]s /// or call [State.setState]. Such widgets are commonly used at the root of an /// application or page, and communicate with subwidgets via [ChangeNotifier]s, /// [Stream]s, or other such objects. Stateful widgets following such a pattern /// are relatively cheap (in terms of CPU and GPU cycles), because they are /// built once then never update. They can, therefore, have somewhat complicated /// and deep build methods. /// /// 第二类是使用 [State.setState] 或依赖于 [InheritedWidget]s 的widget。 /// 这些通常会在应用程序的生命周期内重建多次，因此最小化重建此类widget的影响非常重要。 /// （它们也可以使用 [State.initState] 或 [State.didChangeDependency] 并分配资源，但重要的部分是它们重建。） /// The second category is widgets that use [State.setState] or depend on /// [InheritedWidget]s. These will typically rebuild many times during the /// application\u0026#39;s lifetime, and it is therefore important to minimize the impact /// of rebuilding such a widget. (They may also use [State.initState] or /// [State.didChangeDependencies] and allocate resources, but the important part /// is that they rebuild.) /// /// 有几种技术可以用来最小化重建stateful widget的影响： /// There are several techniques one can use to minimize the impact of /// rebuilding a stateful widget: /// /// * 将状态推送到叶子。 /// 例如，如果您的页面有一个滴答作响的时钟，则不要将状态放在页面顶部并在每次时钟滴答时重建整个页面，而是创建一个仅更新自身的专用时钟widget。 /// * Push the state to the leaves. For example, if your page has a ticking /// clock, rather than putting the state at the top of the page and /// rebuilding the entire page each time the clock ticks, create a dedicated /// clock widget that only updates itself. /// /// * 最小化由build方法及其创建的任何widgets传递创建的节点数量。 /// 理想情况下，stateful widget只会创建一个小部件，并且该widget将是一个 [RenderObjectWidget]。 （显然这并不总是实用，但是widget越接近这个理想，它的效率就越高。） /// * Minimize the number of nodes transitively created by the build method and /// any widgets it creates. Ideally, a stateful widget would only create a /// single widget, and that widget would be a [RenderObjectWidget]. /// (Obviously this isn\u0026#39;t always practical, but the closer a widget gets to /// this ideal, the more efficient it will be.) /// /// * 如果子树没有更改，则缓存代表该子树的widget，并在每次可以使用时重新使用它。 /// 为此，请将widget分配给“final”状态变量并在构建方法中重新使用它。 /// 重用widget比创建新的（但配置相同的）widget要高效得多。 /// 另一种缓存策略是将widget的可变部分提取到接受子参数的 [StatefulWidget] 中。 /// * If a subtree does not change, cache the widget that represents that /// subtree and re-use it each time it can be used. To do this, assign /// a widget to a `final` state variable and re-use it in the build method. It /// is massively more efficient for a widget to be re-used than for a new (but /// identically-configured) widget to be created. Another caching strategy /// consists in extracting the mutable part of the widget into a [StatefulWidget] /// which accepts a child parameter. /// /// * 尽可能使用“const” widget。 （这相当于缓存一个widget并重新使用它。） /// * Use `const` widgets where possible. (This is equivalent to caching a /// widget and re-using it.) /// /// * 避免更改任何创建的子树的深度或更改子树中任何widget的类型。 /// 例如，不要返回子控件或包装在[IgnorePointer]中的子控件，而是始终将子控件包装在[IgnorePointer]中并控制[IgnorePointer.ignoring]属性。 /// 这是因为更改子树的深度需要重新构建、布局和绘制整个子树，而仅更改属性将需要对渲染树进行最小可能的更改（例如，在[IgnorePointer]的情况下，根本不需要布局或重新绘制）。 /// * Avoid changing the depth of any created subtrees or changing the type of /// any widgets in the subtree. For example, rather than returning either the /// child or the child wrapped in an [IgnorePointer], always wrap the child /// widget in an [IgnorePointer] and control the [IgnorePointer.ignoring] /// property. This is because changing the depth of the subtree requires /// rebuilding, laying out, and painting the entire subtree, whereas just /// changing the property will require the least possible change to the /// render tree (in the case of [IgnorePointer], for example, no layout or /// repaint is necessary at all). /// /// * 如果由于某种原因必须更改深度，请考虑将子树的公共部分包装在具有 [GlobalKey] 的小部件中，该 [GlobalKey] 在stateful widget的生命周期中保持一致。 /// （如果没有其它widget可以方便地分配key，则 [KeyedSubtree] widget可能对此很有用。） /// * If the depth must be changed for some reason, consider wrapping the /// common parts of the subtrees in widgets that have a [GlobalKey] that /// remains consistent for the life of the stateful widget. (The /// [KeyedSubtree] widget may be useful for this purpose if no other widget /// can conveniently be assigned the key.) /// /// {@macro flutter.flutter.widgets.framework.prefer_const_over_helper} /// /// This video gives more explanations on why `const` constructors are important /// and why a [Widget] is better than a helper method. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo} /// /// For more details on the mechanics of rebuilding a widget, see /// the discussion at [Element.rebuild]. /// /// {@tool snippet} /// /// This is a skeleton of a stateful widget subclass called `YellowBird`. /// /// In this example, the [State] has no actual state. State is normally /// represented as private member fields. Also, normally widgets have more /// constructor arguments, each of which corresponds to a `final` property. /// /// ```dart /// class YellowBird extends StatefulWidget { /// const YellowBird({ super.key }); /// /// @override /// State\u0026lt;YellowBird\u0026gt; createState() =\u0026gt; _YellowBirdState(); /// } /// /// class _YellowBirdState extends State\u0026lt;YellowBird\u0026gt; { /// @override /// Widget build(BuildContext context) { /// return Container(color: const Color(0xFFFFE306)); /// } /// } /// ``` /// {@end-tool} /// {@tool snippet} /// /// This example shows the more generic widget `Bird` which can be given a /// color and a child, and which has some internal state with a method that /// can be called to mutate it: /// /// ```dart /// class Bird extends StatefulWidget { /// const Bird({ /// super.key, /// this.color = const Color(0xFFFFE306), /// this.child, /// }); /// /// final Color color; /// final Widget? child; /// /// @override /// State\u0026lt;Bird\u0026gt; createState() =\u0026gt; _BirdState(); /// } /// /// class _BirdState extends State\u0026lt;Bird\u0026gt; { /// double _size = 1.0; /// /// void grow() { /// setState(() { _size += 0.1; }); /// } /// /// @override /// Widget build(BuildContext context) { /// return Container( /// color: widget.color, /// transform: Matrix4.diagonal3Values(_size, _size, 1.0), /// child: widget.child, /// ); /// } /// } /// ``` /// {@end-tool} /// /// 按照惯例，widget构造函数仅使用命名参数。同样按照约定，第一个参数是 [key]，最后一个参数是 `child`、`children` 或等效参数。 /// By convention, widget constructors only use named arguments. Also by /// convention, the first argument is [key], and the last argument is `child`, /// `children`, or the equivalent. 可以看到，StatefulWidget的注释还是比较多的，这也恰恰反映了它的一个重要性，毕竟平时用它比较多。在StatefulWidget注释当中，它想尽可能地为API使用者讲明白StatefulWidget是什么，因此这不仅有常规的介绍，而且也有出于性能优化的一个考虑（目前来说，性能优化这块并不是本文的重点），以及最后还贴心地给出了使用示例，下面总结下StatefulWidget的特性：\n1、StatefulWidget实例本身是不可变的，它是将其可变状态存储在由createState方法创建的单独 State对象中。\n2、将StatefulWidget插入到树中的多个位置时，会创建多个单独的State实例；如果 StatefulWidget从树中删除，然后再次插入到树中，框架将再次调用createState来创建一个新的 State对象。\n3、StatefulWidget的实现者在状态更改时可以使用State.setState及时通知State。\n4、如果StatefulWidget的创建者使用GlobalKey作为其key，那么当它从树中的一个位置移动到另一个位置时，StatefulWidget会保留相同的State对象。\n5、\u0026hellip;\n这里给出了StatefulWidget的部分特性，主要是想让大家对StatefulWidget有一个初级认知，至于更多的特性需要从Flutter框架源码中去挖掘，这个任务留给个人自行去探索了。\nOK，我们继续看StatefulWidget的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 abstract class StatefulWidget extends Widget { const StatefulWidget({ super.key }); /// 创建一个StatefulElement来管理此widget在树中的位置 /// Creates a [StatefulElement] to manage this widget\u0026#39;s location in the tree. /// /// 子类重写此方法的情况并不常见。 /// It is uncommon for subclasses to override this method. @override StatefulElement createElement() =\u0026gt; StatefulElement(this); /// 在树中的给定位置为此widget创建可变状态 /// Creates the mutable state for this widget at a given location in the tree. /// /// 子类应该重写此方法以返回其关联State子类的新创建的实例： /// Subclasses should override this method to return a newly created /// instance of their associated [State] subclass: /// /// ```dart /// @override /// State\u0026lt;SomeWidget\u0026gt; createState() =\u0026gt; _SomeWidgetState(); /// ``` /// /// 框架可以在StatefulWidget的生命周期内多次调用此方法。例如，如果widget被插入树中的多个位置，框架将为每个位置创建一个单独的State对象。 /// 类似地，如果widget从树中删除，然后再次插入到树中，框架将再次调用createState来创建一个新的State对象，从而简化State对象的生命周期 /// The framework can call this method multiple times over the lifetime of /// a [StatefulWidget]. For example, if the widget is inserted into the tree /// in multiple locations, the framework will create a separate [State] object /// for each location. Similarly, if the widget is removed from the tree and /// later inserted into the tree again, the framework will call [createState] /// again to create a fresh [State] object, simplifying the lifecycle of /// [State] objects. @protected @factory State createState(); } 从StatefulWidget的源码可以知道，它继承自抽象类Widget，重写了createElement方法，返回一个StatefulElement实例，并且在Widget的基础上新增了一个createState抽象方法，用于返回一个State实例。\n这两个方法的功能从注释中也可以看的明明白白，关于StatefulWidget的分析先讲到这里。\n三、分析StatefulElement源码 先看下StatefulElement的注释。\n1 2 3 /// 使用 [StatefulWidget] 作为其配置的 [Element]。 /// An [Element] that uses a [StatefulWidget] as its configuration. class StatefulElement extends ComponentElement 可以看到，StatefulElement的注释非常简要，从注释中并不能看出该Element的特性所在，不过可以知道的是StatefulElement继承自ComponentElement，那么来看下ComponentElement的注释。\n1 2 3 4 5 6 7 8 9 10 /// 组成其它[Element]s的一个[Element]. /// An [Element] that composes other [Element]s. /// /// ComponentElement不是直接创建RenderObject ，而是通过创建其它Element来间接创建RenderObject /// Rather than creating a [RenderObject] directly, a [ComponentElement] creates /// [RenderObject]s indirectly by creating other [Element]s. /// /// 与RenderObjectElement对比 /// Contrast with [RenderObjectElement]. abstract class ComponentElement extends Element 可以看到，ComponentElement属于组合型Element，它不是直接创建RenderObject，而是通过创建其它Element来间接创建RenderObject，并且ComponentElement继承自Element，那么来看下Element的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /// 树中特定位置的 [Widget] 实例。 /// An instantiation of a [Widget] at a particular location in the tree. /// /// Widgets描述了如何配置子树，但同一个widget可用于同时配置多个子树，因为widgets是不可变的。 /// [Element]表示使用widget来配置树中的特定位置。 /// 随着时间的推移，与给定Element关联的widget可能会发生变化，例如，如果父widget重建并为此位置创建新的widget。 /// Widgets describe how to configure a subtree but the same widget can be used /// to configure multiple subtrees simultaneously because widgets are immutable. /// An [Element] represents the use of a widget to configure a specific location /// in the tree. Over time, the widget associated with a given element can /// change, for example, if the parent widget rebuilds and creates a new widget /// for this location. /// /// Elements形成一棵树。大多数elements都有一个唯一的子元素，但某些widgets（例如 [RenderObjectElement] 的子类）可以有多个子元素。 /// Elements form a tree. Most elements have a unique child, but some widgets /// (e.g., subclasses of [RenderObjectElement]) can have multiple children. /// /// Elements具有以下生命周期： /// Elements have the following lifecycle: /// /// * 框架通过在将用作element初始配置的widget上调用 [Widget.createElement] 来创建一个element。 /// * The framework creates an element by calling [Widget.createElement] on the /// widget that will be used as the element\u0026#39;s initial configuration. /// /// * 框架调用 [mount] 将新创建的element添加到给定父级中给定槽处的树中。 /// [mount] 方法负责填充任何子widgets，并根据需要调用 [attachRenderObject] 将任何关联的渲染对象附加到渲染树。 /// * The framework calls [mount] to add the newly created element to the tree /// at a given slot in a given parent. The [mount] method is responsible for /// inflating any child widgets and calling [attachRenderObject] as /// necessary to attach any associated render objects to the render tree. /// /// * 此时，该element被认为是“active”并且可能出现在屏幕上。 /// * At this point, the element is considered \u0026#34;active\u0026#34; and might appear on /// screen. /// /// * 在某些时候，父级可能决定更改用于配置此element的widget，例如因为父级使用新状态进行了重建。 /// 发生这种情况时，框架将使用新的widget调用 [update]。 /// 新的widget将始终具有与旧widget相同的 [runtimeType] 和键。 /// 如果父级希望更改树中此位置的widget的 [runtimeType] 或键，则可以通过卸载此element并在此位置填充新widget来实现。 /// * At some point, the parent might decide to change the widget used to /// configure this element, for example because the parent rebuilt with new /// state. When this happens, the framework will call [update] with the new /// widget. The new widget will always have the same [runtimeType] and key as /// old widget. If the parent wishes to change the [runtimeType] or key of /// the widget at this location in the tree, it can do so by unmounting this /// element and inflating the new widget at this location. /// /// * 在某些时候，祖先可能决定从树中删除此element（或中间祖先），祖先通过调用 [deactivateChild] 本身来完成此操作。 /// 停用中间祖先将从渲染树中删除该element的渲染对象，并将该element添加到 [owner] 的非活动element列表中，从而导致框架对此element调用 [deactivate]。 /// * At some point, an ancestor might decide to remove this element (or an /// intermediate ancestor) from the tree, which the ancestor does by calling /// [deactivateChild] on itself. Deactivating the intermediate ancestor will /// remove that element\u0026#39;s render object from the render tree and add this /// element to the [owner]\u0026#39;s list of inactive elements, causing the framework /// to call [deactivate] on this element. /// /// * 此时，该元素被视为“inactive”并且不会出现在屏幕上。 /// element只能保持inactive状态直到当前动画帧结束。 /// 在动画帧结束时，任何仍处于非活动状态的elements都将被卸载。 /// * At this point, the element is considered \u0026#34;inactive\u0026#34; and will not appear /// on screen. An element can remain in the inactive state only until /// the end of the current animation frame. At the end of the animation /// frame, any elements that are still inactive will be unmounted. /// /// * 如果该element被重新合并到树中（例如，因为它或其祖先之一具有可重用的global key）， /// 框架将从 [owner] 的非活动element列表中删除该element，对该element调用 [activate]，并将该element的渲染对象重新附加到渲染树。 /// （此时，该element再次被视为“active”并且可能出现在屏幕上。） /// * If the element gets reincorporated into the tree (e.g., because it or one /// of its ancestors has a global key that is reused), the framework will /// remove the element from the [owner]\u0026#39;s list of inactive elements, call /// [activate] on the element, and reattach the element\u0026#39;s render object to /// the render tree. (At this point, the element is again considered \u0026#34;active\u0026#34; /// and might appear on screen.) /// /// * 如果在当前动画帧结束时该element没有重新合并到树中，框架将对该element调用 [unmount]。 /// * If the element does not get reincorporated into the tree by the end of /// the current animation frame, the framework will call [unmount] on the /// element. /// /// * 此时，该element被视为“defunct”，并且将来不会合并到树中。 /// * At this point, the element is considered \u0026#34;defunct\u0026#34; and will not be /// incorporated into the tree in the future. 可以看到，Element的注释还是挺多的，大部分是描述了它的生命周期。\nOK，结合StatefulElement、ComponentElement以及Element三者的注释，总结一下StatefulElement的特性：\n1、StatefulWidget为StatefulElement提供配置，而StatefulElement则是树中特定位置的StatefulWidget实例。\n2、StatefulElement用来组成其它Element，是一种组合型的Element，StatefulElement不是直接创建RenderObject，而是通过创建其它Element来间接创建RenderObject。\n3、\u0026hellip;\n这里给出了StatefulElement的部分特性，余下的留给个人去探索。OK，继续看下StatefulElement的部分源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StatefulElement extends ComponentElement { /// Creates an element that uses the given widget as its configuration. StatefulElement(StatefulWidget widget) : _state = widget.createState(), super(widget) { assert(() { if (!state._debugTypesAreRight(widget)) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;StatefulWidget.createState must return a subtype of State\u0026lt;${widget.runtimeType}\u0026gt;\u0026#39;), ErrorDescription( \u0026#39;The createState function for ${widget.runtimeType} returned a state \u0026#39; \u0026#39;of type ${state.runtimeType}, which is not a subtype of \u0026#39; \u0026#39;State\u0026lt;${widget.runtimeType}\u0026gt;, violating the contract for createState.\u0026#39;, ), ]); } return true; }()); assert(state._element == null); state._element = this; assert( state._widget == null, \u0026#39;The createState function for $widget returned an old or invalid state \u0026#39; \u0026#39;instance: ${state._widget}, which is not null, violating the contract \u0026#39; \u0026#39;for createState.\u0026#39;, ); state._widget = widget; assert(state._debugLifecycleState == _StateLifecycle.created); } @override Widget build() =\u0026gt; state.build(this); /// The [State] instance associated with this location in the tree. /// /// There is a one-to-one relationship between [State] objects and the /// [StatefulElement] objects that hold them. The [State] objects are created /// by [StatefulElement] in [mount]. State\u0026lt;StatefulWidget\u0026gt; get state =\u0026gt; _state!; State\u0026lt;StatefulWidget\u0026gt;? _state; } 可以看到，在StatefulElement的构造方法中，它做了四件事情。\n执行_state = widget.createState()创建了State实例，并赋值给StatefulElement的成员变量_state，也就是说StatefulElement持有了State实例引用。 执行super(widget)调用父类ComponentElement的构造方法，然后一级一级往上传递this，也就是StatefulWidget本身引用，最后在Element的构造方法中赋值给它的成员变量_widget，说明Element会持有Widget的引用。 执行state._element = this;，将StatefulElement赋值给State的成员变量_element，说明State也持有了StatefulElement引用。 执行state._widget = widget;，将StatefulWidget赋值给State的成员变量_widget，说明State也持有了StatefulWidget引用。 OK，现在应该理清了StatefulWidget、StatefulElement以及State之间的关系。因此，可以得出以下结论：\nStatefulElement持有了State实例引用 StatefulElement持有了StatefulWidget实例引用 State又会反过来持有了StatefulWidget与StatefulElement的引用 StatefulWidget只是负责创建StatefulElement与State实例，并不持有它们 关于State的分析后面会讲到，在此之前，我们看下之前的一个runApp示例，补充之前没给出的StatefulWidget加载的一个执行流程图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void main() { _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MyPage(); } } class MyPage extends StatefulWidget { const MyPage({super.key}); @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return const ColoredBox(color: Colors.pinkAccent); } } StatefulWidget加载的一个执行流程图如下所示。\n四、分析State源码 遇事不决，直接找State的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /// [StatefulWidget] 的逻辑和内部状态 /// The logic and internal state for a [StatefulWidget]. /// /// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。 /// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。 /// State is information that (1) can be read synchronously when the widget is /// built and (2) might change during the lifetime of the widget. It is the /// responsibility of the widget implementer to ensure that the [State] is /// promptly notified when such state changes, using [State.setState]. /// /// [State] 对象是由框架在填充 [StatefulWidget] 并将其插入到树中时调用 [StatefulWidget.createState] 方法创建的。 /// 因为给定的 [StatefulWidget] 实例可以多次填充（例如，该widget一次在多个位置合并到树中），可能有多个 [State] 对象与给定的 [StatefulWidget] 实例关联。 /// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [StatefulWidget.createState] 以创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。 /// [State] objects are created by the framework by calling the /// [StatefulWidget.createState] method when inflating a [StatefulWidget] to /// insert it into the tree. Because a given [StatefulWidget] instance can be /// inflated multiple times (e.g., the widget is incorporated into the tree in /// multiple places at once), there might be more than one [State] object /// associated with a given [StatefulWidget] instance. Similarly, if a /// [StatefulWidget] is removed from the tree and later inserted in to the tree /// again, the framework will call [StatefulWidget.createState] again to create /// a fresh [State] object, simplifying the lifecycle of [State] objects. /// /// [State] 对象具有以下生命周期： /// [State] objects have the following lifecycle: /// /// * 框架通过调用 [StatefulWidget.createState] 创建一个 [State] 对象。 /// * The framework creates a [State] object by calling /// [StatefulWidget.createState]. /// /// * 新创建的 [State] 对象与 [BuildContext] 关联。 /// 这种关联是永久的：[State] 对象永远不会更改其 [BuildContext]。 /// 但是，[BuildContext] 本身可以与其子树一起在树中移动。此时，[State]对象就被认为是[mounted]。 /// * The newly created [State] object is associated with a [BuildContext]. /// This association is permanent: the [State] object will never change its /// [BuildContext]. However, the [BuildContext] itself can be moved around /// the tree along with its subtree. At this point, the [State] object is /// considered [mounted]. /// /// * 框架调用[initState]。[State]的子类应覆盖 [initState]去执行依赖于[BuildContext]或widget的一次性初始化，当调用[initState]方法时，它们分别作为[context]和[widget]属性可用。 /// * The framework calls [initState]. Subclasses of [State] should override /// [initState] to perform one-time initialization that depends on the /// [BuildContext] or the widget, which are available as the [context] and /// [widget] properties, respectively, when the [initState] method is /// called. /// /// * 框架调用[didChangeDependency]。 /// [State] 的子类应重写 [didChangeDependency] 以执行涉及 [InheritedWidget] 的初始化。 /// 如果调用 [BuildContext.dependOnInheritedWidgetOfExactType]，则如果inherited widgets随后发生更改或者widget在树中移动，则将再次调用 [didChangeDependency] 方法。 /// * The framework calls [didChangeDependencies]. Subclasses of [State] should /// override [didChangeDependencies] to perform initialization involving /// [InheritedWidget]s. If [BuildContext.dependOnInheritedWidgetOfExactType] is /// called, the [didChangeDependencies] method will be called again if the /// inherited widgets subsequently change or if the widget moves in the tree. /// /// * 此时，[State] 对象已完全初始化，框架可能会多次调用其 [build] 方法来获取此子树的用户界面的描述。 /// [State] 对象可以通过调用其 [setState] 方法自发请求重建其子树，这表明它们的某些内部状态已发生变化，可能会影响该子树中的用户界面。 /// * At this point, the [State] object is fully initialized and the framework /// might call its [build] method any number of times to obtain a /// description of the user interface for this subtree. [State] objects can /// spontaneously request to rebuild their subtree by calling their /// [setState] method, which indicates that some of their internal state /// has changed in a way that might impact the user interface in this /// subtree. /// /// * 在此期间，父widget可能会重建并请求更新树中的此位置以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget。 /// 发生这种情况时，框架将更新 [widget] 属性以引用新的widget，然后使用先前的widget作为参数调用 [didUpdateWidget] 方法。 /// [State] 对象应覆盖 [didUpdateWidget] 以响应其关联widget中的更改（例如，启动隐式动画）。 /// 框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。 /// * During this time, a parent widget might rebuild and request that this /// location in the tree update to display a new widget with the same /// [runtimeType] and [Widget.key]. When this happens, the framework will /// update the [widget] property to refer to the new widget and then call the /// [didUpdateWidget] method with the previous widget as an argument. [State] /// objects should override [didUpdateWidget] to respond to changes in their /// associated widget (e.g., to start implicit animations). The framework /// always calls [build] after calling [didUpdateWidget], which means any /// calls to [setState] in [didUpdateWidget] are redundant. (See alse the /// discussion at [Element.rebuild].) /// /// * 在开发过程中，如果发生热重载（无论是通过按“r”从命令行“flutter”工具启动，还是从 IDE 启动），都会调用 [reassemble] 方法。 /// 这提供了重新初始化在 [initState] 方法中准备的任何数据的机会。 /// * During development, if a hot reload occurs (whether initiated from the /// command line `flutter` tool by pressing `r`, or from an IDE), the /// [reassemble] method is called. This provides an opportunity to /// reinitialize any data that was prepared in the [initState] method. /// /// * 如果包含 [State] 对象的子树从树中删除（例如，因为父级使用不同的 [runtimeType] 或 [Widget.key] 构建了一个widget），则框架调用 [deactivate] 方法。 /// 子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。 /// * If the subtree containing the [State] object is removed from the tree /// (e.g., because the parent built a widget with a different [runtimeType] /// or [Widget.key]), the framework calls the [deactivate] method. Subclasses /// should override this method to clean up any links between this object /// and other elements in the tree (e.g. if you have provided an ancestor /// with a pointer to a descendant\u0026#39;s [RenderObject]). /// /// * 此时，框架可能会将该子树重新插入到树的另一部分中。 /// 如果发生这种情况，框架将确保调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。 /// 如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。 /// 因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。 /// * At this point, the framework might reinsert this subtree into another /// part of the tree. If that happens, the framework will ensure that it /// calls [build] to give the [State] object a chance to adapt to its new /// location in the tree. If the framework does reinsert this subtree, it /// will do so before the end of the animation frame in which the subtree was /// removed from the tree. For this reason, [State] objects can defer /// releasing most resources until the framework calls their [dispose] /// method. /// /// * 如果框架在当前动画帧结束时没有重新插入此子树，框架将调用 [dispose]，这表明此 [State] 对象将永远不会再次构建。 /// 子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。 /// * If the framework does not reinsert this subtree by the end of the current /// animation frame, the framework will call [dispose], which indicates that /// this [State] object will never build again. Subclasses should override /// this method to release any resources retained by this object (e.g., /// stop any active animations). /// /// * 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。 /// 此时调用[setState]是错误的。生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。 /// * After the framework calls [dispose], the [State] object is considered /// unmounted and the [mounted] property is false. It is an error to call /// [setState] at this point. This stage of the lifecycle is terminal: there /// is no way to remount a [State] object that has been disposed. 对于State，要关注的重点是它的生命周期，这点从注释中对State生命周期的大量描述也可以看出，这里总结下State生命周期的特性：\n1、框架通过调用StatefulWidget.createState创建一个State对象，新创建的State对象与BuildContext关联。\n2、State的子类可以覆盖initState方法去执行一次性初始化，此时context和widget属性可用。\n3、State的子类可以重写didChangeDependency以执行涉及InheritedWidget的初始化。\n4、State对象完全初始化后，可以通过调用其setState方法自发请求重建其子树。\n5、如果父widget重建并请求更新树中的此位置以显示具有相同runtimeType和Widget.key的新widget，框架将更新widget属性以引用新的widget，然后使用先前的widget作为参数调用didUpdateWidget方法，State的子类可以覆盖didUpdateWidget方法以响应其关联widget中的更改。\n6、在开发过程中，如果发生热重载会调用reassemble方法。\n7、如果包含State对象的子树从树中删除，那么会调用deactivate方法，State的子类可以覆盖deactivate方法做一些清除Element链接的操作。\n8、如果框架在当前动画帧结束时没有重新插入此子树，框架将调用dispose，这表明此State对象将永远不会再次构建。\n9、框架调用dispose后，State对象被视为已卸载，并且mounted属性为false。\n10、\u0026hellip;\n这里给出了State生命周期的部分特性，余下的留给个人去探索。OK，继续看下State生命周期相关方法的源码。\n4.1、initState方法 看下initState方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /// 当该对象插入到树中时调用。 /// Called when this object is inserted into the tree. /// /// 框架将为它创建的每个 [State] 对象调用此方法一次。 /// The framework will call this method exactly once for each [State] object /// it creates. /// /// 重写此方法以执行初始化，该初始化取决于此对象插入树中的位置（即 [context]）或用于配置此对象的widget（即 [widget]）。 /// Override this method to perform initialization that depends on the /// location at which this object was inserted into the tree (i.e., [context]) /// or on the widget used to configure this object (i.e., [widget]). /// /// {@template flutter.widgets.State.initState} /// 如果 [State] 的 [build] 方法依赖于一个本身可以更改状态的对象，例如 [ChangeNotifier] 或 [Stream]，或者可以订阅接收通知的其它对象， /// 那么请务必订阅并在 [initState]、[didUpdateWidget] 和 [dispose] 中正确取消订阅： /// If a [State]\u0026#39;s [build] method depends on an object that can itself /// change state, for example a [ChangeNotifier] or [Stream], or some /// other object to which one can subscribe to receive notifications, then /// be sure to subscribe and unsubscribe properly in [initState], /// [didUpdateWidget], and [dispose]: /// /// * 在[initState]中，订阅该对象。 /// * In [initState], subscribe to the object. /// * 在 [didUpdateWidget] 中，如果更新的小部件配置需要替换对象，则取消订阅旧对象并订阅新对象。 /// * In [didUpdateWidget] unsubscribe from the old object and subscribe /// to the new one if the updated widget configuration requires /// replacing the object. /// * 在[dispose]中，取消订阅该对象。 /// * In [dispose], unsubscribe from the object. /// /// {@endtemplate} /// /// 您不能从此方法中使用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// 但是，在此方法之后将立即调用 [didChangeDependency]，并且可以在此处使用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// You cannot use [BuildContext.dependOnInheritedWidgetOfExactType] from this /// method. However, [didChangeDependencies] will be called immediately /// following this method, and [BuildContext.dependOnInheritedWidgetOfExactType] can /// be used there. /// /// 该方法的实现应该从调用继承的方法开始，如“super.initState()”。 /// Implementations of this method should start with a call to the inherited /// method, as in `super.initState()`. @protected @mustCallSuper void initState() { // 启用断言时跟踪 [State] 对象的生命周期。 // 该状态表明[State] 对象已创建。此时会调用[State.initState]。 assert(_debugLifecycleState == _StateLifecycle.created); if (kFlutterMemoryAllocationsEnabled) { MemoryAllocations.instance.dispatchObjectCreated( library: _flutterWidgetsLibrary, className: \u0026#39;$State\u0026#39;, object: this, ); } } 关于initState方法的说明都在注释中了，那框架在什么地方触发的initState方法呢？\n调用了ComponentElement的mount方法，在mount方法中又调用了_firstBuild方法。\n_firstBuild方法被子类StatefulElement重写了，并且在该方法中调用了initState方法。\n最后附上initState方法的执行流程图。\n4.2、didChangeDependencies方法 看下didChangeDependencies方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// 当此 [State] 对象的依赖项发生更改时调用。 /// Called when a dependency of this [State] object changes. /// /// 例如，如果先前对 [build] 的调用引用了后来更改的 [InheritedWidget]，则框架将调用此方法来通知此对象有关更改的信息。 /// For example, if the previous call to [build] referenced an /// [InheritedWidget] that later changed, the framework would call this /// method to notify this object about the change. /// /// 该方法也会在 [initState] 之后立即调用。从此方法调用 [BuildContext.dependOnInheritedWidgetOfExactType] 是安全的。 /// This method is also called immediately after [initState]. It is safe to /// call [BuildContext.dependOnInheritedWidgetOfExactType] from this method. /// /// 子类很少重写此方法，因为框架总是在依赖项更改后调用 [build]。 /// 某些子类确实会重写此方法，因为当它们的依赖项发生变化时，它们需要执行一些昂贵的工作（例如，网络获取），而对于每个构建来说，这些工作都太昂贵了。 /// Subclasses rarely override this method because the framework always /// calls [build] after a dependency changes. Some subclasses do override /// this method because they need to do some expensive work (e.g., network /// fetches) when their dependencies change, and that work would be too /// expensive to do for every build. @protected @mustCallSuper void didChangeDependencies() { } 关于didChangeDependencies方法的说明都在注释中了，那框架在什么地方触发的didChangeDependencies方法呢？\n调用了ComponentElement的mount方法，在mount方法中又调用了_firstBuild方法。\n_firstBuild方法被子类StatefulElement重写了，并且在该方法中调用了initState方法，随后又调用了didChangeDependencies方法，最后执行super._firstBuild()，也就是调用ComponentElement的_firstBuild方法。\n在ComponentElement的_firstBuild方法中，执行了rebuild方法。\n在rebuild方法中又会调用performRebuild方法，该方法被子类StatefulElement和ComponentElement重写了，这里我们看StatefulElement重写的performRebuild方法，可以看到执行了didChangeDependencies方法。\n最后附上didChangeDependencies方法的执行流程图。\n4.3、build方法 看下build方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 /// 描述此widget代表的用户界面部分。 /// Describes the part of the user interface represented by this widget. /// /// 框架在许多不同的情况下调用此方法。例如： /// The framework calls this method in a number of different situations. For /// example: /// /// * 在调用 [initState] 之后 /// * After calling [initState]. /// * 在调用 [didUpdateWidget] 之后 /// * After calling [didUpdateWidget]. /// * 在收到对 [setState] 的调用之后。 /// * After receiving a call to [setState]. /// * 此 [State] 对象的依赖项更改后（例如，先前 [build] 更改引用的 [InheritedWidget]）。 /// * After a dependency of this [State] object changes (e.g., an /// [InheritedWidget] referenced by the previous [build] changes). /// * 调用 [deactivate] 后，然后将 [State] 对象重新插入到树中的另一个位置。 /// * After calling [deactivate] and then reinserting the [State] object into /// the tree at another location. /// /// 该方法可以在每个帧中调用，并且除了构建widget之外不应该有任何副作用。 /// This method can potentially be called in every frame and should not have /// any side effects beyond building a widget. /// /// 框架将此widget下面的子树替换为此方法返回的widget，方法是更新现有子树或删除子树并填充新子树， /// 具体取决于此方法返回的widget是否可以更新现有子树的根，通过调用 [Widget.canUpdate] 确定。 /// The framework replaces the subtree below this widget with the widget /// returned by this method, either by updating the existing subtree or by /// removing the subtree and inflating a new subtree, depending on whether the /// widget returned by this method can update the root of the existing /// subtree, as determined by calling [Widget.canUpdate]. /// /// 通常，实现会返回新创建的widgets星座，这些widgets配置有来自该widget的构造函数、给定的 [BuildContext] 和此 [State] 对象的内部状态的信息。 /// Typically implementations return a newly created constellation of widgets /// that are configured with information from this widget\u0026#39;s constructor, the /// given [BuildContext], and the internal state of this [State] object. /// /// 给定的 [BuildContext] 包含有关在树中构建此小部件的位置的信息。 /// 例如，上下文为树中的该位置提供一组inherited widgets。 /// [BuildContext] 参数始终与此 [State] 对象的 [context] 属性相同，并且在此对象的生命周期内保持不变。 /// 此处冗余地提供了 [BuildContext] 参数，以便此方法与 [WidgetBuilder] 的签名匹配。 /// The given [BuildContext] contains information about the location in the /// tree at which this widget is being built. For example, the context /// provides the set of inherited widgets for this location in the tree. The /// [BuildContext] argument is always the same as the [context] property of /// this [State] object and will remain the same for the lifetime of this /// object. The [BuildContext] argument is provided redundantly here so that /// this method matches the signature for a [WidgetBuilder]. /// /// 设计讨论 /// ## Design discussion /// /// 为什么 [build] 方法在 [State] 上，而不是在 [StatefulWidget] 上？ /// ### Why is the [build] method on [State], and not [StatefulWidget]? /// /// 将 `Widget build(BuildContext context)` 方法放在 [State] 上， /// 而不是将 `Widget build(BuildContext context, State state)` 方法放在 [StatefulWidget] 上， /// 可以为开发人员在子类化 [StatefulWidget] 时提供更大的灵活性。 /// Putting a `Widget build(BuildContext context)` method on [State] rather /// than putting a `Widget build(BuildContext context, State state)` method /// on [StatefulWidget] gives developers more flexibility when subclassing /// [StatefulWidget]. /// /// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。 /// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。 /// For example, [AnimatedWidget] is a subclass of [StatefulWidget] that /// introduces an abstract `Widget build(BuildContext context)` method for its /// subclasses to implement. If [StatefulWidget] already had a [build] method /// that took a [State] argument, [AnimatedWidget] would be forced to provide /// its [State] object to subclasses even though its [State] object is an /// internal implementation detail of [AnimatedWidget]. /// /// 从概念上讲，[StatelessWidget] 也可以以类似的方式实现为 [StatefulWidget] 的子类。 /// 如果 [build] 方法位于 [StatefulWidget] 而不是 [State]，那么这将不再可能。 /// Conceptually, [StatelessWidget] could also be implemented as a subclass of /// [StatefulWidget] in a similar manner. If the [build] method were on /// [StatefulWidget] rather than [State], that would not be possible anymore. /// /// 将 [build] 函数放在 [State] 而不是 [StatefulWidget] 上也有助于避免与隐式捕获 `this` 的闭包相关的一类错误。 /// 如果您在 [StatefulWidget] 上的 [build] 函数中定义了一个闭包， /// 则该闭包将隐式捕获“this”，即当前的widget实例，并且在范围内具有该实例的（不可变）字段： /// Putting the [build] function on [State] rather than [StatefulWidget] also /// helps avoid a category of bugs related to closures implicitly capturing /// `this`. If you defined a closure in a [build] function on a /// [StatefulWidget], that closure would implicitly capture `this`, which is /// the current widget instance, and would have the (immutable) fields of that /// instance in scope: /// /// ```dart /// // (this is not valid Flutter code) /// class MyButton extends StatefulWidgetX { /// MyButton({super.key, required this.color}); /// /// final Color color; /// /// @override /// Widget build(BuildContext context, State state) { /// return SpecialWidget( /// handler: () { print(\u0026#39;color: $color\u0026#39;); }, /// ); /// } /// } /// ``` /// /// 例如，假设父级构建“MyButton”时“color”为蓝色，则 print 函数中的“color”指的是蓝色，正如预期的那样。 /// 现在，假设父级用绿色重建“MyButton”。 /// 第一次构建创建的闭包仍然隐式引用原始widget，并且“颜色”仍然打印蓝色， /// 即使widget已更新为绿色；如果该闭包比它的widget寿命更长，它会打印过时的信息。 /// For example, suppose the parent builds `MyButton` with `color` being blue, /// the `$color` in the print function refers to blue, as expected. Now, /// suppose the parent rebuilds `MyButton` with green. The closure created by /// the first build still implicitly refers to the original widget and the /// `$color` still prints blue even through the widget has been updated to /// green; should that closure outlive its widget, it would print outdated /// information. /// /// 相反，使用 [State] 对象上的 [build] 函数，在 [build] 期间创建的闭包隐式捕获 [State] 实例而不是 widget 实例： /// In contrast, with the [build] function on the [State] object, closures /// created during [build] implicitly capture the [State] instance instead of /// the widget instance: /// /// ```dart /// class MyButton extends StatefulWidget { /// const MyButton({super.key, this.color = Colors.teal}); /// /// final Color color; /// // ... /// } /// /// class MyButtonState extends State\u0026lt;MyButton\u0026gt; { /// // ... /// @override /// Widget build(BuildContext context) { /// return SpecialWidget( /// handler: () { print(\u0026#39;color: ${widget.color}\u0026#39;); }, /// ); /// } /// } /// ``` /// /// 现在，当父级用绿色重建“MyButton”时，第一个构建创建的闭包仍然引用 [State] 对象，该对象在重建过程中保留， /// 但框架已更新 [State] 对象的 [widget] 属性以引用新的 `MyButton` 实例，并且 `{widget.color}` 按预期打印绿色。 /// Now when the parent rebuilds `MyButton` with green, the closure created by /// the first build still refers to [State] object, which is preserved across /// rebuilds, but the framework has updated that [State] object\u0026#39;s [widget] /// property to refer to the new `MyButton` instance and `${widget.color}` /// prints green, as expected. /// /// See also: /// /// * [StatefulWidget], which contains the discussion on performance considerations. @protected Widget build(BuildContext context); 关于build方法的说明都在注释中了，那框架在什么地方触发的build方法呢？\n在调用initState方法之后 在调用didUpdateWidget方法之后 在调用setState方法之后。 此State对象的依赖项更改后（例如，先前build更改引用的InheritedWidget）。 调用deactivate后，然后将State对象重新插入到树中的另一个位置。 关于build方法的各个触发条件，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。\n4.4、didUpdateWidget方法 看下didUpdateWidget方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// 每当widget配置更改时调用。 /// Called whenever the widget configuration changes. /// /// 如果父widget重建并请求树中的此位置更新以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget， /// 框架将更新此 [State] 对象的 [widget] 属性以引用新的widget，然后使用前一个widget作为参数调用此方法。 /// If the parent widget rebuilds and requests that this location in the tree /// update to display a new widget with the same [runtimeType] and /// [Widget.key], the framework will update the [widget] property of this /// [State] object to refer to the new widget and then call this method /// with the previous widget as an argument. /// /// 重写此方法以在 [widget] 更改时做出响应（例如，启动隐式动画）。 /// Override this method to respond when the [widget] changes (e.g., to start /// implicit animations). /// /// 框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。 /// The framework always calls [build] after calling [didUpdateWidget], which /// means any calls to [setState] in [didUpdateWidget] are redundant. /// /// {@macro flutter.widgets.State.initState} /// /// 该方法的实现应该从调用继承的方法开始，如“super.didUpdateWidget(oldWidget)”。 /// Implementations of this method should start with a call to the inherited /// method, as in `super.didUpdateWidget(oldWidget)`. @mustCallSuper @protected void didUpdateWidget(covariant T oldWidget) { } 关于didUpdateWidget方法的说明都在注释中了，那框架在什么地方触发的didUpdateWidget方法呢？\n当Widget通过build方法构建后，就会执行Element的updateChild方法，然后将该Widget的引用作为第二个参数newWidget传入到updateChild方法中。\n然后通过Widget的canUpdate方法判断newWidget是否可用于更新当前将oldWidget作为其配置的Element。\n如果canUpdate方法返回true，就会执行child.update(newWidget)，也就是执行Element的update方法。该方法被子类StatefulElement重写了，所以看下StatefulElement的update方法。\n可以看到，StatefulElement的update方法中执行了State的didUpdateWidget方法，这里就不附上didUpdateWidget方法的执行流程图了。\n4.5、deactivate方法 看下deactivate方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 当该对象从树中删除时调用。 /// Called when this object is removed from the tree. /// /// 每当框架从树中删除此 [State] 对象时，框架都会调用此方法。 /// 在某些情况下，框架会将 [State] 对象重新插入树的另一部分（例如，如果由于使用 [GlobalKey]，包含此 [State] 对象的子树从树中的一个位置嫁接到另一个位置） ）。 /// 如果发生这种情况，框架将调用 [activate] 以使 [State] 对象有机会重新获取它在 [deactivate] 中释放的任何资源。 /// 然后，它还将调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。 /// 如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。 /// 因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。 /// The framework calls this method whenever it removes this [State] object /// from the tree. In some cases, the framework will reinsert the [State] /// object into another part of the tree (e.g., if the subtree containing this /// [State] object is grafted from one location in the tree to another due to /// the use of a [GlobalKey]). If that happens, the framework will call /// [activate] to give the [State] object a chance to reacquire any resources /// that it released in [deactivate]. It will then also call [build] to give /// the [State] object a chance to adapt to its new location in the tree. If /// the framework does reinsert this subtree, it will do so before the end of /// the animation frame in which the subtree was removed from the tree. For /// this reason, [State] objects can defer releasing most resources until the /// framework calls their [dispose] method. /// /// 子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。 /// Subclasses should override this method to clean up any links between /// this object and other elements in the tree (e.g. if you have provided an /// ancestor with a pointer to a descendant\u0026#39;s [RenderObject]). /// /// 该方法的实现应该以调用继承的方法结束，如“super.deactivate()”。 /// Implementations of this method should end with a call to the inherited /// method, as in `super.deactivate()`. @protected @mustCallSuper void deactivate() { } 关于deactivate方法的说明都在注释中了，那框架在什么地方触发的deactivate方法呢？\n当Widget通过build方法构建后，就会执行Element的updateChild方法，然后将该Widget的引用作为第二个参数newWidget传入到updateChild方法中。\n这里先解释下红框部分：\n上面红框：表示如果newWidget为null，并且child不为null，那么需要将child删除，因为它不再具有配置。 下面红框：表示如果newWidget、child两者都不为空，并且如果Widget.canUpdate()返回false，表明新的Widget与旧的Widget不相同了，就需要先将老的child从渲染树中去除，重新去挂载新child。 这里多插一嘴，updateChild方法作用就是使用给定的新配置更新给定的child，它是widgets系统的核心，每次我们根据更新的配置添加、更新或删除child时都会调用它。\n这里总结下updateChild方法的执行：\nnewWidget == null newWidget != null child == null 返回null 返回新的Element child != null 旧的child被移除, 返回null 如果可能，更新旧child，返回child或新的Element 在红框部分，都会调用deactivateChild方法，然后在deactivateChild方法中执行owner!._inactiveElements.add(child)。\n在_InactiveElements的add方法中，执行了_deactivateRecursively()。\n在_InactiveElements的_deactivateRecursively()中，执行了element.deactivate()。\nElement的deactivate方法被子类StatefulElement重写了，所以看下StatefulElement的deactivate方法。\n可以看到，StatefulElement的deactivate方法中执行了State的deactivate方法，这里就不附上deactivate方法的执行流程图了。\n4.6、dispose方法 看下dispose方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 当该对象从树中永久删除时调用。 /// Called when this object is removed from the tree permanently. /// /// 当此 [State] 对象不再构建时，框架将调用此方法。 /// 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。此时调用[setState]是错误的。 /// 生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。 /// The framework calls this method when this [State] object will never /// build again. After the framework calls [dispose], the [State] object is /// considered unmounted and the [mounted] property is false. It is an error /// to call [setState] at this point. This stage of the lifecycle is terminal: /// there is no way to remount a [State] object that has been disposed. /// /// 子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。 /// Subclasses should override this method to release any resources retained /// by this object (e.g., stop any active animations). /// /// {@macro flutter.widgets.State.initState} /// /// 该方法的实现应该以调用继承的方法结束，如“super.dispose()”。 /// Implementations of this method should end with a call to the inherited /// method, as in `super.dispose()`. @protected @mustCallSuper void dispose() { assert(_debugLifecycleState == _StateLifecycle.ready); assert(() { _debugLifecycleState = _StateLifecycle.defunct; return true; }()); if (kFlutterMemoryAllocationsEnabled) { MemoryAllocations.instance.dispatchObjectDisposed(object: this); } } 关于dispose方法的说明都在注释中了，那框架在什么地方触发的dispose方法呢？\n在RendererBinding的initInstances方法中，会调用addPersistentFrameCallback方法注册一个持久帧回调。\n在持久帧回调_handlePersistentFrameCallback中调用了RendererBinding的drawFrame方法。\nRendererBinding的drawFrame方法被子类WidgetsBinding重写了，所以看下WidgetsBinding的drawFrame方法。\n在WidgetsBinding的drawFrame方法中执行了BuildOwner的finalizeTree方法。\n在BuildOwner的finalizeTree方法中执行了_InactiveElements的_unmountAll方法。\n在_InactiveElements的_unmountAll方法中执行了_unmount方法。\n在_InactiveElements的_unmount方法中又调用了Element的unmount方法。\nElement的unmount方法被子类StatefulElement重写了，所以看下StatefulElement的unmount方法。\n可以看到，StatefulElement的unmount方法中执行了State的dispose方法，这里就不附上dispose方法的执行流程图了。\n4.7、setState方法 看下setState方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 /// 通知框架该对象的内部状态已更改。 /// Notify the framework that the internal state of this object has changed. /// /// 每当您更改 [State] 对象的内部状态时，请在传递给 [setState] 的函数中进行更改： /// Whenever you change the internal state of a [State] object, make the /// change in a function that you pass to [setState]: /// /// ```dart /// setState(() { _myState = newValue; }); /// ``` /// /// 提供的回调将立即同步调用。它不能返回 future（回调不能是“异步”），因为这样就不清楚状态何时实际被设置。 /// The provided callback is immediately called synchronously. It must not /// return a future (the callback cannot be `async`), since then it would be /// unclear when the state was actually being set. /// /// 调用 [setState] 通知框架此对象的内部状态已更改，可能会影响此子树中的用户界面，这会导致框架为此 [State] 对象安排 [build]。 /// Calling [setState] notifies the framework that the internal state of this /// object has changed in a way that might impact the user interface in this /// subtree, which causes the framework to schedule a [build] for this [State] /// object. /// /// 如果您只是直接更改状态而不调用 [setState]，框架可能不会安排 [build]，并且此子树的用户界面可能不会更新以反映新状态。 /// If you just change the state directly without calling [setState], the /// framework might not schedule a [build] and the user interface for this /// subtree might not be updated to reflect the new state. /// /// 通常，建议 [setState] 方法仅用于包装对状态的实际更改，而不是可能与更改相关的任何计算。 /// 例如，这里将 [build] 函数使用的值递增，然后将更改写入磁盘，但只有递增被包装在 [setState] 中： /// Generally it is recommended that the [setState] method only be used to /// wrap the actual changes to the state, not any computation that might be /// associated with the change. For example, here a value used by the [build] /// function is incremented, and then the change is written to disk, but only /// the increment is wrapped in the [setState]: /// /// ```dart /// Future\u0026lt;void\u0026gt; _incrementCounter() async { /// setState(() { /// _counter++; /// }); /// Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package /// final String dirName = directory.path; /// await File(\u0026#39;$dirName/counter.txt\u0026#39;).writeAsString(\u0026#39;$_counter\u0026#39;); /// } /// ``` /// /// 框架调用[dispose]后调用该方法是错误的。您可以通过检查[mounted]属性是否为true来判断调用该方法是否合法。 /// It is an error to call this method after the framework calls [dispose]. /// You can determine whether it is legal to call this method by checking /// whether the [mounted] property is true. @protected void setState(VoidCallback fn) { assert(() { if (_debugLifecycleState == _StateLifecycle.defunct) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() called after dispose(): $this\u0026#39;), ErrorDescription( \u0026#39;This error happens if you call setState() on a State object for a widget that \u0026#39; \u0026#39;no longer appears in the widget tree (e.g., whose parent widget no longer \u0026#39; \u0026#39;includes the widget in its build). This error can occur when code calls \u0026#39; \u0026#39;setState() from a timer or an animation callback.\u0026#39;, ), ErrorHint( \u0026#39;The preferred solution is \u0026#39; \u0026#39;to cancel the timer or stop listening to the animation in the dispose() \u0026#39; \u0026#39;callback. Another solution is to check the \u0026#34;mounted\u0026#34; property of this \u0026#39; \u0026#39;object before calling setState() to ensure the object is still in the \u0026#39; \u0026#39;tree.\u0026#39;, ), ErrorHint( \u0026#39;This error might indicate a memory leak if setState() is being called \u0026#39; \u0026#39;because another object is retaining a reference to this State object \u0026#39; \u0026#39;after it has been removed from the tree. To avoid memory leaks, \u0026#39; \u0026#39;consider breaking the reference to this object during dispose().\u0026#39;, ), ]); } if (_debugLifecycleState == _StateLifecycle.created \u0026amp;\u0026amp; !mounted) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() called in constructor: $this\u0026#39;), ErrorHint( \u0026#39;This happens when you call setState() on a State object for a widget that \u0026#39; \u0026#34;hasn\u0026#39;t been inserted into the widget tree yet. It is not necessary to call \u0026#34; \u0026#39;setState() in the constructor, since the state is already assumed to be dirty \u0026#39; \u0026#39;when it is initially created.\u0026#39;, ), ]); } return true; }()); final Object? result = fn() as dynamic; assert(() { if (result is Future) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() callback argument returned a Future.\u0026#39;), ErrorDescription( \u0026#39;The setState() method on $this was called with a closure or method that \u0026#39; \u0026#39;returned a Future. Maybe it is marked as \u0026#34;async\u0026#34;.\u0026#39;, ), ErrorHint( \u0026#39;Instead of performing asynchronous work inside a call to setState(), first \u0026#39; \u0026#39;execute the work (without updating the widget state), and then synchronously \u0026#39; \u0026#39;update the state inside a call to setState().\u0026#39;, ), ]); } // We ignore other types of return values so that you can do things like: // setState(() =\u0026gt; x = 3); return true; }()); _element!.markNeedsBuild(); } 碍于篇幅有限，本文不会去分析setState方法的执行流程，后续可能会出一篇来专门分析setState方法。\n4.8、reassemble方法 看下reassemble方法的注释。\n1 2 3 4 5 6 7 8 9 /// {@macro flutter.widgets.Element.reassemble} /// /// 除了调用此方法之外，还保证在发出重组信号时调用 [build] 方法。因此，大多数widgets不需要在 [reassemble] 方法中执行任何操作。 /// In addition to this method being invoked, it is guaranteed that the /// [build] method will be invoked when a reassemble is signaled. Most /// widgets therefore do not need to do anything in the [reassemble] method. @protected @mustCallSuper void reassemble() { } reassemble方法是专门为开发调试提供的，通过点击AS的Flutter Hot Reload按钮来触发，并且在Release模式下永远不会被调用。所以关于reassemble方法的触发流程，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。\n至此，State的生命周期方法分析完毕，最后给出State的生命周期流程图。\n五、State生命周期示例 现在要实现的需求：\n1、点击“减一”按钮，由MyChild控制setState进行构建\n2、点击“+”、“添加或移除MyChild控件”按钮，由MyParent控制setState进行构建\n3、MyParent与MyChild中的计数器值要保持一致\n4、不同操作场景下，观察MyChild的生命周期变化\n那么，最终的实现代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyParent(title: \u0026#39;State生命周期演示\u0026#39;), ); } } class MyParent extends StatefulWidget { const MyParent({super.key, required this.title}); final String title; @override State\u0026lt;MyParent\u0026gt; createState() =\u0026gt; _MyParentState(); } class _MyParentState extends State\u0026lt;MyParent\u0026gt; { int _counter = 0; bool _isShowCounter = true; void _incrementCounter() { setState(() { _counter++; }); } void _toggleCounter() { setState(() { _isShowCounter = !_isShowCounter; }); } void _counterChanged(int counter) =\u0026gt; _counter = counter; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: _isShowCounter ? MyChild(counter: _counter, counterChanged: _counterChanged) : Container(), floatingActionButton: Column( mainAxisAlignment: MainAxisAlignment.end, children: [ FloatingActionButton( onPressed: _incrementCounter, tooltip: \u0026#39;Increment\u0026#39;, child: const Icon(Icons.add), ), const SizedBox(height: 10), FloatingActionButton( onPressed: _toggleCounter, tooltip: \u0026#39;ToggleCounter\u0026#39;, child: Icon(_isShowCounter ? Icons.toggle_on : Icons.toggle_off), ) ], ), ); } } class MyChild extends StatefulWidget { final int counter; final ValueChanged\u0026lt;int\u0026gt; counterChanged; const MyChild({super.key, required this.counter, required this.counterChanged}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { int _counter = 0; void _decrementCounter() { setState(() { debugPrint(\u0026#39;setState\u0026#39;); _counter--; }); widget.counterChanged(_counter); } @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); } @override void didChangeDependencies() { super.didChangeDependencies(); _counter = widget.counter; debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override void didUpdateWidget(covariant MyChild oldWidget) { super.didUpdateWidget(oldWidget); _counter = widget.counter; debugPrint(\u0026#39;didUpdateWidget\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ const Text( \u0026#39;You have pushed the button this many times:\u0026#39;, ), Text( \u0026#39;$_counter\u0026#39;, style: Theme.of(context).textTheme.headlineMedium, ), ElevatedButton( onPressed: _decrementCounter, child: const Text(\u0026#39;减一\u0026#39;), ), ], ), ); } @override void reassemble() { super.reassemble(); debugPrint(\u0026#39;reassemble\u0026#39;); } @override void deactivate() { super.deactivate(); debugPrint(\u0026#39;deactivate\u0026#39;); } @override void dispose() { super.dispose(); debugPrint(\u0026#39;dispose\u0026#39;); } } 程序运行后，效果如图下所示。\n程序刚运行起来，打印日志为： 1 2 3 I/flutter ( 7658): initState I/flutter ( 7658): didChangeDependencies I/flutter ( 7658): build 点击“减一”按钮，打印日志为： 1 2 I/flutter ( 7658): setState I/flutter ( 7658): build 点击“+”按钮，打印日志为： 1 2 I/flutter ( 7658): didUpdateWidget I/flutter ( 7658): build 点击“Flutter Hot Reload”按钮，打印日志为： 1 2 3 I/flutter ( 7658): reassemble I/flutter ( 7658): didUpdateWidget I/flutter ( 7658): build 点击“添加或移除MyChild控件”按钮，此时状态为移除，那么打印日志为： 1 2 I/flutter ( 7658): deactivate I/flutter ( 7658): dispose 点击“添加或移除MyChild控件”按钮，此时状态为添加，那么打印日志为： 1 2 3 I/flutter ( 7658): initState I/flutter ( 7658): didChangeDependencies I/flutter ( 7658): build ","date":"2023-10-18T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","section":"post","tags":null,"title":"解读Flutter源码之StatefulWidget\u0026State的生命周期"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWidget另一类，并且XXXWidget基本上都有与之对应的XXXElement。\n在本文中，将会通过一个小案例以及Debug调试源码的方式深入分析runApp方法的执行过程。\n二、小案例之设计问题 笔者在最初设计小案例时，预期想要的Widget层次结构是下图这样的。\n对应的代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MyPage(); } } class MyPage extends StatefulWidget { const MyPage({super.key}); @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return const ColoredBox(color: Colors.pinkAccent); } } 程序运行起来后，可以看到如下效果。\n但是当笔者通过Flutter Inspector查看Widget层次结构时，发现事与愿违，它的结构变为如下所示。\n可以发现，此时的Widget层次结构多出了一个View结构，这无疑会给后面的分析带来不必要的干扰，因此需要看下有无办法去掉View结构部分。\n看了下runApp的源码，发现View结构这一部分是在WidgetsBinding的wrapWithDefaultView方法中被添加进来的。\n再看下wrapWithDefaultView方法的注释： 由runApp用于将提供的rootWidget包装在默认View中。 View决定应用程序渲染到哪个FlutterView中。目前这是来自platformDispatcher的PlatformDispatcher.implicitView 。提供给此方法的rootWidget必须尚未包装在View中。\nOK，这wrapWithDefaultView方法的注释看得一头雾水，没关系，再看下View的红框部分注释。\n翻译：提供的child包装在根据给定view构造的MediaQuery中。 查看了View的部分源码发现的确如此。\n这里的child指我们传入的Widget，view指FlutterView，结合之前的分析，笔者大胆猜测wrapWithDefaultView方法的用意：用View对FlutterView进行一个指定渲染的优化管理，在View中先让MediaQuery初始化，为的是让后续的子Widget能够通过MediaQuery获取相关媒体查询数据。也就是说，如果不想调用wrapWithDefaultView方法，只要保证后续子Widget没用到MediaQuery就OK。\n前面所给出的MyApp代码中是完全没有用到MediaQuery的，所以这点不用担心，我们可以大大方方的不调用wrapWithDefaultView方法，改造后runApp方法如下。\n1 2 3 4 5 6 7 8 9 10 void main() { _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); binding ..scheduleAttachRootWidget(app) ..scheduleWarmUpFrame(); } 但是这样还不行，因为scheduleAttachRootWidget方法是一个@protected方法，外部调用该方法的话会有警告，所以直接把方法体的代码摘抄出来就好了。\n1 2 3 4 5 6 7 void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } 再次运行程序，然后通过Flutter Inspector查看Widget层次结构，发现与预期的Widget层次结构一致。\n温馨提示：此处runApp方法的改动是为了在Debug调试源码过程中减少其它Widget的干扰，而在实际项目中不能这样做。\n三、Root分析 OK，现在从程序入口_runApp方法开始分析。该方法接收一个Widget参数，接下来执行WidgetsFlutterBinding的ensureInitialized方法，返回一个WidgetsBinding实例。\n2.1、WidgetsFlutterBinding.ensureInitialized() 1 2 3 4 5 6 7 8 class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding._instance == null) { WidgetsFlutterBinding(); } return WidgetsBinding.instance; } } 由上面源码可知，在ensureInitialized方法中，首先会判断WidgetsBinding._instance == null，如果满足条件，则调用WidgetsFlutterBinding的构造方法进行初始化，最后返回WidgetsBinding.instance实例。\n当然了，第一次调用ensureInitialized方法时WidgetsBinding._instance肯定为null，这里可以打个断点Debug看下。\n此时会有个意外的发现，WidgetsFlutterBinding中根本就没有构造方法，毫无疑问会执行其父类BindingBase的构造方法。\nOK，我们继续跟踪其父类BindingBase的源码。\n发现父类BindingBase构造方法中有一个initInstances方法，这里打个断点Debug调试一下，进入initInstances方法。\n然后进入了WidgetsBinding的initInstances方法，继续Debug下一步，来到super.initInstances()。\n继续Debug进入super.initInstances()，然后进入了RendererBinding的initInstances方法。\n以此类推，当断点Debug调试走到BindingBase的initInstances方法时，它的调用堆栈如下图所示。\n对于出现这样栈帧顺序的方法调用栈，其实并不感到意外，回顾之前WidgetsFlutterBinding的声明处源码。\n1 class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding 可以发现，WidgetsFlutterBinding混入了GestureBinding、SchedulerBinding、ServicesBinding、PaintingBinding、SemanticsBinding、RendererBinding、WidgetsBinding这七个Binding，并且这些Binding都是BindingBase的子类，每个Binding都重写了父类BindingBase的initInstances方法，也在各自重写的initInstances方法体中调用了super.initInstances()以及执行了实例变量引用的赋值_instance = this。\n因此，initInstances方法的调用顺序为：WidgetsBinding -\u0026gt; RendererBinding -\u0026gt; SemanticsBinding -\u0026gt; PaintingBinding -\u0026gt; ServicesBinding -\u0026gt; SchedulerBinding -\u0026gt; GestureBinding，最后才调用父类BindingBase中的initInstances方法，这点从上图的方法调用栈也可以看出。\n也许你会有疑问：为什么initInstances方法的调用顺序是这样的？\n这其实是Dart语言中with关键字的一个语法特性了，如果一个类with混入的多个类中都有相同的方法（例如上面的initInstances方法），那么当调用该方法时，只会调用距离with关键字最远类中的方法，也就是上面WidgetsBinding中的initInstances方法。\n但是由于WidgetsBinding在initInstances方法中又调用了super.initInstances()，所以才会一级一级地往父类方向调用，直到调用父类BindingBase中的initInstances方法。\n因为调用的是WidgetsFlutterBinding的构造方法来进行初始化，所以ensureInitialized方法实例化的是WidgetsFlutterBinding对象了，只不过把实例引用赋值给了WidgetsBinding，如下图所示。\n2.2、attachRootWidget方法 在WidgetsFlutterBinding.ensureInitialized()实例化WidgetsFlutterBinding后，接下来会继续执行WidgetsBinding的attachRootWidget方法，这个方法接收了一个Widget参数。\n那么attachRootWidget方法做了什么事情？看下它的注释。\n1 2 /// Takes a widget and attaches it to the [rootElement], creating it if /// necessary. 翻译：获取一个Widget并将其附加到rootElement ，并在必要时创建它。 attachRootWidget方法的源码如下图所示。\n由上面源码可知，attachRootWidget方法体中先是执行了RenderObjectToWidgetAdapter构造方法，然后再执行该实例对象的attachToRenderTree方法。\n2.3、RenderObjectToWidgetAdapter构造方法 先打个断点Debug看下RenderObjectToWidgetAdapter构造方法传入的参数。\n可以看到，RenderObjectToWidgetAdapter构造方法传入了3个参数，其中参数child就是我们自己的MyApp；参数container传入了renderView，它的类型为RenderView；最后一个参数debugShortDescription从名字上看是调试用的，这个不用管。\n关于参数container传入了renderView，那么这个renderView是怎么来的呢？\n回顾下之前所讲的那七个混入Binding之一的RendererBinding，其实renderView是在RendererBinding的initInstances方法中初始化的。\nOK，RenderObjectToWidgetAdapter构造方法的参数分析完毕，接下来继续看attachToRenderTree方法。\n2.4、attachToRenderTree方法 先打个断点Debug看下attachToRenderTree方法传入的参数。\n可以看到，attachToRenderTree方法接收2个参数，一个是BuildOwner，另一个是可选的位置参数RenderObjectToWidgetElement。\n关于传入的参数buildOwner，那么这个buildOwner是怎么来的呢？它是在那七个混入Binding之一的WidgetsBinding的initInstances方法中初始化的。\nOK，开始分析attachToRenderTree方法源码，因为element为null，所以重点分析下红框部分。\nowner.lockState()接收一个VoidCallback回调，lockState方法体中只是进行一些断言操作，然后在try-finally中执行callback方法，lockState方法的源码如下。\nlockState方法体中没做什么操作，所以lockState方法回调中先调用了createElement方法，创建Element实例后，再调用Element实例的assignOwner方法，因为assignOwner方法不是主线的重点，所以这部分不做讲解。\n继续看主线的重点：createElement方法，它调用的是RenderObjectToWidgetAdapter这个Widget的createElement方法。\n可以发现，调用了RenderObjectToWidgetElement构造方法，方法参数传入的是this，表示RenderObjectToWidgetAdapter本身。\nRenderObjectToWidgetElement构造方法参数执行super.widget，就会把widget一级一级往上传递，先是执行了 RenderObjectElement的构造方法，最后执行了Element的构造方法。并且在Element的构造方法中，把一路传递过来的this，也就是RenderObjectToWidgetAdapter本身赋值给了Element的成员变量_widget，那么Element就持有了这个Widget。\nOK，owner.lockState()已经分析完成，继续看owner.buildScope()，buildScope方法体的实现与前面的lockState方法较为相似，也只是进行一些断言判断，最后在try-finally中执行callback方法。\nbuildScope方法体中没做什么操作，所以在buildScope方法回调中就会执行element的mount方法，也就是RenderObjectToWidgetElement的mount方法。\n分析下RenderObjectToWidgetElement的mount方法，这里分两步走，一步是执行super.mount，也就是执行父类的mount方法；另一步是执行_rebuild方法，这个后面会讲。\n看下第一步，也就是执行父类的mount方法，它会一级一级往上执行，先是执行RenderObjectElement的mount方法，最后执行Element的mount方法。\n可以看到，在Element的mount方法中主要是对一些属性进行赋值操作，如_parent等。当Element的mount方法执行完成后就会出栈，然后回来执行RenderObjectElement的mount方法。\n在RenderObjectElement的mount方法中会执行widget的createRenderObject方法，想必该Widget是谁应该知道吧，它就是之前在构造方法中将参数一级一级往上传递的this，也就是RenderObjectToWidgetAdapter，它是RootWidget，如果不确定，可以Debug断点调试看下。\n继续执行RenderObjectToWidgetAdapter的 createRenderObject方法，会返回一个container，也就是之前讲的RenderView。\n然后将createRenderObject方法返回值赋值给RenderObjectElement的成员变量_renderObject，于是得出一个结论：RenderObjectElement会持有一个RenderObject实例。\n接着，继续执行RenderObjectElement中的attachRenderObject方法。\n在RenderObjectElement中的attachRenderObject方法中，它一共做了三件事情。\n1、执行_findAncestorRenderObjectElement方法，沿着父类往上查找最远处RenderObjectElement类型的Element，并且赋值给 _ancestorRenderObjectElement；其中_parent是在Element的mount方法中赋值，一开始_parent为null，所以_findAncestorRenderObjectElement方法返回为null，相当于该方法没执行。\n2、执行上一步返回的_ancestorRenderObjectElement的insertRenderObjectChild方法将renderObject插入渲染树中； 但是由于_ancestorRenderObjectElement为null，所以insertRenderObjectChild方法并没有触发。\n3、执行_findAncestorParentDataElement方法，沿着父类往上查找最近处ParentDataElement类型的Element，但是由于_parent为null，所以该方法执行了个寂寞。\n因此，整体上RenderObjectElement中的attachRenderObject方法相当于没执行到。\nOK，RenderObjectElement的mount方法分析完了，此时会继续出栈，然后继续执行RenderObjectToWidgetElement的mount方法中super.mount()之后的逻辑。\n也就是执行RenderObjectToWidgetElement的_rebuild方法，在 _rebuild方法中，执行了updateChild方法，参数一_child为null，参数二就是我们自己的MyApp，参数三为Object。\n继续执行Element的updateChild方法，因为此时child为null，所以会执行红框部分，也就是执行inflateWidget方法。\n继续执行Element的inflateWidget方法，之前已经知道传入的newWidget为MyApp，看下它的源码。\n在Element中的inflateWidget方法中，它一共做了3件事情。\n1、校验key是否为GlobalKey，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。\n2、执行newWidget的createElement方法，也就是执行MyApp的createElement方法，返回一个Element实例。\n3、执行上一步返回Element实例的mount方法。\n看到这里，相信你会觉得createElement、mount方法似曾相识，因为之前分析过了。\n总结下Root分析的执行流程，如下图所示。\n四、StatelessWidget分析 接着Root分析，继续执行MyApp的createElement方法，因为MyApp的类型是StatelessWidget，所以执行了StatelessWidget的createElement方法。\n然后创建了StatelessElement实例，并将this传入StatelessElement的构造方法中，this也就是MyApp本身，而StatelessElement构造方法的参数执行了super.widget，会一级一级地向父类传递this，先是执行了ComponentElement的构造方法，最后再执行Element的构造方法，将传递的this赋值给Element的成员变量_widget。\n这种子类Element向父类一级一级传递this的行为我们之前讲过的，也是似曾相识了。\n接着Root分析，继续执行Element的mount方法。因为StatelessElement没有mount方法，所以执行的是ComponentElement的mount方法。\n可以看到，先是执行了super.mount，也就是执行Element的mount方法，这个之前看过，只是一些成员变量的赋值操作。\n然后执行了_firstBuild方法，在该方法中又执行了Element的rebuild方法。\n在Element的rebuild方法中，try-finally处执行了performRebuild方法，然后又回到了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，做了两件事情。\n1、执行build方法。这里执行了StatelessElement的build方法。\n这里的widget就是我们自己的MyApp，所以执行了MyApp的build方法，创建了MyPage实例。\n2、执行了Element的updateChild方法，看到该方法是否又似曾相识，OK，继续分析。\n因为此时child为null，所以会执行红框部分，也就是执行inflateWidget方法。\n继续执行Element的inflateWidget方法，之前已经知道传入的newWidget为MyPage，看下它的源码。\n在Element中的inflateWidget方法中，它一共做了三件事情，这个前面讲过。\n1、校验key是否为GlobalKey，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。\n2、执行newWidget的createElement方法，也就是执行MyPage的createElement方法，返回一个Element实例。\n3、执行上一步返回Element实例的mount方法。\n看到这里，相信你会觉得再熟悉不过，因为之前多次分析过createElement、mount方法了。\n五、StatefulWidget分析 接着StatelessWidget分析，继续执行MyPage的createElement方法，因为MyPage的类型是StatefulWidget，所以执行了StatefulWidget的createElement方法。\n然后创建了StatefulElement实例，并将this传入StatefulElement的构造方法中，this也就是MyPage本身。\n在StatefulElement的构造方法中，执行了widget.createState()，widget就是我们的MyPage，也就是执行了MyPage的createState方法。\n将创建好的_MyPageState实例赋值给StatefulElement的成员变量_state，也就是说StatefulElement持有了State实例。\n与此同时，StatefulElement构造方法中还执行了super(widget)，会一级一级地向父类传递this，先是执行了ComponentElement的构造方法，最后再执行Element的构造方法，将传递的this赋值给Element的成员变量_widget。\n这种子类Element向父类一级一级传递this的行为我们之前讲过的，也是老相识了。\n接着StatelessWidget分析，继续执行Element的mount方法。因为StatefulElement没有mount方法，所以执行的是ComponentElement的mount方法。\n可以看到，先是执行了super.mount，也就是执行Element的mount方法，这个之前看过，只是一些成员变量的赋值操作。\n然后执行了_firstBuild方法，在该方法中又执行了Element的rebuild方法。\n在Element的rebuild方法中，try-finally处执行了performRebuild方法，然后又回到了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，做了两件事情。\n1、执行build方法。这里执行了StatefulElement的build方法。\n这里执行了state.build()，也就是执行了_MyPageState的build方法，创建了ColoredBox实例。\n2、执行了Element的updateChild方法，该方法是老朋友了。\n再后面就是ColoredBox的分析，因为ColoredBox最终父类的类型与根布局RenderObjectToWidgetAdapter的类型都是RenderObjectWidget，因此分析都是差不多的，后面就留给你们发挥了。\n当然了，runApp方法的分析肯定不止上面这些内容，后续有机会再补上。\n","date":"2023-10-14T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/","section":"post","tags":null,"title":"解读Flutter源码之runApp"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、Widget的分类 作为一个初学者，我们知道在Flutter中万物皆Widget，这恰恰说明了Widget在Flutter中的一个重要性，那么以Android开发者的角度来看，Flutter中的Widget是否等同于Android中的View呢？或者说Widget能否像Android中的UI控件一样分为ViewGroup、View两种形式呢？比如说，将需要传入child参数的Widget可认为ViewGroup，如Container、Center等，将不需要传入child参数的Widget可认为View，如Text、Icon等等，如此分类是否合理呢？\nOK，带着疑问，我们先来看下Widget的部分注释。\n1 2 3 4 5 /// Describes the configuration for an [Element]. /// /// Widgets are the central class hierarchy in the Flutter framework. A widget /// is an immutable description of part of a user interface. Widgets can be /// inflated into elements, which manage the underlying render tree. 翻译：Widget描述一个Element的配置。Widget是Flutter框架中的中心类层次结构。一个widget是用户界面一部分的不可变描述。Widget可以创建出Element，这些Element管理底层渲染树。\n其中“be inflated into”在谷歌翻译中会被翻译为“膨胀为”，但是我认为应该翻译为“创建出”比较合理，因为在Widget源码中有一个抽象的createElement方法，就是用来创建并返回Element对象的。\n1 2 3 4 5 6 7 8 9 10 11 12 /// Widget的部分源码 abstract class Widget extends DiagnosticableTree { const Widget({ this.key }); final Key? key; @protected @factory Element createElement(); } 现在，我们知道了Widget在Flutter中扮演着一个UI配置的角色，它是不可变的，Widget本身既非视图，也不会直接绘制任何内容。从这一维度上讲，Widget不完全等同于Android中的View，所以将Widget像Android中的UI控件一样分为ViewGroup、View两种形式我认为并不合理。\n那么Widget该如何分类呢？我们可以先查看Widget的所有直接子类，比对直接子类之间的区别来进行分类。\n选中Widget-》点击AS菜单栏Navigate中的Type Hierarchy选项，就可以输出Widget的继承关系层次结构（使用快捷键呼出也可以，我这里的默认快捷键是F4）。\n经过仔细比对Widget直接子类之间的区别，将Widget分类后如下图所示。\n如上图所示，根据有无RenderObject大致可以将Widget分为RenderObjectWidget一类和非RenderObjectWidget另一类。\nRenderObjectWidget一类 那么RenderObjectWidget是什么？看下它的部分注释说明。\n1 2 3 /// RenderObjectWidgets provide the configuration for [RenderObjectElement]s, /// which wrap [RenderObject]s, which provide the actual rendering of the /// application. 翻译：RenderObjectWidget为RenderObjectElement提供配置，RenderObjectElement包装了RenderObject，RenderObject提供应用程序的实际渲染。\n到这里已经初步知道这三颗树在Flutter中的作用了，Widget为Element提供配置，Element管理着RenderObject，实际渲染的是RenderObject。\n再来看下RenderObjectWidget源码。\n由上图可知，RenderObjectWidget抽象类主要包含4个方法：createElement、createRenderObject、updateRenderObject、didUnmountRenderObject，其中createElement和createRenderObject为抽象方法，需要子类去实现，也就是说， RenderObjectWidget不仅要创建Element，也要创建RenderObject。\n下面以同样的方式查看RenderObjectWidget继承关系层次结构，又可以将RenderObjectWidget一类分为以下几类。\nWidget 说明 SingleChildRenderObjectWidget 为SingleChildRenderObjectElement提供配置，只能传入单个Child的Widget MultiChildRenderObjectWidget 为MultiChildRenderObjectElement提供配置，可以传入多个Child的Widget LeafRenderObjectWidget 为LeafRenderObjectElement提供配置，没有Child的Widget RenderObjectToWidgetAdapter 从RenderObject到Element树的桥梁 非RenderObjectWidget另一类 非RenderObjectWidget又可以按有无State分为StatefulWidget、StatelessWidget和ProxyWidget等等，我们只重点看下StatefulWidget和StatelessWidget。\n首先看下StatefulWidget的部分注释。\n1 /// A widget that has mutable state. 翻译：Widget具有可变状态。\n在StatefulWidget中主要有createElement和createState方法，其中createElement方法返回了一个StatefulElement，而createState方法则为一个抽象方法，就是我们经常实现的一个方法。\n为什么说StatefulWidget是可变的？这是因为State信息在Widget的生命周期中可能会发生变化。Widget实现者可以确保在状态更改时使用State.setState及时通知State。\n至于StatelessWidget，看下它的部分注释。\n1 /// A widget that does not require mutable state. 翻译：不需要可变状态的Widget。\nStatelessWidget主要有createElement和build方法，其中createElement方法返回了一个StatelessElement，而build方法则为一个抽象方法，就是我们经常实现的一个方法。\n二、 Element的分类 通过对上面Widget分类的了解，我们可以看出它主要是为了给Element提供配置和创建Element而生的。并且细心点就可以发现，对于上述提到的XXXWidget基本上都有对应的XXXElement，如下：\n1 2 3 4 5 6 7 StatelessWidget -\u0026gt; StatelessElement StatefulWidget -\u0026gt; StatefulElement InheritedWidget -\u0026gt; InheritedElement LeafRenderObjectWidget -\u0026gt; LeafRenderObjectElement SingleChildRenderObjectWidget -\u0026gt; SingleChildRenderObjectElement MultiChildRenderObjectWidget -\u0026gt; MultiChildRenderObjectElement ... 那么，Element到底是什么？首先看下Element的部分注释。\n1 /// An instantiation of a [Widget] at a particular location in the tree. 翻译：树中特定位置的Widget实例。\n通过查看Element的部分源码我们可以发现，Element中不仅持有了Widget、还持有了RenderObject，从这一角度来讲，Element是Widget与RenderObject之间沟通的桥梁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Element的部分源码 abstract class Element extends DiagnosticableTree implements BuildContext { Element(Widget widget) : assert(widget != null), widget = widget; @override Widget get widget =\u0026gt; _widget!; Widget? _widget; RenderObject? get renderObject { RenderObject? result; void visit(Element element) { assert(result == null); if (element._lifecycleState == _ElementLifecycle.defunct) { return; } else if (element is RenderObjectElement) { result = element.renderObject; } else { element.visitChildren(visit); } } visit(this); return result; } } 下面以同样的方式查看Element继承关系层次结构，可以发现每个XXXElement基本上是通过继承ComponentElement或RenderObjectElement来间接继承Element，Element分类如下图所示。\n三、RenderObject的分类 通过前面的了解，我们知道RenderObject用来渲染的，那么RenderObject是什么呢？看下它的部分注释。\n1 2 3 4 /// An object in the render tree. /// /// The [RenderObject] class hierarchy is the core of the rendering /// library\u0026#39;s reason for being. 翻译：渲染树中的对象。RenderObject类层次结构是渲染库存在的核心。\n下面以同样的方式查看RenderObject继承关系层次结构，又可以将RenderObject分为以下几类。\nRenderObject 说明 RenderObjectWithChildMixin 用于渲染只有一个子对象的泛型mixin ContainerRenderObjectMixin 用于渲染具有多个子对象的泛型mixin RenderView 渲染树的根节点 RenderBox 二维笛卡尔坐标系中的渲染对象 RenderSliver 在视口中实现滚动效果的渲染对象的基类 RelayoutWhenSystemFontsChangeMixin RenderObject的Mixin每当系统字体更改时都会调用systemFontsDidChange ","date":"2023-10-10T14:47:31+08:00","permalink":"https://anddevmk.cn/post/flutter%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89%E9%A2%97%E6%A0%91%E5%88%86%E7%B1%BB/","section":"post","tags":null,"title":"Flutter源码之三颗树分类"},{"categories":["Java"],"contents":" 注：本文代码基于JDK 17\n一、概述 动态代理，一个听起来很高深的名词，其实并非如此，在日常的开发中，你或多或少都有遇到过，比如你调用第三方SDK的方法时，该方法的具体实现或许就是使用了动态代理，这个本文后面会讲到。\n不管是在Java开发还是Android开发中，动态代理的应用场景都非常广泛，因此我们需要学习它，并且了解它的运行原理，这也是本文接下来要做的事情。\n二、什么是代理？ 代理在我们的日常生活中很常见，比如说：\n恶略天气出去吃饭麻烦，可以点外卖\n爷爷不会使用手机充话费，找孙女帮忙充\n在这两个例子中，外卖骑手、孙女这两个角色都是帮我们干活的，他们做着我们不能做或不想做的事情。\n因此，代理其实就是当前对象不能做或不想做的事情，委托给别的对象做。\n三、静态代理的使用 还是以上面的“孙女帮爷爷充话费”为例进行说明，现有一个行为接口Action，包含了一个充话费的方法recharge。\n1 2 3 4 5 6 7 8 9 10 /** * 行为接口 */ public interface Action { /** * 充话费 */ void recharge(); } 因为爷爷需要充话费，所以Grandfather类实现了Action接口。\n1 2 3 4 5 6 7 8 9 10 /** * 爷爷 */ public final class Grandfather implements Action { @Override public void recharge() { System.out.println(\u0026#34;recharge\u0026#34;); } } 但是，爷爷并不会使用手机充话费，于是他找了孙女请求帮忙充话费，那么Granddaughter类也要实现Action接口，然后把两者的充话费行为关联起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 孙女 */ public final class Granddaughter implements Action { private final Action action; public Granddaughter(Action action) { this.action = action; } @Override public void recharge() { System.out.println(\u0026#34;before recharge\u0026#34;); if (action != null) action.recharge(); System.out.println(\u0026#34;after recharge\u0026#34;); } } 最终的main方法如下：\n1 2 3 4 5 6 7 8 public class Client { public static void main(String[] args) { Grandfather grandfather = new Grandfather(); Granddaughter granddaughter = new Granddaughter(grandfather); granddaughter.recharge(); } } 由上面代码可知，Grandfather和Granddaughter两个类都实现了相同的接口Action，实际对象是Grandfather，代理对象是Granddaughter。\nGranddaughter内部有一个action的成员变量，指向实际对象，在构造方法中被初始化，对于方法recharge方法的调用，它转发给了实际对象，接着在调用前后输出了一些跟踪调试信息，这也是代理对原方法进行增强的一种体现，上面代码输出如下：\n1 2 3 before recharge recharge after recharge 因此，代理背后一般至少有一个实际对象，代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。\n在代码中创建了一个代理类Granddaughter，它的代码是在写程序时固定的，所以称为静态代理。\n虽然静态代理实现简单，且不侵入原代码，但是当场景复杂一些的时候，静态代理的缺点也会暴露出来。\n1、当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有2种方式：\n只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类 2、当接口增加、删除、修改方法的时候，目标对象与代理类都要同时修改，十分不易维护。\n那么，这要如何改进呢？\n当然是让代理类动态的生成，这也是接下来要说的动态代理。\n四、动态代理的使用 在静态代理中，代理类是直接定义在代码中的，而在动态代理中，代理类是动态生成的，那么就有一个疑问了，要如何去实现动态代理呢？\n在JDK中，提供了java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler这两个类来实现动态代理。动态代理的使用有2个步骤：\n创建一个类去实现InvocationHandler接口，并且实现该接口的invoke方法。\n使用Proxy类的newProxyInstance方法去创建代理类的实例对象。\n接下来，我们按照上面的步骤一一实现动态代理，首先创建一个类ActionInvocationHandler，让它去实现InvocationHandler接口，并且实现该接口的invoke方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Action接口调用处理器 */ public class ActionInvocationHandler implements InvocationHandler { private final Object realObj; // 实际对象 public ActionInvocationHandler(Object realObj) { this.realObj = realObj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;before recharge\u0026#34;); Object result = method.invoke(realObj, args); System.out.println(\u0026#34;after recharge\u0026#34;); return result; } } ActionInvocationHandler类实现了InvocationHandler接口，它的构造方法接受一个Object类型的参数realObj，realObj表示被代理的实际对象，接着在invoke方法中处理所有的接口调用，它有3个参数：\nproxy：表示代理对象本身，注意了，它不是被代理的实际对象，这个参数一般用处不大；\nmethod：表示代理方法的method对象；\nargs：表示代理方法的参数；\n上面调用了method的invoke方法，传递了实际对象realObj作为参数，达到了调用实际对象对应方法的目的，在调用任何方法前后，我们输出了跟踪调试语句。需要注意的是，不能将proxy作为参数传递给method的invoke方法，比如：\n1 Object result = method.invoke(proxy, args); 上面的语句会造成死循环，因为proxy表示当前代理对象，这又会调用到ActionInvocationHandler的invoke方法。\n然后使用Proxy类的newProxyInstance方法去创建代理类的实例对象，调用代理类的实例对象的方法，代码如下：\n1 2 3 4 5 6 7 8 9 public class Client { public static void main(String[] args) { Grandfather grandfather = new Grandfather(); Action action = (Action) Proxy.newProxyInstance(Action.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Action.class}, new ActionInvocationHandler(grandfather)); action.recharge(); } } 和静态代理相比，代码看起来复杂不少，但是Action接口和Grandfather的定义不变，程序的输出也没变，只是代理对象Granddaughter的创建方式变了，它使用Proxy类的静态方法newProxyInstance来创建代理对象，该方法的声明如下：\n1 2 3 public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) newProxyInstance方法有3个参数：\nloader：代理类的类加载器；\ninterfaces：代理类要实现的接口列表，它是一个数组，元素的类型只能是接口，不能是普通的类；\nh：h的类型为InvocationHandler，它是一个接口，只定义了一个方法invoke，对代理接口所有方法的调用都会转给该方法。\nnewProxyInstance方法的返回值类型为Object，可以强制转换为interfaces数组中的某个接口类型。这里我们强制转换为了Action类型，需要注意的是，它不能强制转换为某个类类型。\n如果上面动态代理的代码令你感到疑惑，那么接下来让我们一起去深入源码，慢慢解开你心中的疑惑。\n五、动态代理的原理 我们先看下Proxy类的newProxyInstance方法，因为它返回的是代理类的实例对象，那么代理类的实例对象是怎么被构造出来的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) { Objects.requireNonNull(h); // 如果没有调用setSecurityManager方法设置SecurityManager，那么getSecurityManager方法返回为null，因此，默认情况下caller即为null，否则返回调用此方法的方法的调用者的类 @SuppressWarnings(\u0026#34;removal\u0026#34;) final Class\u0026lt;?\u0026gt; caller = System.getSecurityManager() == null ? null : Reflection.getCallerClass(); /* * Look up or generate the designated proxy class and its constructor. */ // 分析1 Constructor\u0026lt;?\u0026gt; cons = getProxyConstructor(caller, loader, interfaces); // 分析2 return newProxyInstance(caller, cons, h); } 分析1：调用getProxyConstructor方法创建代理类的构造方法所对应的构造器对象cons，\n其中方法的参数传入了类加载器loader和数组interfaces；\n分析2：调用newProxyInstance方法创建代理类的实例对象并返回，其中方法的参数传入了构造器对象cons和InvocationHandler类型的变量h。\nOK，首先看getProxyConstructor方法的实现，它是怎么创建的构造器对象cons？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private static Constructor\u0026lt;?\u0026gt; getProxyConstructor(Class\u0026lt;?\u0026gt; caller, ClassLoader loader, Class\u0026lt;?\u0026gt;... interfaces) { // optimization for single interface // 代理接口数组中只有单个接口 if (interfaces.length == 1) { Class\u0026lt;?\u0026gt; intf = interfaces[0]; // 默认情况下，caller为null，不满足此处if if (caller != null) { // 检查创建代理类所需的权限 checkProxyAccess(caller, loader, intf); } return proxyCache.sub(intf).computeIfAbsent( loader, (ld, clv) -\u0026gt; new ProxyBuilder(ld, clv.key()).build() ); } else { // 代理接口数组中存在多个接口 // interfaces cloned final Class\u0026lt;?\u0026gt;[] intfsArray = interfaces.clone(); // 默认情况下，caller为null，不满足此处if if (caller != null) { // 检查创建代理类所需的权限 checkProxyAccess(caller, loader, intfsArray); } final List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; intfs = Arrays.asList(intfsArray); return proxyCache.sub(intfs).computeIfAbsent( loader, (ld, clv) -\u0026gt; new ProxyBuilder(ld, clv.key()).build() ); } } 通过上面代码可知，根据数组interfaces的长度来分情况处理，但是不管怎样，最终都是调用了proxyCache变量的复杂调用链进行相关操作，那么proxyCache是什么玩意？\n1 2 3 4 5 6 7 8 public class Proxy implements java.io.Serializable { /** * a cache of proxy constructors with * {@link Constructor#setAccessible(boolean) accessible} flag already set */ private static final ClassLoaderValue\u0026lt;Constructor\u0026lt;?\u0026gt;\u0026gt; proxyCache = new ClassLoaderValue\u0026lt;\u0026gt;(); } 由代码注释可知，proxyCache是已设置accessible标志的代理构造函数的缓存，并且它是ClassLoaderValue类型。跟踪ClassLoaderValue类发现它继承自抽象类AbstractClassLoaderValue，当调用ClassLoaderValue的sub方法时，因为ClassLoaderValue没有sub方法，所以实际上是调用了抽象类AbstractClassLoaderValue的sub方法，这个sub方法创建了Sub对象，而Sub类又是AbstractClassLoaderValue的内部类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public abstract class AbstractClassLoaderValue\u0026lt;CLV extends AbstractClassLoaderValue\u0026lt;CLV, V\u0026gt;, V\u0026gt; { public \u0026lt;K\u0026gt; Sub\u0026lt;K\u0026gt; sub(K key) { return new Sub\u0026lt;\u0026gt;(key); } public final class Sub\u0026lt;K\u0026gt; extends AbstractClassLoaderValue\u0026lt;Sub\u0026lt;K\u0026gt;, V\u0026gt; { private final K key; Sub(K key) { this.key = key; } } } 根据proxyCache变量的复杂调用链，下一步就是调用Sub类的computeIfAbsent方法了，但是Sub类没有computeIfAbsent方法，那么调用的就是父类AbstractClassLoaderValue的computeIfAbsent方法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public abstract class AbstractClassLoaderValue\u0026lt;CLV extends AbstractClassLoaderValue\u0026lt;CLV, V\u0026gt;, V\u0026gt; { public V computeIfAbsent(ClassLoader cl, BiFunction\u0026lt; ? super ClassLoader, ? super CLV, ? extends V \u0026gt; mappingFunction) throws IllegalStateException { ConcurrentHashMap\u0026lt;CLV, Object\u0026gt; map = map(cl); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) CLV clv = (CLV) this; Memoizer\u0026lt;CLV, V\u0026gt; mv = null; while (true) { Object val = (mv == null) ? map.get(clv) : map.putIfAbsent(clv, mv); if (val == null) { if (mv == null) { // create Memoizer lazily when 1st needed and restart loop mv = new Memoizer\u0026lt;\u0026gt;(cl, clv, mappingFunction); continue; } // mv != null, therefore sv == null was a result of successful // putIfAbsent try { // trigger Memoizer to compute the value V v = mv.get(); // attempt to replace our Memoizer with the value map.replace(clv, mv, v); // return computed value return v; } catch (Throwable t) { // our Memoizer has thrown, attempt to remove it map.remove(clv, mv); // propagate exception because it\u0026#39;s from our Memoizer throw t; } } else { try { return extractValue(val); } catch (Memoizer.RecursiveInvocationException e) { // propagate recursive attempts to calculate the same // value as being calculated at the moment throw e; } catch (Throwable t) { // don\u0026#39;t propagate exceptions thrown from foreign Memoizer - // pretend that there was no entry and retry // (foreign computeIfAbsent invocation will try to remove it anyway) } } // TODO: // Thread.onSpinLoop(); // when available } } } computeIfAbsent方法当中用到了ConcurrentHashMap，这里可以知道应该是支持多线程并发的，computeIfAbsent方法的功能可以解读为：返回与此ClassLoaderValue和给定ClassLoader关联的值，如果不存在，则通过调用给定的mappingFunction来计算该值，将其关联并返回它。\n很明显，map中没有缓存时，创建构造器的核心逻辑落在了在ProxyBuilder类上，继续跟踪ProxyBuilder类，发现它是Proxy的内部类，先看它的成员变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Proxy implements java.io.Serializable { private static final class ProxyBuilder { // 分析1 private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess(); // 分析2：所有代理类名称的前缀 // prefix for all proxy class names private static final String proxyClassNamePrefix = \u0026#34;$Proxy\u0026#34;; // 分析3：用于生成唯一代理类名称的下一个数字 // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); // 分析4：已定义代理类的反向缓存，也就是已经生成代理类的纪录为true // a reverse cache of defined proxy classes private static final ClassLoaderValue\u0026lt;Boolean\u0026gt; reverseProxyCache = new ClassLoaderValue\u0026lt;\u0026gt;(); } } 分析1：创建了JavaLangAccess实例，它是通过SharedSecrets的getJavaLangAccess方法来获取，我寻思既然有getXXX方法，那么也应该有setXXX方法，经过一番搜索，发现JavaLangAccess的setJavaLangAccess方法是在System类的setJavaLangAccess方法中被调用，而System类的setJavaLangAccess方法将通过虚拟机VM来调用。\n1 2 3 4 5 6 7 8 9 10 11 12 private static void setJavaLangAccess() { // Allow privileged classes outside of java.lang SharedSecrets.setJavaLangAccess(new JavaLangAccess() { // 埋下伏笔 public Class\u0026lt;?\u0026gt; defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) { return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source); } // ... }); } 继续跟踪ProxyBuilder类的构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ProxyBuilder(ClassLoader loader, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces) { // 分析2：如果模块系统未初始化，那么代理是不支持的 if (!VM.isModuleSystemInited()) { throw new InternalError(\u0026#34;Proxy is not supported until \u0026#34; + \u0026#34;module system is fully initialized\u0026#34;); } // 分析3：代理接口数量最多只能65535个 if (interfaces.size() \u0026gt; 65535) { throw new IllegalArgumentException(\u0026#34;interface limit exceeded: \u0026#34; + interfaces.size()); } // 分析4：返回代理接口的所有公共非静态方法签名引用的所有类型(返回值类型、共享参数类型，共享异常类型) Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; refTypes = referencedTypes(loader, interfaces); // 分析5：验证给定的代理接口和给定的引用类型对定义加载器可见 // IAE if violates any restrictions specified in newProxyInstance validateProxyInterfaces(loader, interfaces, refTypes); this.interfaces = interfaces; // 分析6：返回生成的代理类所属的模块，有如下规则： // 1、如果任何代理接口是包私有的，则代理类位于包私有接口的同一模块中 // 2、如果所有代理接口都是公共的并且位于导出包中，则代理类位于无条件导出包中的动态模块中 // 3、如果所有代理接口都是公共的，并且至少有一个位于非导出包中，则该代理类位于非导出包中的动态模块中 this.module = mapToModule(loader, interfaces, refTypes); assert getLoader(module) == loader; } // 分析1：如果是单个代理接口的情况，其实也是把接口转换为List，然后调用另一个构造方法 ProxyBuilder(ClassLoader loader, Class\u0026lt;?\u0026gt; intf) { this(loader, Collections.singletonList(intf)); } 由上面代码可知，代理类的生成有着许多限制规则，主要是Java 9引入了模块管理的概念，继续跟踪ProxyBuilder类的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 生成一个代理类并返回其代理构造函数，并已设置可访问标志 Constructor\u0026lt;?\u0026gt; build() { // 分析1：定义代理类的Class对象 Class\u0026lt;?\u0026gt; proxyClass = defineProxyClass(module, interfaces); assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Prox final Constructor\u0026lt;?\u0026gt; cons; try { // 分析2：返回代理类的构造器 cons = proxyClass.getConstructor(constructorParams); } catch (NoSuchMethodException e) { throw new InternalError(e.toString(), e); } AccessController.doPrivileged(new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { cons.setAccessible(true); return null; } }); return cons; } 很明显，代理类的生成过程都在defineProxyClass方法当中，继续跟踪。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 private static Class\u0026lt;?\u0026gt; defineProxyClass(Module m, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces) { // 分析1：定义代理类所在的包路径 String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; boolean nonExported = false; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ // 分析2：记录非公共代理接口的包，以便代理类将定义在同一个包中。验证所有非公共代理接口是否位于同一个包中。 for (Class\u0026lt;?\u0026gt; intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { accessFlags = Modifier.FINAL; // non-public, final String pkg = intf.getPackageName(); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( \u0026#34;non-public interfaces from different packages\u0026#34;); } } else { if (!intf.getModule().isExported(intf.getPackageName())) { // module-private types nonExported = true; } } } // 分析3：所有代理接口都是公共和导出的 if (proxyPkg == null) { // all proxy interfaces are public and exported if (!m.isNamed()) throw new InternalError(\u0026#34;ununamed module: \u0026#34; + m); // 如果代理接口所在包名在模块中是不可导出的，那么代理接口包名定义为com.sun.proxy.模块名，否则定义为模块名 proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \u0026#34;.\u0026#34; + m.getName() : m.getName(); } else if (proxyPkg.isEmpty() \u0026amp;\u0026amp; m.isNamed()) { throw new IllegalArgumentException( \u0026#34;Unnamed package cannot be added to \u0026#34; + m); } if (m.isNamed()) { if (!m.getDescriptor().packages().contains(proxyPkg)) { throw new InternalError(proxyPkg + \u0026#34; not exist in \u0026#34; + m.getName()); } } /* * Choose a name for the proxy class to generate. */ // 分析4：选择要生成的代理类的名称 // 计数器+1 long num = nextUniqueNumber.getAndIncrement(); // 如果包名为\u0026#34;\u0026#34;，代理类名字 $Proxy + 计数器数字，否则 包名.$Proxy + 计数器数字 String proxyName = proxyPkg.isEmpty() ? proxyClassNamePrefix + num : proxyPkg + \u0026#34;.\u0026#34; + proxyClassNamePrefix + num; ClassLoader loader = getLoader(m); trace(proxyName, m, loader, interfaces); /* * Generate the specified proxy class. */ // 分析5：生成指定的代理类 // 动态生成代理类字节数组 byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags); try { // 通过代理类字节数组定义代理类Class对象，对于了前面说的System的setJavaLangAccess方法的实现 Class\u0026lt;?\u0026gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile, null, \u0026#34;__dynamic_proxy__\u0026#34;); // 缓存代理类已经生成过的标记true reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE); return pc; } catch (ClassFormatError e) { /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); } } 继续跟踪ProxyGenerator的generateProxyClass方法，看看是如何生成代理类字节数组的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 给定名称和代理接口列表生成代理类 static byte[] generateProxyClass(ClassLoader loader, final String name, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces, int accessFlags) { // 分析1 ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags); final byte[] classFile = gen.generateClassFile(); // 分析2 if (saveGeneratedFiles) { java.security.AccessController.doPrivileged( new java.security.PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { try { int i = name.lastIndexOf(\u0026#39;.\u0026#39;); Path path; if (i \u0026gt; 0) { Path dir = Path.of(dotToSlash(name.substring(0, i))); Files.createDirectories(dir); path = dir.resolve(name.substring(i + 1) + \u0026#34;.class\u0026#34;); } else { path = Path.of(name + \u0026#34;.class\u0026#34;); } Files.write(path, classFile); return null; } catch (IOException e) { throw new InternalError( \u0026#34;I/O exception saving generated file: \u0026#34; + e); } } }); } return classFile; } 分析1：调用了ProxyGenerator的generateClassFile方法来生成代理类的字节数组，跟踪看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 生成代理类的类文件。该方法驱动类文件生成过程 private byte[] generateClassFile() { // 确定代理类的基础信息（类修饰符、类名、父类、实现的接口等等） visit(V14, accessFlags, dotToSlash(className), null, JLR_PROXY, typeNames(interfaces)); /* * Add proxy methods for the hashCode, equals, * and toString methods of java.lang.Object. This is done before * the methods from the proxy interfaces so that the methods from * java.lang.Object take precedence over duplicate methods in the * proxy interfaces. */ // 分析1：将所有方法封装成ProxyMethod对象 // 为java.lang.Object的hashCode、equals和toString方法添加代理方法。这是在代理接口中的方法之前完成的，以便 java.lang.Object 中的方法优先于代理接口中的重复方法。 addProxyMethod(hashCodeMethod); addProxyMethod(equalsMethod); addProxyMethod(toStringMethod); /* * Accumulate all of the methods from the proxy interfaces. */ // 遍历所有代理接口中的所有方法，并生成ProxyMethod对象 for (Class\u0026lt;?\u0026gt; intf : interfaces) { for (Method m : intf.getMethods()) { if (!Modifier.isStatic(m.getModifiers())) { addProxyMethod(m, intf); } } } /* * For each set of proxy methods with the same signature, * verify that the methods\u0026#39; return types are compatible. */ // 对于具有相同签名的每组代理方法，验证方法的返回类型是否兼容 for (List\u0026lt;ProxyMethod\u0026gt; sigmethods : proxyMethods.values()) { checkReturnTypes(sigmethods); } // 分析2：开始生成代理类的构造，方法，成员变量等等 // 生成代理类的构造方法 generateConstructor(); // 遍历ProxyMethod列表 for (List\u0026lt;ProxyMethod\u0026gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { // add static field for the Method object // 为Method对象添加静态字段 visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName, LJLR_METHOD, null, null); // Generate code for proxy method // 生成代理方法的代码 pm.generateMethod(this, className); } } // 生成代理类的静态代码块 generateStaticInitializer(); generateLookupAccessor(); // 第一步：计算 ClassFile 结构的大小（以字节为单位）。 magic 字段使用 4 个字节，10 个强制字段（minor_version、major_version、constant_pool_count、access_flags、this_class、super_class、interfaces_count、fields_count、methods_count 和 attribute_count）每个使用 2 个字节，每个接口也使用 2 个字节。 // 第二步：分配一个正确大小的 ByteVector并用 ClassFile 内容填充它。 // 也就是写入魔数、次版本号、主版本号、常量池等等。 // 第三步：转换为二进制数组输出 return toByteArray(); } 分析2：saveGeneratedFiles是用于保存生成的代理类文件的调试标志，如下所示：\n1 2 3 4 private static final boolean saveGeneratedFiles = java.security.AccessController.doPrivileged( new GetBooleanAction( \u0026#34;jdk.proxy.ProxyGenerator.saveGeneratedFiles\u0026#34;)); AccessController的doPrivileged方法需要传入PrivilegedAction接口，而PrivilegedAction接口中有一个run方法，run方法的返回值即为saveGeneratedFiles，又因为GetBooleanAction实现了PrivilegedAction接口，所以只需跟踪GetBooleanAction的run方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class GetBooleanAction implements java.security.PrivilegedAction\u0026lt;Boolean\u0026gt; { private String theProp; /** * Constructor that takes the name of the system property whose boolean * value needs to be determined. * * @param theProp the name of the system property. */ public GetBooleanAction(String theProp) { this.theProp = theProp; } public Boolean run() { return Boolean.getBoolean(theProp); } } 继续跟踪Boolean的getBoolean方法。\n1 2 3 4 5 6 7 8 public static boolean getBoolean(String name) { boolean result = false; try { result = parseBoolean(System.getProperty(name)); } catch (IllegalArgumentException | NullPointerException e) { } return result; } 很显然，调用了System类的getProperty方法，然后转换为boolean值返回，name其实就是\njdk.proxy.ProxyGenerator.saveGeneratedFiles，那么我们只需要在Proxy类的newProxyInstance方法之前，通过System类的setProperty方法设置该值为true即可保存代理类文件。\n1 2 3 4 5 6 7 8 9 10 public class Client { public static void main(String[] args) { System.setProperty(\u0026#34;jdk.proxy.ProxyGenerator.saveGeneratedFiles\u0026#34;, \u0026#34;true\u0026#34;); Grandfather grandfather = new Grandfather(); Action action = (Action) Proxy.newProxyInstance(Action.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Action.class}, new ActionInvocationHandler(grandfather)); action.recharge(); } } 运行过后，会在如下位置生成代理类，这也是接口都是public修饰时的情况。\n本例中生成的代理类如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public final class $Proxy0 extends Proxy implements Action { private static final Method m0; private static final Method m1; private static final Method m2; private static final Method m3; public $Proxy0(InvocationHandler var1) { super(var1); } public final int hashCode() { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final boolean equals(Object var1) { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final String toString() { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void recharge() { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m0 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;); m1 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m2 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;); m3 = Class.forName(\u0026#34;com.pengmj.proxy.Action\u0026#34;).getMethod(\u0026#34;recharge\u0026#34;); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup var0) throws IllegalAccessException { if (var0.lookupClass() == Proxy.class \u0026amp;\u0026amp; var0.hasFullPrivilegeAccess()) { return MethodHandles.lookup(); } else { throw new IllegalAccessException(var0.toString()); } } } 由上面代码可知：\n1、代理类$Proxy0继承自Proxy类，并实现了我们自己定义的Action接口；\n有一个疑问：问什么JDK动态代理只能基于接口进行代理？\n因为它已经继承了Proxy类了，而Java不支持多继承。\n2、代理类使用了final修饰，说明代理类无法被继承；\n3、接口中所有被代理的方法以及Object类的hashCode、equals、toString方法在static静态代码块中通过反射建立了method对象；\n4、当调用接口中所有被代理的方法以及Object类的hashCode、equals、toString方法时，都会转交给InvocationHandler的invoke方法；\n我们回到之前流程，当创建了代理类的构造器之后，就会调用newProxyInstance方法，继续跟踪看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private static Object newProxyInstance(Class\u0026lt;?\u0026gt; caller, // null if no SecurityManager Constructor\u0026lt;?\u0026gt; cons, InvocationHandler h) { /* * Invoke its constructor with the designated invocation handler. */ try { if (caller != null) { checkNewProxyPermission(caller, cons.getDeclaringClass()); } return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException | InstantiationException e) { throw new InternalError(e.toString(), e); } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else { throw new InternalError(t.toString(), t); } } } 很明显了，通过构造器直接newInstance创建代理类实例对象，构造方法传入的参数为h。至此，JDK动态代理的原理就讲解完成了。\n六、动态代理在Android上的运用 在Android上，动态代理也隐隐约约地存在着，比如网络请求框架Retrofit，它的create方法就使用了动态代理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { validateServiceInterface(service); return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {service}, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args); } }); } ","date":"2023-08-11T22:39:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","section":"post","tags":null,"title":"解读JDK动态代理"},{"categories":["Kotlin"],"contents":" 注：本文代码基于Kotlin 1.9.0\n前言 一般而言，Kotlin的协程实现分为两个层次：\n基础设施层：标准库的协程API，主要对协程提供了概念和语义上最基本的支持，API所在包名的前缀为kotlin.coroutines.*。基于此，本文主要内容就是解读Kotlin协程启动源码。\n业务框架层：协程的上层框架支持，API所在包名的前缀为kotlinx.coroutines.*。\n整体上，将通过Kotlin协程的基础设施创建的协程称为简单协程，将基于简单协程实现的各种业务层进行封装之后得到的协程称为复合协程。\n一、协程的创建 在Kotlin当中创建一个简单协程不是什么难事，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) 标准库中提供了一个createCoroutine方法，我们可以通过它来创建协程，不过这个协程并不会立即执行，我们先来看看它的声明:\n1 2 3 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; 这里解释下上面的声明：\n1、suspend ()-\u0026gt;T是createCoroutine方法的Receiver，Receiver是一个被suspend关键字修饰的挂起函数，这也是协程的执行体，我们不妨称它为协程体。这里补充一条Kotlin基础知识：Kotlin扩展的本质就是定义了一个函数，当程序用对象调用扩展方法时，Kotlin在编译过程中会执行静态解析，将调用扩展函数的调用者作为函数的第一个参数传入，也就是说，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，对于本文后面的内容来说，这是一个伏笔，叫它伏笔1吧；\n2、参数completion会在协程执行完成后调用，实际上就是协程的完成回调；\n3、返回值是一个Continuation对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动。\n二、协程的启动 调用continuation的resume方法之后，协程体会立即开始执行，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 此时要抛出本文要重点解决的问题：为什么调用continuation.resume(Unit)就会触发协程体的执行呢？\n如果按一般思路去理解，上面代码返回的变量continuation就是问题的突破口，只要找出continuation变量的真身，就能定位到resume方法的具体实现，从而找出触发协程体执行的所在。\nOK，一步步来，我们先看suspend方法的源码：\n1 public inline fun \u0026lt;R\u0026gt; suspend(noinline block: suspend () -\u0026gt; R): suspend () -\u0026gt; R = block suspend方法比较简单，把传入的挂起函数原封不动地返回，但是要注意：suspend方法是一个内联方法，而参数block是非内联的，意味着block在编译后会生成一个函数对象（匿名内部类），这里是埋下伏笔2。\ncreateCoroutine方法的声明我们前面讲过了，现在完整看下createCoroutine方法的源码：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 由源码可知，这里调用了2个参数的构造方法创建了SafeContinuation对象，其中第1个参数先不管，后面会讲到，第2个参数为COROUTINE_SUSPENDED。知道了continuation变量的实例对象是SafeContinuation，也就是说可以推测下，调用continuation变量的resume方法实际上是调用了SafeContinuation的resume方法，继续跟踪SafeContinuation的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal expect class SafeContinuation\u0026lt;in T\u0026gt; : Continuation\u0026lt;T\u0026gt; { internal constructor(delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any?) @PublishedApi internal constructor(delegate: Continuation\u0026lt;T\u0026gt;) @PublishedApi internal fun getOrThrow(): Any? override val context: CoroutineContext override fun resumeWith(result: Result\u0026lt;T\u0026gt;): Unit } public interface Continuation\u0026lt;in T\u0026gt; { public val context: CoroutineContext public fun resumeWith(result: Result\u0026lt;T\u0026gt;) } 通过观察SafeContinuation的源码，可以得到3个结论：\n1、SafeContinuation类是expect关键字修饰，意味着它是一个跨平台类，也就是说不同平台该类有不同的实现。这里先说明，后面我们只看Kotlin平台下的具体实现；\n2、SafeContinuation类实现了接口Continuation；\n3、SafeContinuation类中并没有resume方法，然而我们先前推测过，调用continuation的resume方法实际上是调用了SafeContinuation的resume方法，很显然这是错的。\n看到这里或许已经一头雾水了，但是先不要着急哈，继续寻找突破口，先看下continuation变量的resume方法的源码：\n1 2 public inline fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resume(value: T): Unit = resumeWith(Result.success(value)) 由源码可知，resume方法是接口Continuation的一个扩展方法，其内部调用了Continuation的resumeWith方法，结合前面说的，SafeContinuation实现了接口Continuation，那么最终调用的就是SafeContinuation的resumeWith方法了。\n但是SafeContinuation是一个跨平台类，要先找到它的具体实现，在Kotlin平台上的具体实现位置为：\nSafeContinuation具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 internal actual class SafeContinuation\u0026lt;in T\u0026gt; internal actual constructor( private val delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any? ) : Continuation\u0026lt;T\u0026gt;, CoroutineStackFrame { @PublishedApi internal actual constructor(delegate: Continuation\u0026lt;T\u0026gt;) : this(delegate, UNDECIDED) public actual override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { while (true) { // lock-free loop val cur = this.result // atomic read when { cur === UNDECIDED -\u0026gt; if (RESULT.compareAndSet(this, UNDECIDED, result.value)) return cur === COROUTINE_SUSPENDED -\u0026gt; if (RESULT.compareAndSet(this, COROUTINE_SUSPENDED, RESUMED)) { delegate.resumeWith(result) return } else -\u0026gt; throw IllegalStateException(\u0026#34;Already resumed\u0026#34;) } } } } 先前讲过，创建SafeContinuation对象时传入的第2个参数为COROUTINE_SUSPENDED，那么可以知道，SafeContinuation的resumeWith方法执行后实际上调用的是delegate变量的resumeWith方法，于是乎，现在可以从找continuation变量的真身转为找delegate变量的真身了，因为SafeContinuation只是个包装马甲，真正做事情的是delegate变量，那么delegate变量又是什么了？\nSafeContinuation对象被创建是通过调用2个参数的构造方法，其中delegate变量是第1个参数待传入，我们可以回去跟踪下SafeContinuation被创建时的源码：\n1 2 3 4 5 6 7 8 9 10 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) public expect fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; public expect fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; 由源码可知，delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() 而且发现createCoroutineUnintercepted方法和intercepted方法都是跨平台方法，要先找到它们的具体实现，在Kotlin平台上的具体实现位置为：\ncreateCoroutineUnintercepted方法和intercepted方法的具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) // ① return if (this is BaseContinuationImpl) create(probeCompletion) // ② else createCoroutineFromSuspendFunction(probeCompletion) { // ③ (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } private inline fun \u0026lt;T\u0026gt; createCoroutineFromSuspendFunction( completion: Continuation\u0026lt;T\u0026gt;, crossinline block: (Continuation\u0026lt;T\u0026gt;) -\u0026gt; Any? ): Continuation\u0026lt;Unit\u0026gt; { val context = completion.context // label == 0 when coroutine is not started yet (initially) or label == 1 when it was return if (context === EmptyCoroutineContext) object : RestrictedContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } else object : ContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;, context) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } } public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this // ④ 这里解释下上面的标号地方：\n标号①、probeCoroutineCreated方法如下：\n1 2 3 internal fun \u0026lt;T\u0026gt; probeCoroutineCreated(completion: Continuation\u0026lt;T\u0026gt;): Continuation\u0026lt;T\u0026gt; { return completion } 代码很简单，就是把传入的completion原封不动的返回。\n标号②、如果suspend () -\u0026gt; T是BaseContinuationImpl的子类，那么调用BaseContinuationImpl类的create方法，并返回Continuation\u0026lt;Unit\u0026gt;，该方法如下：\n1 2 3 4 5 6 7 8 internal abstract class BaseContinuationImpl( public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public open fun create(completion: Continuation\u0026lt;*\u0026gt;): Continuation\u0026lt;Unit\u0026gt; { throw UnsupportedOperationException(\u0026#34;create(Continuation) has not been overridden\u0026#34;) } } BaseContinuationImpl类的create方法默认没有实现，估计是其子类实现了。\n标号③、如果suspend () -\u0026gt; T不是BaseContinuationImpl的子类，那么调用createCoroutineFromSuspendFunction方法，并返回Continuation\u0026lt;Unit\u0026gt;，其方法闭包中会将suspend () -\u0026gt; T强制转换为Function1接口，并调用Function1接口的invoke方法。\n解释下createCoroutineFromSuspendFunction方法的实现：\ncreateCoroutineFromSuspendFunction方法内部会先判断context变量是否为EmptyCoroutineContext对象，如果是的话则返回RestrictedContinuationImpl对象，否则就返回ContinuationImpl对象。\n标号④、将调用Continuation接口扩展方法intercepted的调用者强制转换为ContinuationImpl对象，如果转换成功，则调用ContinuationImpl的intercepted方法，否则返回调用者本身。\nOK，上面分析那么多，发现有2个名字比较显眼：ContinuationImpl和BaseContinuationImpl，可以认为它们和delegate的构建肯定有关系，到这里就不往下看源码了，因为看不懂了，啊哈哈～。\n既然按一般思路去跟踪源码无法定位到问题，那么只能反编译源码了，去看看编译器是否在编译后添加了“魔法”，回顾下先前协程启动的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 运行过上面代码后，点击IDEA的Tools-\u0026gt;Kotlin-\u0026gt;Show Kotlin ByteCode来查看字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 // ================com/pengmj/kotlincoroutine/SampleKt.class ================= // class version 52.0 (52) // access flags 0x31 public final class com/pengmj/kotlincoroutine/SampleKt { // access flags 0x19 public final static main()V L0 LINENUMBER 6 L0 L1 LINENUMBER 9 L1 L2 LINENUMBER 6 L2 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ACONST_NULL INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V CHECKCAST kotlin/jvm/functions/Function1 ASTORE 1 L3 ALOAD 1 L4 LINENUMBER 9 L4 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 DUP INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.\u0026lt;init\u0026gt; ()V CHECKCAST kotlin/coroutines/Continuation INVOKESTATIC kotlin/coroutines/ContinuationKt.createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; L5 LINENUMBER 6 L5 ASTORE 0 L6 LINENUMBER 17 L6 ALOAD 0 ASTORE 1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; ASTORE 2 L7 ALOAD 1 GETSTATIC kotlin/Result.Companion : Lkotlin/Result$Companion; POP ALOAD 2 INVOKESTATIC kotlin/Result.constructor-impl (Ljava/lang/Object;)Ljava/lang/Object; L8 INVOKEINTERFACE kotlin/coroutines/Continuation.resumeWith (Ljava/lang/Object;)V (itf) L9 LINENUMBER 18 L9 RETURN L10 LOCALVARIABLE continuation Lkotlin/coroutines/Continuation; L6 L10 0 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x1009 public static synthetic main([Ljava/lang/String;)V INVOKESTATIC com/pengmj/kotlincoroutine/SampleKt.main ()V RETURN MAXSTACK = 0 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=2, d1={\u0026#34;\\u0000\\u0008\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001\\u00a8\\u0006\\u0002\u0026#34;}, d2={\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.class ================= // class version 52.0 (52) // access flags 0x30 // signature Lkotlin/coroutines/jvm/internal/SuspendLambda;Lkotlin/jvm/functions/Function1\u0026lt;Lkotlin/coroutines/Continuation\u0026lt;-Ljava/lang/Integer;\u0026gt;;Ljava/lang/Object;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin.coroutines.jvm.internal.SuspendLambda implements kotlin.jvm.functions.Function1\u0026lt;kotlin.coroutines.Continuation\u0026lt;? super java.lang.Integer\u0026gt;, java.lang.Object\u0026gt; final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { // access flags 0x11 public final invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object; @Lorg/jetbrains/annotations/Nullable;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 INVOKESTATIC kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED ()Ljava/lang/Object; L0 LINENUMBER 6 L0 ASTORE 3 ALOAD 0 GETFIELD com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.label : I TABLESWITCH 0: L1 default: L2 L1 ALOAD 1 INVOKESTATIC kotlin/ResultKt.throwOnFailure (Ljava/lang/Object;)V L3 LINENUMBER 7 L3 BIPUSH 88 ISTORE 2 L4 LINENUMBER 8 L4 BIPUSH 123 ILOAD 2 IADD INVOKESTATIC kotlin/coroutines/jvm/internal/Boxing.boxInt (I)Ljava/lang/Integer; L5 ARETURN L2 LINENUMBER 6 L2 NEW java/lang/IllegalStateException DUP LDC \u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34; INVOKESPECIAL java/lang/IllegalStateException.\u0026lt;init\u0026gt; (Ljava/lang/String;)V ATHROW LOCALVARIABLE x I L4 L5 2 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$1; L3 L2 0 LOCALVARIABLE $result Ljava/lang/Object; L3 L2 1 MAXSTACK = 3 MAXLOCALS = 4 @Lkotlin/coroutines/jvm/internal/DebugMetadata;(f=\u0026#34;sample.kt\u0026#34;, l={}, i={}, s={}, n={}, m=\u0026#34;invokeSuspend\u0026#34;, c=\u0026#34;com.pengmj.kotlincoroutine.SampleKt$main$continuation$1\u0026#34;) // access flags 0x0 \u0026lt;init\u0026gt;(Lkotlin/coroutines/Continuation;)V ALOAD 0 ICONST_1 ALOAD 1 INVOKESPECIAL kotlin/coroutines/jvm/internal/SuspendLambda.\u0026lt;init\u0026gt; (ILkotlin/coroutines/Continuation;)V RETURN MAXSTACK = 3 MAXLOCALS = 2 // access flags 0x0 I label // access flags 0x11 // signature (Lkotlin/coroutines/Continuation\u0026lt;*\u0026gt;;)Lkotlin/coroutines/Continuation\u0026lt;Lkotlin/Unit;\u0026gt;; // declaration: kotlin.coroutines.Continuation\u0026lt;kotlin.Unit\u0026gt; create(kotlin.coroutines.Continuation\u0026lt;?\u0026gt;) public final create(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; @Lorg/jetbrains/annotations/NotNull;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 ALOAD 1 LDC \u0026#34;completion\u0026#34; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullParameter (Ljava/lang/Object;Ljava/lang/String;)V NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ALOAD 1 INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V ASTORE 2 ALOAD 2 ARETURN L1 LOCALVARIABLE this Lkotlin/coroutines/jvm/internal/BaseContinuationImpl; L0 L1 0 LOCALVARIABLE completion Lkotlin/coroutines/Continuation; L0 L1 1 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x11 public final invoke(Ljava/lang/Object;)Ljava/lang/Object; ALOAD 0 ALOAD 1 CHECKCAST kotlin/coroutines/Continuation INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.create (Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; CHECKCAST com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.invokeSuspend (Ljava/lang/Object;)Ljava/lang/Object; ARETURN MAXSTACK = 2 MAXLOCALS = 2 @Lkotlin/Metadata;(mv={1, 9, 0}, k=3, d1={\u0026#34;\\u0000\\n\\n\\u0000\\n\\u0002\\u0010\\u0008\\n\\u0002\\u0008\\u0002\\u0010\\u0000\\u001a\\u00020\\u0001H\\u008a@\\u00a2\\u0006\\u0004\\u0008\\u0002\\u0010\\u0003\u0026#34;}, d2={\u0026#34;\u0026lt;anonymous\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;invoke\u0026#34;, \u0026#34;(Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;}) OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.class ================= // class version 52.0 (52) // access flags 0x31 // signature Ljava/lang/Object;Lkotlin/coroutines/Continuation\u0026lt;Ljava/lang/Integer;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin.coroutines.Continuation\u0026lt;java.lang.Integer\u0026gt; public final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin/coroutines/Continuation { OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x1 public getContext()Lkotlin/coroutines/CoroutineContext; @Lorg/jetbrains/annotations/NotNull;() // invisible L0 LINENUMBER 11 L0 GETSTATIC kotlin/coroutines/EmptyCoroutineContext.INSTANCE : Lkotlin/coroutines/EmptyCoroutineContext; CHECKCAST kotlin/coroutines/CoroutineContext ARETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public resumeWith(Ljava/lang/Object;)V // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 LINENUMBER 14 L0 ALOAD 1 INVOKESTATIC kotlin/Result.toString-impl (Ljava/lang/Object;)Ljava/lang/String; ASTORE 2 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L2 L3 LINENUMBER 15 L3 RETURN L4 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L4 0 LOCALVARIABLE result Ljava/lang/Object; L0 L4 1 MAXSTACK = 2 MAXLOCALS = 3 // access flags 0x0 \u0026lt;init\u0026gt;()V L0 LINENUMBER 9 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=1, d1={\u0026#34;\\u0000%\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0008\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0003\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0002*\\u0001\\u0000\\u0008\\n\\u0018\\u00002\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\u0001J\\u001e\\u0010\\u0007\\u001a\\u00020\\u00082\\u000c\\u0010\\u0009\\u001a\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\nH\\u0016\\u00f8\\u0001\\u0000\\u00a2\\u0006\\u0002\\u0010\\u000bR\\u0014\\u0010\\u0003\\u001a\\u00020\\u00048VX\\u0096\\u0004\\u00a2\\u0006\\u0006\\u001a\\u0004\\u0008\\u0005\\u0010\\u0006\\u0082\\u0002\\u0004\\n\\u0002\\u0008\\u0019\\u00a8\\u0006\\u000c\u0026#34;}, d2={\u0026#34;com/pengmj/kotlincoroutine/SampleKt$main$continuation$2\u0026#34;, \u0026#34;Lkotlin/coroutines/Continuation;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;context\u0026#34;, \u0026#34;Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;getContext\u0026#34;, \u0026#34;()Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;resumeWith\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;Lkotlin/Result;\u0026#34;, \u0026#34;(Ljava/lang/Object;)V\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================META-INF/Kotlin.kotlin_module ================= \u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000 \u0026amp; \u001acom.pengmj.kotlincoroutine\u0012\u0008SampleKt\u0026#34;\u0000*\u0000 在上面一大片字节码中，我们着重看这几行：\n1 2 3 4 5 6 7 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { } 由上面字节码可知：\n编译器帮我们创建了2个匿名内部类SampleKt$main$continuation$1和SampleKt$main$continuation$2，它们的类名是\u0026lt;FileName\u0026gt;Kt$\u0026lt;FunctionName\u0026gt;$continuation$1这样的形式，其中\u0026lt;FileName\u0026gt;和\u0026lt;FunctionName\u0026gt;指代的是代码所在的文件名和函数名。\n这里会有个疑问：这些匿名内部类是哪来的？\n第一个匿名内部类SampleKt$main$continuation$1，它就是我们的协程体，那个用以创建协程的suspend方法传入的Lambda表达式，即suspend ()-\u0026gt;R，也对应了前面说过的埋下伏笔2；\n并且SampleKt$main$continuation$1继承了抽象类SuspendLambda，还实现了Function1接口，继续追踪SuspendLambda时，发现它间接实现了Continuation接口，与先前提到的ContinuationImpl、BaseContinuationImpl存在继承关系，如下图所示：\n第二个匿名内部类SampleKt$main$continuation$2，从它的字节码中可以看出它有getContext方法、resumeWith方法以及无参构造方法，可以猜到它就是createCoroutine方法传入的对象表达式，学过Kotlin基础的应该明白，对象表达式其实是增强版的匿名内部类。\n到目前为止还看不出什么，还需要把字节码再转译一下，点击Kotlin ByteCode面板上的Decompile按钮，转译后的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } }); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { // ① @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } // $FF: synthetic method public static void main(String[] var0) { main(); } } 这里解释下上面的标号地方：\n标号①、调用了ContinuationKt的createCoroutine方法，第一个参数传入var1变量，而var1变量的类型是Function1，对应的Koltin实际代码为：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 前面提过埋下伏笔1，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，此时可以推断出，这里的var1就是第一个匿名内部类SampleKt$main$continuation$1的实例；createCoroutine方法第二个参数则是completion回调，也是前面说的第二个匿名内部类SampleKt$main$continuation$2。\n标号②、还记得前面说的createCoroutineUnintercepted方法和intercepted方法的具体实现吗？\n1 2 3 4 5 6 7 8 9 10 11 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) return if (this is BaseContinuationImpl) create(probeCompletion) // ① else createCoroutineFromSuspendFunction(probeCompletion) { (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } 因为SampleKt$main$continuation$1是BaseContinuationImpl的子类，所以会执行上面①处的create方法，此处调用的是BaseContinuationImpl类的create方法，但是BaseContinuationImpl类中没有具体实现create方法，所以由子类SampleKt$main$continuation$1来实现，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } }); } 发现在create方法中又创建了一个匿名内部类对象var2，类型为Function1，那么可以知道createCoroutineUnintercepted方法返回的就是新的SampleKt$main$continuation$1对象。\n有一个疑问：var2和外部new Function1创建的匿名内部类对象var1有什么区别和关联呢？\n先声明下，从Kotlin代码反编译而来的Java代码可能会出现不符合Java代码执行逻辑的情况。外部创建的匿名内部类对象var1主要是用来帮助启动协程，因此completion传入为null；而create方法中创建的匿名内部类对象var2主要是用来管理协程的状态。\n如果你看到本文的后续内容后，可能会回过头来问，为什么var2可以调用var1中的invokeSuspend方法，它们不是两个不同的对象吗？\n是的，没错，它们的确是两个不同的对象，但是因为反编译后的源码不一定能准确的表达完整Java代码执行逻辑，这里我再手动转译一下，应该就能看明白了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public final class SampleKt { final class SampleKt$main$continuation$1 extends SuspendLambda implements Function1 { public SampleKt$main$continuation$1(Continuation completion){ super(completion) } int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new SampleKt$main$continuation$1(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } } public static final void main() { SampleKt$main$continuation$1 var1 = new SampleKt$main$continuation$1(null); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } } 还记得我们最初的那个任务吗？就是找到delegate变量的真身，我们已经知道delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() createCoroutineUnintercepted方法已经分析了，返回的就是新的SampleKt$main$continuation$1对象，那么继续看intercepted方法：\n1 2 public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this 很明显，SampleKt$main$continuation$1也是ContinuationImpl的子类，因而这里调用了ContinuationImpl的intercepted方法：\n1 2 3 4 5 6 7 8 9 10 internal abstract class ContinuationImpl( completion: Continuation\u0026lt;Any?\u0026gt;?, private val _context: CoroutineContext? ) : BaseContinuationImpl(completion) { public fun intercepted(): Continuation\u0026lt;Any?\u0026gt; = intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this) .also { intercepted = it } } 上面代码说明如果设置了协程的拦截器，那么就从上下文中去找，如果上下文中也没有，则用自身SampleKt$main$continuation$1，最后赋值。很显然，本例是没有设置协程的拦截器，那么intercepted方法返回的就是SampleKt$main$continuation$1，所以delegate变量的真身就是SampleKt$main$continuation$1。\n接下来看看delegate变量调用了resumeWith方法的流程，因为SampleKt$main$continuation$1中没有resumeWith方法，再根据继承关系，我们看BaseContinuationImpl类的resumeWith方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal abstract class BaseContinuationImpl( // This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet // it has a public getter (since even untrusted code is allowed to inspect its call stack). public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public final override fun resumeWith(result: Result\u0026lt;Any?\u0026gt;) { // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume var current = this var param = result while (true) { // Invoke \u0026#34;resume\u0026#34; debug probe on every resumed continuation, so that a debugging library infrastructure // can precisely track what part of suspended callstack was already resumed probeCoroutineResumed(current) with(current) { val completion = completion!! // fail fast when trying to resume continuation without completion val outcome: Result\u0026lt;Any?\u0026gt; = try { val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) } catch (exception: Throwable) { Result.failure(exception) } releaseIntercepted() // this state machine instance is terminating if (completion is BaseContinuationImpl) { // unrolling recursion via loop current = completion param = outcome } else { // top-level completion reached -- invoke and return completion.resumeWith(outcome) return } } } } protected abstract fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? } 上面代码的重点是调用了invokeSuspend方法，这是个抽象方法，由子类SampleKt$main$continuation$1实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } } } 这里invokeSuspend方法通过状态机来执行协程体中的逻辑，最终返回处理结果Boxing.boxInt(123 + x)，很显然，invokeSuspend方法其实就是suspend {}闭包中的处理逻辑。\n回到BaseContinuationImpl类的resumeWith方法，看下这2行代码：\n1 2 val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return 如果invokeSuspend方法返回值是挂起状态COROUTINE_SUSPENDED，则resumeWith方法直接退出，否则就通过调用completion.resumeWith(outcome)传递给外部。\n至此，协程启动流程就讲解完成了。\n","date":"2023-07-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBkotlin%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81/","section":"post","tags":null,"title":"解读Kotlin协程启动源码"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 事件分发机制是View体系中一个非常重要的核心知识点，也是难点，不少Android开发者搞了几年的Android，或许也还没完全弄明白它的原理。\n另外，在Android开发过程中难免会碰到滑动冲突的场景，而解决滑动冲突的理论基础就是事件分发机制，因此掌握事件分发机制十分必要。\n接下来，本文会先从实践的角度总结出结论，然后从源码的角度去看事件分发的过程，最后利用前面所学知识去演示如何解决开发中常见的滑动冲突。\n二、从实践的角度总结出结论 2.1、实践前的理论知识 事件分发主要涉及3个方法，代码如下：\n1 2 3 4 5 6 7 8 // Activity、ViewGroup、View都有提供该方法，该方法的作用：事件的分发 public boolean dispatchTouchEvent(MotionEvent event) // 仅ViewGroup提供该方法，该方法的作用：事件的拦截 public boolean onInterceptTouchEvent(MotionEvent ev) // Activity、View都有提供该方法，该方法的作用：事件的处理 public boolean onTouchEvent(MotionEvent event) 这3个方法有2个共同点，第一个共同点就是都有一个入参MotionEvent，它表示当用户触摸屏幕时所进行的每一次交互（每一次交互指的是手指在UI控件上从按下、滑动再到抬起的过程），都会产生一次同一序列的触摸事件，这些触摸事件被封装进了MotionEvent类里，通过以下方法可以获取触摸事件的类型，代码如下：\n1 val action = ev?.action 在事件分发过程中，常用的触摸事件类型有以下4种：\nACTION_DOWN：表示手指按下的事件。\nACTION_MOVE：表示手指移动的事件。\nACTION_UP：表示手指抬起的事件。\nACTION_CANCEL：表示当前触摸事件已终止。\n第二个共同点是都需要返回boolean类型的返回值，关于返回值的作用是什么后面会讲到。\n那么，事件分发中这3个方法之间有什么关系呢？\n它们之间的关系可以用以下伪代码来表示：\n1 2 3 4 5 6 7 8 9 public boolean dispatchTouchEvent(MotionEvent ev) { boolean result = false; if (onInterceptTouchEvent(ev)) { result = onTouchEvent(ev); } else { result = child.dispatchTouchEvent(ev); } return result; } 通过伪代码，先大致了解下触摸事件的传递规则：对于一个根ViewGroup来说，触摸事件产生后，首先会传递给它，这时它的dispatchTouchEvent方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。\n2.2、实践开始 开始前，我们先编写一个UI界面，本文之后的讲解都是基于该UI界面的层次结构，UI界面运行后的效果如下：\n从运行效果图可以知道，该UI界面内部嵌套了一个紫色的MyViewGroup2控件、一个绿色的MyViewGroup1控件以及一个黑色的MyView控件，布局文件代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup2 android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;@color/purple_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup1 android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;@color/black\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup1\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup2\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 其中MyViewGroup2控件和MyViewGroup1控件的实现是一样的，都是继承自ConstraintLayout，以MyViewGroup2为例，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyViewGroup2 : ConstraintLayout { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 而MyView继承自View，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyView : View { constructor(context: Context?) : super(context) constructor( context: Context?, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 最后，MainActivity的代码如下：\n1 2 3 4 5 6 7 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } 之前介绍事件分发的相关方法时，代码注释里有描述过，在Activity、ViewGroup、View中都有dispatchTouchEvent方法，在Activity、View中都有onTouchEvent方法，对于ViewGroup而言，则多了一个onInterceptTouchEvent方法。\n因此，本文先讲解不包含onInterceptTouchEvent方法时的事件分发过程，然后再讲解包含onInterceptTouchEvent方法时的事件分发过程。\n2.2.1、ACTION_DOWN的事件分发过程（不包含onInterceptTouchEvent方法的情况） 既然先讨论的是不包含onInterceptTouchEvent方法的情况，那么只需将MainActivity、MyViewGroup2、MyViewGroup1、MyView都重写dispatchTouchEvent方法和onTouchEvent方法，为了验证在这种情况下的ACTION_DOWN事件分发过程，都打上日志进行观察，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.onTouchEvent(event) } 为什么要加上if (LOG_ACTION_DOWN)判断条件呢？这是一个开关，用于日志过滤，方便观察。本文所有源码将在文末贴出。\n2.2.1.1、在dispatchTouchEvent方法中拦截ACTION_DOWN事件 在dispatchTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道dispatchTouchEvent方法需要返回boolean类型的返回值，它的返回值有3种情况：\n情况一：返回super.dispatchTouchEvent dispatchTouchEvent方法默认返回super.dispatchTouchEvent，表示不拦截任何事件，它是View体系中默认的事件分发过程。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n情况二：返回true 在dispatchTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.dispatchTouchEvent(ev) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true之后，ACTION_DOWN事件就会直接停止传递，后面的子控件都不会接收到这个事件。\n情况三：返回false 和之前返回true的情况一样，这里返回false的情况也有两种方式拦截ACTION_DOWN事件，并且两种情况下的表现对于ACTION_DOWN事件来说是没区别的，最终打印结果是一样的，所以这里演示的是仅拦截ACTION_DOWN事件。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return false } } return super.dispatchTouchEvent(ev) } 运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup2的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup1的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyView的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回false拦截事件之后，事件并不会直接停止传递，而是向父控件的onTouchEvent方法回传。\n2.2.1.2、在onTouchEvent方法中拦截ACTION_DOWN事件 在onTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和View体系中默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面的结论也是针对情况二来讲。\n在onTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论在哪个控件的onTouchEvent方法中拦截ACTION_DOWN事件并返回true，事件都会直接停止传递，后面的父控件都不会接收到这个事件。\n2.2.2、ACTION_DOWN的事件分发过程（包含onInterceptTouchEvent方法的情况） 在onInterceptTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onInterceptTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onInterceptTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面结论也是针对情况二来讲。\n在onInterceptTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n若在ViewGroup的onInterceptTouchEvent方法中拦截ACTION_DOWN事件，只会改变ACTION_DOWN事件的正常流向，事件会直接流向自己的onTouchEvent方法中，并不会截断事件。\n2.2.3、多个方法拦截的情况 一般我们在拦截事件时，都是共同使用onInterceptTouchEvent方法和onTouchEvent方法的，通过在onInterceptTouchEvent方法中返回true，将ACTION_DOWN消息流向自己的onTouchEvent方法中，然后在该onTouchEvent方法中返回true拦截事件。\n下面以MyViewGroup1为例，在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true，在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true。\n修改MyViewGroup1的onInterceptTouchEvent方法和onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n2.2.4、ACTION_MOVE和ACTION_UP的事件分发过程 ACTION_MOVE和ACTION_UP事件的分发过程与之前所讲的ACTION_DOWN事件并不是完全一样的，为了对比两者，我会用黑色箭头表示ACTION_DOWN的事件分发过程，用红色箭头合并表示ACTION_MOVE和ACTION_UP的事件分发过程，为什么两者都用红色箭头表示呢？这是因为ACTION_MOVE和ACTION_UP的事件流向是完全相同的，后面都以ACTION_MOVE事件来讲解。\n2.2.4.1、ACTION_MOVE默认的事件分发过程 ACTION_MOVE默认的事件分发过程，和之前所讲的ACTION_DOWN事件默认的事件分发过程是一样的，也就是所有的事件分发方法都不做拦截处理。\n修改MainActivity、MyView的dispatchTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 修改MyViewGroup2、MyViewGroup1的dispatchTouchEvent方法、onInterceptTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.2、在dispatchTouchEvent方法中拦截ACTION_MOVE事件 按照之前在dispatchTouchEvent方法中拦截ACTION_DOWN事件的写法，同样地，在dispatchTouchEvent方法中拦截ACTION_MOVE事件，比如说修改MyViewGroup2的dispatchTouchEvent方法，你可能会写下如下代码：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } } return super.dispatchTouchEvent(ev) 然而代码运行后，发现并不能如愿地看到想要的ACTION_MOVE日志，也就是说代码没有起作用，这是因为ACTION_MOVE事件根本就不会流到MyViewGroup2的dispatchTouchEvent方法中，前面讲过，默认情况下，ACTION_MOVE事件的流向是从MainActivity的dispatchTouchEvent方法直接到MainActivity的onTouchEvent方法。\n那如何让ACTION_MOVE事件继续往子控件流向呢？\n解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。其中前一种方式与后两种方式对于ACTION_MOVE事件的流向，它们的表现形式是不一样的；后两种方式对于ACTION_MOVE事件来说没区别，最终打印结果是一样的，所以本文后面会介绍第一种方式和第三种方式。\n2.2.4.2.1、仅拦截ACTION_DOWN事件 在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。\n2.2.4.2.2、拦截所有事件 在MainActivity的dispatchTouchEvent方法中拦截所有事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回true拦截事件之后，ACTION_MOVE事件的流向与ACTION_DOWN事件的完全相同，事件会直接停止传递，后面的子控件都不会接收到这个事件。\n2.2.4.3、在onTouchEvent方法中拦截ACTION_MOVE事件 和在dispatchTouchEvent方法中拦截ACTION_MOVE事件相似，对于希望在onTouchEvent方法中拦截ACTION_MOVE事件，解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。又因为这里只有仅拦截ACTION_DOWN事件和拦截所有事件的表现是不一样的，所以本文只会演示这2种。\n2.2.4.3.1、仅拦截ACTION_DOWN事件 在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun onTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n此处结论同2.2.4.2.1小节。\n2.2.4.3.2、拦截所有事件 在MainActivity的onTouchEvent方法中拦截所有事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截所有事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论ACTION_DOWN消息的流向是怎样的，只要最终流到onTouchEvent函数中就行。假设控件A最终在onTouchEvent函数中消费了ACTION_DOWN消息，那么ACTION_MOVE消息的流向就是先流到控件A的dispatchTouchEvent函数中，最终直接流到控件A的onTouchEvent函数中，进而消息停止传递。\n2.2.4.4、多个方法拦截的情况 注：下面演示都是拦截所有事件\n2.2.4.4.1、组合dispatchTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyView的dispatchTouchEvent方法中返回false，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyView的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return false } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.2、组合onInterceptTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyViewGroup1的onInterceptTouchEvent方法中返回true，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyViewGroup1的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.3、一种特殊情况 在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_MOVE事件返回true，而在MyView的onTouchEvent方法中返回true*。\n修改MyViewGroup2的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return super.onInterceptTouchEvent(ev) } 修改MyView的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: onTouchEvent -\u0026gt; ACTION_CANCEL ACTION_MOVE事件分发过程如下图所示：\n本来ACTION_MOVE事件依然会从MainActivity的dispatchTouchEvent方法流向子控件，但是在到达MyViewGroup2的onInterceptTouchEvent方法时，ACTION_MOVE事件被拦截了。到这里，这次的ACTION_MOVE事件就没有了，变成了ACTION_CANCEL事件继续向子控件传递，一直传递到ACTION_MOVE事件原本要传递的位置，通知所有被截断的子控件，它们的事件取消了，后面没有事件再传递过来。\n三、从源码的角度去看事件分发的过程 3.1、Activity的事件分发过程 当用户触摸屏幕的时候，触摸事件就会传递给当前的Activity，由Activity的dispatchTouchEvent方法进行事件分发，所以先从该方法进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // android.app.Activity public boolean dispatchTouchEvent(MotionEvent ev) { // 分析1 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 分析2 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 分析3 return onTouchEvent(ev); } 分析1：这里是个if条件判断，如果触摸事件的类型是ACTION_DOWN，那么调用onUserInteraction方法，onUserInteraction方法的解释如下：\n1 2 3 4 5 6 7 // android.app.Activity // 当用户与屏幕交互（例如触摸、键盘输入或轨迹球滚动）时，系统会调用该方法 // 此回调和onUserLeaveHint方法旨在帮助Activity智能管理状态栏通知；具体来说，用于帮助Activity确定取消通知的适当时间 // 所有对Activity的onUserLeaveHint回调的调用都将伴随对onUserInteraction调用。这确保Activity将被告知相关的用户活动，例如下拉通知窗格并触摸那里的项目 public void onUserInteraction() { } 分析2：这里有也是个if条件判断，它调用了getWindow的superDispatchTouchEvent方法，一旦if条件为true成立，那么直接return true，整个dispatchTouchEvent方法便会执行完毕，后面的onTouchEvent方法不会被触发。\n继续看getWindow方法，代码如下：\n1 2 3 4 5 // android.app.Activity public Window getWindow() { return mWindow; } getWindow方法返回的是一个mWindow，而mWindow的初始化在Activity的attach方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // android.app.Activity final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); // ... } 可以看到，mWindow是一个PhoneWindow对象，也就是说之前if条件中getWindow的superDispatchTouchEvent方法实际上是调用了PhoneWindow对象的superDispatchTouchEvent方法，那么继续看PhoneWindow对象的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 // com.android.internal.policy.PhoneWindow @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } PhoneWindow对象的superDispatchTouchEvent方法又转接给了mDecor的superDispatchTouchEvent方法，而mDecor是一个DecorView对象，它是窗口的顶层视图，包含窗口装饰，DecorView初始化的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // com.android.internal.policy.PhoneWindow @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the // decor, when theme attributes and the like are crysta // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } // ... } private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted \u0026amp;\u0026amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } else { mDecor.setWindow(this); } // ... } protected DecorView generateDecor(int featureId) { // System process doesn\u0026#39;t have application context and in that case we need to directly // the context we have. Otherwise we want the application context, so we don\u0026#39;t cling to // activity. // ... return new DecorView(context, featureId, this, getAttributes()); } DecorView是在installDecor方法中被初始化的，此处代码和Activity的setContentView方法的源码相关联，只是这里的分析不是本文的重点，所以不会展开讲解。\nOK，回到之前流程，那么调用的是DecorView的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 // com.android.internal.policy.DecorView public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } } DecorView继承自FrameLayout，FrameLayout继承自ViewGroup，而FrameLayout没有重写dispatchTouchEvent方法，那么super.dispatchTouchEvent调用的就是ViewGroup的dispatchTouchEvent方法了。\n至此，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup。\n分析3：如果getWindow的superDispatchTouchEvent方法返回false，那么if条件判断不成立，就会继续执行Activity的onTouchEvent方法。\n继续看Activity的onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 // android.app.Activity public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 这里调用了mWindow的shouldCloseOnTouch方法，我们知道，mWindow的实现类是PhoneWindow，所以shouldCloseOnTouch方法的具体实现应该就在PhoneWindow对象里，可惜PhoneWindow中并没有实现该方法，所以只能找Window对象本身了，果然Window类下有shouldCloseOnTouch方法的实现，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // android.view.Window @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public boolean shouldCloseOnTouch(Context context, MotionEvent event) { final boolean isOutside = event.getAction() == MotionEvent.ACTION_UP \u0026amp;\u0026amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside \u0026amp;\u0026amp; peekDecorView() != null \u0026amp;\u0026amp; isOutside) { return true; } return false; } isOutside表示触摸位置是否在DecorView的外部，它的判断逻辑为：如果触摸事件为ACTION_UP事件并且触摸事件的坐标x，y超出了DecorView边界时，则认为触摸位置在DecorView的外部；如果触摸事件为ACTION_OUTSIDE，那么也认为触摸位置在DecorView的外部。\n然后来到if条件的判断了，第一个条件是一个mCloseOnTouchOutside布尔值，它表示点击DecorView外部时是否可以关闭。如果将Activity设置成Dialog样式的时候，可以通过setCloseOnTouchOutside方法设置mCloseOnTouchOutside布尔值为true；第二个条件是一个peekDecorView方法，它返回的是mDecor对象，也就是判断mDecor对象是否为null；第三个条件就是我们的isOutside值了。\n如果同时满足上面所说的3个条件，那么整个shouldCloseOnTouch方法就会返回true，否则返回false。但是一般情况下很少将Activity设置为Dialog样式，所以也就用不到setCloseOnTouchOutside方法，所以mCloseOnTouchOutside的值false，那么if条件判断为false，整个shouldCloseOnTouch方法返回false，所以最终onTouchEvent方法也是返回false。\n3.2、ViewGroup的事件分发过程 上面分析了Activity的事件分发过程，可以知道，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup，那么继续看ViewGroup的dispatchTouchEvent方法，因为ViewGroup的dispatchTouchEvent方法很长，所以我们先分析前面一部分代码，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... // 分析1 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // 分析2 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // 分析3 // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 分析3.1 final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // 分析3.1.1 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { // 分析3.1.2 intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. // 分析3.2 intercepted = true; } // ... } // ... return handled; } 分析1：handled布尔值用来标记事件分发的处理结果，并最终作为dispatchTouchEvent方法的返回值；onFilterTouchEventForSecurity方法是做一个安全性检查，默认返回true；但是在我们执行敏感控件的点击事件时，有可能会被恶意软件在此之上加上一个不可接受事件的窗口，骗取我们的点击，那么解决办法是调用View的setFilterTouchesWhenObscured方法设置true，它会往View的setFlags方法中添加FILTER_TOUCHES_WHEN_OBSCURED，表示当视图的窗口被另一个可见窗口遮挡时框架丢弃触摸事件，这时onFilterTouchEventForSecurity方法就会返回false，从而dispatchTouchEvent方法返回false。\n分析2：if判断如果触摸事件的类型为ACTION_DOWN，表示新的ACTION_DOWN事件来了，也就是同一序列的触摸事件的起点，所以需要调用cancelAndClearTouchTargets方法来取消并清除所有触摸目标，以及调用resetTouchState方法来重置所有触摸状态以准备新的循环。这两方法里面的重点是清空mFirstTouchTarget，重置FLAG_DISALLOW_INTERCEPT标记，这里cancelAndClearTouchTargets方法和resetTouchState方法的源码就不列出来了，可自行查阅。\n分析3：intercepted布尔值用来表示是否拦截事件；接下来是一个if判断，条件一是触摸事件的类型为ACTION_DOWN，条件二是mFirstTouchTarget != null。mFirstTouchTarget和后面的代码逻辑有关，它的作用就是当ViewGroup不拦截事件并将事件交由子元素处理时，mFirstTouchTarget会被赋值并指向子元素，这时mFirstTouchTarget != null成立。\n如果if判断为true 接下来，如果触摸事件的类型为ACTION_DOWN，或者mFirstTouchTarget != null时，就会进入分析3.1，布尔值disallowIntercept用来表示不允许父View拦截事件，它和FLAG_DISALLOW_INTERCEPT这个标志位有关，并且该标志位的位运算可以通过requestDisallowInterceptTouchEvent方法设置，从而改变disallowIntercept的值。\n默认情况下，也就是没设置FLAG_DISALLOW_INTERCEPT标志位时，disallowIntercept的值为false，此时就会进入分析3.1.1，接着调用onInterceptTouchEvent方法拦截事件，如果onInterceptTouchEvent方法返回true，表示ViewGroup会拦截当前事件，那么intercepted被赋值为true，反之赋值为false。来看下onInterceptTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // android.view.ViewGroup public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } onInterceptTouchEvent方法比较简单，if条件第一个判断触摸事件是否来自鼠标设备；第二个判断触摸事件的类型是否是ACTION_DOWN；第三个检查是否按下了鼠标按键；第四个判断触摸位置是否在滚动条上。在大多数情况下if条件不会成立，也就是可以认为默认情况下onInterceptTouchEvent方法返回false。\n如果通过requestDisallowInterceptTouchEvent方法设置FLAG_DISALLOW_INTERCEPT标志位，此时disallowIntercept为true，那么就不满足if(!disallowIntercept)条件了，所以不会再调用onInterceptTouchEvent方法，而是走的else逻辑，从而进入分析3.1.2，将intercepted赋值为false。\n注意：FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件。\n为什么？\n因为前面说过，ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。因此，子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN事件的处理。\n如果if判断为false 如果ViewGroup拦截事件，那么子View就无法获得事件，当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN ||mFirstTouchTarget ! = null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，然后走的是else逻辑，也就是进入分析3.2，将intercepted赋值为true。\n到这里，我们已经知道，intercepted的值如果为true，表示ViewGroup要拦截事件，反之不拦截，接下来，继续看ViewGroup的不拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE; final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0 \u0026amp;\u0026amp; !isMouseEvent; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex); final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } } } 如果不是ACTION_CANCEL事件或者ViewGroup不拦截事件时，倒叙遍历子View，然后调用dispatchTransformedTouchEvent方法进行分发事件，注意该方法第三个参数child，此时child不为null，继续看dispatchTransformedTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // android.view.ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 前面说过，此时child不为null，那么就会调用child的dispatchTouchEvent方法进行事件的分发，如果child的dispatchTouchEvent方法返回true，那么if(dispatchTransformedTouchEvent)条件成立，就会执行后面的addTouchTarget方法，给mFirstTouchTarget赋值，addTouchTarget方法代码如下：\n1 2 3 4 5 6 7 8 // android.view.ViewGroup private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } 从上面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。那么如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）。\n接下来，继续看ViewGroup拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { } } return handled; } 如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。在这两种情况下，ViewGroup会自己处理点击事件。注意dispatchTransformedTouchEvent方法的第三个参数child，此时child为null，从前面的分析可以知道，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。\n3.3、View的事件分发过程 上面分析了ViewGroup的事件分发过程，可以知道，ViewGroup拦截事件后，让触摸事件的分发从ViewGroup流转到了View，那么继续看View的dispatchTouchEvent方法，这里省略了一些不重要的代码，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean dispatchTouchEvent(MotionEvent event) { boolean result = false; if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } return result; } 可以看到View的dispatchTouchEvent方法处理比较简单，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，如果没有设置mOnTouchListener监听器，或者onTouch方法返回false时，那么就会调用View的onTouchEvent方法，继续看onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // android.view.View public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED \u0026amp;\u0026amp; (mPrivateFlags4 \u0026amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn\u0026#39;t respond to them. return clickable; } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } return false; } 从上面代码可以知道，View处于不可用时依然会消耗事件。如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法。好了，继续看onTouchEvent对事件的处理，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // android.view.View public boolean onTouchEvent(MotionEvent event) { if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } } mIgnoreNextUpEvent = false; break; } return true; } return false; } 只要View满足clickable，当ACTION_UP事件发生时，最终会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean performClick() { // We still need to call this method to handle the cases where p // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; } 至此，事件分发机制的源码就分析完成了。\n四、解决开发中常见的滑动冲突 经过前面理论知识的准备，下面就要进入解决开发中常见的滑动冲突的实战环节。\n4.1、常见的滑动冲突场景\u0026amp;处理思路 当内外两层View都可以滑动的时候，就会产生滑动冲突，常见的滑动冲突场景如下图所示：\n场景一：外部滑动方向和内部滑动方向不一致 此种场景可以根据当前滑动方向是横向还是纵向来判断事件到底该交给谁来处理。\n那滑动方向怎么判断呢？\n在滑动过程中会有两个点的坐标，通过两个点的坐标就可以计算手指的移动距离，如图所示：\n手指移动后横向距离变化为dx，纵向距离变化为dy，如果dx＞dy，那么此次滑动就算作横向滑动；相反，则认为此次滑动是纵向滑动。\n场景二：外部滑动方向和内部滑动方向不致 当内外两层都在同一个方向可以滑动的时候，显然存在逻辑问题。因为当手指开始滑动的时候，系统无法知道用户到底是想让哪一层滑动，所以当手指滑动的时候就会出现问题，要么只有一层能滑动，要么就是内外两层都滑动得很卡顿。\n这种得根据业务需求，通过下面的拦截与禁止拦截的方法，决定在什么情况下滑动哪个View。\n场景三：上面两种情况的嵌套 上面图中没放出来，是场景一和场景二都存在的情况，也就是它们之间互相嵌套，或者多层嵌套，然而不管多么复杂，解决思路都是一毛一样的，按照上面提的解决思路一层一层处理即可。\n4.2、解决滑动冲突的办法 4.2.1、外部拦截法 所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。\n外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { if(父控件需要当前点击事件){ intercepted = true }else{ intercepted = false } } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } 解释下上面代码，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；\n其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false；\n最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onClick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。\n4.2.2、内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if(自己需要当前点击事件){ parent.requestDisallowInterceptTouchEvent(true) }else{ parent.requestDisallowInterceptTouchEvent(false) } } } return super.dispatchTouchEvent(event) } 解释下上面代码，我留意到一些文章中会写到在子控件的ACTION_DOWN消息中使用getParent().requestDisallowInterceptTouchEvent(true)；，这是无效的，因为如果父控件拦截了ACTION_DOWN消息，则这里写的函数根本不会执行。\n4.3、滑动冲突实战 先上布局文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.core.widget.NestedScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.appcompat.widget.AppCompatEditText android:id=\u0026#34;@+id/edit_text\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;@dimen/edit_text_height\u0026#34; android:text=\u0026#34;@string/edit_text_content\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;1000dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; android:gravity=\u0026#34;center\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/edit_text\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/androidx.core.widget.NestedScrollView\u0026gt; \u0026lt;/layout\u0026gt; 上面是一个EditText，但是这个EditText的内容超出了显示区域，所以它的内容是可以上下滑动的，下面是一个View，高度给得非常大，用来支撑外部的NestedScrollView足够可以滑动，因为NestedScrollView也可以上下滑动，由于双方都可以上下滑动，导致冲突了，运行效果图如下：\n可以看到，在没有处理滑动冲突，在EditText向上滑动时，依然是整体NestedScrollView在滑动，这属于常见的滑动冲突场景里的情况二了，OK，下面就来解决冲突。\n用外部拦截法解决滑动冲突问题 使用外部拦截法来解决滑动冲突问题的话，需要重写NestedScrollView，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class MyNestedScrollView : NestedScrollView { constructor(context: Context) : super(context) { doInit(context) } constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) { doInit(context) } constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) { doInit(context) } private var editTextHeight: Int = 0 private fun doInit(context: Context) { editTextHeight = context.resources.getDimensionPixelSize(R.dimen.edit_text_height) } private var downY: Int = 0 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { downY = ev.y.toInt() intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { intercepted = downY \u0026gt; editTextHeight } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } } 解释下上面代码，因为EditText的高度是固定的，在这个高度之前触摸的位置都是EditText的内容区域，此时让NestedScrollView不要拦截事件，在这个内容区域值之外的位置，让NestedScrollView拦截事件。\n可以看到，在使用外部拦截法时，需要提前知道不拦截消息的区域，这样才能做好消息处理，所以也只有在子控件的位置和大小是固定的并且能获取到的情况下，外部拦截法才是有用的。\n将自定义的MyNestedScrollView替换布局文件里的NestedScrollView即可，运行后效果如下：\n用内部拦截法解决滑动冲突问题 使用内部拦截法来解决滑动冲突问题的话，需要重写EditText，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyEditText : AppCompatEditText { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { parent.requestDisallowInterceptTouchEvent(true) } } return super.dispatchTouchEvent(event) } } 因为在ACTION_MOVE消息到来时，EditText需要自己处理消息，所以这里并没有内部拦截法中判断是否需要该事件的if（自己需要这类点击事件）代码。\n将自定义的MyEditText替换布局文件里的EditText即可，运行后效果同用外部拦截法解决滑动冲突。\n本文源码地址： AndroidEventDispatch\n","date":"2023-06-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","section":"post","tags":null,"title":"Android事件分发机制"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 XML文件在Android中是一种非常常见的文件格式，例如你的主页面布局文件activity_main.xml、Android清单文件AndroidManifest.xml、XXX.xml的res资源文件等等，然而我们在日常开发中往往会忽略XML文件本身，因为AS太过智能化，根据AS智能提示很容易就能写出想要的XML文件，但是我们真的有了解过XML文件吗？还有为什么要去了解XML文件？阅读本文后，你应该可以找到问题的答案。\n因此，本文会把关注点放到XML文件本身，学习它的基础语法，然后循序渐进地讲解Android中怎么解析XML数据，这对之后在Framework层遇到XML解析流程时非常有帮助，比如Activity的setContentView源码里，它是如何将我们写的layout布局文件解析出来的。\n二、XML简单介绍 2.1、什么是XML？ XML的全称为Extensible Markup Language，翻译过来是可扩展标记语言，它是标准通用标记语言的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。\n2.2、XML的基本语法 2.2.1、必须有声明语句 XML声明是XML文档的第一句，代码如下：\n1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; 2.2.2、XML文档有且只有一个根元素 良好格式的XML文档必须有一个根元素，就是紧接着声明后面建立的第一个元素，其他元素都是这个根元素的子元素，根元素完全包括文档中其他所有的元素，根元素的起始标记要放在所有其他元素的起始标记之前；根元素的结束标记要放在所有其他元素的结束标记之后，代码如下：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 在上面代码中，root称为根元素。\n2.2.3、XML标签对大小写敏感 在XML文档中，大小写是有区别的，例如下面代码中“a”和“A”是不同的标记。注意在写元素时，前后标记的大小写要保持一致。最好养成一种习惯，或者全部大写，或者全部小写，或者大写第一个字母，这样可以减少因为大小写不匹配而产生的文档错误。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;A\u0026gt;\u0026lt;/A\u0026gt; \u0026lt;/root\u0026gt; 2.2.4、属性值必须加引号 XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误。\n如下代码为错误演示：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;element id=999\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 如下代码为正确演示：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element id=\u0026#34;999\u0026#34;\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 2.2.5、所有的标记必须有相应的结束标记 在XML中，所有标记必须成对出现，有一个开始标记，就必须有一个结束标记，否则将被视为错误。\n2.2.6、实体引用 在XML中，一些字符拥有特殊的意义，如果你把字符\u0026quot;\u0026lt;\u0026ldquo;放在XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;count\u0026gt;num \u0026lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 为了避免这个错误，需要用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符。\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;count\u0026gt;num \u0026amp;lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 在XML中，有5个预定义的实体引用。\n2.2.7、命名空间 在XML中，因为元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。\n这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的table元素，就会发生命名冲突，XML解析器无法确定如何处理这类冲突。\n如果以Java的思维来描述，可以认为是在同一个包下，创建了两个类名都为Table的类，那么在使用时就会不知道要用的是哪个了。\n因此，需要用XML命名空间来解决该冲突问题。XML命名空间属性被放置于元素的开始标签之中，其语法为：\n1 xmlns:namespace-prefix=\u0026#34;namespaceURI\u0026#34; 当XML命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;root\u0026gt; \u0026lt;s:table xmlns:s=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 命名空间也可以在XML根元素中声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;root xmlns:s=\u0026#34;https://www.student.com/\u0026#34; xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;s:table\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作，其语法为：\n1 xmlns=\u0026#34;namespaceURI\u0026#34; 这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table xmlns=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table xmlns=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 三、Android解析XML数据 3.1、选择XML解释器 Android提供了三种类型的XML解析器，它们是DOM、SAX和XmlPullParser，但是官方建议使用XmlPullParser，这是一种在Android上解析XML的高效且可维护的方式，Android有此接口的两个实现如下：\nKXmlParser，使用XmlPullParserFactory.newPullParser() ExpatPullParser，使用Xml.newPullParser() 上面两种任一选择都可以，在本文的示例中使用的是ExpatPullParser和Xml.newPullParser()。\n3.1.1、XmlPullParser接口 这里仅列举XmlPullParser接口和后面示例有联系的变量和方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public interface XmlPullParser { // ***************next()报告的事件类型*************** // 表明解析器位于文档的最开头，尚未读取任何内容，这种事件类型只能通过在第一次调用next()、nextToken或nextTag()之前调用getEventType()来观察 int START_DOCUMENT = 0; // xml文档的逻辑结束，当到达输入文档的末尾时，从getEventType()、next()和nextToken()返回 int END_DOCUMENT = 1; // 读取开始标记时从getEventType()、next()、nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得（如果命名空间已启用） int START_TAG = 2; // 读取结束标记时从getEventType()、next()或nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得 int END_TAG = 3; // 已读取字符数据并将通过调用getText()获得 int TEXT = 4; // 该数组可用于将事件类型整型常量（如START_TAG或TEXT）转换为字符串。例如，TYPES[START_TAG]的值是字符串“START_TAG”。该数组仅用于诊断输出。依赖数组的内容可能是危险的，因为恶意应用程序可能会更改数组，尽管它是最终的，但由于Java语言的限制 String [] TYPES = { \u0026#34;START_DOCUMENT\u0026#34;, \u0026#34;END_DOCUMENT\u0026#34;, \u0026#34;START_TAG\u0026#34;, \u0026#34;END_TAG\u0026#34;, \u0026#34;TEXT\u0026#34;, \u0026#34;CDSECT\u0026#34;, \u0026#34;ENTITY_REF\u0026#34;, \u0026#34;IGNORABLE_WHITESPACE\u0026#34;, \u0026#34;PROCESSING_INSTRUCTION\u0026#34;, \u0026#34;COMMENT\u0026#34;, \u0026#34;DOCDECL\u0026#34; }; // ***************命名空间相关特性*************** // 这个特性决定了解析器是否处理命名空间。对于所有功能，默认值为false // 注意：该值在解析期间不能更改，必须在解析前设置 String FEATURE_PROCESS_NAMESPACES = \u0026#34;http://xmlpull.org/v1/doc/features.html#process-namespaces\u0026#34;; // 使用此调用来更改解析器的一般行为，例如命名空间处理或文档类型声明处理。必须在第一次调用next或nextToken之前调用此方法。否则，将抛出异常 void setFeature(String name, boolean state) throws XmlPullParserException; // 将解析器的输入源设置为给定的阅读器并重置解析器。事件类型设置为初始值 START_DOCUMENT。将读取器设置为null只会停止解析并重置解析器状态，从而允许解析器释放解析缓冲区等内部资源 void setInput(Reader in) throws XmlPullParserException; // 设置解析器将要处理的输入流。此调用重置解析器状态并将事件类型设置为初始值START_DOCUMENT // 注意：如果传递了输入编码字符串，则必须使用它。否则，如果inputEncoding为null，解析器应该尝试确定遵循XML 1.0规范的输入编码（见下文） void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException; // ***************TEXT相关方法*************** // 检查当前TEXT事件是否只包含空白字符。对于IGNORABLE_WHITESPACE，这始终为真。对于TEXT和CDSECT，当当前事件文本至少包含一个非空白字符时返回false。对于任何其他事件类型，都会抛出异常 boolean isWhitespace() throws XmlPullParserException; // 以String形式返回当前事件的文本内容。返回值取决于当前事件类型，例如对于TEXT事件，它是元素内容（这是使用next()时的典型情况） String getText (); // ***************START_TAG END_TAG共享方法*************** // 对于START_TAG或END_TAG事件，启用命名空间时返回当前元素的（本地）名称。当命名空间处理被禁用时，原始名称被返回。对于ENTITY_REF事件，返回实体名称。如果当前事件不是START_TAG、END_TAG或ENTITY_REF，则返回null String getName(); // ***************START_TAG属性检索方法*************** // 返回由命名空间URI和命名空间localName标识的属性值。如果命名空间被禁用，命名空间必须为空。如果当前事件类型不是START_TAG，则将抛出IndexOutOfBoundsException String getAttributeValue(String namespace, String name); // ***************实际解析方法*************** // 返回当前事件的类型（START_TAG、END_TAG、TEXT等） int getEventType() throws XmlPullParserException; // 获取下一个解析事件 - 元素内容将被合并，并且必须为整个元素内容只返回一个TEXT事件（将忽略注释和处理指令，并且必须扩展实体引用，或者如果实体引用无法扩展则必须抛出异常）。如果元素内容为空（内容为“”），则不会报告TEXT事件 int next() throws XmlPullParserException, IOException; // ***************使XML解析更容易的实用方法*************** // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配。null将匹配任何名称空间和任何名称。如果测试未通过，则抛出异常。异常文本表示解析器位置、预期事件和不符合要求的当前事件 void require(int type, String namespace, String name) throws XmlPullParserException, IOException; // 如果是START_TAG或END_TAG，则调用next()并返回事件，否则抛出异常。如果有的话，它将跳过实际标记之前的空白TEXT int nextTag() throws XmlPullParserException, IOException; } 接下来，只讲解一下重点的方法。\n3.1.1.1、next方法 从上面的注释可以知道，next方法用于获取下一个解析事件，但是它有一些现象需要知道下。\n现象一：如果元素内容为空，则不会报告TEXT事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // kotlin原始字符串 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) var eventType = parser.eventType while (eventType != XmlPullParser.END_DOCUMENT) { Log.e(\u0026#34;MinKin\u0026#34;, \u0026#34;eventType: ${XmlPullParser.TYPES[eventType]}; name: ${parser.name}; text: ${parser.text}\u0026#34;) eventType = parser.next() } 打印结果如下：\n1 2 3 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: END_TAG; name: school; text: null 从打印结果来看，school元素内容为空时，的确没有触发TEXT事件。\n不知到你们是否留意到，为什么也没有触发END_DOCUMENT事件？\n其实是有触发的，只是不满足条件没法打印出来。因为While循环的判断条件为eventType != XmlPullParser.END_DOCUMENT，当eventType == XmlPullParser.END_DOCUMENT时，此时早已退出循环了，所以没有打印出来。\n特性二：如果实体引用无法扩展则必须抛出异常。 将上面代码中的xml变量替换为如下代码：\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 此时因为school标签之间多了\u0026rdquo;\u0026lt;\u0026quot;，运行时会触发XmlPullParserException这样的一个崩溃。把字符\u0026quot;\u0026lt;\u0026ldquo;放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始，为了避免这个错误，用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符，这也是我们之前讲过的。\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 修改为实体引用后，打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: \u0026lt; E/MinKin: eventType: END_TAG; name: school; text: null 特性三：标签之间不是黏连一起的，比如之间有空格，或者出现了换行，或者存在子标签的情况下，都会报告TEXT事件。 将上面代码中的xml变量替换为如下代码：\n1 2 3 4 // 标签之间有空格 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 1 2 3 4 5 // 标签之间出现了换行 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里school标签之间多打印了一次TEXT事件。如果是存在子标签的情况下，代码如下：\n1 2 3 4 5 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;count\u0026gt;1000\u0026lt;/count\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 5 6 7 8 9 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: START_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: 1000 E/MinKin: eventType: END_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里count标签前后多打印了两次TEXT事件。\n3.1.1.2、nextTag方法 如果当前事件不是START_TAG或END_TAG，会抛出XmlPullParserException异常，例如下面代码就会崩溃。\n1 2 3 4 5 6 7 8 9 10 11 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;清华大学\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) parser.next() parser.nextTag() 分析原因：初始时，当前事件为START_DOCUMENT，调用parser的next方法后，事件变为START_TAG，然后再调用parser的nextTag方法时，它的事件状态应该不满足START_TAG或END_TAG，从而抛出了异常。\n为什么不满足？nextTag方法本质源码为：\n1 2 3 4 5 6 7 8 int eventType = next(); if(eventType == TEXT \u0026amp;\u0026amp; isWhitespace()) { // skip whitespace eventType = next(); } if (eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG) { throw new XmlPullParserException(\u0026#34;expected start or end tag\u0026#34;, this, null); } return eventType; 可以看到，会优先调用next方法，此时当前事件为TEXT，接着会去判断eventType == TEXT \u0026amp;\u0026amp; isWhitespace()，但是isWhitespace方法是不满足的，因为school标签中存在元素内容“清华大学”，所以isWhitespace方法返回false，也就无法进入if条件去进一步调用next，事件停留在TEXT，满足了后面的eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG，从而抛出了异常。\n注意：next方法和nextTag方法需要在合理的地方使用，使用不当就会抛出异常。\n3.2、分析animal 创建一个animal.xml文件，解析animal的第一步是确定感兴趣的字段，解析器会提取这些字段的数据，并忽略其余字段。本案例会演示如何忽略cat标签，仅提取需要的字段。\n要解析的XML内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;animal xmlns=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Rufus\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;labrador\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=labrador\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;拉布拉多猎犬（英文名：Labrador retriever）是起源于加拿大的纽芬兰岛，最早被训练在冰冷的海上将渔网收回和担任搬运工作的一种猎犬。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Marty\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;whippet\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=whippet\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;小灵狗是一种赛狗，性温顺。和蔼。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;cat\u0026gt; \u0026lt;name\u0026gt;大黄\u0026lt;/name\u0026gt; \u0026lt;/cat\u0026gt; \u0026lt;/animal\u0026gt; 习惯性，animal标签包含了命名空间xmlns，profile标签的元素内容标记为HTML，所以要把HTML内容当成整体的纯文本去提取，这里给HTML内容包裹一层\u0026lt;![CDATA[ HTML内容 ]]，否则HTML中的标签会被XML当成元素去解析。\n3.3、实例化XML解释器 解析animal的下一步就是实例化解析器和启动解析的过程，此代码段会初始化一个解析器，使其不处理命名空间并将提供的InputStream用作输入，它通过调用nextTag方法开始解析过程，并调用readAnimal方法，该方法将提取并处理应用感兴趣的数据，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimalXMLParser { // 不使用命名空间 private val ns: String? = null @Throws(XmlPullParserException::class, IOException::class) fun parse(inputStream: InputStream): List\u0026lt;Dog\u0026gt; { inputStream.use { val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(it, null) parser.nextTag() return readAnimal(parser) } } // ... } 3.4、读取animal readAnimal方法执行处理animal的实际工作，它会查找标记为“dog”的元素作为以递归方式处理animal的起点，如果某个标签不是dog标签，则会跳过它，以递归方式处理完整个animal后，readAnimal方法将返回结果集List，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Throws(XmlPullParserException::class, IOException::class) private fun readAnimal(parser: XmlPullParser): List\u0026lt;Dog\u0026gt; { val dogs = mutableListOf\u0026lt;Dog\u0026gt;() // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配 parser.require(XmlPullParser.START_TAG, ns, \u0026#34;animal\u0026#34;) while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } if (parser.name == \u0026#34;dog\u0026#34;) { dogs.add(readDog(parser)) } else { skip(parser) } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;animal\u0026#34;) return dogs } 其中Dog类为：\n1 2 3 4 5 6 data class Dog( val name: String?, val breed: String?, val link: String?, val profile: String? ) 3.5、解析XML 解析XML animal的步骤如下：\n按照分析animal中所述，确定希望包含在应用中的标签。此示例提取了dog标签及其嵌套标签name、breed、link和profile的数据。\n创建以下方法：\n要包含的每个标签的“read”方法，例如readDog方法。解析器会从输入流中读取标签。当遇到此示例中名为name、breed、link和profile的标签时，它会调用该标签的相应方法。否则，它会跳过该标签。 为每个不同类型的标签提取数据并推动解析器解析下一个标签的方法。在此示例中，相关方法如下所示： 对于name、breed和profile标签，解析器会调用 readText方法。此方法通过调用parser的getText方法提取这些标签的数据。 对于link标签，解析器首先会确定链接是否为其感兴趣的类型，再提取该链接的数据。然后使用parser的getAttributeValue方法提取该链接的值。 对于dog标签，解析器会调用readDog方法。此方法会解析条目的嵌套标签，并返回包含数据成员name、breed、link和profile的Dog对象。 一种递归的辅助skip方法。 以下代码段展示了解析器如何解析name、breed、link和profile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @Throws(XmlPullParserException::class, IOException::class) private fun readDog(parser: XmlPullParser): Dog { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;dog\u0026#34;) var name: String? = null var breed: String? = null var link: String? = null var profile: String? = null while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } when (parser.name) { \u0026#34;name\u0026#34; -\u0026gt; name = readName(parser) \u0026#34;breed\u0026#34; -\u0026gt; breed = readBreed(parser) \u0026#34;link\u0026#34; -\u0026gt; link = readLink(parser) \u0026#34;profile\u0026#34; -\u0026gt; profile = readProfile(parser) else -\u0026gt; skip(parser) } } return Dog(name, breed, link, profile) } @Throws(XmlPullParserException::class, IOException::class) private fun readProfile(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;profile\u0026#34;) val profile = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;profile\u0026#34;) return profile } @Throws(XmlPullParserException::class, IOException::class) private fun readLink(parser: XmlPullParser): String { var link = \u0026#34;\u0026#34; parser.require(XmlPullParser.START_TAG, ns, \u0026#34;link\u0026#34;) val tag = parser.name val relType = parser.getAttributeValue(null, \u0026#34;rel\u0026#34;) if (tag == \u0026#34;link\u0026#34;) { if (relType == \u0026#34;alternate\u0026#34;) { link = parser.getAttributeValue(null, \u0026#34;href\u0026#34;) parser.nextTag() } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;link\u0026#34;) return link } @Throws(XmlPullParserException::class, IOException::class) private fun readBreed(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;breed\u0026#34;) val breed = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;breed\u0026#34;) return breed } @Throws(XmlPullParserException::class, IOException::class) private fun readName(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;name\u0026#34;) val name = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;name\u0026#34;) return name } @Throws(XmlPullParserException::class, IOException::class) private fun readText(parser: XmlPullParser): String { var result = \u0026#34;\u0026#34; if (parser.next() == XmlPullParser.TEXT) { result = parser.text parser.nextTag() } return result } 3.6、跳过不感兴趣的标签 解析器需要跳过不感兴趣的标签，下面是解析器的skip方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Throws(XmlPullParserException::class, IOException::class) private fun skip(parser: XmlPullParser) { if (parser.eventType != XmlPullParser.START_TAG) { throw IllegalStateException() } var depth = 1 while (depth != 0) { when (parser.next()) { XmlPullParser.END_TAG -\u0026gt; depth-- XmlPullParser.START_TAG -\u0026gt; depth++ } } } 其工作原理如下：\n如果当前事件不是START_TAG，则会抛出异常。 它会使用START_TAG以及直到匹配的END_TAG（含）的所有事件。 为确保其在遇到正确的END_TAG时停止，而非在遇到原始 START_TAG之后的首个标签时停止，它会不断追踪嵌套深度。 因此，如果当前元素具有嵌套元素，在解析器使用了原始START_TAG及其匹配的END_TAG之间的所有事件之前，depth的值不会为0。例如，看看解析器如何跳过拥有name这个嵌套元素的 cat元素：\n第一次经历while循环时，解析器在\u0026lt;cat\u0026gt;之后遇到的下一个标签是\u0026lt;name\u0026gt;的START_TAG。depth的值递增到2。 第二次经历while循环时，解析器遇到的下一个标签是 END_TAG，也就是\u0026lt;/name\u0026gt;。depth的值递减为1。 第三次，也就是最后一次经历while循环时，解析器遇到的下一个标签是END_TAG，也就是。depth的值递减为0，这表明该方法已成功跳过\u0026lt;cat\u0026gt;元素。 3.7、使用XML数据 第一步：把animal.xml文件放到Assets目录下。\n第二步：本文使用Databinding，所以需要在app的build.gradle中添加依赖：\n1 2 3 4 5 android { dataBinding { enabled = true } } 第三步：改造activity_main.xml布局，这里只有一个点击按钮，给按钮绑定点击事件，点击按钮时触发XML的解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;presenter\u0026#34; type=\u0026#34;com.pengmj.androidparsexml.Presenter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{(view)-\u0026gt;presenter.onParseXML(view)}\u0026#34; android:text=\u0026#34;解析XML\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 第四步：实现点击事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Presenter { companion object { private val tag: String = Presenter::class.java.simpleName } fun onParseXML(view: View) { val inputStream = view.context.assets.open(\u0026#34;animal.xml\u0026#34;) val list = AnimalXMLParser().parse(inputStream) Log.e(tag, list.toString()) } } 第五步：在MainActivity中将Databinding绑定UI层，设置页面点击事件对象。\n1 2 3 4 5 6 7 8 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView\u0026lt;ActivityMainBinding\u0026gt;(this, R.layout.activity_main) binding.presenter = Presenter() } } 本文源码地址： AndroidParseXML\n","date":"2023-05-07T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E8%A7%A3%E6%9E%90xml%E6%95%B0%E6%8D%AE/","section":"post","tags":null,"title":"Android解析XML数据"},{"categories":["Java"],"contents":"一、概述 假设你对ArrayDeque的源码一无所知，那么仅凭ArrayDeque名字来看的话，大概可以猜到它的实现和Array数组有关。\nArrayDeque是Java Collections Framework的一个成员，它的底层是基于定长数组实现的一个双端队列，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据，并且维护了双端队列头部元素的索引head和尾部元素的索引tail，使得它成为了一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始。\n我们知道，数组非尾部的插入和删除效率是比较低的，然而，这在ArrayDeque上的表现却是效率高，这是怎么实现的呢？\n接下来，本文会叙述ArrayDeque是如何维护这样一个循环数组，它的扩容机制是怎么实现的，这些都是ArrayDeque的核心所在；除此之外，本文还会叙述ArrayDeque的基本操作是怎样实现的，以及其它的细节。\n好了，让我们一起逐步揭开它的神秘面纱。\n二、ArrayDeque源码解读 2.1、继承关系 从UML类图中可以看到，ArrayDeque直接或间接实现了Iterable、Collection、Deque、Queue、Cloneable、Serializable这6个接口；ArrayDeque继承了AbstractCollection这个抽象类。\nArrayDeque和LinkedList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，比如说Deque接口、Queue接口的解读，本文不再次叙述，想去了解的话，可参考之前的Java集合系列：一文解读LinkedList源码「JDK11」一文。\n2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 // 存储双端队列元素的数组。所有不包含双端队列元素的数组单元格始终为空。该数组始终至少有一个空槽（在尾部）。 transient Object[] elements; // 双端队列头部元素的索引（这是将被 remove() 或 pop() 删除的元素）；或者任意数字 0 \u0026lt;= head \u0026lt; elements.length 等于 tail 如果双端队列为空。 transient int head; // 将下一个元素添加到双端队列尾部的索引（通过 addLast(E)、add(E) 或 push(E)）； elements[tail] 始终为空。 transient int tail; // 要分配的数组的最大大小。一些 VM 在数组中保留一些标题字。尝试分配更大的数组可能会导致 OutOfMemoryError: Requested array size exceeds VM limit private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从成员变量head、tail的注释可以知道，数组的长度、头部元素、尾部元素都和这两个变量有关，那么当数组初始化后，这样的数组表现形式有4种情况：\n头部元素的索引head == 尾部元素的索引tail，那么数组为空，也就是数组内部没有元素，如下图所示： 头部元素的索引head \u0026lt; 尾部元素的索引tail，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到tail-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail == 0，那么头部元素为elements[head]，尾部元素为elements[elements.length-1]，元素索引从head到elements.length-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail != 0，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构造一个空数组双端队列，其初始容量足以容纳16个元素 public ArrayDeque() { elements = new Object[16]; } // 构造一个空数组双端队列，其初始容量足以容纳指定数量的元素 public ArrayDeque(int numElements) { elements = new Object[(numElements \u0026lt; 1) ? 1 : (numElements == Integer.MAX_VALUE) ? Integer.MAX_VALUE : numElements + 1]; } // 构造一个包含指定集合元素的双端队列，按照集合迭代器返回元素的顺序。（集合的迭代器返回的第一个元素成为第一个元素，或双端队列的前面。） public ArrayDeque(Collection\u0026lt;? extends E\u0026gt; c) { this(c.size()); copyElements(c); } // 将集合c的元素循环添加到队尾 private void copyElements(Collection\u0026lt;? extends E\u0026gt; c) { c.forEach(this::addLast); } 我们看下第二个构造方法，需要传入一个numElements，这里有3种情况确定数组大小：\n如果numElements \u0026lt; 1，那么数组大小为1；\n如果numElements == Integer.MAX_VALUE，那么数组大小为Integer.MAX_VALUE；\n如果numElements \u0026gt;= 1 \u0026amp;\u0026amp; numElements \u0026lt; Integer.MAX_VALUE，那么数组大小为numElements + 1;\n第三种情况：为什么要numElements + 1呢？\n因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置。\n2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ***********尾部插入*********** // 在此双端队列的末尾插入指定的元素 public boolean add(E e) { addLast(e); return true; } // 在此双端队列的末尾插入指定的元素 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 上面说了，tail索引对应的位置是一个空位，所以这里用来存放元素e es[tail] = e; // 计算tail的新索引位置，赋值给tail变量；如果(tail+1) \u0026gt;= es.length，那么tail = 0，否则就是tail+1 // 判断是否head == tail，如果是则表示数组存满了，需要进行扩容 if (head == (tail = inc(tail, es.length))) // 执行扩容 grow(1); } static final int inc(int i, int modulus) { if (++i \u0026gt;= modulus) i = 0; return i; } // 在此双端队列的末尾插入指定的元素 public boolean offer(E e) { return offerLast(e); } // 在此双端队列的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 将指定集合中的所有元素添加到此双端队列的末尾，就像对每个元素调用addLast一样，按照集合的迭代器返回它们的顺序。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // s：原数组的元素个数 // needed：所需的最低额外容量 final int s, needed; // needed = 原数组的元素个数 + 集合c的长度 + 1（tail索引占位）- 原数组长度 // 如果needed\u0026gt;0，说明数组元素个数 + 集合c的长度 + 1（tail索引占位) \u0026gt; 原数组长度，也就是原数组容量不够装集合c了，需要扩容 if ((needed = (s = size()) + c.size() + 1 - elements.length) \u0026gt; 0) // 执行扩容 grow(needed); // 扩容完成后，将集合c的元素循环添加到队尾 copyElements(c); // 如果此双端队列发生了更改，那么返回true return size() \u0026gt; s; } // ***********头部插入*********** // 在此双端队列的前面插入指定的元素 public void addFirst(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 计算head的新索引位置，赋值给head变量；如果(head-1) \u0026lt; 0，那么head = es.length-1，否则就是head-1 es[head = dec(head, es.length)] = e; // 判断是否head==tail，如果是则表示数组存满了，需要进行扩容 if (head == tail) // 执行扩容 grow(1); } static final int dec(int i, int modulus) { if (--i \u0026lt; 0) i = modulus - 1; return i; } // 在此双端队列的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素压入此双端队列所代表的堆栈。换句话说，将元素插入到这个双端队列的前面 public void push(E e) { addFirst(e); } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // ***********尾部删除*********** public E removeLast() { E e = pollLast(); if (e == null) throw new NoSuchElementException(); return e; } public E pollLast() { final Object[] es; // 记录tail的新索引位置 final int t; // 计算tail的新索引位置，赋值给临时变量t；如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出t索引对应的元素 E e = elementAt(es = elements, t = dec(tail, es.length)); if (e != null) // 将t赋值给tail，然后将tail索引位置的元素置为null es[tail = t] = null; return e; } // ***********头部删除*********** // 检索并删除由此双端队列表示的队列的头部。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E remove() { return removeFirst(); } // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。 public E poll() { return pollFirst(); } public E removeFirst() { E e = pollFirst(); if (e == null) throw new NoSuchElementException(); return e; } public E pollFirst() { final Object[] es; // 记录head索引位置 final int h; // 在数组中取出head索引对应的元素 E e = elementAt(es = elements, h = head); if (e != null) { // 将head索引位置的元素置为null es[h] = null; // 计算head的新索引位置，赋值给head；如果(head+1) \u0026gt;= es.length，那么head = 0，否则就是head+1 head = inc(h, es.length); } // 返回head索引对应的元素 return e; } // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。 public E pop() { return removeFirst(); } 2.4.3、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // ***********头部检索*********** // 检索但不删除由此双端队列表示的队列的头部。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E element() { return getFirst(); } // 检索但不删除由此双端队列表示的队列的头部，或者如果此双端队列为空则返回null 。 public E peek() { return peekFirst(); } public E getFirst() { // 在数组中取出head索引对应的元素 E e = elementAt(elements, head); if (e == null) throw new NoSuchElementException(); // 返回head索引对应的元素 return e; } // 返回数组索引 i 处的元素。这是对泛型的轻微滥用，被 javac 所接受 static final \u0026lt;E\u0026gt; E elementAt(Object[] es, int i) { return (E) es[i]; } public E peekFirst() { // 在数组中取出head索引对应的元素 return elementAt(elements, head); } // ***********尾部检索*********** public E getLast() { final Object[] es = elements; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 E e = elementAt(es, dec(tail, es.length)); if (e == null) throw new NoSuchElementException(); return e; } public E peekLast() { final Object[] es; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 return elementAt(es = elements, dec(tail, es.length)); } 2.4.4、扩容机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将此双端队列的容量至少增加给定的数量 // need：所需的最低额外容量 private void grow(int needed) { // overflow-conscious code // 获取旧容量大小 final int oldCapacity = elements.length; // 记录新容量大小 int newCapacity; // Double capacity if small; else grow by 50% // jump：可译为跳跃，是基于旧容量计算的一个值，姑且叫跳跃容量 // 如果oldCapacity \u0026lt; 64，那么jump = oldCapacity + 2，为什么这里是+2？+1不行吗？因为+2有两个含义，一个是给tail占位使用，另一个就是给新元素插入使用 // 如果oldCapacity \u0026gt;= 64，那么jump = oldCapacity \u0026gt;\u0026gt; 1，右移一位表示除2，相当于oldCapacity/2 int jump = (oldCapacity \u0026lt; 64) ? (oldCapacity + 2) : (oldCapacity \u0026gt;\u0026gt; 1); // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 如果（跳跃容量 + 旧容量）\u0026gt; MAX_ARRAY_SIZE，说明超过数组长度允许最大值了 // // newCapacity的值有两个情况： // 如果oldCapacity \u0026lt; 64，那newCapacity为oldCapacity * 2 + 2 // 如果oldCapacity \u0026gt;= 64，那newCapacity为oldCapacity * 1.5 if (jump \u0026lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE \u0026gt; 0) // 出现上面说的两种情况时，需要重新调整新容量大小 newCapacity = newCapacity(needed, jump); // 将原数组的元素全部拷贝到新数组中去 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated // 此时数组只是扩大了，但是tail==head，即依然指向同一位置，为避免歧义，需要调整head和tail的位置 if (tail \u0026lt; head || (tail == head \u0026amp;\u0026amp; es[head] != null)) { // wrap around; slide first leg forward to end of array // 计算扩容后数组的剩余空间 int newSpace = newCapacity - oldCapacity; // 将旧数据复制到新位置 System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); // 将旧位置的旧数据全部清空，head成为新位置⾸元素的位置 for (int i = head, to = (head += newSpace); i \u0026lt; to; i++) es[i] = null; } } // 边缘条件的容量计算，尤其是溢出 private int newCapacity(int needed, int jump) { final int oldCapacity = elements.length, minCapacity; // 边界处理：判断旧容量 + 所需的最低额外容量是否超过数组长度允许最大值 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE \u0026gt; 0) { if (minCapacity \u0026lt; 0) throw new IllegalStateException(\u0026#34;Sorry, deque too big\u0026#34;); return Integer.MAX_VALUE; } // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 返回minCapacity = oldCapacity + needed if (needed \u0026gt; jump) return minCapacity; // 如果最小容量minCapacity没有超过数组长度允许最大值，并且need \u0026lt;= jump // 边界处理：判断旧容量+跳跃容量是否超过数组长度允许最大值 return (oldCapacity + jump - MAX_ARRAY_SIZE \u0026lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; } 下面通过一个小例子去演示扩容机制的执行流程，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 初始时，数组⻓度是5，真实索引是0-4，head = tail = 0 ArrayDeque\u0026lt;Integer\u0026gt; arrayDeque = new ArrayDeque\u0026lt;\u0026gt;(4); // 执行完，head = 0, tail = 1；此时数组为：[1, null, null, null, null] arrayDeque.addLast(1); // 执行完，head = 4，tail = 1；此时数组为：[1, null, null, null, 2] arrayDeque.addFirst(2); // 执行完，head = 3，tail = 1；此时数组为：[1, null, null, 3, 2] arrayDeque.addFirst(3); // 执行完，head = 2，tail = 1；此时数组为：[1, null, 4, 3, 2] arrayDeque.addFirst(4); // 执行完，head = tail = 1，触发扩容；此时数组为：[1, 5, 4, 3, 2]，扩容容量为5*2+2 // 然后将旧数据复制到新位置，此时数组为：[1, 5, 4, 3, 2, null, null, null, 5, 4, 3, 2] // 接着清掉旧数据，这时head = 8，tail = 1；此时数组为：[1, null, null, null, null, null, null, null, 5, 4, 3, 2] arrayDeque.addFirst(5); // 执行完，head = 8, tail = 2；此时数组为：[1, 6, null, null, null, null, null, null, 5, 4, 3 ,2] arrayDeque.addLast(6); 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 返回此双端队列中的元素数 public int size() { // i = tail，j = head，modulus = elements.length // 那么i -= j为i = i-j，代入后是tail = tail - head，然后判断计算后的tail是否 \u0026lt; 0 // 如果 \u0026lt; 0，说明是head \u0026gt; tail的情况，对应于前面讲成员变量提到的数组情况3或4，这种情况下， tail会再次计算，tail = tail + elements.length，这样计算就可以求出数组的元素个数，不明白可以对照图来看 // 如果 \u0026gt;= 0，说明是head \u0026lt;= tail的情况，对应于前面讲成员变量提到的数组情况1或2，这种情况下，直接把tail返回即可，因为if条件判断时已经计算过了，这样计算就可以求出数组的元素个数，不明白可以对照图来看 return sub(tail, head, elements.length); } static final int sub(int i, int j, int modulus) { if ((i -= j) \u0026lt; 0) i += modulus; return i; } // 如果此双端队列包含指定元素，则返回true 。更正式地说，当且仅当此双端队列包含至少一个满足o.equals(e)的元素e时才返回true public boolean contains(Object o) { if (o != null) { final Object[] es = elements; // to = (i \u0026lt;= end) ? end : es.length; 代入为：to = （head \u0026lt;= tail）? tail : es.length; // 这里要判断head \u0026lt;= tail，如果是true，那么to==end，即to为tail，说明内层for循环只需要遍历区间[head,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false // 如果head \u0026gt; tail，如果为true，那么to = es.length，说明内层for循环要遍历区间[head,es.length)中是否存在和o元素相同的元素，如果存在，返回true // 否则，内存for循环执行完成，外层for循环此时执行 i = 0, to = end； // 接着内存for循环继续要遍历区间[0,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false for (int i = head, end = tail, to = (i \u0026lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i \u0026lt; to; i++) if (o.equals(es[i])) return true; if (to == end) break; } } return false; } 三、总结 在ArrayDeque的源码中，并没有与并发相关的代码，所以说ArrayDeque是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。\nArrayDeque没有索引位置的概念，不能根据索引位置进行操作，所以没有更改操作，如set方法。\n另外，ArrayDeque禁止添加空元素。最关键一点是：ArrayDeque用作堆栈时很可能比Stack快，用作队列时比LinkedList快。\n","date":"2023-04-24T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraydeque%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayDeque源码「JDK11」"},{"categories":["Java"],"contents":"一、概述 LinkedList是Java Collections Framework的一个成员，然后底层是基于双向链表来实现的。对于LinkedList来说，可能平常开发用的频率并没有ArrayList多，这并不是我们不去学习LinkedList原理的理由。我们知道，ArrayList的特点是随机访问效率很高，但是非尾部的插入和删除性能就比较低，因为要挪动元素位置。LinkedList和ArrayList一样实现了List接口，因为两者底层的实现不一样，造就了它的特点与ArrayList几乎正好相反。\n接下来，本文会叙述LinkedList是如何维护这样一个双向链表的，基本操作是怎样实现的，以及其它的细节。\n二、LinkedList源码解读 2.1、继承关系 从UML类图中可以看到，LinkedList直接或间接实现了Iterable、Collection、List、Deque、Queue、Cloneable、Serializable这7个接口；LinkedList直接或间接继承了AbstractSequentialList、AbstractList、AbstractCollection这3个抽象类。\n可能细心的同学会发现，为什么AbstractList实现了List接口，LinkedList还要去再实现一次List接口？\n关于这一点，在之前的Java集合系列：一文解读ArrayList源码「JDK11」一文中已有解答，除此之外，LinkedList和ArrayList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，本文不再次叙述，想去了解的话，可点击上文链接去了解。\n2.1.1、Queue接口 Queue接口是一个队列接口，它对Collection接口进行了扩展。所谓队列，就类似于日常生活中的各种排队，特点就是先进先出，在尾部添加元素，从头部删除元素，它的接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此队列，则在成功时返回true并在当前没有可用空间时抛出IllegalStateException boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，当使用容量受限的队列时，此方法通常优于add，后者可能仅通过抛出异常来插入元素失败 boolean offer(E e); // 检索并删除此队列的头部。此方法与poll()的不同之处仅在于，如果此队列为空，它会抛出异常 E remove(); // 检索并删除此队列的头部，如果此队列为空，则返回null E poll(); // 检索但不删除此队列的头部。此方法与peek不同之处仅在于，如果此队列为空，它会抛出异常 E element(); // 检索但不删除此队列的头部，如果此队列为空，则返回null E peek(); } Queue队列提供了插入、删除和检查操作。这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（null或false ，具体取决于操作），如下图所示：\n注意：Queue队列实现通常不允许插入null元素，尽管某些实现（例如 LinkedList）不禁止插入null。即使在允许它的实现中，也不应将null插入到Queue队列中，因为null也被poll方法用作特殊的返回值，以指示队列不包含任何元素。\n实践一下，我们把LinkedList当作Queue队列来使用，如下代码：\n1 2 3 4 5 6 7 Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(\u0026#34;Jerry\u0026#34;); queue.offer(\u0026#34;Tom\u0026#34;); queue.offer(\u0026#34;May\u0026#34;); while (queue.peek() != null) { System.out.println(queue.poll()); } 2.1.2、Deque接口 Deque接口对Queue接口进行了扩展，Deque是“double ended queue”的缩写，它定义了访问双端队列两端元素的方法，接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此双端队列的前面，如果当前没有可用空间则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerFirst void addFirst(E e); // 如果可以在不违反容量限制的情况下立即插入指定的元素，则在此双端队列的末尾插入指定的元素，如果当前没有可用空间，则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerLast。此方法等效于add void addLast(E e); // 将指定的元素插入此双端队列的前面，除非它违反容量限制。当使用容量受限的双端队列时，此方法通常优于addFirst方法，后者仅通过抛出异常才能插入元素失败。 boolean offerFirst(E e); // 除非违反容量限制，否则在此双端队列的末尾插入指定的元素。当使用容量受限的双端队列时，此方法通常优于addLast方法，后者仅通过抛出异常才能插入元素失败 boolean offerLast(E e); // 检索并删除此双端队列的第一个元素。此方法与pollFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeFirst(); // 检索并删除此双端队列的最后一个元素。此方法与pollLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeLast(); // 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null E pollFirst(); // 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null E pollLast(); // 检索但不删除此双端队列的第一个元素。此方法与peekFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getFirst(); // 检索但不删除此双端队列的最后一个元素。此方法与peekLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getLast(); // 检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回null E peekFirst(); // 检索但不删除此双端队列的最后一个元素，如果此双端队列为空则返回null E peekLast(); // *** Queue methods *** // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true并在当前没有可用空间时抛出IllegalStateException .使用容量受限的双端队列时，通常最好使用offer 。此方法等效于addLast boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true ，如果当前没有可用空间则返回false 。当使用容量受限的双端队列时，此方法通常优于add方法，后者仅通过抛出异常才能插入元素失败。此方法等效于offerLast boolean offer(E e); // 检索并删除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于removeFirst() E remove(); // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。此方法等效于pollFirst() E poll(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于getFirst() E element(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回null 。此方法等效于peekFirst() E peek(); // *** Stack methods *** // 如果可以在不违反容量限制的情况下立即将元素推入此双端队列表示的堆栈（换句话说，在此双端队列的头部），如果当前没有可用空间则抛出IllegalStateException void push(E e); // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。此方法等效于removeFirst() E pop(); } Deque接口提供了插入、删除和检查的方法，这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（ null或false ，具体取决于操作），如下图所示：\n当双端队列用作队列时，会产生FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。从Queue接口继承的方法与Deque接口方法完全等价，如下图所示：\n除此之外，双端队列也可以用作LIFO（后进先出）堆栈。应优先使用此接口而不是使用Stack类。当双端队列用作堆栈时，元素从双端队列的开头被压入和弹出。Stack方法等同于Deque方法，如下图所示：\n实践一下，我们把LinkedList当作Deque堆栈来使用，如下代码：\n1 2 3 4 5 6 7 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;Jerry\u0026#34;); deque.push(\u0026#34;Tom\u0026#34;); deque.push(\u0026#34;May\u0026#34;); while (deque.peek() != null) { System.out.println(deque.pop()); } 注意：当双端队列用作队列或堆栈时，peek方法同样有效；在任何一种情况下，元素都是从双端队列的开头提取的。\n虽然并未严格要求Deque队列实现禁止插入空元素，但强烈建议它们这样做。强烈建议任何确实允许null元素的Deque实现的用户不要利用插入null的能力。之所以如此，是因为null被各种方法用作特殊的返回值，以指示双端队列为空。\nDeque接口除了上面介绍的核心方法外，它还有一个迭代器方法，可以从后往前遍历，如下代码：\n1 2 3 4 5 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(new String[]{\u0026#34;Jerry\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;May\u0026#34;})); Iterator\u0026lt;String\u0026gt; iterator = deque.descendingIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2.2、成员变量 1 2 3 4 5 6 7 8 // LinkedList的大小（它包含的元素数） transient int size = 0; // 指向第一个节点的指针 transient Node\u0026lt;E\u0026gt; first; // 指向最后一个节点的指针 transient Node\u0026lt;E\u0026gt; last; LinkedList的成员变量不多，我们重点看下内部类Node节点的实现，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static class Node\u0026lt;E\u0026gt; { // 存储元素 E item; // 后继节点 Node\u0026lt;E\u0026gt; next; // 前驱节点 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 从上面Node节点的构造函数来看，Node节点的结构如下图所示：\nLinkedList就是由一个个的Node节点双向连接而成，如下图所示：\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 // 构造一个空列表 public LinkedList() { } // 构造一个包含指定集合元素的列表，按照集合迭代器返回元素的顺序 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { this(); // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 addAll(c); } 2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // ***********尾部插入*********** // 将指定的元素附加到此列表的末尾 public boolean add(E e) { linkLast(e); return true; } // 将指定的元素附加到此列表的末尾 public void addLast(E e) { linkLast(e); } // 添加指定元素作为此列表的尾部（最后一个元素） public boolean offer(E e) { return add(e); } // 在此列表的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return addAll(size, c); } // ***********头部插入*********** // 在此列表的开头插入指定的元素 public void addFirst(E e) { linkFirst(e); } // 在此列表的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素推入此列表表示的堆栈中。换句话说，将元素插入此列表的前面 public void push(E e) { addFirst(e); } // ***********中间插入*********** // 在此列表中的指定位置插入指定元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一） public void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 如果插入的索引位置为size，那说明是尾部插入 if (index == size) // 执行尾部插入 linkLast(element); else // 先找到当前链表上指定index位置的node节点，然后再插入新节点 linkBefore(element, node(index)); } // ***********插入核心实现*********** // 链接e作为最后一个元素 void linkLast(E e) { // 获取当前链表的last节点 final Node\u0026lt;E\u0026gt; l = last; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 让新节点成为last节点 last = newNode; // 如果last节点为null，说明这是第一次插入新节点，所以新节点也是first节点 if (l == null) first = newNode; else // 否则新节点是last节点的下一个节点 l.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 链接e作为第一个元素 private void linkFirst(E e) { // 获取当前链表的first节点 final Node\u0026lt;E\u0026gt; f = first; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 让新节点成为last节点 first = newNode; // 如果first节点为null，说明这是第一次插入新节点，所以新节点也是last节点 if (f == null) last = newNode; else // 否则新节点是first节点的上一个节点 f.prev = newNode; // 更新size：元素个数+1 size++; modCount++; } // 返回指定元素索引处的（非空）节点。 Node\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1 == size/2 // 如果index \u0026lt; size/2，那么就从first节点开始往后遍历查找 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 如果index \u0026gt;= size/2，那么就从last节点开始往前遍历查找 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } // 在非空节点 succ 之前插入元素 e void linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; // 获取当前链表的succ节点的前一个节点pred final Node\u0026lt;E\u0026gt; pred = succ.prev; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 让新节点成为succ节点的前一个节点 succ.prev = newNode; // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 将指定集合中的所有元素插入此列表，从指定位置开始。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的​​迭代器返回的顺序出现在列表中。 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 将集合c的元素按集合c的顺序转换为数组返回 Object[] a = c.toArray(); // 如果数组长度为0，那么返回false int numNew = a.length; if (numNew == 0) return false; // 定义当前链表index索引对应的succ节点，以及succ节点的前节点pred Node\u0026lt;E\u0026gt; pred, succ; // 如果index == size，说明是尾部插入 if (index == size) { // size位置的节点为null succ = null; // pred节点为插入位置的前节点last pred = last; } else { // 否则是中间插入，那么先找到当前链表上指定index位置的node节点，然后再插入新节点 succ = node(index); // pred为succ的前节点 pred = succ.prev; } // 遍历数组，让数组转换为链表 for (Object o : a) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新节点 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 每一轮循环结束，新节点就是pred节点 pred = newNode; } // 如果succ节点为null，说明是尾部插入，此时插入已经完成，那么pred节点为数组的最后一个节点，所以理所应当成为last节点 if (succ == null) { last = pred; } else { // 如果succ节点不为null，说明是中间插入，此时插入已经完成，那么数组的最后一个节点指向插入位置节点succ pred.next = succ; // 数组的最后一个节点pred，理所应当成为插入位置节点succ的上一个节点 succ.prev = pred; } // 更新size：元素个数+数组长度 size += numNew; modCount++; return true; } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 // ***********尾部删除*********** // 从此列表中移除并返回最后一个元素 public E removeLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 检索并删除此列表的最后一个元素，如果此列表为空，则返回null public E pollLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : unlinkLast(l); } // ***********头部删除*********** // 检索并删除此列表的头部（第一个元素） public E remove() { return removeFirst(); } // 检索并删除此列表的头部（第一个元素） public E poll() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表中移除并返回第一个元素。 public E removeFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 检索并删除此列表的第一个元素，如果此列表为空，则返回null public E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素 public E pop() { return removeFirst(); } // ***********中间删除*********** // 移除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）。返回从列表中删除的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } // ***********删除核心实现*********** // 取消链接非空的第一个节点f private E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // assert f == first \u0026amp;\u0026amp; f != null; // 获取node节点的元素element final E element = f.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = f.next; // 将node节点持有的元素item置为null f.item = null; // 将node节点持有的后继节点指针置为null f.next = null; // help GC // node节点的下一个节点成为first节点 first = next; // 如果next节点为null，说明最后一个节点也被删除了，那么last节点置为null if (next == null) last = null; else // 否则node节点置为null next.prev = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空的最后一个节点l private E unlinkLast(Node\u0026lt;E\u0026gt; l) { // assert l == last \u0026amp;\u0026amp; l != null; // 获取node节点的元素element final E element = l.item; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = l.prev; // 将node节点持有的元素item置为null l.item = null; // 将node节点持有的前躯节点指针置为null l.prev = null; // help GC // node节点的上一个节点成为last节点 last = prev; // 如果prev节点为null，说明最后一个节点也被删除了，那么first节点置为null if (prev == null) first = null; else // 否则node节点置为null prev.next = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空节点x E unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null; // 获取node节点的元素element final E element = x.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = x.next; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 如果prev节点为null，说明是头部删除，那么next节点成为first节点 if (prev == null) { first = next; } else { // 如果prev节点不为null，说明是中间删除，那么next节点成为前驱节点prev的下一个节点 prev.next = next; // node节点的前驱节点指针置为null x.prev = null; } // 如果next节点为null，说明是尾部删除，那么prev节点成为last节点 if (next == null) { last = prev; } else { // 如果prev节点不为null，说明是中间删除，那么prev节点成为后继节点next的上一个节点 next.prev = prev; // node节点的后继节点指针置为null x.next = null; } // 将node节点持有的元素item置为null x.item = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果此列表不包含该元素，则它保持不变。更正式地说，删除具有最低索引i元素 public boolean remove(Object o) { // 如果要删除的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后执行删除 if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果要删除的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后执行删除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 2.4.3、更改 1 2 3 4 5 6 7 8 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { checkElementIndex(index); Node\u0026lt;E\u0026gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 2.4.4、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ***********头部检索*********** // 检索但不删除此列表的头部（第一个元素） public E element() { return getFirst(); } // 检索但不删除此列表的头部（第一个元素） public E peek() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // 返回此列表中的第一个元素 public E getFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 检索但不删除此列表的第一个元素，如果此列表为空，则返回null public E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // ***********尾部检索*********** // 返回此列表中的最后一个元素 public E getLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回null public E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } // ***********中间检索*********** // 返回此列表中指定位置的元素 public E get(int index) { checkElementIndex(index); return node(index).item; } 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 返回此列表中指定元素第一次出现的索引，如果此列表不包含该元素，则返回 -1，更正式地说，返回具有最低索引i元素 public int indexOf(Object o) { int index = 0; // 如果要查找的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后返回index if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { // 如果要查找的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后返回index for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 三、总结 在LinkedList的源码中，并没有与并发相关的代码，所以说LinkedList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new LinkedList(...)); 另外，LinkedList要根据实际的业务场景来使用，比如说，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，使用LinkedList会有更好的性能。\n","date":"2023-04-19T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBlinkedlist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读LinkedList源码「JDK11」"},{"categories":null,"contents":" 此博客主要用来对日常的开发等相关的内容进行记录，如果需要转载请表明出处。\n","date":"2023-04-16T20:53:15+08:00","permalink":"https://anddevmk.cn/about/","section":"","tags":null,"title":"关于"},{"categories":["Java"],"contents":"一、概述 ArrayList是经常用到的一个容器，它是Java Collections Framework的一个成员，然后底层是基于定长数组来实现的，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据。\n因此，扩容机制是ArrayList的核心所在，这一点是务必要掌握的；除此之外，本文还会叙述ArrayList的基本操作是怎样实现的，以及其它的细节。\n二、ArrayList源码解读 2.1、继承关系 从UML类图中可以看到，ArrayList直接或间接实现了Iterable、Collection、List、RandomAccess、Cloneable、Serializable这6个接口；ArrayList直接或间接继承了AbstractList、AbstractCollection这2个抽象类。\n疑问来了：为什么AbstractList实现了List接口，ArrayList还要去再实现一次List接口，是吃饱了撑着吗？\n带着疑问，我立马去网上冲浪一波，然后发现了3个对此的解释。\n观点1：如果ArrayList没去实现List接口，会导致class的getInterfaces方法返回不同的结果，这么做是为了方便基于List接口的动态代理。\n观点2：这可能是为了增加继承结构的可追踪性。当浏览Javadoc或类似的东西时，就不必遍历整个继承树，它不会有任何不良影响，并且可以帮助理解代码。\n观点3：ArrayList的作者Josh Bloch曾经认为ArrayList再实现一次List接口是有一些价值的，但后来发现这是个错误。\n以上3个观点均出自stackoverflow的一个帖子，我们了解下就好了，深究意义不大，具体原因还得是作者自己才知道。\n2.1.1、Iterable接口 2.1.1.1、概述 Iterable表示可迭代的，它有个iterator方法，需要返回Iterator对象，Iterator是一个接口，表示为迭代器。Iterable接口的定义如下：\n1 2 3 4 5 6 public interface Iterable\u0026lt;T\u0026gt; { Iterator\u0026lt;T\u0026gt; iterator(); // .....省略 } 那么实现Iterable接口有什么作用呢？先说结论：只要对象实现了Iterable接口，就可以使用for-each语法，编译器会转换为调用Iterable和Iterator接口的方法。\n我们平常用for-each语法遍历list时，你可能会写下如下代码：\n1 2 3 4 5 6 7 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(3); list.add(1); list.add(2); list.add(3); for (Integer value : list) { System.out.println(\u0026#34;value: \u0026#34; + value); } 这种for-each语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：\n1 2 3 4 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.next()); } 除了Iterable接口的iterator方法外，List接口也有一个listIterator方法，需要返回ListIterator对象，ListIterator是一个接口，它对Iterator接口做了扩展。比如，可以从末尾往前遍历，如下代码：\n1 2 3 4 ListIterator\u0026lt;Integer\u0026gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.previous()); } 2.1.1.2、fail-fast机制 那些年，年少时所犯下的错误，想起自己刚入门Java时，曾经写过如下代码：\n1 2 3 4 5 for (Integer value : list) { if (value \u0026lt; 3) { list.remove(value); } } 当年的直觉告诉你，这么写不存在问题，但是运行却会报并发修改的错误：\n1 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException 显然，这里是没有并发的代码，我们去看看ConcurrentModificationException的注释描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 当不允许进行此类修改时，已检测到对象的并发修改的方法可能会抛出此异常。 * This exception may be thrown by methods that have detected concurrent * modification of an object when such modification is not permissible. * \u0026lt;p\u0026gt; * 例如，通常不允许一个线程在另一个线程迭代集合时修改集合。 * For example, it is not generally permissible for one thread to modify a Collection * while another thread is iterating over it. * 通常，在这些情况下迭代的结果是不确定的。 * In general, the results of the iteration are undefined under these circumstances. * 如果检测到此行为，某些 Iterator 实现（包括 JRE 提供的所有通用集合实现）可能会选择抛出此异常。 * Some Iterator implementations (including those of all the general purpose collection implementations * provided by the JRE) may choose to throw this exception if this behavior is * detected. * 执行此操作的迭代器被称为fail-fast迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间出现任意的、不确定的行为的风险。 * Iterators that do this are known as \u0026lt;i\u0026gt;fail-fast\u0026lt;/i\u0026gt; iterators, * as they fail quickly and cleanly, rather that risking arbitrary, * non-deterministic behavior at an undetermined time in the future. * \u0026lt;p\u0026gt; * 请注意，此异常并不总是表示对象已被不同的线程并发修改。 * Note that this exception does not always indicate that an object has * been concurrently modified by a \u0026lt;i\u0026gt;different\u0026lt;/i\u0026gt; thread. * 如果单个线程发出一系列违反对象契约的方法调用，则该对象可能会抛出此异常。 * If a single thread issues a sequence of method invocations that violates the * contract of an object, the object may throw this exception. * 例如，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。 * For example, if a thread modifies a collection directly while it is * iterating over the collection with a fail-fast iterator, the iterator * will throw this exception. * 请注意，不能保证fail-fast行为，因为一般来说，在存在非同步并发修改的情况下不可能做出任何硬性保证。 * \u0026lt;p\u0026gt;Note that fail-fast behavior cannot be guaranteed as it is, generally * speaking, impossible to make any hard guarantees in the presence of * unsynchronized concurrent modification. * ail-fast操作会尽最大努力抛出ConcurrentModificationException。 * Fail-fast operations throw {@code ConcurrentModificationException} on a best-effort basis. * 因此，编写依赖于此异常的正确性的程序是错误的： ConcurrentModificationException应该仅用于检测错误。 * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: \u0026lt;i\u0026gt;{@code ConcurrentModificationException} * should be used only to detect bugs.\u0026lt;/i\u0026gt; * * @author Josh Bloch * @see Collection * @see Iterator * @see Spliterator * @see ListIterator * @see Vector * @see LinkedList * @see HashSet * @see Hashtable * @see TreeMap * @see AbstractList * @since 1.2 */ 上面的注释说的很明显了，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。\n那么如何避免异常呢？可以使用迭代器的remove方法，如下所示：\n1 2 3 4 5 6 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { if (iterator.next() \u0026lt; 3) { iterator.remove(); } } 它自己的remove方法为何又可以使用呢？我们需要看下迭代器的原理了。\n2.1.1.3、迭代器的原理 我们先来看下ArrayList中iterator方法的实现，代码如下：\n1 2 3 4 5 6 7 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } } iterator方法实现很简单，直接new一个Itr对象返回，Itr是ArrayList的一个成员内部类，实现了Iterator接口，它的代码量并不多，所以直接贴出来了，看注释应该就能明白。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return 下一个要返回的元素位置 int lastRet = -1; // index of last element returned; -1 if no such 最后一个返回的索引位置，如果没有，为-1 int expectedModCount = modCount; // 期望的修改次数，初始化为外部类当前的修改次数modCount // prevent creating a synthetic constructor Itr() {} public boolean hasNext() { return cursor != size; // cursor与数组元素数量的比较 } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { // 校验是否发生了结构性变化 checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 更新cursor的值，每次+1 cursor = i + 1; // 更新lastRet值，返回对应的元素 return (E) elementData[lastRet = i]; } public void remove() { // 注意：lastRet \u0026lt; 0时会抛出异常，所以调用remove()之前需要先调用next()去更新lastRet的值 if (lastRet \u0026lt; 0) throw new IllegalStateException(); // 校验是否发生了结构性变化 checkForComodification(); try { // 执行ArrayList的remove方法，modCount++ ArrayList.this.remove(lastRet); // 更新cursor的值，remove后元素数量少了一个，相当于cursor=cursor-1 cursor = lastRet; // 重置lastRet lastRet = -1; // 更新expectedModCount expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 校验是否发生了结构性变化，所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 迭代器源码中next方法，remove方法都会调用checkForComodification方法进行校验是否发生了结构性变化，由此可见，迭代器的内部维护了索引位置相关的数据，要求在迭代过程中，不能发生结构性变化，否则这些索引位置功能就会失效。\n2.1.2、RandomAccess接口 RandomAccess内部是没有任何代码的接口，它属于标记接口，其定义如下：\n1 2 public interface RandomAccess { } 实现了RandomAccess接口的类表示支持快速随机访问，用在一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现，比如Collections类的binarySearch方法，会根据List是否实现了RandomAccess接口而采用不同的实现，代码如下：\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } 2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。注意：要将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少 // 可以理解为标记调空参数构造方法 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 都将扩展为 DEFAULT_CAPACITY。 transient Object[] elementData; // ArrayList的大小（它包含的元素数） private int size; // 要分配的数组的最大大小（除非必要） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表，使得正在进行的迭代可能会产生不正确的结果。 protected transient int modCount = 0; 疑问来了：我们知道了ArrayList实现了Serializable接口，但是elementData为何要用transient修饰，这不表示elementData不能被序列化？\n其实玄机在于ArrayList中的两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 将ArrayList实例的状态保存到流中（即序列化它）。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // 从流中重构ArrayList实例（即反序列化） private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { elements[i] = s.readObject(); } elementData = elements; } else if (size == 0) { elementData = EMPTY_ELEMENTDATA; } else { throw new java.io.InvalidObjectException(\u0026#34;Invalid size: \u0026#34; + size); } } ArrayList在序列化的时候会调用writeObject方法，直接将size和element写入ObjectOutputStream；反序列化时调用readObject方法，从ObjectInputStream获取size和element，再恢复到elementData。\nelementData是存储ArrayList元素的数组缓冲区，通常扩容后都会预留一些空间，也就是说有部分空间实际没有存储元素，序列化时只序列化实际存储的那些元素，而不是整个数组，从而可以节省空间和时间。\n疑问来了：为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8而不是Integer.MAX_VALUE？\n因为存储了Array的头部信息，所以这里需要减去8。\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 空参构造方法 public ArrayList() { // 由于没有指定初始容量，所以赋值一个空实例的共享空数组实例，可以理解为标记调空参数构造方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定了初始容量的构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 创建指定大小的Object数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 elementData = c.toArray(); if ((size = elementData.length) != 0) { // 重复调用Arrays.copyOf()是为了防止c.toArray()不返回Object[] // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } } 2.4、核心方法 2.4.1、add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将指定的元素附加到此列表的末尾 public boolean add(E e) { // 此列表在结构上被修改的次数 modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { // 数组容量满了，执行扩容机制 if (s == elementData.length) // 得到一个扩容后的新数组 elementData = grow(); // size位置插入元素 elementData[s] = e; // 更新size大小：原元素个数大小+1 size = s + 1; } // 在此列表中的指定位置插入指定元素 public void add(int index, E element) { // 校验index的范围 rangeCheckForAdd(index); modCount++; // 当前元素个数大小 final int s; Object[] elementData; // 数组容量满了，执行扩容机制 if ((s = size) == (elementData = this.elementData).length) // 得到一个扩容后的新数组 elementData = grow(); // 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 移动后，index位置空余出来，即可将element插入到index位置 elementData[index] = element; // 更新size大小：原元素个数大小+1 size = s + 1; } // 将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; // 原数组的剩余容量不够插入数组的大小时，就进行扩容 if (numNew \u0026gt; (elementData = this.elementData).length - (s = size)) // 得到一个扩容后的新数组 elementData = grow(s + numNew); // 将插入数组的元素拷贝到扩容数组上 System.arraycopy(a, 0, elementData, s, numNew); // 更新size大小：原元素个数大小+插入数组的长度 size = s + numNew; return true; } 关于add方法，如果是末尾插入，那么平均时间复杂度为O(1)；如果是非末尾插入，因为需要移动元素，那么平均时间复杂度为O(n)。因此，我们应该尽量避免在大数据量中调用add带索引参数的方法。\n2.4.2、grow方法（扩容机制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private Object[] grow() { return grow(size + 1); } // 增加容量以确保它至少可以容纳最小容量参数指定的元素数 private Object[] grow(int minCapacity) { // minCapacity = size + 1 // 先计算新容量大小，再根据新容量大小创建一个Object[]新数组，把数据拷贝到新数组上 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 返回至少与给定最小容量一样大的容量。如果足够，返回增加 50% 的当前容量。除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。 private int newCapacity(int minCapacity) { // overflow-conscious code // 旧容量 = 原数组的长度 int oldCapacity = elementData.length; // 新容量 = 旧容量 + 旧容量右移一位（相当于除于2） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt;= 0) { // 如果是调用了无参数构造方法，没有指定初始容量时 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 默认初始容量就为10 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 其它情况一律size + 1 return minCapacity; } // 如果还没达到最大容量，那就是新容量大小，否则返回一个返回一个巨大的容量 return (newCapacity - MAX_ARRAY_SIZE \u0026lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // size+1 \u0026gt; MAX_ARRAY_SIZE时，那么返回一个巨大的容量Integer.MAX_VALUE，否则MAX_ARRAY_SIZE return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 2.4.3、remove方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 移除此列表中指定位置的元素 public E remove(int index) { // 校验index的范围 Objects.checkIndex(index, size); final Object[] es = elementData; // 取出要移除的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E oldValue = (E) es[index]; // 删除元素 fastRemove(es, index); // 返回要移除的元素 return oldValue; } // 跳过边界检查并且不返回删除的值的私有删除方法 private void fastRemove(Object[] es, int i) { modCount++; final int newSize; // 如果删除的元素索引位置非最后一个元素位置，那么将当前位于该位置的元素（如果有）和任何后续元素向左移动（将其索引减一）。 if ((newSize = size - 1) \u0026gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); // 移动原size-1位置多余了，需要置null es[size = newSize] = null; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果列表不包含该元素，则它不变。 public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; // 使用了java label语法 found: { // 如果传入null，那么遍历去查看是否存在null的元素，找到就跳出循环 if (o == null) { for (; i \u0026lt; size; i++) if (es[i] == null) break found; } else { // 如果传入不为null，那么遍历去查看是否存在相同的元素，找到就跳出循环 for (; i \u0026lt; size; i++) if (o.equals(es[i])) break found; } // 上面两个条件下都找不到要查找的元素，则返回false return false; } // 找到要删除的元素后执行删除 fastRemove(es, i); return true; } 2.4.4、set方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { // 校验index的范围 Objects.checkIndex(index, size); // 获取索引位置对应的元素 E oldValue = elementData(index); // 设置索引位置对应的元素 elementData[index] = element; // 返回要修改的元素 return oldValue; } // 返回索引位置对应的元素 E elementData(int index) { return (E) elementData[index]; } 2.4.5、get方法 1 2 3 4 5 6 7 // 返回此列表中指定位置的元素 public E get(int index) { // 校验index的范围 Objects.checkIndex(index, size); // 返回索引位置对应的元素 return elementData(index); } 2.5、其它方法 2.5.1、ensureCapacity方法 1 2 3 4 5 6 7 8 9 10 11 12 // 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数。 // 也就是说，这个方法的使用场景是如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数 public void ensureCapacity(int minCapacity) { // 最小容量不得低于原数组的长度，同时原数组不是第一次调用空参数构造方法和第一次扩容 if (minCapacity \u0026gt; elementData.length \u0026amp;\u0026amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u0026amp;\u0026amp; minCapacity \u0026lt;= DEFAULT_CAPACITY)) { modCount++; // 进行扩容 grow(minCapacity); } } 2.5.2、trimToSize方法 1 2 3 4 5 6 7 8 9 10 11 12 // 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList实例的存储 public void trimToSize() { modCount++; // 数组容量没装满元素 if (size \u0026lt; elementData.length) { // 如果元素个数为0，那么赋值一个空实例的共享空数组实例 elementData = (size == 0) ? EMPTY_ELEMENTDATA // 否则拷贝元素到新数组上，新数组的大小就是元素个数的数量 : Arrays.copyOf(elementData, size); } } 三、总结 在ArrayList的源码中，并没有与并发相关的代码，所以说ArrayList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new ArrayList(...)); 另外，ArrayList是经常用到的一个容器，要根据实际的业务场景来使用，比如说，当添加、删除数据不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会有更好的性能。\n","date":"2023-04-16T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraylist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayList源码「JDK11」"}]