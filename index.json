[{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在之前解读Flutter源码之InheritedWidget一文中，我们已知晓，在Widget多层嵌套的情况下，将数据从父级Widget传递给子级Widget时，采用InheritedWidget的方式非常好用。\n但是，如果传递方向是反过来的情况下，也就是变为从子级Widget向父级Widget传递数据，那么依然可以选择从InheritedWidget传入Listener的方式来实现。\n例如，还是之前的计数器示例，只不过添加多一个“Post”按钮来触发子级Widget向父级Widget传递数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyParent( counter: _counter, listener: (String result) =\u0026gt; ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(result))), child: const MyChild(), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; final ValueChanged\u0026lt;String\u0026gt; listener; const MyParent({ super.key, required this.counter, required this.listener, required super.child, }); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ElevatedButton( onPressed: () =\u0026gt; MyParent.of(context).listener(\u0026#39;Hello World!\u0026#39;), child: const Text(\u0026#39;Post\u0026#39;), ), ], ), ); } } 程序运行起来后，效果如下：\n另外，Flutter的NotificationListener（通知监听）为我们提供了一个更优雅的方式去实现上面的效果，并且功能更强大，可以传递给多个父级Widget处理。\n二、什么是通知监听？ 关于NotificationListener（通知监听），在Flutter官网中是找不到它的详细介绍的，而且NotificationListener的代码注释也非常少，先来看下它的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /// 一个监听在树上冒泡的Notification的widget /// A widget that listens for [Notification]s bubbling up the tree. /// /// 仅当Notifications的runtimeType是T的子类型时，才会触发onNotification回调。 /// Notifications will trigger the [onNotification] callback only if their /// [runtimeType] is a subtype of `T`. /// /// 要发送通知，请使用Notification.dispatch方法。 /// To dispatch notifications, use the [Notification.dispatch] method. class NotificationListener\u0026lt;T extends Notification\u0026gt; extends ProxyWidget { const NotificationListener({ super.key, required super.child, this.onNotification, }); /// 当适当类型的通知到达树中的此位置时调用。 /// Called when a notification of the appropriate type arrives at this /// location in the tree. /// /// 返回 true 取消通知冒泡。返回 false 以允许通知继续分派给更远的祖先 /// Return true to cancel the notification bubbling. Return false to /// allow the notification to continue to be dispatched to further ancestors. /// /// 通知的发送时间有所不同。主要有两种可能性：帧之间的分发和布局期间的分发 /// Notifications vary in terms of when they are dispatched. There are two /// main possibilities: dispatch between frames, and dispatch during layout. /// /// 对于在布局期间分派的通知（例如从LayoutChangedNotification继承的通知），调用State.setState来响应通知为时已晚（根据定义，布局当前发生在后代中，因为通知会在树中冒泡）。 /// 对于依赖于布局的小部件，请考虑使用LayoutBuilder /// For notifications that dispatch during layout, such as those that inherit /// from [LayoutChangedNotification], it is too late to call [State.setState] /// in response to the notification (as layout is currently happening in a /// descendant, by definition, since notifications bubble up the tree). For /// widgets that depend on layout, consider a [LayoutBuilder] instead. final NotificationListenerCallback\u0026lt;T\u0026gt;? onNotification; @override Element createElement() { return _NotificationElement\u0026lt;T\u0026gt;(this); } } 可以发现，上面NotificationListener的注释是描述得不够详细的，下面结合它的注释\u0026amp;笔者的观点总结一下它的特性。\n1、与InheritedWidget一样，NotificationListener同样继承自ProxyWidget，ProxyWidget用来提供了一个子Widget，而不是构建一个新的Widget。\n2、NotificationListener可以指定一个泛型T，该泛型T必须是Notification的子类。注意：当显式指定泛型T时，如ScrollUpdateNotification，NotificationListener便只会接收ScrollUpdateNotification类型的通知。\n3、NotificationListener需要传入一个onNotification参数，它的类型是NotificationListenerCallback，如果返回true时就会取消通知冒泡，否则允许通知继续分派给更远的祖先。\n4、通知是Flutter中一个重要的机制，在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父级Widget都可以通过NotificationListener来监听通知。因此，Flutter中将这种由子级Widget向父级Widget的传递通知的机制称为通知冒泡（Notification Bubbling）。\n5、通知冒泡和用户触摸事件（Listener）是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。\n6、Flutter中很多地方使用了通知，如下面将要介绍的PageView示例，它所创建的 _PageViewState 的build方法中就使用了NotificationListener监听滚动通知来实现onPageChanged功能，看下build方法源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @override Widget build(BuildContext context) { final AxisDirection axisDirection = _getDirection(context); final ScrollPhysics physics = _ForceImplicitScrollPhysics( allowImplicitScrolling: widget.allowImplicitScrolling, ).applyTo( widget.pageSnapping ? _kPagePhysics.applyTo(widget.physics ?? widget.scrollBehavior?.getScrollPhysics(context)) : widget.physics ?? widget.scrollBehavior?.getScrollPhysics(context), ); return NotificationListener\u0026lt;ScrollNotification\u0026gt;( onNotification: (ScrollNotification notification) { // 监听滚动通知 if (notification.depth == 0 \u0026amp;\u0026amp; widget.onPageChanged != null \u0026amp;\u0026amp; notification is ScrollUpdateNotification) { final PageMetrics metrics = notification.metrics as PageMetrics; // 获取当前页码 final int currentPage = metrics.page!.round(); if (currentPage != _lastReportedPage) { _lastReportedPage = currentPage; // 实现onPageChanged回调 widget.onPageChanged!(currentPage); } } return false; }, child: Scrollable( dragStartBehavior: widget.dragStartBehavior, axisDirection: axisDirection, controller: widget.controller, physics: physics, restorationId: widget.restorationId, scrollBehavior: widget.scrollBehavior ?? ScrollConfiguration.of(context).copyWith(scrollbars: false), viewportBuilder: (BuildContext context, ViewportOffset position) { return Viewport( // TODO(dnfield): we should provide a way to set cacheExtent // independent of implicit scrolling: // https://github.com/flutter/flutter/issues/45632 cacheExtent: widget.allowImplicitScrolling ? 1.0 : 0.0, cacheExtentStyle: CacheExtentStyle.viewport, axisDirection: axisDirection, offset: position, clipBehavior: widget.clipBehavior, slivers: \u0026lt;Widget\u0026gt;[ SliverFillViewport( viewportFraction: widget.controller.viewportFraction, delegate: widget.childrenDelegate, padEnds: widget.padEnds, ), ], ); }, ), ); } 这里给出了NotificationListener的部分特性，主要是想让大家对NotificationListener有一个初级认知。\n三、通知监听示例 在下面示例中，将通过NotificationListener来监听PageView的滚动通知的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;PageView滚动通知监听\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _widgets = [ const ColoredBox(color: Colors.redAccent), const ColoredBox(color: Colors.greenAccent), const ColoredBox(color: Colors.blueAccent), ]; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: NotificationListener( onNotification: (notification) { switch (notification.runtimeType) { case ScrollStartNotification: debugPrint(\u0026#39;开始滚动\u0026#39;); break; case ScrollUpdateNotification: debugPrint(\u0026#39;正在滚动\u0026#39;); break; case ScrollEndNotification: debugPrint(\u0026#39;滚动停止\u0026#39;); break; case OverscrollNotification: debugPrint(\u0026#39;滚动到边界\u0026#39;); break; case UserScrollNotification: debugPrint(\u0026#39;用户滚动\u0026#39;); break; } return false; }, child: PageView.builder( itemCount: _widgets.length, itemBuilder: (context, index) =\u0026gt; _widgets[index], ), ), ); } } 程序运行起来后，效果如下：\n当滑动PageView时，上面这5个通知均会输出相应的日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... I/flutter (21018): 开始滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 正在滚动 ... I/flutter (21018): 正在滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 滚动停止 I/flutter (21018): 用户滚动 I/flutter (21018): 开始滚动 I/flutter (21018): 用户滚动 I/flutter (21018): 正在滚动 I/flutter (21018): 滚动到边界 I/flutter (21018): 滚动到边界 ... I/flutter (21018): 滚动到边界 I/flutter (21018): 滚动停止 I/flutter (21018): 用户滚动 通过查看它们的源码可以发现它们均继承自ScrollNotification类，并且不同类型的通知会包含不同的信息，比如ScrollUpdateNotification就有一个scrollDelta属性，它记录了移动的位移等。\n通知 说明 ScrollStartNotification Scrollable小部件已开始滚动的通知 ScrollUpdateNotification Scrollable小部件已更改其滚动位置的通知 ScrollEndNotification Scrollable小部件已停止滚动的通知 OverscrollNotification Scrollable小部件尚未更改其滚动位置，因为更改会导致其滚动位置超出其滚动范围的通知 UserScrollNotification 用户已更改滚动ScrollDirection或已停止滚动的通知 除了上面提到的和滚动相关的通知，还有一些其它的通知，例如KeepAliveNotification等，这些其它的通知和特定的功能相关。\n四、分析通知源码 4.1、通知节点树的形成 当你使用NotificationListener这个Widget时，它所关联的Element为 _NotificationElement，对于每个 _NotificationElement 来说，它会持有一个父通知节点 _NotificationNode（上一个 _NotificationElement 所创建的通知节点）。\n那么，在Element树的背后就会形成一颗通知节点树，来看下源码，了解下这颗通知节点树是怎么形成的。\n通知节点树形成的关键在于attachNotificationTree方法，那么它是在哪里执行的？\n当新创建的Element第一次添加到树中时，就会执行mount方法，在mount方法中会执行attachNotificationTree方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @mustCallSuper void mount(Element? parent, Object? newSlot) { assert(_lifecycleState == _ElementLifecycle.initial); assert(_parent == null); assert(parent == null || parent._lifecycleState == _ElementLifecycle.active); assert(slot == null); _parent = parent; _slot = newSlot; _lifecycleState = _ElementLifecycle.active; _depth = _parent != null ? _parent!.depth + 1 : 1; if (parent != null) { // Only assign ownership if the parent is non-null. If parent is null // (the root node), the owner should have already been assigned. // See RootRenderObjectElement.assignOwner(). _owner = parent.owner; } assert(owner != null); final Key? key = widget.key; if (key is GlobalKey) { owner!._registerGlobalKey(key, this); } _updateInheritance(); // 创建通知节点 attachNotificationTree(); } 以及在Element的activate方法中触发，也就是当先前停用的Element重新合并到Element树中时，也会执行attachNotificationTree方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @mustCallSuper void activate() { assert(_lifecycleState == _ElementLifecycle.inactive); assert(owner != null); final bool hadDependencies = (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) || _hadUnsatisfiedDependencies; _lifecycleState = _ElementLifecycle.active; // We unregistered our dependencies in deactivate, but never cleared the list. // Since we\u0026#39;re going to be reused, let\u0026#39;s clear our list now. _dependencies?.clear(); _hadUnsatisfiedDependencies = false; _updateInheritance(); // 创建通知节点 attachNotificationTree(); if (_dirty) { owner!.scheduleBuildFor(this); } if (hadDependencies) { didChangeDependencies(); } } 看下Element的attachNotificationTree方法，对于在mount第一个 _NotificationElement 之前的Element来说，它的通知节点为null。\n1 2 3 4 5 6 7 Element? _parent; _NotificationNode? _notificationTree; @protected void attachNotificationTree() { _notificationTree = _parent?._notificationTree; } 另外，attachNotificationTree方法会被子类NotifiableElementMixin重写，而且NotificationListener所关联的 _NotificationElement 会混入NotifiableElementMixin。\n因此，对于 _NotificationElement 来说，它会创建一个新的通知节点 _NotificationNode，看下NotifiableElementMixin的attachNotificationTree方法源码就知道。\n1 2 3 4 5 6 7 mixin NotifiableElementMixin on Element { @override void attachNotificationTree() { _notificationTree = _NotificationNode(_parent?._notificationTree, this); } } 再看下 _NotificationNode 源码可以发现， _NotificationNode 会持有父组件的 _NotificationNode（上一个 _NotificationElement 所创建的通知节点），也就是对应于parent参数，以及持有当前 _NotificationElement 所混入NotifiableElementMixin实例，也就是对应于current参数。\n1 2 3 4 5 6 class _NotificationNode { _NotificationNode(this.parent, this.current); NotifiableElementMixin? current; _NotificationNode? parent; } 总结：当Element执行mount方法挂载，如果遇到第一个_NotificationElement时，就会为其创建一个_NotificationNode通知节点，该通知节点会持有上一个_NotificationElement所创建的通知节点，注意此时之前Element的通知节点均为null，所以该通知节点持有的上一个_NotificationElement所创建的通知节点为null。之后的Element继续执行mount方法挂载，这些Element持有的通知节点依然是第一个_NotificationElement所创建的通知节点。如果遇到第二个_NotificationElement时，就会为其创建一个_NotificationNode通知节点，该通知节点会持有上一个_NotificationElement所创建的通知节点，也就是第一个_NotificationElement所创建的通知节点，如此往复形成一颗通知节点树。\n4.2、触发通知分发的过程 以上面PageView为例，之前看过它的build方法实现，内部会构建一个Scrollable，Scrollable是一个StatefulWidget，它所创建的State为ScrollableState。\n在ScrollableState中，有一个 _updatePosition 方法，来看下它的源码，发现它会执行 _effectiveScrollController.createScrollPosition 来创建一个ScrollPosition。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 仅在肯定会触发重建的地方调用此方法 // Only call this from places that will definitely trigger a rebuild. void _updatePosition() { _configuration = widget.scrollBehavior ?? ScrollConfiguration.of(context); _physics = _configuration.getScrollPhysics(context); if (widget.physics != null) { _physics = widget.physics!.applyTo(_physics); } else if (widget.scrollBehavior != null) { _physics = widget.scrollBehavior!.getScrollPhysics(context).applyTo(_physics); } final ScrollPosition? oldPosition = _position; if (oldPosition != null) { _effectiveScrollController.detach(oldPosition); // It\u0026#39;s important that we not dispose the old position until after the // viewport has had a chance to unregister its listeners from the old // position. So, schedule a microtask to do it. scheduleMicrotask(oldPosition.dispose); } // 创建一个ScrollPosition _position = _effectiveScrollController.createScrollPosition(_physics!, this, oldPosition); assert(_position != null); // 将ScrollPosition添加到ScrollController中的_positions中保存 _effectiveScrollController.attach(position); } 看下ScrollController的createScrollPosition方法，这个方法有子类PageController实现，发现它内部创建了一个 _PagePosition 实例。\n1 2 3 4 5 6 7 8 9 10 11 @override ScrollPosition createScrollPosition(ScrollPhysics physics, ScrollContext context, ScrollPosition? oldPosition) { return _PagePosition( physics: physics, context: context, initialPage: initialPage, keepPage: keepPage, viewportFraction: viewportFraction, oldPosition: oldPosition, ); } 通过跟踪 _PagePosition 的源码，可以发现它继承自ScrollPositionWithSingleContext，而ScrollPositionWithSingleContext又继承自ScrollPosition。\n在ScrollPosition中，定义了几个通知分发的方法，供子类 _PagePosition 调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // NOTIFICATION DISPATCH /// Called by [beginActivity] to report when an activity has started. void didStartScroll() { activity!.dispatchScrollStartNotification(copyWith(), context.notificationContext); } /// Called by [setPixels] to report a change to the [pixels] position. void didUpdateScrollPositionBy(double delta) { activity!.dispatchScrollUpdateNotification(copyWith(), context.notificationContext!, delta); } /// Called by [beginActivity] to report when an activity has ended. /// /// This also saves the scroll offset using [saveScrollOffset]. void didEndScroll() { activity!.dispatchScrollEndNotification(copyWith(), context.notificationContext!); saveOffset(); if (keepScrollOffset) { saveScrollOffset(); } } /// Called by [setPixels] to report overscroll when an attempt is made to /// change the [pixels] position. Overscroll is the amount of change that was /// not applied to the [pixels] value. void didOverscrollBy(double value) { assert(activity!.isScrolling); activity!.dispatchOverscrollNotification(copyWith(), context.notificationContext!, value); } /// Dispatches a notification that the [userScrollDirection] has changed. /// /// Subclasses should call this function when they change [userScrollDirection]. void didUpdateScrollDirection(ScrollDirection direction) { UserScrollNotification(metrics: copyWith(), context: context.notificationContext!, direction: direction).dispatch(context.notificationContext); } /// Dispatches a notification that the [ScrollMetrics] have changed. void didUpdateScrollMetrics() { assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks); assert(_haveScheduledUpdateNotification); _haveScheduledUpdateNotification = false; if (context.notificationContext != null) { ScrollMetricsNotification(metrics: copyWith(), context: context.notificationContext!).dispatch(context.notificationContext); } } 当PageController调用jumpToPage方法时，就会执行 _PagePosition 的jumpTo方法。\n1 2 3 4 5 6 7 8 9 void jumpToPage(int page) { final _PagePosition position = this.position as _PagePosition; if (position._cachedPage != null) { position._cachedPage = page.toDouble(); return; } position.jumpTo(position.getPixelsFromPage(page.toDouble())); } 因为ScrollPosition定义了jumpTo抽象方法，由子类来实现，所以看下 _PagePosition 的jumpTo方法，但是跟踪源码后发现 _PagePosition 并没有实现jumpTo方法，所以看下它的父类ScrollPositionWithSingleContext的jumpTo方法。\n1 2 3 4 5 6 7 8 9 10 11 12 @override void jumpTo(double value) { goIdle(); if (pixels != value) { final double oldPixels = pixels; forcePixels(value); didStartScroll(); didUpdateScrollPositionBy(pixels - oldPixels); didEndScroll(); } goBallistic(0.0); } 可以发现，在ScrollPositionWithSingleContext的jumpTo方法中，调用它的父类ScrollPosition的一些方法，它们是didStartScroll、didUpdateScrollPositionBy以及didEndScroll，之前讲过这几个方法是用来分发通知的。\n这里以didStartScroll方法为例，看下它的源码，执行了ScrollActivity的dispatchScrollStartNotification方法。\n1 2 3 void didStartScroll() { activity!.dispatchScrollStartNotification(copyWith(), context.notificationContext); } 看下ScrollActivity的dispatchScrollStartNotification方法，可以看到，执行了ScrollStartNotification的dispatch方法。\n1 2 3 void dispatchScrollStartNotification(ScrollMetrics metrics, BuildContext? context) { ScrollStartNotification(metrics: metrics, context: context).dispatch(context); } 4.2、通知分发 看下ScrollStartNotification的dispatch方法，因为ScrollStartNotification的终极父类是Notification，所以执行的是Notification的dispatch方法。\n在Notification的dispatch方法中，执行BuildContext的dispatchNotification方法，并把当前Notification实例，也就是ScrollStartNotification作为参数传入了dispatchNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class Notification { /// Abstract const constructor. This constructor enables subclasses to provide /// const constructors so that they can be used in const expressions. const Notification(); /// Start bubbling this notification at the given build context. /// /// The notification will be delivered to any [NotificationListener] widgets /// with the appropriate type parameters that are ancestors of the given /// [BuildContext]. If the [BuildContext] is null, the notification is not /// dispatched. void dispatch(BuildContext? target) { target?.dispatchNotification(this); } } 因为BuildContext只是一个句柄，所以看下它的实现类Element的dispatchNotification方法。可以看到，执行了 _notificationTree 的dispatchNotification方法。\n1 2 3 4 5 6 _NotificationNode? _notificationTree; @override void dispatchNotification(Notification notification) { _notificationTree?.dispatchNotification(notification); } 看下 _NotificationNode的dispatchNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class _NotificationNode { _NotificationNode(this.parent, this.current); NotifiableElementMixin? current; _NotificationNode? parent; void dispatchNotification(Notification notification) { // 分析1 if (current?.onNotification(notification) ?? true) { return; } // 分析2 parent?.dispatchNotification(notification); } } 分析1 这里分2种情况：\n1、如果current为空，说明通知分发已完成，这时直接return，不执行分析2。\n2、如果current不为空，说明通知分发正在进行中，可以发现调用了NotifiableElementMixin的onNotification方法，而 _NotificationElement 混入了NotifiableElementMixin，所以实际上调用了 _NotificationElement 的onNotification方法。\n1 2 3 4 5 6 7 8 9 10 11 12 class _NotificationElement\u0026lt;T extends Notification\u0026gt; extends ProxyElement with NotifiableElementMixin { _NotificationElement(NotificationListener\u0026lt;T\u0026gt; super.widget); @override bool onNotification(Notification notification) { final NotificationListener\u0026lt;T\u0026gt; listener = widget as NotificationListener\u0026lt;T\u0026gt;; if (listener.onNotification != null \u0026amp;\u0026amp; notification is T) { return listener.onNotification!(notification); } return false; } } 此处widget指的是NotificationListener，如果NotificationListener传入了onNotification回调并且notification是泛型T以及泛型T的子类时，就会通过调用listener.onNotification回调出去。\n关于 _NotificationElement 的onNotification方法返回值有3种情况：\n1、如果NotificationListener没有传入了onNotification回调，那么 _NotificationElement的onNotification就会返回false，此时会执行 _NotificationNode的dispatchNotification方法中的分析2部分。\n2、如果NotificationListener传入了onNotification回调，并且该方法返回false，同样会执行 _NotificationNode 的dispatchNotification方法中的分析2部分。\n3、如果NotificationListener传入了onNotification回调，并且该方法返回true，则不会执行 _NotificationNode的dispatchNotification方法中的分析2部分。\n分析2 执行了parent?.dispatchNotification，也就是继续向上分发通知。\n五、自定义通知 从源码分析中可以知道，通知分发是调用Notification的dispatch方法，那我们可以自定义一个Notification来进行分发。\n这里还是改造之前的计数器示例，实现与在InheritedWidget中传入Listener的方式的同等效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: NotificationListener\u0026lt;MyNotification\u0026gt;( onNotification: (MyNotification notification) { ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text(notification.msg))); return false; }, child: MyParent( counter: _counter, child: const MyChild(), ), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; const MyParent({ super.key, required this.counter, required super.child, }); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ElevatedButton( onPressed: () =\u0026gt; MyNotification(msg: \u0026#39;Hello World!\u0026#39;).dispatch(context), child: const Text(\u0026#39;Post\u0026#39;), ), ], ), ); } } class MyNotification extends Notification { final String msg; MyNotification({required this.msg}); } ","date":"2023-11-07T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bnotificationlistener/","section":"post","tags":null,"title":"解读Flutter源码之NotificationListener"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 如果你开发的App失去了交互动画，那么这将是一件很难想象的事情，此时它的体验必然一言难尽，用户会为它贴上“傻快”、“生硬”、“粗糙”等标签，从而你将不得不丢失一部分用户。\n因此，精心设计的动画会使UI更生动，它有助于提升App更精巧的外观和感觉，从而改善用户体验。\n在Flutter的Material Widgets中，这些Widgets均自带其设计规范中定义的标准动画效果，能让各种动画效果的实现变得容易，当然了，你也可以定制这些效果。\n二、动画概览 在Flutter中，创建动画可以有多种不同实现方式。那么，究竟哪种才是最适合你的呢？可以参考下面的决策树，它将帮助你挑选实现Flutter动画的正确方式。\n2.1、动画的实现方式 按照动画的实现方式来分类，可以分为隐式动画与显式动画。\n隐式动画 所有隐式动画均扩展了ImplicitlyAnimatedWidget类。你可以使用内置的隐式动画，例如AnimatedContainer、AnimatedAlign等，这些是最简单的动画。如果内置的隐式动画不能够满足你的需求，你也可以使用TweenAnimationBuilder创建一个自定义的隐式动画。\n显式动画 所谓显式动画，就是需要手动控制，而不是让框架控制。你可以使用内置的其中一个显式动画类来实现，例如ScaleTransition、RotationTransition等。如果内置的显式动画不能够满足你的需求，你也可以使用AnimatedBuilder或AnimatedWidget创建一个自定义的显式动画。\n当然了，不管隐式动画还是显式动画，它们也只是对底层Animation的一个封装，只是封装后的使用自由度不太相同罢了。\n2.2、动画的类型 按照动画的类型来分类，可以分为补间动画与基于物理动画。\n补间动画 补间动画是“介于两者之间”的缩写。在补间动画中，定义了起点和终点以及时间轴，再定义过渡时间和速度的曲线，然后框架会计算如何从起点过渡到终点。\n基于物理动画 在基于物理基础的动画中，动作是模拟真实世界的行为来进行建模的。举个例子，当您抛球时，球落地的时间和位置取决于抛出的速度和距离地面的高度。类似地，附在弹簧上的球和附在绳子上的球掉落（和反弹）方式是不一样的。\n2.3、预置动画 预置动画指的是pub.dev上的animations库中所包含的动画，它是由Flutter官方提供的。这个库包含了以下内置常用模式： Container变换、共享轴变化、渐变穿透和渐变变换。\n2.4、常见的动画模式 常见的动画模式包括列表或网格动画、共享元素转换、交织动画等。\n列表或网格动画 这种模式用于在列表或网格中添加或删除元素。\n共享元素转换 在这个模式中，用户从页面中选择一个元素，通常是图像，然后UI会在新页面中为指定元素添加动画，并生成更多细节。在Flutter中，您可以通过Hero组件轻松实现路径（页面）间的共享元素转换动画。\n例如，下面这两种风格的Hero动画：\n1、当改变位置和大小时，Hero从一页飞至另一页。\n2、Hero的边界改变形状由圆变方，同时从一页飞至另一页。\n为什么要将这种可飞行的共享组件称为Hero（英雄），有一种说法是说美国文化中的超人是可以飞的，那是美国人心中的大英雄，还有漫威中的超级英雄基本上都是会飞的，所以Flutter开发人员就对这种“会飞的Widget”就起了一个富有浪漫主义的名字Hero。当然这种说法并非官方解释，但却很有意思。\n交织动画 将复杂的动画分解成较小的动作，其中一些动作被延迟，分解后的这些小动画可以是连续的，也可以部分或完全重叠。例如：有一个柱状图，需要在高度增长的同时改变颜色，等到增长到最大高度后，我们需要在X轴上平移一段距离。\n使用交织动画需要注意以下几点：\n1、要创建交织动画，需要使用多个动画对象（Animation）\n2、一个AnimationController控制所有的动画对象\n3、给每一个动画对象指定时间间隔（Interval）\nOK，动画总览讲解完毕，最后再给出一张动画总览的思维导图。\n三、动画基础 在任何系统的UI框架中，动画的实现原理都是相同的，即在一段时间内，快速地多次改变UI外观；由于人眼会产生视觉暂留，所以最终看到的就是一个“连续”的动画，这和电影的原理是一样的。\nFlutter中对动画进行了抽象，主要涉及Animation、Curve、Controller、Tween这四个角色，它们一起配合来完成一个完整动画，下面来一一介绍它们。\n3.1、Animation 1、在Flutter中，动画对象Animation无法获取屏幕上显示的内容，它与渲染或 build() 方法无关。\n2、Animation是一个已知当前值value和状态status（已完成或已解除）的抽象类，其中一个比较常见的Animation类型是 Animation\u0026lt;double\u0026gt;。\n3、动画还可以插入除double以外的类型，比如Animation\u0026lt;Color\u0026gt;或者Animation\u0026lt;Size\u0026gt;。\n4、一个Animation对象在一段时间内，持续生成介于两个值之间的插入值。这个Animation对象输出的可能是直线，曲线，阶梯函数，或者任何自定义的映射，这由Curve来决定。\n5、根据Animation对象的不同控制方式，它可以反向运行，或者中途切换方向。\n6、在动画的每一帧中，我们可以通过Animation对象的value属性获取动画的当前值。\n3.1.1、动画通知 一个Animation对象可以有不止一个Listener和StatusListener，用addListener() 和addStatusListener() 来定义。\n当动画值改变时调用Listener。Listener最常用的操作是调用 setState() 进行重建。\n当一个动画开始，结束，前进或后退时，会调用StatusListener，用AnimationStatus来定义。\n3.2、Curve CurvedAnimation定义动画进程为非线性曲线。\n1 2 final CurvedAnimation curve = CurvedAnimation(parent: controller, curve: Curves.easeIn); CurvedAnimation和AnimationController（下面介绍）都是Animation\u0026lt;double\u0026gt;类型。CurvedAnimation可以通过包装AnimationController和Curve生成一个新的动画对象，我们正是通过这种方式来将动画和动画执行的曲线关联起来的。\nCurves类中定义了很多常用曲线。\nCurves曲线 动画过程 linear 线性动画曲线 decelerate 变化率开始快速然后减速的曲线 ease 快速加速、缓慢结束的立方动画曲线 easeIn 缓慢开始并快速结束的立方动画曲线 easeOut 快速开始并缓慢结束的立方动画曲线 easeInOut 一条立方动画曲线，缓慢开始，加速，然后缓慢结束 bounceIn 幅度不断增长的振荡曲线 bounceOut 一条先增大后减小幅度的振荡曲线 bounceInOut 一条先增大后减小幅度的振荡曲线 \u0026hellip; \u0026hellip; 如果内置的Curves曲线不能满足你的要求，你也可以自定义Curves曲线。例如：\n1 2 3 4 5 6 import \u0026#39;dart:math\u0026#39;; class ShakeCurve extends Curve { @override double transform(double t) =\u0026gt; sin(t * pi * 2); } 3.3、AnimationController AnimationController是个特殊的Animation对象，每当硬件准备新帧时，它都会生成一个新值。默认情况下，AnimationController在给定期间内会线性生成从 0.0 到 1.0 的数字。例如，这段代码创建了一个动画对象，但是没有启动运行。\n1 2 3 4 final AnimationController controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); AnimationController生成数字的区间可以通过lowerBound和upperBound来指定，如：\n1 2 3 4 5 6 final AnimationController controller = AnimationController( duration: const Duration(milliseconds: 2000), lowerBound: 10.0, upperBound: 20.0, vsync: this ); AnimationController源自于Animation\u0026lt;double\u0026gt;，所以可以用在任何需要Animation对象的地方。但是AnimationController还有其它方法控制动画，例如：forward() 方法可以启动正向动画，reverse() 可以启动反向动画。\n在动画开始执行后开始生成动画帧，屏幕每刷新一次就是一个动画帧，在动画的每一帧，会随着根据动画的曲线来生成当前的动画值（Animation.value），然后根据当前的动画值去构建UI，当所有动画帧依次触发时，动画值会依次改变，所以构建的UI也会依次变化，所以最终我们可以看到一个完成的动画。\n创建AnimationController的同时，也赋予了一个vsync参数。vsync的存在防止后台动画消耗不必要的资源。您可以通过添加SingleTickerProviderStateMixin到类定义，将有状态的对象用作vsync。\n注意：在一些情况下，一个位置可能会超过AnimationController的 0.0-1.0 的范围。例如，fling() 函数可以根据我们手指滑动（甩出）的速度(velocity)、力量(force)等来模拟一个手指甩出动画，因此它的动画值可以在[0.0，1.0]范围之外。即使AnimationController在范围内，CurvedAnimation也可能会出现超出 0.0-1.0 范围的情况。根据所选曲线的不同，CurvedAnimation的输出范围可能会超过输入。举个例子，弹性曲线（比如Curves.elasticIn）会明显超出或低于默认范围。\n3.4、Tween 在默认情况下，AnimationController对象的范围是 0.0-0.1。如果需要不同的范围或者不同的数据类型，可以使用Tween配置动画来插入不同的范围或数据类型。例如下面的示例中，Tween的范围是 -200 到 0.0。\n1 final Tween doubleTween = Tween\u0026lt;double\u0026gt;(begin: -200.0, end: 0.0); Tween是无状态的对象，只有begin和end。Tween的这种单一用途用来定义从输入范围到输出范围的映射。输入范围一般为 0.0-1.0，但这并不是必须的。\nTween源自Animatable\u0026lt;T\u0026gt;，而不是Animation\u0026lt;T\u0026gt;。像动画这样的可动画元素不必重复输出。例如，ColorTween指定了两种颜色之间的过程。\n1 2 final Tween colorTween = ColorTween(begin: Colors.transparent, end: Colors.black54); Tween对象不存储任何状态。而是提供evaluate(Animation\u0026lt;double\u0026gt; animation)方法，将映射函数应用于动画当前值。Animation对象的当前值可以在.value方法中找到。evaluate方法还执行一些内部处理内容，比如确保当动画值在 0.0 和1.0 时分别返回起始点和终点。\n3.4.1、Tween.animate 要使用Tween对象，请在Tween调用animate()，传入控制器对象。例如，下面的代码在 500 ms 的进程中生成 0-255 范围内的整数值。\n1 2 3 AnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); Animation\u0026lt;int\u0026gt; alpha = IntTween(begin: 0, end: 255).animate(controller); 注意：animate() 方法会返回一个Animation，而不是Animatable。\n下面的示例展示了一个控制器，一个曲线，和一个Tween。\n1 2 3 4 5 AnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); final Animation\u0026lt;double\u0026gt; curve = CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation\u0026lt;int\u0026gt; alpha = IntTween(begin: 0, end: 255).animate(curve); 四、动画示例 现有一需求，点击scale按钮，可以将一个Icon变大或缩小，并且中途还可以调转动画的方向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;动画演示\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: const MyWidget(), ); } } class MyWidget extends StatefulWidget { const MyWidget({super.key}); @override State\u0026lt;MyWidget\u0026gt; createState() =\u0026gt; _MyWidgetState(); } class _MyWidgetState extends State\u0026lt;MyWidget\u0026gt; with SingleTickerProviderStateMixin { late AnimationController _animationController; late Animation\u0026lt;double\u0026gt; _animation; @override void initState() { super.initState(); _animationController = AnimationController( vsync: this, duration: const Duration(seconds: 1), reverseDuration: const Duration(seconds: 1), ); _animation = CurvedAnimation( parent: _animationController, curve: Curves.easeIn, reverseCurve: Curves.bounceIn, ); _animation = Tween(begin: 200.0, end: 300.0).animate(_animation) ..addListener(() { setState(() { }); }); } void _scale() { if (_animation.status == AnimationStatus.completed || _animation.status == AnimationStatus.forward) { _animationController.reverse(); } else if (_animation.status == AnimationStatus.dismissed || _animation.status == AnimationStatus.reverse) { _animationController.forward(); } } @override void dispose() { super.dispose(); _animationController.dispose(); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ Icon( Icons.account_circle, size: _animation.value, ), OutlinedButton( onPressed: _scale, child: const Text(\u0026#39;scale\u0026#39;), ) ], ), ); } } 程序运行起来后，UI效果为：\n五、分析动画源码 5.1、_animationController.forward() 从动画的启动方法入手，也就是AnimationController的forward方法，看下它的源码。\n1 2 3 4 5 6 7 8 9 TickerFuture forward({ double? from }) { // 指定动画方向为正向 _direction = _AnimationDirection.forward; // 因为没有传入from，所以这里为null，此处不会执行 if (from != null) { value = from; } return _animateToInternal(upperBound); } 在AnimationController的forward方法中，执行了 _animateToInternal 方法，这里传入了upperBound，它是该动画被视为完成的值。\nupperBound是在AnimationController的构造方法中传入，只是本示例中没有传入，所以取的是默认值为 1.0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimationController extends Animation\u0026lt;double\u0026gt; with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin { AnimationController({ double? value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, // 默认值 this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, required TickerProvider vsync, }) : assert(upperBound \u0026gt;= lowerBound), _direction = _AnimationDirection.forward { _ticker = vsync.createTicker(_tick); _internalSetValue(value ?? lowerBound); } } 继续跟踪AnimationController的 _animateToInternal 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 TickerFuture _animateToInternal(double target, { Duration? duration, Curve curve = Curves.linear }) { double scale = 1.0; /// SemanticsBinding.instance.disableAnimations用来判断该平台是否要求禁用或简化动画。 /// 可通过设置debugSemanticsDisableAnimations可以覆盖此设置以进行测试或调试 /// 例如： /// /// ```dart /// import \u0026#39;package:flutter/rendering.dart\u0026#39;; /// /// void main() { /// // debugSemanticsDisableAnimations = true; /// runApp(const MyApp()); /// } /// ``` /// 本示例中很明显没有禁用动画，所以此处不执行，scale的值仍然为1.0 if (SemanticsBinding.instance.disableAnimations) { switch (animationBehavior) { case AnimationBehavior.normal: // 由于该框架无法处理零持续时间动画，因此我们以正常持续时间的 5% 运行它，以将大多数动画限制为单帧。 // 理想情况下，框架将能够处理零持续时间动画，但是，如果不延迟至少一帧，永久重复动画的常见模式可能会导致无限循环。 // Since the framework cannot handle zero duration animations, we run it at 5% of the normal // duration to limit most animations to a single frame. // Ideally, the framework would be able to handle zero duration animations, however, the common // pattern of an eternally repeating animation might cause an endless loop if it weren\u0026#39;t delayed // for at least one frame. scale = 0.05; case AnimationBehavior.preserve: break; } } // simulationDuration是模拟持续时间，但是由于duration参数没有传入，所以simulationDuration为null Duration? simulationDuration = duration; // 因为simulationDuration为null，所以此处执行 if (simulationDuration == null) { assert(!(this.duration == null \u0026amp;\u0026amp; _direction == _AnimationDirection.forward)); assert(!(this.duration == null \u0026amp;\u0026amp; _direction == _AnimationDirection.reverse \u0026amp;\u0026amp; reverseDuration == null)); // 获取动画的范围，因为在AnimationController构造方法中，upperBound与lowerBound参数均没传入，所以都是取默认值，upperBound为1.0，lowerBound为0.0，那么此处range为1.0 final double range = upperBound - lowerBound; // range.isFinite是判断range这个数字是否是有限的。 // 唯一的非有限数是 NaN 值、正无穷大和负无穷大。所有整数都是有限的。 // 所有数字都满足isInfinite、isFinite和isNaN之一 // 因为range为1.0，所以range.isFinite是true // 因为target为传入的upperBound，所以它的值为1.0，_value默认值为0.0，所以remainingFraction的最终计算结果为1.0，也就是动画的执行进度剩余百分比 final double remainingFraction = range.isFinite ? (target - _value).abs() / range : 1.0; // 如果动画方向为反向并且反向动画时间reverseDuration（此处reverseDuration也就是AnimationController构造方法传入的reverseDuration）不为null， // 那么directionDuration为反向动画时间，否则为正向动画时间duration（此处duration也就是AnimationController构造方法传入的duration） // 在前面的forward方法中，_direction已经被赋值为_AnimationDirection.forward，所以这里directionDuration为this.duration，也就是1s final Duration directionDuration = (_direction == _AnimationDirection.reverse \u0026amp;\u0026amp; reverseDuration != null) ? reverseDuration! : this.duration!; // 那么最终计算后的simulationDuration模拟持续时间为1s simulationDuration = directionDuration * remainingFraction; } else if (target == value) { // Already at target, don\u0026#39;t animate. simulationDuration = Duration.zero; } // 停止运行该动画。这不会触发任何通知。动画停止在当前状态。 stop(); // 因为simulationDuration为1s，所以这里不执行 if (simulationDuration == Duration.zero) { if (value != target) { _value = clampDouble(target, lowerBound, upperBound); notifyListeners(); } _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.completed : AnimationStatus.dismissed; _checkStatusChanged(); return TickerFuture.complete(); } assert(simulationDuration \u0026gt; Duration.zero); assert(!isAnimating); // 执行_startSimulation方法，并且创建_InterpolationSimulation实例并作为参数传入该方法 return _startSimulation(_InterpolationSimulation(_value, target, simulationDuration, curve, scale)); } 在AnimationController的 _animateToInternal 方法中，执行了 _startSimulation 方法，并且创建 _InterpolationSimulation 实例并作为参数传入该方法。\n继续跟踪AnimationController的 _startSimulation 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TickerFuture _startSimulation(Simulation simulation) { assert(!isAnimating); // 将前面创建的_InterpolationSimulation实例赋值给成员变量_simulation _simulation = simulation; // 初始化动画上一帧的时间，动画还没开始，所以为0 _lastElapsedDuration = Duration.zero; // 计算_value，也就是外部使用的_animation.value // clampDouble主要对simulation.x(0.0)这个结果做了大小限制（lowerBound \u0026lt;= 结果 \u0026lt;= upperBound） // 此处执行的是_InterpolationSimulation的x方法，_value的最终计算结果为0.0 _value = clampDouble(simulation.x(0.0), lowerBound, upperBound); // 启动Ticker，每个动画帧均会调用一次回调，这个等下再分析 final TickerFuture result = _ticker!.start(); // 因为_direction为_AnimationDirection.forward，所以此时_status状态为AnimationStatus.forward _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.forward : AnimationStatus.reverse; // 调用所有状态监听器 _checkStatusChanged(); // 最后将TickerFuture返回，但是本示例中没用到，这里就不讲解了 return result; } 关于simulation.x(0.0)，这里分析下，它执行了 _InterpolationSimulation 的x方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // _InterpolationSimulation的作用就是将Engine层返回的每一帧时间转换为[0.0, 1.0]范围的数值 class _InterpolationSimulation extends Simulation { // _begin传入的是_value，它的值为0.0 // _end传入的是target，它的值为1.0 // duration传入的是simulationDuration，它的值为1s // _curve传入的是curve，它的值为Curves.linear // scale传入的是scale，它的值为1.0 _InterpolationSimulation(this._begin, this._end, Duration duration, this._curve, double scale) : assert(duration.inMicroseconds \u0026gt; 0), // duration.inMicroseconds表示获取微秒数，所以1s的微秒数为1000000，microsecondsPerSecond表示每秒的微秒数 // 结合传入的参数值，那么_durationInSeconds最终的计算结果为1s _durationInSeconds = (duration.inMicroseconds * scale) / Duration.microsecondsPerSecond; final double _durationInSeconds; final double _begin; final double _end; final Curve _curve; @override double x(double timeInSeconds) { // 外部调用simulation.x(0.0)时传入0.0，所以此处timeInSeconds为0.0，所以t最终的计算结果为0 final double t = clampDouble(timeInSeconds / _durationInSeconds, 0.0, 1.0); // 因为t为0，所以执行这里，返回_begin，它的值为0.0 if (t == 0.0) { return _begin; } else if (t == 1.0) { return _end; } else { return _begin + (_end - _begin) * _curve.transform(t); } } } 关于 _checkStatusChanged 方法，这里分析下。\n1 2 3 4 5 6 7 8 9 10 11 12 AnimationStatus _lastReportedStatus = AnimationStatus.dismissed; void _checkStatusChanged() { // 因为在_startSimulation方法中，_status已经被赋值为AnimationStatus.forward，所以这里将成员变量_status赋值给status，那么此时newStatus的值为AnimationStatus.forward final AnimationStatus newStatus = status; // _lastReportedStatus的默认值为AnimationStatus.dismissed，所以if判断不相等，此处执行 if (_lastReportedStatus != newStatus) { _lastReportedStatus = newStatus; // 将newStatus通知给所有已注册的状态监听器 notifyStatusListeners(newStatus); } } 因为AnimationController混入了AnimationLocalStatusListenersMixin，所以这里的notifyStatusListeners方法执行的是AnimationLocalStatusListenersMixin的notifyStatusListeners方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void notifyStatusListeners(AnimationStatus status) { final List\u0026lt;AnimationStatusListener\u0026gt; localListeners = _statusListeners.toList(growable: false); for (final AnimationStatusListener listener in localListeners) { try { // 遍历所有AnimationStatusListener，将status回调出去 if (_statusListeners.contains(listener)) { listener(status); } } catch (exception, stack) { InformationCollector? collector; assert(() { collector = () =\u0026gt; \u0026lt;DiagnosticsNode\u0026gt;[ DiagnosticsProperty\u0026lt;AnimationLocalStatusListenersMixin\u0026gt;( \u0026#39;The $runtimeType notifying status listeners was\u0026#39;, this, style: DiagnosticsTreeStyle.errorProperty, ), ]; return true; }()); FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: \u0026#39;animation library\u0026#39;, context: ErrorDescription(\u0026#39;while notifying status listeners for $runtimeType\u0026#39;), informationCollector: collector, )); } } } 先回到 _startSimulation 方法上来，其实整个 _startSimulation 方法的重点是_ticker!.start()，因为它启动了动画，那么 _ticker 是什么？又在哪创建的？\n5.2、AnimationController的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimationController extends Animation\u0026lt;double\u0026gt; with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin { AnimationController({ double? value, this.duration, this.reverseDuration, this.debugLabel, this.lowerBound = 0.0, this.upperBound = 1.0, this.animationBehavior = AnimationBehavior.normal, required TickerProvider vsync, }) : assert(upperBound \u0026gt;= lowerBound), _direction = _AnimationDirection.forward { // 此处执行了TickerProvider的createTicker方法 _ticker = vsync.createTicker(_tick); _internalSetValue(value ?? lowerBound); } } 在AnimationController的构造方法中，执行了vsync.createTicker(_tick)这行代码，也就是执行了TickerProvider的createTicker方法，而createTicker方法需要传入的参数是一个TickerCallback，这里传入的实参为AnimationController的 _tick 方法。\n在本示例中，vsync参数传入的是this，即混入的SingleTickerProviderStateMixin，它是专门用来提供和管理单个Ticker。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class _MyWidgetState extends State\u0026lt;MyWidget\u0026gt; with SingleTickerProviderStateMixin { late AnimationController _animationController; late Animation\u0026lt;double\u0026gt; _animation; @override void initState() { super.initState(); _animationController = AnimationController( // 传入this，即混入的SingleTickerProviderStateMixin vsync: this, duration: const Duration(seconds: 1), reverseDuration: const Duration(seconds: 1), ); } } 因此，vsync.createTicker实际上执行了SingleTickerProviderStateMixin的createTicker方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 mixin SingleTickerProviderStateMixin\u0026lt;T extends StatefulWidget\u0026gt; on State\u0026lt;T\u0026gt; implements TickerProvider { Ticker? _ticker; @override Ticker createTicker(TickerCallback onTick) { assert(() { if (_ticker == null) { return true; } throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;$runtimeType is a SingleTickerProviderStateMixin but multiple tickers were created.\u0026#39;), ErrorDescription(\u0026#39;A SingleTickerProviderStateMixin can only be used as a TickerProvider once.\u0026#39;), ErrorHint( \u0026#39;If a State is used for multiple AnimationController objects, or if it is passed to other \u0026#39; \u0026#39;objects and those objects might use it more than one time in total, then instead of \u0026#39; \u0026#39;mixing in a SingleTickerProviderStateMixin, use a regular TickerProviderStateMixin.\u0026#39;, ), ]); }()); // 这里创建了Ticker实例并赋值给成员变量_ticker // 此处Ticker构造方法传入的参数onTick，它的实例是AnimationController的_tick方法。 _ticker = Ticker(onTick, debugLabel: kDebugMode ? \u0026#39;created by ${describeIdentity(this)}\u0026#39; : null); _updateTickerModeNotifier(); _updateTicker(); // Sets _ticker.mute correctly. // 把Ticker实例返回 return _ticker!; } } 当 _startSimulation 方法执行了 _ticker!.start() 时，就会执行上面创建的 _ticker 的start方法，跟踪下Ticker的start方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 TickerFuture start() { assert(() { if (isActive) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;A ticker was started twice.\u0026#39;), ErrorDescription(\u0026#39;A ticker that is already active cannot be started again without first stopping it.\u0026#39;), describeForError(\u0026#39;The affected ticker was\u0026#39;), ]); } return true; }()); assert(_startTime == null); // 此处创建了一个TickerFuture对象，表示正在进行的Ticker序列的对象。 // Ticker.start方法返回一个TickerFuture。如果使用Ticker.stop停止Ticker ，并将canceled参数设置为 false（默认值），则TickerFuture将成功完成。 // 如果Ticker在未停止的情况下被处置，或者如果在canceled设置为 true 的情况下停止，则此 Future 将永远不会完成 _future = TickerFuture._(); // shouldScheduleTick表示是否应该安排一个tick // 不应安排tick的原因包括： // 1、已经为下一帧安排了一个tick // 2、ticker未激活（尚未调用start） // 3、ticker没有在ticking，例如因为它被muted （请参阅isTicking ） // 通过断点调试来看，此处shouldScheduleTick为true，所以执行了scheduleTick方法。 if (shouldScheduleTick) { scheduleTick(); } // schedulerPhase表示调度程序当前运行的阶段，通过断点调试来看，SchedulerBinding.instance.schedulerPhase.index的值为0， // 也就是schedulerPhase所处状态为idle，所以SchedulerBinding.instance.schedulerPhase.index \u0026gt; SchedulerPhase.idle.index不满足，不会执行这里代码 if (SchedulerBinding.instance.schedulerPhase.index \u0026gt; SchedulerPhase.idle.index \u0026amp;\u0026amp; SchedulerBinding.instance.schedulerPhase.index \u0026lt; SchedulerPhase.postFrameCallbacks.index) { _startTime = SchedulerBinding.instance.currentFrameTimeStamp; } // 返回一个TickerFuture对象，此处的返回就是forward方法的返回值 return _future!; } 在Ticker的start方法中，执行了scheduleTick方法，跟踪看看。\n1 2 3 4 5 6 7 // scheduleTick方法的作用是为下一帧安排一个tick void scheduleTick({ bool rescheduling = false }) { assert(!scheduled); assert(shouldScheduleTick); // 执行了SchedulerBinding的scheduleFrameCallback方法，该方法需要传入一个FrameCallback实例，该实例就是Ticker的_tick方法。 _animationId = SchedulerBinding.instance.scheduleFrameCallback(_tick, rescheduling: rescheduling); } 先看下SchedulerBinding的scheduleFrameCallback方法。\n1 2 3 4 5 6 7 8 9 10 int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) { // 执行了scheduleFrame方法。调用dart:ui.PlatformDispatcher.scheduleFrame来安排新帧 // 调用此函数后，引擎将（最终）调用handleBeginFrame scheduleFrame(); // 下一帧回调实例的Id，此处+1 _nextFrameCallbackId += 1; // 将callback包装成_FrameCallbackEntry对象，存入瞬态回调Map集合_transientCallbacks中 _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling); return _nextFrameCallbackId; } 看下SchedulerBinding的scheduleFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void scheduleFrame() { if (_hasScheduledFrame || !framesEnabled) { return; } assert(() { if (debugPrintScheduleFrameStacks) { debugPrintStack(label: \u0026#39;scheduleFrame() called. Current phase is $schedulerPhase.\u0026#39;); } return true; }()); // 执行ensureFrameCallbacksRegistered方法，确保PlatformDispatcher.onBeginFrame和PlatformDispatcher.onDrawFrame的回调已注册 ensureFrameCallbacksRegistered(); // 执行platformDispatcher的scheduleFrame，请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调 platformDispatcher.scheduleFrame(); _hasScheduledFrame = true; } 看下ensureFrameCallbacksRegistered方法。\n1 2 3 4 5 6 7 @protected void ensureFrameCallbacksRegistered() { // 为platformDispatcher的onBeginFrame注册回调，这里具体实现是_handleBeginFrame方法 platformDispatcher.onBeginFrame ??= _handleBeginFrame; // 为platformDispatcher的onDrawFrame注册回调，这里具体实现是_handleDrawFrame方法 platformDispatcher.onDrawFrame ??= _handleDrawFrame; } 再看下platformDispatcher.scheduleFrame()，这里是external修饰，说明调用了Engine层的方法了，它在不同平台有不同实现。\n1 2 3 4 5 // 请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调。 void scheduleFrame() =\u0026gt; _scheduleFrame(); @Native\u0026lt;Void Function()\u0026gt;(symbol: \u0026#39;PlatformConfigurationNativeApi::ScheduleFrame\u0026#39;) external static void _scheduleFrame(); 这里就不深入底层实现了，不过可以猜测，在Android中应该是调用了Choreographer注册了Vysnc信号监听，然后再回调给Flutter，具体留给你们去验证了。\n等到Engine层处理完成，将会回调给Framework层的 _beginFrame 方法，在 _beginFrame 方法中执行了PlatformDispatcher的 _beginFrame 方法。\n1 2 3 4 5 @pragma(\u0026#39;vm:entry-point\u0026#39;) void _beginFrame(int microseconds, int frameNumber) { PlatformDispatcher.instance._beginFrame(microseconds); PlatformDispatcher.instance._updateFrameData(frameNumber); } 在PlatformDispatcher的 _beginFrame 方法中，执行了 _invoke1 方法，第一个参数传入的是onBeginFrame回调，这个就是之前讲过的SchedulerBinding的ensureFrameCallbacksRegistered方法中注册的回调。\n1 2 3 4 5 6 7 8 void _beginFrame(int microseconds) { _invoke1\u0026lt;Duration\u0026gt;( // 此处传入onBeginFrame onBeginFrame, _onBeginFrameZone, Duration(microseconds: microseconds), ); } 来看下 _invoke1 方法，执行了callback()，也就是调用了onBeginFrame的回调引用，那么就会触发SchedulerBinding的 _handleBeginFrame 方法。\n1 2 3 4 5 6 7 8 9 10 11 void _invoke1\u0026lt;A\u0026gt;(void Function(A a)? callback, Zone zone, A arg) { if (callback == null) { return; } if (identical(zone, Zone.current)) { // 此处调用外部方法引用，传入参数是arg，也就是一个Duration，这个时间是每一帧的时间 callback(arg); } else { zone.runUnaryGuarded\u0026lt;A\u0026gt;(callback, arg); } } 继续看SchedulerBinding的 _handleBeginFrame 方法，执行了handleBeginFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void handleBeginFrame(Duration? rawTimeStamp) { _frameTimelineTask?.start(\u0026#39;Frame\u0026#39;); _firstRawTimeStampInEpoch ??= rawTimeStamp; _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp); if (rawTimeStamp != null) { _lastRawTimeStamp = rawTimeStamp; } assert(() { _debugFrameNumber += 1; if (debugPrintBeginFrameBanner || debugPrintEndFrameBanner) { final StringBuffer frameTimeStampDescription = StringBuffer(); if (rawTimeStamp != null) { _debugDescribeTimeStamp(_currentFrameTimeStamp!, frameTimeStampDescription); } else { frameTimeStampDescription.write(\u0026#39;(warm-up frame)\u0026#39;); } _debugBanner = \u0026#39;▄▄▄▄▄▄▄▄ Frame ${_debugFrameNumber.toString().padRight(7)} ${frameTimeStampDescription.toString().padLeft(18)} ▄▄▄▄▄▄▄▄\u0026#39;; if (debugPrintBeginFrameBanner) { debugPrint(_debugBanner); } } return true; }()); assert(schedulerPhase == SchedulerPhase.idle); _hasScheduledFrame = false; try { // TRANSIENT FRAME CALLBACKS _frameTimelineTask?.start(\u0026#39;Animate\u0026#39;); _schedulerPhase = SchedulerPhase.transientCallbacks; final Map\u0026lt;int, _FrameCallbackEntry\u0026gt; callbacks = _transientCallbacks; _transientCallbacks = \u0026lt;int, _FrameCallbackEntry\u0026gt;{}; // 此处遍历执行_transientCallbacks，也就是传入的Ticker的_tick方法实例 callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) { if (!_removedIds.contains(id)) { _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp!, callbackEntry.debugStack); } }); _removedIds.clear(); } finally { _schedulerPhase = SchedulerPhase.midFrameMicrotasks; } } 看下Ticker的 _tick 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void _tick(Duration timeStamp) { assert(isTicking); assert(scheduled); _animationId = null; _startTime ??= timeStamp; // 执行了SingleTickerProviderStateMixin的createTicker方法中传入的onTick参数 // 也就是执行了AnimationController构造方法中的vsync.createTicker(_tick)传入的_tick方法实例 _onTick(timeStamp - _startTime!); // The onTick callback may have scheduled another tick already, for // example by calling stop then start again. if (shouldScheduleTick) { scheduleTick(rescheduling: true); } } 看下AnimationController的 _tick 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // elapsed是Engine层返回的每一帧时间Duration，每一帧的时间都不一样 void _tick(Duration elapsed) { _lastElapsedDuration = elapsed; // 将拿到的每一帧的时间单位改为秒 final double elapsedInSeconds = elapsed.inMicroseconds.toDouble() / Duration.microsecondsPerSecond; assert(elapsedInSeconds \u0026gt;= 0.0); // 执行clampDouble方法获取_value，此时的_value依然是_simulation控制，也就是_InterpolationSimulation实例 _value = clampDouble(_simulation!.x(elapsedInSeconds), lowerBound, upperBound); // 等到elapsedInSeconds时间达到我们设定的动画时间Duration，也就是本示例中的1s，表示动画执行完成 if (_simulation!.isDone(elapsedInSeconds)) { // 如果_direction是_AnimationDirection.forward，更改_status为AnimationStatus.completed，否则改为AnimationStatus.dismissed _status = (_direction == _AnimationDirection.forward) ? AnimationStatus.completed : AnimationStatus.dismissed; // 停止当前动画，移除当前瞬态帧回调，那么_tick方法就不会被再回调执行 stop(canceled: false); } // 执行notifyListeners方法，通知所有listeners回调 notifyListeners(); // 执行_checkStatusChanged，通知所有status listeners回调 _checkStatusChanged(); } 至此，forward方法完成了第一帧动画的初始操作，可以说它启动了动画。等到在addListener方法中执行setState方法时，就会触发下一轮 _tick 方法的执行以及build方法的执行，这样一帧一帧执行直到动画完成。\n关于setState方法的分析参考解读Flutter源码之setState一文。\n5.3、_animation.value 通过 _animation.value 最初拿到的是AnimationController的 _value，也就是上面 _tick 方法中计算出来的 _value，为什么这么说呢？看下面分析就知道了。\n在本示例中，CurvedAnimation的构造方法将 _animationController 作为参数传了进去。\n1 2 3 4 5 6 _animation = CurvedAnimation( // 传入_animationController parent: _animationController, curve: Curves.easeIn, reverseCurve: Curves.bounceIn, ); 可以发现CurvedAnimation混入了AnimationWithParentMixin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CurvedAnimation extends Animation\u0026lt;double\u0026gt; with AnimationWithParentMixin\u0026lt;double\u0026gt; { CurvedAnimation({ required this.parent, required this.curve, this.reverseCurve, }) { // 根据_animationController的初始状态，更新Curved曲线的方向 _updateCurveDirection(parent.status); // 给_animationController注册状态监听，用来更新后续Curved曲线的方向 parent.addStatusListener(_updateCurveDirection); } @override final Animation\u0026lt;double\u0026gt; parent; } 看下AnimationWithParentMixin，可以发现此时的listeners管理以及status依然是转发给parent处理，也就是还是由AnimationController来管理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 mixin AnimationWithParentMixin\u0026lt;T\u0026gt; { Animation\u0026lt;T\u0026gt; get parent; void addListener(VoidCallback listener) =\u0026gt; parent.addListener(listener); void removeListener(VoidCallback listener) =\u0026gt; parent.removeListener(listener); void addStatusListener(AnimationStatusListener listener) =\u0026gt; parent.addStatusListener(listener); void removeStatusListener(AnimationStatusListener listener) =\u0026gt; parent.removeStatusListener(listener); AnimationStatus get status =\u0026gt; parent.status; } 但是，CurvedAnimation重写了AnimationController成员变量value，可以看到在value中拿到parent.value后，执行了 activeCurve.transform(t) 进行转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @override double get value { // 获取Curves曲线的方向 final Curve? activeCurve = _useForwardCurve ? curve : reverseCurve; // 获取AnimationController的value值，这个值之前由simulation计算得来 final double t = parent.value; if (activeCurve == null) { return t; } // 控制动画范围 if (t == 0.0 || t == 1.0) { assert(() { final double transformedValue = activeCurve.transform(t); final double roundedTransformedValue = transformedValue.round().toDouble(); if (roundedTransformedValue != t) { throw FlutterError( \u0026#39;Invalid curve endpoint at $t.\\n\u0026#39; \u0026#39;Curves must map 0.0 to near zero and 1.0 to near one but \u0026#39; \u0026#39;${activeCurve.runtimeType} mapped $t to $transformedValue, which \u0026#39; \u0026#39;is near $roundedTransformedValue.\u0026#39;, ); } return true; }()); return t; } // 执行Curve转换 return activeCurve.transform(t); } 这里执行了Curve的父类ParametricCurve的transform方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class Curve extends ParametricCurve\u0026lt;double\u0026gt; { const Curve(); @override double transform(double t) { // 控制动画范围 if (t == 0.0 || t == 1.0) { return t; } // 执行父类ParametricCurve的transform方法 return super.transform(t); } } 在ParametricCurve的transform方法中，执行了transformInternal方法，该方法由子类实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 abstract class ParametricCurve\u0026lt;T\u0026gt; { const ParametricCurve(); T transform(double t) { assert(t \u0026gt;= 0.0 \u0026amp;\u0026amp; t \u0026lt;= 1.0, \u0026#39;parametric value $t is outside of [0, 1] range.\u0026#39;); // 执行transformInternal方法 return transformInternal(t); } @protected T transformInternal(double t) { throw UnimplementedError(); } } 在本示例中，对于动画的方向是正向的，CurvedAnimation构造方法中传入的子类是Curves.easeIn；对于动画的方向是反向的，CurvedAnimation构造方法中传入的子类是Curves.bounceIn。因为本示例只讲解forward方法，所以这里只以Curves.easeIn为例讲解，看下源码。\n1 static const Cubic easeIn = Cubic(0.42, 0.0, 1.0, 1.0); 看下Cubic实现的transformInternal方法。它是返回点t处的曲线值。但是给定的参数值t将介于 0.0 和 1.0 之间（包含 0.0 和 1.0），那和我们实际Widget的参数映射还是不一致，比如本示例中Icon的size参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @override double transformInternal(double t) { double start = 0.0; double end = 1.0; while (true) { final double midpoint = (start + end) / 2; final double estimate = _evaluateCubic(a, c, midpoint); if ((t - estimate).abs() \u0026lt; _cubicErrorBound) { return _evaluateCubic(b, d, midpoint); } if (estimate \u0026lt; t) { start = midpoint; } else { end = midpoint; } } } 想要和我们实际Widget的参数映射一致，就需要讲到Tween了，看下本示例中的实现。\n1 _animation = Tween(begin: 200.0, end: 300.0).animate(_animation) 看下Tween的animate方法，方法参数传入了上一步创建的CurvedAnimation，返回的是 _AnimatedEvaluation 实例。\n1 2 3 Animation\u0026lt;T\u0026gt; animate(Animation\u0026lt;double\u0026gt; parent) { return _AnimatedEvaluation\u0026lt;T\u0026gt;(parent, this); } 看下 _AnimatedEvaluation实现。\n1 2 3 4 5 6 7 8 9 10 11 class _AnimatedEvaluation\u0026lt;T\u0026gt; extends Animation\u0026lt;T\u0026gt; with AnimationWithParentMixin\u0026lt;double\u0026gt; { _AnimatedEvaluation(this.parent, this._evaluatable); @override final Animation\u0026lt;double\u0026gt; parent; final Animatable\u0026lt;T\u0026gt; _evaluatable; @override T get value =\u0026gt; _evaluatable.evaluate(parent); } 可以看到 _AnimatedEvaluation 继承自Animation，和CurvedAnimation一样混入了AnimationWithParentMixin，此时的listeners管理以及status是转发给parent处理，也就是CurvedAnimation。\n而且 _AnimatedEvaluation 重写了AnimationController成员变量value，当执行 _animation.value时就会调用该value。可以看到在value中执行了 _evaluatable.evaluate(parent) 进行转换。\n_evaluatable 就是 _AnimatedEvaluation 构造方法传入进来的this，指的是Tween实例，又因为Tween继承自Animatable，看下Animatable的evaluate方法。\n1 2 3 4 5 6 abstract class Animatable\u0026lt;T\u0026gt; { T transform(double t); T evaluate(Animation\u0026lt;double\u0026gt; animation) =\u0026gt; transform(animation.value); } 可以看到啊，在Animatable的evaluate方法中，执行了transform方法，传入的是animation.value，实际上就拿到了CurvedAnimation的value，这个方法由子类实现，现在看下Tween的transform方法。\n1 2 3 4 5 6 7 8 9 10 @override T transform(double t) { if (t == 0.0) { return begin as T; } if (t == 1.0) { return end as T; } return lerp(t); } 在Tween的transform方法中，执行了lerp方法进行Widget参数映射到[0.0, 1.0]范围。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @protected T lerp(double t) { assert(begin != null); assert(end != null); assert(() { // Assertions that attempt to catch common cases of tweening types // that do not conform to the Tween requirements. dynamic result; try { // ignore: avoid_dynamic_calls result = (begin as dynamic) + ((end as dynamic) - (begin as dynamic)) * t; result as T; return true; } on NoSuchMethodError { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot lerp between \u0026#34;$begin\u0026#34; and \u0026#34;$end\u0026#34;.\u0026#39;), ErrorDescription( \u0026#39;The type ${begin.runtimeType} might not fully implement `+`, `-`, and/or `*`. \u0026#39; \u0026#39;See \u0026#34;Types with special considerations\u0026#34; at https://api.flutter.dev/flutter/animation/Tween-class.html \u0026#39; \u0026#39;for more information.\u0026#39;, ), if (begin is Color || end is Color) ErrorHint(\u0026#39;To lerp colors, consider ColorTween instead.\u0026#39;) else if (begin is Rect || end is Rect) ErrorHint(\u0026#39;To lerp rects, consider RectTween instead.\u0026#39;) else ErrorHint( \u0026#39;There may be a dedicated \u0026#34;${begin.runtimeType}Tween\u0026#34; for this type, \u0026#39; \u0026#39;or you may need to create one.\u0026#39;, ), ]); } on TypeError { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;Cannot lerp between \u0026#34;$begin\u0026#34; and \u0026#34;$end\u0026#34;.\u0026#39;), ErrorDescription( \u0026#39;The type ${begin.runtimeType} returned a ${result.runtimeType} after \u0026#39; \u0026#39;multiplication with a double value. \u0026#39; \u0026#39;See \u0026#34;Types with special considerations\u0026#34; at https://api.flutter.dev/flutter/animation/Tween-class.html \u0026#39; \u0026#39;for more information.\u0026#39;, ), if (begin is int || end is int) ErrorHint(\u0026#39;To lerp int values, consider IntTween or StepTween instead.\u0026#39;) else ErrorHint( \u0026#39;There may be a dedicated \u0026#34;${begin.runtimeType}Tween\u0026#34; for this type, \u0026#39; \u0026#39;or you may need to create one.\u0026#39;, ), ]); } }()); // ignore: avoid_dynamic_calls return (begin as dynamic) + ((end as dynamic) - (begin as dynamic)) * t as T; } 关于lerp方法，这里插一嘴，因为Tween的子类很多，所以lerp方法可以由Tween的子类去实现，例如Tween的子类SizeTween，看下SizeTween的lerp方法。\n1 2 3 4 5 6 7 class SizeTween extends Tween\u0026lt;Size?\u0026gt; { SizeTween({ super.begin, super.end }); @override Size? lerp(double t) =\u0026gt; Size.lerp(begin, end, t); } 可以发现SizeTween的lerp方法，它是调用了Size的lerp方法。除了Size之外，还有很多类也重写了lerp方法，比如Color，BorderRadius，Border等等，它们分别对应的是ColorTween，BorderRadiusTween，BorderTween。\n总结一下本示例中 _animation.value 的执行过程：\n当外部调用_animation.value时，就会执行Tween中的value，在Tween的value中就会执行CurvedAnimation中的value，在CurvedAnimation的value中就会执行AnimationController的value。\n所以说 _animation.value 的执行是一个向上转发，向下执行的过程。\n六、动画总结 当执行forward方法时，就会启动动画，此时只是执行了动画的第一帧，然后就会触发addListener的回调，在addListener的回调中，执行了setState方法。\n接着又会触发addListener的回调与build方法的执行，这样就形成了递归执行的过程，在这个过程中，通过引用 _animation.value 可以拿到每一帧的值，这个值是经过了simulation模拟计算将每一帧时间转换为[0.0，1.0]范围，在[0.0，1.0]范围内也经过了Curve曲线速度的转换，最后再通过Tween映射为具体的Widget的参数范围。\n每次build方法执行时，_animation.value 的值会重新计算，从而改变Widget参数完成整个动画过程。\n","date":"2023-11-04T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Banimation/","section":"post","tags":null,"title":"解读Flutter源码之Animation"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、子Widget多层嵌套之状态管理问题 在Flutter开发中，如果父Widget想要控制子Widget的状态，最常见的办法是把子Widget的状态提升到父Widget中，当父Widget修改该状态并且执行了setState方法之后，子Widget就会发生重建，而子Widget可通过构造方法传入父Widget的状态，然后在build方法中使用该状态即可。\n例如下面这个计数器示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyChild(counter: _counter), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyChild extends StatelessWidget { final int counter; const MyChild({super.key, required this.counter}); @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Text( \u0026#39;$counter\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ); } } 程序运行UI效果为：\n点击FloatingActionButton时日志打印如下：\n1 I/flutter ( 7101): build 但是，如果考虑到父Widget与子Widget之间嵌套很深的情况时，上面的方案其实就不是那么好使了，因为状态的传递需要通过子Widget的构造方法一层一层地传入，这样维护起来非常麻烦且不够优雅，那么Flutter官方有提供什么解决办法呢？是有的，它就是InheritedWidget。\n二、什么是InheritedWidget？ 遇事不决，先看InheritedWidget的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 /// 有效地沿树传播信息的widgets的基类。 /// Base class for widgets that efficiently propagate information down the tree. /// /// 要从构建上下文获取特定类型的inherited widget的最近实例，请使用BuildContext.dependOnInheritedWidgetOfExactType。 /// To obtain the nearest instance of a particular type of inherited widget from /// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType]. /// /// 当以这种方式引用Inherited widgets时，当Inherited widgets本身更改状态时，将导致使用者重建。 /// Inherited widgets, when referenced in this way, will cause the consumer to /// rebuild when the inherited widget itself changes state. /// /// 以下是名为FrogColor的inherited widget的骨架 /// The following is a skeleton of an inherited widget called `FrogColor`: /// /// ```dart /// class FrogColor extends InheritedWidget { /// const FrogColor({ /// super.key, /// required this.color, /// required super.child, /// }); /// /// final Color color; /// /// static FrogColor? maybeOf(BuildContext context) { /// return context.dependOnInheritedWidgetOfExactType\u0026lt;FrogColor\u0026gt;(); /// } /// /// static FrogColor of(BuildContext context) { /// final FrogColor? result = maybeOf(context); /// assert(result != null, \u0026#39;No FrogColor found in context\u0026#39;); /// return result!; /// } /// /// @override /// bool updateShouldNotify(FrogColor oldWidget) =\u0026gt; color != oldWidget.color; /// } /// ``` /// {@end-tool} /// /// ## 实现“of”和“maybeOf”方法 /// ## Implementing the `of` and `maybeOf` methods /// /// 约定是在InheritedWidget上提供两个静态方法of和maybeOf ，它们调用BuildContext.dependOnInheritedWidgetOfExactType。 /// 这允许类定义自己的后备逻辑，以防范围内没有widget /// The convention is to provide two static methods, `of` and `maybeOf`, on the /// [InheritedWidget] which call /// [BuildContext.dependOnInheritedWidgetOfExactType]. This allows the class to /// define its own fallback logic in case there isn\u0026#39;t a widget in scope. /// /// `of` 方法通常返回一个不可为 null 的实例，并在未找到 [InheritedWidget] 时断言，而 `maybeOf` 方法则返回一个可为 null 的实例，并在未找到 [InheritedWidget] 时返回 null。 /// “of”方法通常通过内部调用“maybeOf”来实现。 /// The `of` method typically returns a non-nullable instance and asserts if the /// [InheritedWidget] isn\u0026#39;t found, and the `maybeOf` method returns a nullable /// instance, and returns null if the [InheritedWidget] isn\u0026#39;t found. The `of` /// method is typically implemented by calling `maybeOf` internally. /// /// 有时，“of”和“maybeOf”方法返回一些数据，而不是inherited widget本身；例如，在这种情况下，它可能返回一个 [Color] 而不是“FrogColor”小部件。 /// Sometimes, the `of` and `maybeOf` methods return some data rather than the /// inherited widget itself; for example, in this case it could have returned a /// [Color] instead of the `FrogColor` widget. /// /// 有时，inherited widget是另一个类的实现细节，因此是私有的。 /// 在这种情况下，“of”和“maybeOf”方法通常在公共类上实现。 /// 例如，[Theme]被实现为[StatelessWidget]，它构建了一个私有inherited widget； [Theme.of] 使用 [BuildContext.dependOnInheritedWidgetOfExactType] 查找inherited widget，然后返回其中的 [ThemeData]。 /// Occasionally, the inherited widget is an implementation detail of another /// class, and is therefore private. The `of` and `maybeOf` methods in that case /// are typically implemented on the public class instead. For example, [Theme] /// is implemented as a [StatelessWidget] that builds a private inherited /// widget; [Theme.of] looks for that private inherited widget using /// [BuildContext.dependOnInheritedWidgetOfExactType] and then returns the /// [ThemeData] inside it. /// /// ## 调用“of”或“maybeOf”方法 /// ## Calling the `of` or `maybeOf` methods /// /// 使用“of”或“maybeOf”方法时，“context”必须是 [InheritedWidget] 的后代，这意味着它必须位于树中 [InheritedWidget]“下方”。 /// When using the `of` or `maybeOf` methods, the `context` must be a descendant /// of the [InheritedWidget], meaning it must be \u0026#34;below\u0026#34; the [InheritedWidget] /// in the tree. /// /// 在此示例中，使用的“context”是来自 [Builder] 的context，它是“FrogColor” widget的子级，因此这是可行的。 /// In this example, the `context` used is the one from the [Builder], which is /// a child of the `FrogColor` widget, so this works. /// /// ```dart /// // continuing from previous example... /// class MyPage extends StatelessWidget { /// const MyPage({super.key}); /// /// @override /// Widget build(BuildContext context) { /// return Scaffold( /// body: FrogColor( /// color: Colors.green, /// child: Builder( /// builder: (BuildContext innerContext) { /// return Text( /// \u0026#39;Hello Frog\u0026#39;, /// style: TextStyle(color: FrogColor.of(innerContext).color), /// ); /// }, /// ), /// ), /// ); /// } /// } /// ``` /// 在此示例中，使用的“context”是来自“MyOtherPage” widget的上下文，该widget是“FrogColor”widget的父级，因此这不起作用，并且会在调用“FrogColor.of”时断言。 /// In this example, the `context` used is the one from the `MyOtherPage` /// widget, which is a parent of the `FrogColor` widget, so this does not work, /// and will assert when `FrogColor.of` is called. /// /// ```dart /// // continuing from previous example... /// /// class MyOtherPage extends StatelessWidget { /// const MyOtherPage({super.key}); /// /// @override /// Widget build(BuildContext context) { /// return Scaffold( /// body: FrogColor( /// color: Colors.green, /// child: Text( /// \u0026#39;Hello Frog\u0026#39;, /// style: TextStyle(color: FrogColor.of(context).color), /// ), /// ), /// ); /// } /// } /// ``` 可以看到，注释详细地描述了InheritedWidget的特性以及贴心地给出了相应的示例，根据InheritedWidget的注释，可以总结下它的特性：\n1、InheritedWidget是沿着Widget树传播信息的基类。\n2、可以使用BuildContext.dependOnInheritedWidgetOfExactType获取特定类型的InheritedWidget的最近实例。\n3、当InheritedWidget本身更改状态时，将导致使用者重建。\n4、使用of或maybeOf方法时，context必须是InheritedWidget的后代，这意味着它必须位于树中InheritedWidget下方。\n5、\u0026hellip;\n这里给出了InheritedWidget的部分特性，主要是想让大家对InheritedWidget有一个初级认知。\n继续看下InheritedWidget的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 abstract class InheritedWidget extends ProxyWidget { const InheritedWidget({ super.key, required super.child }); @override InheritedElement createElement() =\u0026gt; InheritedElement(this); /// 框架是否应该通知继承自此widget的widgets /// Whether the framework should notify widgets that inherit from this widget. /// /// 当这个widget被重建时，有时我们需要重建从这个widget继承的widgets，但有时我们不需要。 /// 例如，如果这个widget保存的数据与“oldWidget”保存的数据相同，那么我们不需要重建继承“oldWidget”保存数据的widgets。 /// When this widget is rebuilt, sometimes we need to rebuild the widgets that /// inherit from this widget but sometimes we do not. For example, if the data /// held by this widget is the same as the data held by `oldWidget`, then we /// do not need to rebuild the widgets that inherited the data held by /// `oldWidget`. /// /// 框架通过使用先前占据树中此位置的widget作为参数来调用此函数来区分这些情况。 /// 保证给定的widget与该对象具有相同的 [runtimeType]。 /// The framework distinguishes these cases by calling this function with the /// widget that previously occupied this location in the tree as an argument. /// The given widget is guaranteed to have the same [runtimeType] as this /// object. @protected bool updateShouldNotify(covariant InheritedWidget oldWidget); } 可以发现，InheritedWidget继承自ProxyWidget，InheritedWidget的构造方法需要传入一个child，createElement方法返回了一个InheritedElement实例，并且在父类ProxyWidget的基础上新增了一个updateShouldNotify方法，从该方法的注释也可以了解到，它用于判断是否应该通知继承InheritedWidget的Widget。\n三、InheritedWidget示例演示 使用InheritedWidget改造之前的计数器示例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;计数器\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { int _counter = 0; void _increment() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: MyParent( counter: _counter, child: const MyChild(), ), floatingActionButton: FloatingActionButton( onPressed: _increment, tooltip: \u0026#39;increment\u0026#39;, child: const Icon(Icons.add), ), ); } } class MyParent extends InheritedWidget { final int counter; const MyParent({super.key, required this.counter, required super.child}); static MyParent? maybeOf(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;MyParent\u0026gt;(); static MyParent of(BuildContext context) { final MyParent? result = maybeOf(context); assert(result != null, \u0026#39;No MyParent found in context\u0026#39;); return result!; } @override bool updateShouldNotify(covariant MyParent oldWidget) =\u0026gt; counter != oldWidget.counter; } class MyChild extends StatefulWidget { const MyChild({super.key}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { @override void didChangeDependencies() { super.didChangeDependencies(); debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Text( \u0026#39;${MyParent.of(context).counter}\u0026#39;, style: const TextStyle( fontSize: 100, color: Colors.black, ), ), ); } } 程序运行UI效果和之前的计数器示例一样，可以参考上面gif图。\n在InheritedWidget示例中，点击FloatingActionButton时日志打印如下：\n1 2 I/flutter ( 7101): didChangeDependencies I/flutter ( 7101): build 在上面的InheritedWidget示例中，可以发现存在3个疑点：\n1、对于之前的计数器示例，每次点击FloatingActionButton时仅会触发build方法，而对于InheritedWidget示例，如果目标子Widget是StatefulWidget，那么还会触发State的didChangeDependencies方法，这是为什么呢？\n2、如果把InheritedWidget示例中const MyChild()的const修饰去掉，会发生什么？\n3、我们知道，子Widget通过MyParent.of方法获取InheritedWidget的实例，使用的是context的dependOnInheritedWidgetOfExactType方法，除此之外还有一个getInheritedWidgetOfExactType方法也可以获取InheritedWidget的实例，那这两个方法之间有什么区别？\n关于这3个疑点，等下分析源码时再进行讲解。\n四、分析InheritedWidget源码 4.1、InheritedElement注册阶段 程序启动后，当执行到MyChild关联的State的build方法时，就会调用MyParent.of方法，而InheritedElement注册阶段在于context的dependOnInheritedWidgetOfExactType方法，具体实现在Element，点击进去看下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @override T? dependOnInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;({Object? aspect}) { assert(_debugCheckStateIsActiveForAncestorLookup()); // 分析1 final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T]; // 分析2 if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } // 分析3 _hadUnsatisfiedDependencies = true; return null; } 分析1：这里涉及Element的成员变量_inheritedElements，代码如下：\n1 PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt;? _inheritedElements; 可以看到_inheritedElements的类型是PersistentHashMap，它是一个键值对的集合，其中Key为Type，这里的Type为InheritedWidget或InheritedWidget的子类，Value为InheritedElement。\n在分析1中，首先判断_inheritedElements == null，如果不为null，那么以InheritedWidget类型为Key获取InheritedElement。\n那么_inheritedElements是在哪里赋值的？对于非InheritedElement来说，它是在Element的_updateInheritance()方法中赋值，看下它的源码。\n1 2 3 4 void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); _inheritedElements = _parent?._inheritedElements; } 而对于InheritedElement来说，它是在InheritedElement的_updateInheritance()方法中赋值，看下它的源码。\n1 2 3 4 5 6 7 @override void _updateInheritance() { assert(_lifecycleState == _ElementLifecycle.active); final PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt; incomingWidgets = _parent?._inheritedElements ?? const PersistentHashMap\u0026lt;Type, InheritedElement\u0026gt;.empty(); _inheritedElements = incomingWidgets.put(widget.runtimeType, this); } 可以看到，如果父类的_inheritedElements为null，那么就会创建一个空的PersistentHashMap实例，赋值给局部变量incomingWidgets，然后以InheritedWidget的runtimeType为Key，把当前的InheritedElement作为Value存入该HashMap中。\n那么_updateInheritance()方法是在哪里触发的？它是在Element的mount方法中触发的，也就是当InheritedElement添加到Element树时，就会将InheritedElement存入到这个_inheritedElements。\n以及在Element的activate方法中触发的，也就是当InheritedElement重新合并到Element树时，就会将InheritedElement存入到这个_inheritedElements。\n现在知道了为什么通过dependOnInheritedWidgetOfExactType方法能够获取距离目标子Widget最近的一个InheritedWidget子类的实例了？\n因为InheritedWidget子类的runtimeType作为Key是唯一的，对于相同类型的Key，每次添加InheritedElement进_inheritedElements这个HashMap时会覆盖掉之前的InheritedElement。\n分析2：如果以InheritedWidget类型为Key从HashMap中获取的InheritedElement不为null，那么就会执行dependOnInheritedElement方法，看下它的源码。\n1 2 3 4 5 6 7 @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) { _dependencies ??= HashSet\u0026lt;InheritedElement\u0026gt;(); _dependencies!.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget as InheritedWidget; } 这里涉及Element的成员变量_dependencies，代码如下：\n1 Set\u0026lt;InheritedElement\u0026gt;? _dependencies; 可以看到_dependencies的类型是HashSet，用来存放InheritedElement，为什么用一个Set集合来存放这些InheritedElement呢？\n因为当前Element（比如MyChild所关联的StatefulElement）所依赖的InheritedWidget可能不值一个，并且比如多次调用MyParent.of时，Set确保同一个InheritedElement只能添加一次。\n在dependOnInheritedElement方法中，如果_dependencies为null，就会创建一个空的HashSet，然后把从_inheritedElements![T]获取的ancestor存入该HashSet。\n紧接着执行ancestor（也就是InheritedElement）的updateDependencies方法。\n1 2 3 4 @protected void updateDependencies(Element dependent, Object? aspect) { setDependencies(dependent, null); } 在InheritedElement的updateDependencies方法中，执行了setDependencies方法。\n1 2 3 4 @protected void setDependencies(Element dependent, Object? value) { _dependents[dependent] = value; } 这里涉及InheritedElement的成员变量_dependents，代码如下：\n1 final Map\u0026lt;Element, Object?\u0026gt; _dependents = HashMap\u0026lt;Element, Object?\u0026gt;(); 可以看到_dependents的类型是HashMap，也就是一个键值对的集合，其中Key为Element，Value为Object。\n将当前Element（此处是MyChild所关联的StatefulElement）作为Key，此时value为null，存入了该HashMap。\n目前所讲源码中涉及了3个集合_inheritedElements、_dependencies、_dependents，它们之间的关系如下图。\n分析3：回到dependOnInheritedWidgetOfExactType方法，如果_inheritedElements == null成立，那么该方法返回null，表示查找不到指定类型的InheritedWidget。\n到这里先解释下之前的疑点3：\n我们知道，子Widget通过MyParent.of方法获取InheritedWidget的实例，使用的是context的dependOnInheritedWidgetOfExactType方法，除此之外还有一个getInheritedWidgetOfExactType方法也可以获取InheritedWidget的实例，那这两个方法之间有什么区别？\n看下getInheritedWidgetOfExactType方法源码。\n1 2 3 4 5 6 7 8 9 10 11 @override T? getInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;() { return getElementForInheritedWidgetOfExactType\u0026lt;T\u0026gt;()?.widget as T?; } @override InheritedElement? getElementForInheritedWidgetOfExactType\u0026lt;T extends InheritedWidget\u0026gt;() { assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedElements == null ? null : _inheritedElements![T]; return ancestor; } 可以看到，相比于dependOnInheritedWidgetOfExactType方法，是少了InheritedElement注册部分，所以如果InheritedWidget的状态发生改变，是无法通知子Widget进行重建的。\n1 2 3 if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } 4.2、InheritedElement通知更新阶段 当点击FloatingActionButton时，就会执行setState方法，那么示例中_MyPageState的build方法就会执行。\n关于setState方法的分析请参考解读Flutter源码之setState一文，InheritedElement通知更新阶段从BuildOwner的buildScope方法开始讲起。\n在BuildOwner的buildScope方法的While循环中，当前正在执行element.rebuild()方法，此处element正是MyPage所关联的StatefulElement，注意BuildOwner中的一个布尔值成员变量_scheduledFlushDirtyElements，因为While循环还没执行完，所以不会执行到finally语句（它在finally语句中修改为false），所以布尔值为true，OK，知道这些信息就行。\n从MyPage的重建一直到MyParent的重建，中间嵌套太多层了，这部分不会进行讲解，而是从MyParent的重建开始讲起。\n当执行到MyParent的重建时，就会执行Element的updateChild方法，因为MyParent不是const修饰，所以每次都会创建一个MyParent新实例，那么 if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)是不成立的，就会执行下面的else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，这里MyParent是没有传入Key的，所以满足else if条件。\n接着执行child.update(newWidget)，也就是执行Element的update方法。\n又因为MyParent所关联的Element为InheritedElement，而InheritedElement的父类为ProxyElement，所以执行了ProxyElement的update方法。\n1 2 3 4 5 6 7 8 9 @override void update(ProxyWidget newWidget) { final ProxyWidget oldWidget = widget as ProxyWidget; assert(widget != newWidget); super.update(newWidget); assert(widget == newWidget); updated(oldWidget); rebuild(force: true); } 在ProxyElement的update方法中，一共做了3件事情：\n1、执行super.update(newWidget)，更新InheritedElement所关联的Widget，也就是MyParent。\n2、执行updated(oldWidget)方法，这里是执行了InheritedElement的updated方法，看下它的源码。\n1 2 3 4 5 6 @override void updated(InheritedWidget oldWidget) { if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) { super.updated(oldWidget); } } 在InheritedElement的updated方法中，先执行updateShouldNotify方法，也就是我们在MyParent中实现的方法，用于判断是否应该通知继承InheritedWidget的Widget。\n如果updateShouldNotify方法返回true，那么执行super.updated(oldWidget)，也就是执行父类ProxyElement的updated方法。\n1 2 3 4 @protected void updated(covariant ProxyWidget oldWidget) { notifyClients(oldWidget); } 在ProxyElement的updated方法中，执行了notifyClients方法，这个方法由子类实现，这里看InheritedElement的notifyClients方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @override void notifyClients(InheritedWidget oldWidget) { assert(_debugCheckOwnerBuildTargetExists(\u0026#39;notifyClients\u0026#39;)); for (final Element dependent in _dependents.keys) { assert(() { // check that it really is our descendant Element? ancestor = dependent._parent; while (ancestor != this \u0026amp;\u0026amp; ancestor != null) { ancestor = ancestor._parent; } return ancestor == this; }()); // check that it really depends on us assert(dependent._dependencies!.contains(this)); notifyDependent(oldWidget, dependent); } } 在InheritedElement的notifyClients方法中，for循环遍历了_dependents的keys，然后在for循环中执行了notifyDependent方法。\n1 2 3 4 @protected void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) { dependent.didChangeDependencies(); } 在InheritedElement的notifyDependent方法中，执行了Element的didChangeDependencies方法。因为之前注册的就是我们自己的MyChild所关联的StatefulElement，所以执行的StatefulElement的didChangeDependencies方法。\n1 2 3 4 5 @override void didChangeDependencies() { super.didChangeDependencies(); _didChangeDependencies = true; } 在StatefulElement的didChangeDependencies方法中，执行了super.didChangeDependencies()，也就是执行了父类Element的didChangeDependencies方法，然后把_didChangeDependencies赋值为true。\n1 2 3 4 5 6 @mustCallSuper void didChangeDependencies() { assert(_lifecycleState == _ElementLifecycle.active); // otherwise markNeedsBuild is a no-op assert(_debugCheckOwnerBuildTargetExists(\u0026#39;didChangeDependencies\u0026#39;)); markNeedsBuild(); } 在Element的didChangeDependencies方法中，执行了Element的markNeedsBuild方法，markNeedsBuild方法是老朋友了，它会将Element标记为脏并将其添加到Widget的全局列表中以在下一帧中重建，这里的Element指MyChild所关联的StatefulElement。\n在Element的markNeedsBuild方法中，执行了BuildOwner的scheduleBuildFor方法。\n在BuildOwner的scheduleBuildFor方法中，执行if (!_scheduledFlushDirtyElements \u0026amp;\u0026amp; onBuildScheduled != null)，还记得之前讲的成员变量_scheduledFlushDirtyElements的值为true吗，这是因为MyParent及其子Widget还没重建完成。\n所以if条件不成立，onBuildScheduled!()不会执行，这里只是把MyChild所关联的StatefulElement添加进_dirtyElements。\n整体上看MyPage的重建已经包括了MyChild的重建，所以这里MyChild的重建是不需要单独放在下一帧去处理了，还是放在_MyPageState最初执行setState时的那一帧进行重建。\n此时需要While循环处理的_dirtyElements如下。\n3、回到ProxyElement的update方法中，接着执行rebuild(force: true)，也就是执行Element的rebuild方法，这个方法是老朋友了，在它的内部会执行performRebuild方法。\n因为ComponentElement为ProxyElement的父类，所以这里执行了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，执行了MyParent所关联的Element的build方法，也就是ProxyElement的build方法，这个build方法就是用来构建MyChild这个Widget的。\n在ComponentElement的performRebuild方法中，接着执行了Element的updateChild方法。因为MyChild使用const修饰，它相当于一个常量，所以满足if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，然后直接返回之前的Element，也就是MyParent所关联的Element。\n到这里就解释了之前的疑点2：\n如果把InheritedWidget示例中const MyChild()的const修饰去掉，会发生什么？\nOK，回到最初在_MyPageState中执行setState方法时，它会触发BuildOwner的buildScope方法，在第一轮While循环中，任务是重建MyPage，现在已经循环完了，然后index+1。\n下面进入第二轮While循环来重建MyChild，执行了Element的rebuild方法。\n之前讲过，在Element的rebuild方法中会执行performRebuild方法，此时执行的就是StatefulElement的performRebuild方法。\n1 2 3 4 5 6 7 8 @override void performRebuild() { if (_didChangeDependencies) { state.didChangeDependencies(); _didChangeDependencies = false; } super.performRebuild(); } 因为之前_didChangeDependencies已经赋值为true，所以这里执行了state.didChangeDependencies()，触发了State的didChangeDependencies方法。\n到这里就解释了之前的疑点1：\n对于之前的计数器示例，每次点击FloatingActionButton时仅会触发build方法，而对于InheritedWidget示例，如果目标子Widget是StatefulWidget，那么还会触发State的didChangeDependencies方法，这是为什么呢？\n接着执行super.performRebuild()，调用父类ComponentElement的performRebuild方法，这个方法也是老朋友了，最终会触发MyChild的build方法。\n4.3、InheritedElement取消注册阶段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @mustCallSuper void deactivate() { assert(_lifecycleState == _ElementLifecycle.active); assert(_widget != null); // Use the private property to avoid a CastError during hot reload. if (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) { for (final InheritedElement dependency in _dependencies!) { dependency._dependents.remove(this); } // 为了方便起见，我们实际上并没有清除此处的列表，尽管它不再代表我们注册的内容。 // 如果我们永远不会被重用，那也没关系。 // 如果这样做，那么我们将在 activate() 中清除该列表。 // 这样做的好处是，它允许 Element 的 activate() 实现根据我们这里是否有依赖关系来决定是否重建。 // For expediency, we don\u0026#39;t actually clear the list here, even though it\u0026#39;s // no longer representative of what we are registered with. If we never // get re-used, it doesn\u0026#39;t matter. If we do, then we\u0026#39;ll clear the list in // activate(). The benefit of this is that it allows Element\u0026#39;s activate() // implementation to decide whether to rebuild based on whether we had // dependencies here. } _inheritedElements = null; _lifecycleState = _ElementLifecycle.inactive; } InheritedElement取消注册是在Element的deactivate方法，比如当MyChild所关联的Element（也就是StatefulElement）执行了deactivate方法，如果_dependencies不为null且不为空，那么将当前Element从InheritedElement的_dependents中移除。\n下次在InheritedElement的notifyClients方法中for循环遍历_dependents的keys时，就无法再通知MyChild所关联的Element。\n1 2 3 4 5 6 @override void notifyClients(InheritedWidget oldWidget) { for (final Element dependent in _dependents.keys) { notifyDependent(oldWidget, dependent); } } 然后执行_inheritedElements = null，把_inheritedElements也置为null。\n但是，_dependencies在deactivate方法中是没有被清除的，通过deactivate方法中的注释可以知道，如果Element永远不会被重用，那也没关系。\n可以之后在activate方法中清除该列表，这样做的好处是，它允许Element的activate方法实现根据我们这里是否有依赖关系来决定是否重建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @mustCallSuper void activate() { assert(_lifecycleState == _ElementLifecycle.inactive); assert(owner != null); // 是否有依赖关系 final bool hadDependencies = (_dependencies != null \u0026amp;\u0026amp; _dependencies!.isNotEmpty) || _hadUnsatisfiedDependencies; _lifecycleState = _ElementLifecycle.active; // 我们在 deactivate 中注销了我们的依赖项，但从未清除过列表 // We unregistered our dependencies in deactivate, but never cleared the list. // 由于我们将被重用，所以现在让我们清除我们的列表。 // Since we\u0026#39;re going to be reused, let\u0026#39;s clear our list now. _dependencies?.clear(); _hadUnsatisfiedDependencies = false; _updateInheritance(); attachNotificationTree(); if (_dirty) { owner!.scheduleBuildFor(this); } // 如果有有依赖关系，执行didChangeDependencies进行重建 if (hadDependencies) { didChangeDependencies(); } } 五、InheritedWidget扩展 除了上面讲的InheritedWidget，其实InheritedWidget还存在一些特定的子类，如下图。\n5.1、InheritedModel介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 /// 一种 [InheritedWidget]，旨在用作模型的基类，其依赖项可能仅依赖于整个模型的一部分或“方面”。 /// An [InheritedWidget] that\u0026#39;s intended to be used as the base class for models /// whose dependents may only depend on one part or \u0026#34;aspect\u0026#34; of the overall /// model. /// /// 当inherited widget根据 [InheritedWidget.updateShouldNotify] 发生更改时，inherited widget的依赖项将无条件重建。 /// 此widget类似，只是依赖项不会无条件重建。 /// An inherited widget\u0026#39;s dependents are unconditionally rebuilt when the /// inherited widget changes per [InheritedWidget.updateShouldNotify]. This /// widget is similar except that dependents aren\u0026#39;t rebuilt unconditionally. /// /// 依赖于 [InheritedModel] 的Widgets用一个值来限定其依赖关系，该值指示它们所依赖的模型的“方面”。 /// 当重建模型时，依赖项也将被重建，但前提是模型中存在与它们提供的方面相对应的更改。 /// Widgets that depend on an [InheritedModel] qualify their dependence with a /// value that indicates what \u0026#34;aspect\u0026#34; of the model they depend on. When the /// model is rebuilt, dependents will also be rebuilt, but only if there was a /// change in the model that corresponds to the aspect they provided. /// /// 类型参数“T”是模型方面对象的类型。 /// The type parameter `T` is the type of the model aspect objects. /// /// Widgets使用静态方法创建对 [InheritedModel] 的依赖：[InheritedModel.inheritFrom]。 /// 此方法的“context”参数定义模型更改时将重建的子树。 /// 通常，“inheritFrom”方法是从特定于模型的静态“maybeOf”或“of”方法调用的，这是许多查找事物的 Flutter 框架类中存在的约定。例如： /// Widgets create a dependency on an [InheritedModel] with a static method: /// [InheritedModel.inheritFrom]. This method\u0026#39;s `context` parameter defines the /// subtree that will be rebuilt when the model changes. Typically the /// `inheritFrom` method is called from a model-specific static `maybeOf` or /// `of` methods, a convention that is present in many Flutter framework classes /// which look things up. For example: /// /// ```dart /// class MyModel extends InheritedModel\u0026lt;String\u0026gt; { /// const MyModel({super.key, required super.child}); /// /// // ... /// static MyModel? maybeOf(BuildContext context, [String? aspect]) { /// return InheritedModel.inheritFrom\u0026lt;MyModel\u0026gt;(context, aspect: aspect); /// } /// /// // ... /// static MyModel of(BuildContext context, [String? aspect]) { /// final MyModel? result = maybeOf(context, aspect); /// assert(result != null, \u0026#39;Unable to find an instance of MyModel...\u0026#39;); /// return result!; /// } /// } /// ``` /// /// 调用 `MyModel.of(context, \u0026#39;foo\u0026#39;)` 或 `MyModel.maybeOf(context, \u0026#39;foo\u0026#39;)` 意味着仅当 `MyModel` 的 `foo` aspect发生更改时才应该重建 `context`。 /// 如果“aspect”为空，则模型支持所有aspects。 /// Calling `MyModel.of(context, \u0026#39;foo\u0026#39;)` or `MyModel.maybeOf(context, /// \u0026#39;foo\u0026#39;)` means that `context` should only be rebuilt when the `foo` aspect of /// `MyModel` changes. If the `aspect` is null, then the model supports all /// aspects. /// /// {@tool snippet} /// 重建inherited model时， [updateShouldNotify] 和 [updateShouldNotifyDependent] 方法用于决定应该重建什么。 /// 如果 [updateShouldNotify] 返回 true，则针对每个依赖项及其依赖的aspect对象集测试inherited model的 [updateShouldNotifyDependent] 方法。 /// [updateShouldNotify Dependent] 方法必须将aspectj依赖项集与模型本身的更改进行比较。例如： /// When the inherited model is rebuilt the [updateShouldNotify] and /// [updateShouldNotifyDependent] methods are used to decide what should be /// rebuilt. If [updateShouldNotify] returns true, then the inherited model\u0026#39;s /// [updateShouldNotifyDependent] method is tested for each dependent and the /// set of aspect objects it depends on. The [updateShouldNotifyDependent] /// method must compare the set of aspect dependencies with the changes in the /// model itself. For example: /// /// ```dart /// class ABModel extends InheritedModel\u0026lt;String\u0026gt; { /// const ABModel({ /// super.key, /// this.a, /// this.b, /// required super.child, /// }); /// /// final int? a; /// final int? b; /// /// @override /// bool updateShouldNotify(ABModel oldWidget) { /// return a != oldWidget.a || b != oldWidget.b; /// } /// /// @override /// bool updateShouldNotifyDependent(ABModel oldWidget, Set\u0026lt;String\u0026gt; dependencies) { /// return (a != oldWidget.a \u0026amp;\u0026amp; dependencies.contains(\u0026#39;a\u0026#39;)) /// || (b != oldWidget.b \u0026amp;\u0026amp; dependencies.contains(\u0026#39;b\u0026#39;)); /// } /// /// // ... /// } /// ``` /// {@end-tool} /// /// 在前面的示例中，[updateShouldNotify Dependent] 检查的依赖项只是传递给“dependOnInheritedWidgetOfExactType”的aspect字符串。 /// 它们被表示为一个 [Set]，因为一个 Widget 可以依赖于模型的多个aspect。 /// 如果一个widget依赖于模型但没有指定某个aspect，那么模型中的更改将导致widget无条件地重建。 /// In the previous example the dependencies checked by /// [updateShouldNotifyDependent] are just the aspect strings passed to /// `dependOnInheritedWidgetOfExactType`. They\u0026#39;re represented as a [Set] because /// one Widget can depend on more than one aspect of the model. If a widget /// depends on the model but doesn\u0026#39;t specify an aspect, then changes in the /// model will cause the widget to be rebuilt unconditionally. /// /// {@tool dartpad} /// 此示例演示如何实现 [InheritedModel] 以基于合格的依赖关系重建widget。 /// 当点击“调整logo”按钮时，仅重建logo widget，而背景widget不受影响。 /// This example shows how to implement [InheritedModel] to rebuild a widget /// based on a qualified dependence. When tapped on the \u0026#34;Resize Logo\u0026#34; button /// only the logo widget is rebuilt while the background widget remains /// unaffected. /// /// ** See code in examples/api/lib/widgets/inherited_model/inherited_model.0.dart ** abstract class InheritedModel\u0026lt;T\u0026gt; extends InheritedWidget 通过InheritedModel的注释可以知道，InheritedModel相比于InheritedWidget可以更细粒度地控制依赖于InheritedModel的子Widget的重建。\n还有一点，我们经常用的媒体查询MediaQuery也是继承自InheritedModel。\n5.2、InheritedNotifier介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 /// [Listenable] [notifier] 的inherited widget，当触发 [notifier] 时更新其依赖项。 /// An inherited widget for a [Listenable] [notifier], which updates its /// dependencies when the [notifier] is triggered. /// /// 这是 [InheritedWidget] 的变体，专门用于 [Listenable] 的子类，例如 [ChangeNotifier] 或 [ValueNotifier]。 /// This is a variant of [InheritedWidget], specialized for subclasses of /// [Listenable], such as [ChangeNotifier] or [ValueNotifier]. /// /// 每当[notifier]发送通知或每当[notifier]的身份发生变化时，依赖项都会收到通知。 /// Dependents are notified whenever the [notifier] sends notifications, or /// whenever the identity of the [notifier] changes. /// /// 多个通知被合并，因此即使 [notifier] 在两帧之间触发多次，依赖项也仅重建一次。 /// Multiple notifications are coalesced, so that dependents only rebuild once /// even if the [notifier] fires multiple times between two frames. /// /// 通常，该类是一个类的子类，该类提供一个“of”静态方法，该方法使用该类调用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// Typically this class is subclassed with a class that provides an `of` static /// method that calls [BuildContext.dependOnInheritedWidgetOfExactType] with that /// class. /// /// [updateShouldNotify] 方法也可以被重写，以在 [notifier] 本身发生更改的情况下更改逻辑。 /// 如果 [notifier] 发生更改，则使用旧的 [notifier] 调用 [updateShouldNotify] 方法。 /// 当它返回 true 时，依赖项被标记为需要在该框架中重建。 /// The [updateShouldNotify] method may also be overridden, to change the logic /// in the cases where [notifier] itself is changed. The [updateShouldNotify] /// method is called with the old [notifier] in the case of the [notifier] being /// changed. When it returns true, the dependents are marked as needing to be /// rebuilt this frame. /// /// {@tool dartpad} /// 此示例显示了三个旋转方块，它们使用祖先 [InheritedNotifier] (`SpinModel`) 上的notifier的值来进行旋转。 /// [InheritedNotifier] 不需要了解子级，并且 `notifier` 参数不需要是动画控制器，它可以是任何实现 [Listenable] 的东西（如 [ChangeNotifier]）。 /// This example shows three spinning squares that use the value of the notifier /// on an ancestor [InheritedNotifier] (`SpinModel`) to give them their /// rotation. The [InheritedNotifier] doesn\u0026#39;t need to know about the children, /// and the `notifier` argument doesn\u0026#39;t need to be an animation controller, it /// can be anything that implements [Listenable] (like a [ChangeNotifier]). /// /// `SpinModel` 类可以轻松地侦听另一个 [Listenable] 对象（例如，保留输入或数据模型值的值的单独对象），并从中获取值。 /// 后代也不需要拥有 [InheritedNotifier] 的实例即可使用它，他们只需要知道他们的祖先中有一个实例即可。 /// 这有助于将widgets与其模型解耦。 /// The `SpinModel` class could just as easily listen to another object (say, a /// separate object that keeps the value of an input or data model value) that /// is a [Listenable], and get the value from that. The descendants also don\u0026#39;t /// need to have an instance of the [InheritedNotifier] in order to use it, they /// just need to know that there is one in their ancestry. This can help with /// decoupling widgets from their models. /// /// ** See code in examples/api/lib/widgets/inherited_notifier/inherited_notifier.0.dart ** /// {@end-tool} abstract class InheritedNotifier\u0026lt;T extends Listenable\u0026gt; extends InheritedWidget 通过InheritedNotifier的注释可以知道，它需要和Listenable一起使用，当触发 notifier时会更新其依赖项。\n5.3、InheritedTheme介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// 一个 [InheritedWidget]，定义 [child] 子树所依赖的视觉属性，例如颜色和文本样式。 /// An [InheritedWidget] that defines visual properties like colors /// and text styles, which the [child]\u0026#39;s subtree depends on. /// /// [captureAll] 和 [CapturedThemes.wrap] 使用 [wrap] 方法来构造一个widget，该widget将把子项包装在widget树的指定部分中存在的所有inherited themes中。 /// The [wrap] method is used by [captureAll] and [CapturedThemes.wrap] to /// construct a widget that will wrap a child in all of the inherited themes /// which are present in a specified part of the widget tree. /// /// 在与其内置环境不同的上下文中显示的widget，就像新路由或overlay的内容一样，将能够看到它所构建的上下文的祖先inherited themes。 /// A widget that\u0026#39;s shown in a different context from the one it\u0026#39;s built in, /// like the contents of a new route or an overlay, will be able to see the /// ancestor inherited themes of the context it was built in. /// /// {@tool dartpad} /// 此示例演示了如何使用 InheritedTheme.capture() 来使用inherited themes来包装新route的内容，这些主题在构建route时存在，但在实际显示route时不存在。 /// This example demonstrates how `InheritedTheme.capture()` can be used /// to wrap the contents of a new route with the inherited themes that /// are present when the route was built - but are not present when route /// is actually shown. /// /// 如果相同的代码在没有 `InheritedTheme.capture() 的情况下运行，则新route的 Text widget将继承“omething must be wrong”反馈文本样式，而不是 MyApp 中定义的默认文本样式。 /// If the same code is run without `InheritedTheme.capture(), the /// new route\u0026#39;s Text widget will inherit the \u0026#34;something must be wrong\u0026#34; /// fallback text style, rather than the default text style defined in MyApp. /// /// ** See code in examples/api/lib/widgets/inherited_theme/inherited_theme.0.dart ** /// {@end-tool} abstract class InheritedTheme extends InheritedWidget 通过InheritedTheme的注释可以知道，它和主题相关联，比如经常用的Theme.of()，它底层会通过dependOnInheritedWidgetOfExactType方法查询_InheritedTheme实例，而_InheritedTheme继承自InheritedTheme。\n","date":"2023-10-31T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Binheritedwidget/","section":"post","tags":null,"title":"解读Flutter源码之InheritedWidget"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、Key是什么？ 在Flutter中，Key的使用是很常见的，就以Scaffold这个Widget来说，当人们使用它的Drawer功能时，必然会涉及openDrawer与closeDrawer这两个行为，它们的具体方法实现定义在ScaffoldState中，可通过如下API调用：\n1 Scaffold.of(context).openDrawer(); // or Scaffold.of(context).closeDrawer(); 不妨点进去看下ScaffoldState中的openDrawer与closeDrawer这两个方法的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 final GlobalKey\u0026lt;DrawerControllerState\u0026gt; _drawerKey = GlobalKey\u0026lt;DrawerControllerState\u0026gt;(); void openDrawer() { if (_endDrawerKey.currentState != null \u0026amp;\u0026amp; _endDrawerOpened.value) { _endDrawerKey.currentState!.close(); } _drawerKey.currentState?.open(); } void closeDrawer() { if (hasDrawer \u0026amp;\u0026amp; isDrawerOpen) { _drawerKey.currentState!.close(); } } 可以发现，它们均使用了_drawerKey这一个GlobalKey来获取currentState，也就是获取了DrawerControllerState实例，然后再调用该实例的open或close方法。\n那么，正如标题所言，Key是什么？还是那句话：遇事不决，先看注释。Key作为参数定义在Widget的构造方法中，默认值为null，也就是使用Widget时可以不传，来看下Widget中关于Key的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @immutable abstract class Widget extends DiagnosticableTree { /// Initializes [key] for subclasses. const Widget({ this.key }); /// 控制一个widget如何替换树中的另一个widget。 /// Controls how one widget replaces another widget in the tree. /// /// 如果两个widgets的 [runtimeType] 和 [key] 属性分别为 [operator==]，则新widget通过更新底层element来替换旧widget（即，通过使用新widget调用 [Element.update] ）。 /// 否则，旧element将从树中删除，新的widget将创建出element，并将新element插入到树中。 /// If the [runtimeType] and [key] properties of the two widgets are /// [operator==], respectively, then the new widget replaces the old widget by /// updating the underlying element (i.e., by calling [Element.update] with the /// new widget). Otherwise, the old element is removed from the tree, the new /// widget is inflated into an element, and the new element is inserted into the /// tree. /// /// 此外，使用 [GlobalKey] 作为widget的 [key] 允许element在树中移动（更改父级）而不会丢失状态。 /// 当找到一个新的widget（其key和type与同一位置的前一个widget不匹配），但在前一帧的树中的其它位置有一个具有相同global key的widget时，该widget的element将移动到新地点。 /// In addition, using a [GlobalKey] as the widget\u0026#39;s [key] allows the element /// to be moved around the tree (changing parent) without losing state. When a /// new widget is found (its key and type do not match a previous widget in /// the same location), but there was a widget with that same global key /// elsewhere in the tree in the previous frame, then that widget\u0026#39;s element is /// moved to the new location. /// /// 通常，作为另一个widget的唯一child的widget不需要显式key。 /// Generally, a widget that is the only child of another widget does not need /// an explicit key. final Key? key; } 再点击进去看下Key本身的一个注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /// [Key] 是 [Widget]、[Element] 和 [SemanticsNode] 的标识符。 /// A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s. /// /// 如果新的widget的key与与该element关联的当前widget的key相同，则该新widget将仅用于更新现有element。 /// A new widget will only be used to update an existing element if its key is /// the same as the key of the current widget associated with the element. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc} /// /// Key在具有相同父级的 [Element] 中必须是唯一的。 /// Keys must be unique amongst the [Element]s with the same parent. /// /// [Key] 的子类应该是 [LocalKey] 或 [GlobalKey] 的子类。 /// Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey]. @immutable abstract class Key { } 结合上面Widget中对Key的注释以及Key本身的一个注释，总结下Key的特性：\n1、Key用于控制一个Widget如何替换树中的另一个Widget。\n2、如果两个Widget的runtimeType和key属性分别为相等，则新Widget通过更新底层Element来替换旧Widget；否则旧Element将从树中删除，新的Widget将创建出Element，并将新Element插入到树中。\n3、使用GlobalKey作为Widget的key允许Element在树中移动（更改父级）而不会丢失状态。\n4、Key在具有相同父级的Element中必须是唯一的。\n5、\u0026hellip;\n这里给出了Key的部分特性，主要是想让大家对Key有一个初级认知。\n二、3个小示例之问题 在分析Key的原理之前，先看个“删除中间色块”的小示例。\n现有一需求：设计一个通用的色块Widget，然后在屏幕中横向摆放三个不同颜色的色块Widget，当点击FloatingActionButton按钮时会删除中间色块。\n2.1、示例1 基于StatelessWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在build方法中进行Color初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyPage(title: \u0026#39;小示例\u0026#39;), ); } } class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatelessBox(colorValue: ColorValue.redAccent), const StatelessBox(colorValue: ColorValue.greenAccent), const StatelessBox(colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatelessBox extends StatelessWidget { final ColorValue colorValue; const StatelessBox({super.key, required this.colorValue}); Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { Color color = _getColor(colorValue); debugPrint(\u0026#34;build: $color\u0026#34;); return Container( width: 100, height: 100, color: color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，日志打印如下：\n1 I/flutter (15182): build: MaterialAccentColor(primary value: Color(0xff448aff)) 总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、蓝，虽然程序运行效果与预期效果相同，但是还是存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么日志打印是蓝色？\n2、为什么红色块自身的build方法不会触发？\n3、\u0026hellip;\n2.2、示例2 基于StatefulWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在initState方法中进行Color初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatefulBox(colorValue: ColorValue.redAccent), const StatefulBox(colorValue: ColorValue.greenAccent), const StatefulBox(colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatefulBox extends StatefulWidget { final ColorValue colorValue; const StatefulBox({super.key, required this.colorValue}); @override State\u0026lt;StatefulBox\u0026gt; createState() =\u0026gt; _StatefulBoxState(); } class _StatefulBoxState extends State\u0026lt;StatefulBox\u0026gt; { late Color _color; @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); _color = _getColor(widget.colorValue); } Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build: $_color\u0026#39;); return Container( width: 100, height: 100, color: _color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 4 5 6 I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15657): initState I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，日志打印如下：\n1 I/flutter (15657): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) 总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、绿，很明显程序运行效果与预期效果不相同，因此存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么删除的是蓝色块？\n2、为什么日志打印是绿色？\n3、为什么红色块自身的build方法不会触发？\n4、\u0026hellip;\n2.3、示例3 基于StatefulWidget设计一个通用的色块Widget，并通过构造方法传入ColorValue枚举值参数来控制色块颜色，然后在initState方法中进行Color初始化，最后在使用色块Widget时给它传入一个Key。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class MyPage extends StatefulWidget { const MyPage({super.key, required this.title}); final String title; @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { final List\u0026lt;Widget\u0026gt; _boxes = [ const StatefulBox(key: ValueKey(1), colorValue: ColorValue.redAccent), const StatefulBox(key: ValueKey(2), colorValue: ColorValue.greenAccent), const StatefulBox(key: ValueKey(3), colorValue: ColorValue.blueAccent), ]; void _refresh() { setState(() { _boxes.removeAt(1); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: Row(children: _boxes), floatingActionButton: FloatingActionButton( onPressed: _refresh, tooltip: \u0026#39;refresh\u0026#39;, child: const Icon(Icons.refresh), ), ); } } enum ColorValue { redAccent, greenAccent, blueAccent } class StatefulBox extends StatefulWidget { final ColorValue colorValue; const StatefulBox({super.key, required this.colorValue}); @override State\u0026lt;StatefulBox\u0026gt; createState() =\u0026gt; _StatefulBoxState(); } class _StatefulBoxState extends State\u0026lt;StatefulBox\u0026gt; { late Color _color; @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); _color = _getColor(widget.colorValue); } Color _getColor(ColorValue colorValue) { switch (colorValue) { case ColorValue.redAccent: return Colors.redAccent; case ColorValue.greenAccent: return Colors.greenAccent; case ColorValue.blueAccent: return Colors.blueAccent; } } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build: $_color\u0026#39;); return Container( width: 100, height: 100, color: _color, ); } } 程序运行起来后，可以看到如下效果。\n程序刚运行起来，日志打印如下：\n1 2 3 4 5 6 I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xffff5252)) I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xff69f0ae)) I/flutter (15938): initState I/flutter (15938): build: MaterialAccentColor(primary value: Color(0xff448aff)) 点击FloatingActionButton按钮后，无日志输出。\n总结：初始时色块颜色从左到右的顺序为红、绿、蓝，当点击FloatingActionButton按钮后，色块颜色的顺序变为红、蓝，虽然程序运行效果与预期效果相同，但还是存在一些疑问（也就是点击FloatingActionButton按钮后）：\n1、为什么在使用色块Widget时给它传入一个Key，程序运行效果相比示例2就又变得正常了？\n2、为什么点击FloatingActionButton按钮后无日志输出？\n3、\u0026hellip;\n看了上面3个小示例的演示，笔者想问它们的运行结果是在你的预料之中还是预料之外？\nOK，不管怎样，接下来分析这3个小示例的执行原理之后谜底就会揭开。\n三、3个小示例之执行原理 3.1、分析示例1 当点击FloatingActionButton按钮后，会执行setState方法，关于setState方法的分析可参考解读Flutter源码之setState一文。\n此处setState方法会先触发Scaffold的重建，Scaffold的重建也会触发其子Widget的重建，然后子Widget的重建也会触发其子Widget的重建，有点像“核裂变的链式反应”，直到所有子Widget均完成重建。\n因为从Scaffold的重建一直到Row的重建，中间实在嵌套太多层了，很不方便分析，所以这里只从Row的父组件KeyedSubtree开始讲起。\n当KeyedSubtree重建完成之后（即KeyedSubtree的父组件_BodyBuilder的build方法已执行），就会执行Element的rebuild方法，在Element的rebuild方法中，接着执行了Element的performRebuild方法，又因为KeyedSubtree是StatelessWidget的子类，所以执行的是ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，执行了KeyedSubtree的build方法重建了Row，然后执行了Element的updateChild方法。\n在Element的updateChild方法中，虽然重建后的Row实例与之前的Row实例不同，但它们的runtimeType是一样的以及key均为null，所以执行了Element的update方法进行Row及其所有子Widget的更新。\n又因为Row是MultiChildRenderObjectWidget的子类，所以执行的是MultiChildRenderObjectElement的update方法来进行Row及其所有子Widget的更新，以上描述所涉及的方法调用栈如下。\n跟踪下MultiChildRenderObjectElement的update方法的源码，可以发现在update方法中，执行了updateChildren方法。\n1 2 3 4 5 6 7 8 9 @override void update(MultiChildRenderObjectWidget newWidget) { super.update(newWidget); final MultiChildRenderObjectWidget multiChildRenderObjectWidget = widget as MultiChildRenderObjectWidget; assert(widget == newWidget); assert(!debugChildrenHaveDuplicateKeys(widget, multiChildRenderObjectWidget.children)); _children = updateChildren(_children, multiChildRenderObjectWidget.children, forgottenChildren: _forgottenChildren); _forgottenChildren.clear(); } 为了方便本文后续的描述，笔者会把重建后的Row叫新Row，而之前的Row就变为旧Row。\nOK，现在解释下updateChildren方法的参数：\noldChildren：它是一个List\u0026lt;Element\u0026gt;，在本示例中，用来存放旧Row中所有子Widget所关联的Element，此处传入的是_children。 newWidgets：它是一个List\u0026lt;Widget\u0026gt;，用来存放新Row中所有子Widget，此处传入的是multiChildRenderObjectWidget.children。 因为删除了中间的绿色块Widget，所以相比初始时的三个色块Widget，现在只剩下红色块Widget与最后一个蓝色块Widget。\nforgottenChildren：一个可选的命名参数，它是一个Set\u0026lt;Element\u0026gt;?，用来存放旧Row中传入了GlobalKey的子Widget所关联的Element，主要作用是避免重复遍历_children来删除子节点的O(n^2) 工作，此处传入的是_forgottenChildren。 在本示例中，因为旧Row中所有子Widget都没有用到GlobalKey，所以_forgottenChildren为空。\nslots：一个可选的命名参数，它是一个List\u0026lt;Object?\u0026gt;?，用来存放旧Row中所有子Widget所关联的槽位，用于定义该子级在其父级子级列表中的位置，因为此处没有传入，所以为null。 多插一嘴，虽然此处没有传入为null，但是旧Row中所有子Widget所关联的槽位还是存在的，这在MultiChildRenderObjectElement的mount方法中已经为旧Row中所有子Widget分配了槽位。\n此时，旧Row中所有子Widget所关联的槽位如下。\nOK，继续跟踪Element的updateChildren方法的源码，可以发现updateChildren方法的源码是比较长的，所以本文会对updateChildren方法的源码拆分为十部分，并且结合示例只讲解被执行到的那部分源码。\n3.1.1、分析第一部分 1 2 3 4 5 6 7 8 9 Element? replaceWithNullIfForgotten(Element child) { return forgottenChildren != null \u0026amp;\u0026amp; forgottenChildren.contains(child) ? null : child; } Object? slotFor(int newChildIndex, Element? previousChild) { return slots != null ? slots[newChildIndex] : IndexedSlot\u0026lt;Element?\u0026gt;(newChildIndex, previousChild); } 在updateChildren方法一开始，就定义了两个局部方法，来分析下：\nreplaceWithNullIfForgotten()：如果旧Row中存在传入了GlobalKey的子Widget，那么该子Widget所关联的Element就需要被过滤掉而不进行处理，避免后续遍历时导致Element被移除，这种情况下会返回null，否则返回传入的child本身。\nslotFor()：获取新Row中newChildIndex索引位置的槽位，之前讲过updateChildren方法并没有传入slots，所以这里会为每个Element创建一个新槽位IndexedSlot。\n3.1.2、分析第二部分 1 2 3 4 5 6 7 8 int newChildrenTop = 0; int oldChildrenTop = 0; int newChildrenBottom = newWidgets.length - 1; int oldChildrenBottom = oldChildren.length - 1; final List\u0026lt;Element\u0026gt; newChildren = List\u0026lt;Element\u0026gt;.filled(newWidgets.length, _NullElement.instance); Element? previousChild; 在updateChildren方法中，定义了几个局部变量，来分析下：\n局部变量 说明 newChildrenTop 遍历newWidgets时的起始位置，从0开始 oldChildrenTop 遍历oldChildren时的起始位置，从0开始 newChildrenBottom 遍历newWidgets时的结束位置，结束位置为newWidgets.length - 1 oldChildrenBottom 遍历oldChildren时的结束位置，结束位置为oldChildren.length - 1 newChildren 它是一个List\u0026lt;Element\u0026gt;，用来存放新Row中所有子Widget所关联的Element previousChild 新Row中子Widget所关联的槽位指向的前一个Element 3.1.3、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 更新列表顶部 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 这个While循环的工作原理是从列表顶部开始更新，也就是从旧Row中第一个子Widget所关联的Element与新Row中第一个子Widget开始往后遍历，判断新旧Widget是否同一个Widget（判断条件是Widget的runtimeType与key），如果是则更新Element所持有的旧Widget为新Widget，否则break退出该While循环。\n当Element更新旧Widget成功时，newChildrenTop与oldChildrenTop就会+1，如果遍历过程中出现Element不能更新旧Widget，那么break退出该While循环，此时newChildrenTop与oldChildrenTop恰好记录了Element不能更新旧Widget时的位置索引。\n3.1.3.1、第一轮循环 第一轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为0，而oldChildrenBottom为2，newChildrenBottom为1，所以满足While循环判断进入循环体。\n分析一：\n1 2 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; 获取oldChild：在本例中，旧Row中所有子Widget都没有传入GlobalKey，所以replaceWithNullIfForgotten()返回的是传入的child本身，也就是oldChildren[0]，它是旧Row中第一个子Widget所关联的Element。 获取newWidget：获取新Row中第一个子Widget。 分析二：\n1 2 3 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } 由分析一可以知道，oldChild == null是不成立的，所以执行了Widget.canUpdate()，来看下canUpdate方法。\n1 2 3 4 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType \u0026amp;\u0026amp; oldWidget.key == newWidget.key; } 可以知道，canUpdate方法中比较了runtimeType与key，也就是比较了旧Row中第一个Widget与新Row中第一个Widget的runtimeType与key，因为两者均没传入key，所以key默认为null，那么比较的就是runtimeType了，而两者的runtimeType均为StatelessBox，所以canUpdate方法返回true，并不会执行break跳出While循环。\n分析三：\n1 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; 执行了Element的updateChild方法，那么updateChild方法是用来干嘛的？\nupdateChild方法使用给定的新配置更新给定的child，它是widgets系统的核心，每次我们根据更新的配置添加、更新或删除child时都会调用它。\n来看下updateChild方法的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } else { deactivateChild(child); newChild = inflateWidget(newWidget, newSlot); } } else { newChild = inflateWidget(newWidget, newSlot); } return newChild; } 这里总结下updateChild方法的工作逻辑：\nnewWidget == null newWidget != null child == null 返回null 返回新的Element child != null 旧的child被移除, 返回null 如果可能，更新旧child，返回child或新的Element 在本示例中，updateChild方法的第一个参数传入了旧Row中第一个Widget所关联的Element，第二个参数传入了新Row中第一个Widget，第三个参数是新Row中第一个Widget所关联的槽位。\n来看下第一轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } } return newChild; } 在updateChild方法中，因为传入的参数child与newWidget都不为null，所以执行到if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，可以看到child.widget == newWidget比较的是两个Widget是否相等，而Widget对==操作符进行了重写，比较的是两者的引用。\n1 2 3 4 // Widget @override @nonVirtual bool operator ==(Object other) =\u0026gt; super == other; Row的children列表是定义为_MyPageState的一个成员变量_boxes，当移除中间色块Widget时，第一个色块Widget的引用在列表中还是没发生变化，所以if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)是成立的，然后进入另一个if判断if (child.slot != newSlot)。\n之前讲过newSlot是在slotFor()局部方法中新创建的，而child.slot是在MultiChildRenderObjectElement的mount方法中创建的，所以这两个slot不是同一个实例。\n但是，这里!=比较的并不是两者的slot引用，因为IndexedSlot重载了==操作符，它们比较的是IndexedSlot构造方法中传入的参数值，相当于执行了equals()，可以看下IndexedSlot的部分源码。\n1 2 3 4 5 6 7 8 9 10 // IndexedSlot @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is IndexedSlot \u0026amp;\u0026amp; index == other.index \u0026amp;\u0026amp; value == other.value; } 可以知道，此时这两个IndexedSlot中参数值的比较是相等的，因而if判断if (child.slot != newSlot)是不成立的，不会执行updateSlotForChild()。\n然后执行newChild = child，直接将旧Row中第一个Widget所关联的Element返回，那么updateChild方法执行完成。\n分析四：\n1 2 3 4 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; 把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，进入第二轮While循环判断。\n3.1.3.2、第二轮循环 第二轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为1，而oldChildrenBottom为2，newChildrenBottom为1，所以满足While循环判断进入循环体。\n分析一、分析二与之前一样，先是获取oldChild与newWidget，然后继续执行updateChild方法。\n分析三：\n在本示例中，updateChild方法的第一个参数传入了旧Row中第二个Widget所关联的Element，第二个参数传入了新Row中第二个Widget，第三个参数是新Row中第二个Widget所关联的槽位。\n来看下第二轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } } return newChild; } 在updateChild方法中，因为传入的参数child与newWidget都不为null，所以执行到if判断if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)。\n但是，此时child.widget == newWidget是不成立的，为什么呢？\n因为child.widget是旧Row中第二个Widget，而newWidget是新Row中第二个子Widget（它其实对应了旧Row中第三个Widget），所以相当于旧Row中第二个Widget与第三个Widget进行比较，很显然这两个引用是不相等的。\n接着执行else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，对于Widget.canUpdate()，之前讲过如果Row的子Widget没有传入key，那么比较的就是runtimeType，很显然两者的runtimeType都是StatelessBox，所以if判断else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))成立，然后进入另一个if判断if (child.slot != newSlot)。\n之前讲过IndexedSlot重写了操作符==，内部比较的是构造方法传入的参数值，相当于执行equals()，所以此时这两个slot依然相等，if判断if (child.slot != newSlot)不成立。\n接着继续执行child.update(newWidget)方法，又因为child的类型为StatelessElement，所以执行了StatelessElement的update方法。\n可以发现，在update方法中先是执行了super.update(newWidget)，也就是执行了Element的update方法，将newWidget赋值给旧Row中第二个Widget所关联的Element，换句话说，旧Row中第二个Widget所关联的Element持有了旧Row中第三个Widget。\n然后在update方法中还执行了rebuild方法，这会重建旧Row中第三个Widget，执行旧Row中第三个Widget的build方法。\nOK，我们回到这个if判断else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，最后执行了newChild = child，将旧Row中第二个Widget所关联的Element返回了。\n分析四：\n1 2 3 4 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; 把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，进入第三轮While循环判断。\n3.1.3.3、第三轮循环 第三轮While循环判断while(oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)，因为此时oldChildrenTop、newChildrenTop均为2，而oldChildrenBottom为2，newChildrenBottom为1，所以不满足While循环判断。\n3.1.4、分析第五部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 扫描列表中间的老孩子 // Scan the old children in the middle of the list. final bool haveOldChildren = oldChildrenTop \u0026lt;= oldChildrenBottom; Map\u0026lt;Key, Element\u0026gt;? oldKeyedChildren; if (haveOldChildren) { oldKeyedChildren = \u0026lt;Key, Element\u0026gt;{}; while (oldChildrenTop \u0026lt;= oldChildrenBottom) { final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); if (oldChild != null) { if (oldChild.widget.key != null) { oldKeyedChildren[oldChild.widget.key!] = oldChild; } else { deactivateChild(oldChild); } } oldChildrenTop += 1; } } 第五部分的工作原理是扫描列表中间的老孩子，也就是扫描oldChildrenTop与oldChildrenBottom之间的旧Widget所关联的Element。\n换句话说就是处理之前列表中间那些无法更新旧Widget为新Widget的Element，如果该Element之前关联的旧Widget传入了key，那么就会把该Element存入一个Map中，否则就会执行deactivateChild方法移除该Element。\n可以发现，有一个bool类型的局部变量haveOldChildren，它的判断条件是oldChildrenTop \u0026lt;= oldChildrenBottom，因为此时oldChildrenTop为2，oldChildrenBottom为2，那么haveOldChildren为true，满足if判断if (haveOldChildren)。\n然后执行While循环判断 while (oldChildrenTop \u0026lt;= oldChildrenBottom)，这里的While循环判断条件与haveOldChildren的判断条件一样的，所以满足While循环判断而进入循环体。\n在While循环体中，获取oldChild，此时的oldChild是旧Row中第三个子Widget所关联的Element。\n因为旧Row中所有子Widget都没有传入Key，并且旧Row中第三个子Widget所关联的Element在新Row中是找不到子Widget去关联的，所以执行deactivateChild方法把旧Row中第三个子Widget所关联的Element移除。\nOK，继续跟踪Element的updateChildren方法源码时，发现后面第六、七、八、九部分都不满足相应的判断条件，所以这几部分都没有执行到，这里就不分析了。\n3.1.5、分析第十部分 直接将newChildren返回，那么updateChildren方法就执行完毕了，意味着Row所关联的MultiChildRenderObjectElement也就更新了_children。\n该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例1中的疑问了：\n1、为什么日志打印是蓝色？ 因为旧Row中第二个子Widget所关联的Element，它对绿色块Widget的持有关系发生了变化，由最初持有了绿色块Widget变为持有了蓝色块Widget，并且触发了蓝色块Widget的build方法，所以日志打印是蓝色。\n2、为什么红色块自身的build方法不会触发？ 因为旧Row中第一个子Widget所关联的Element，它对红色块Widget的持有关系没有发生变化。\n3.2、分析示例2 与示例1中的颜色块StatelessBox不同，示例2中的颜色块StatefulBox是一个StatefulWidget，它的颜色值_color是在initState方法中初始化的。\n我们知道，Element的生命周期比Widget长，而State是在StatefulElement的构造方法中创建的，在此之后，StatefulElement与State便互相持有对方引用，所以State的生命周期也会比Widget长。\n这说明旧Row中子Widget所关联的Element，尽管它对Widget的持有关系发生了变化，也不会影响State中已初始化过的数据（这里指_color），除非State重新创建一个新实例。\n前面有了示例1的详细分析过程为基础，下面分析示例2时不会再从头开始分析，而是分析与示例1不同的部分。\n3.2.1、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 3.2.1.1、第二轮循环 在第二轮While循环中，执行了updateChild方法，此时第一个参数child为旧Row中第二个子Widget所关联的Element，第二个参数newWidget为新Row中的第二个Widget，也是旧Row中第三个子Widget。\n来看下第二轮While循环中，会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { } else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget)) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } child.update(newWidget); newChild = child; } } return newChild; } 执行else if (hasSameSuperclass \u0026amp;\u0026amp; Widget.canUpdate(child.widget, newWidget))，因为Row的所有子Widget均没有传入Key，所以else if判断成立。\n然后执行child.update(newWidget)方法，又因为child的类型为StatefulElement，所以执行了StatefulElement的update方法。\n在StatefulElement的update方法中，一共做了4件事情：\n1、执行super.update(newWidget)，也就是执行了Element的update方法，将newWidget赋值给旧Row中第二个Widget所关联的Element，换句话说，旧Row中第二个Widget所关联的Element持有了旧Row中第三个Widget。\n2、执行state._widget = widget as StatefulWidget，旧Row中第二个Widget所关联的Element，它所持有的State也更新了_widget，也就是State持有了旧Row中第三个Widget。\n3、执行state.didUpdateWidget(oldWidget)，触发了State的didUpdateWidget方法，传入的实参也就是旧Row中第二个Widget。\n4、执行rebuild方法，触发了旧Row中第三个Widget的重建。\n示例2与示例1的不同之处已经讲完，该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例2中的疑问了：\n1、为什么删除的是蓝色块？ 因为旧Row中第二个子Widget所关联的Element，它对绿色块Widget的持有关系发生了变化，由最初持有了绿色块Widget变为持有了蓝色块Widget，并且触发了所关联State的build方法。但是因为该Element所关联的State中_color值一直为绿色没发生变化，所以当执行build方法时读取到的颜色值还是绿色，打印的日志也就为绿色了，这就导致了看起来像是删除了蓝色块。\n2、为什么日志打印是绿色？ 解释与问题1相同。\n3、为什么红色块自身的build方法不会触发？ 因为旧Row中第一个子Widget所关联的Element，它对红色块Widget的持有关系没有发生变化。\n那么，有什么修复办法吗？\n方法1 可以重写State的didUpdateWidget方法，然后对_color进行重新赋值，因为此时的State已经引用了蓝色块_widget。\n1 2 3 4 5 @override void didUpdateWidget(covariant StatefulBox oldWidget) { super.didUpdateWidget(oldWidget); _color = _getColor(widget.colorValue); } 方法2 也就是示例3中的给StatefulBox传入一个Key就行。\n3.3、分析示例3 前面有了示例1与示例2的详细分析过程为基础，下面分析示例3时不会再从头开始分析，而是分析与示例2不同的部分。\n3.3.1、分析第三部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Update the top of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析一 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); final Widget newWidget = newWidgets[newChildrenTop]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析二 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析三 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); // 分析四 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 3.3.1.1、第二轮循环 在第二轮While循环中，看下分析二这里的源码，此时oldChild为旧Row中第二个子Widget所关联的Element，newWidget为新Row中的第二个Widget，也是旧Row中第三个子Widget。\n执行if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))，因为oldChild不为null，所以看下if后半段Widget.canUpdate()。\n因为旧Row中所有子Widget均传入了Key，所以比较的就不止Widget的runtimeType了了，还需要比较key，很明显两者的runtimeType均为StatefulBox，那么剩下的就是比较两者的Key了， 此时oldChild.widget的Key为ValueKey(2)，newWidget的Key为ValueKey(3)。\n一般情况下，Key之间的==操作符是比较两者的引用，但是呢，ValueKey重写了==操作符，比较的是ValueKey构造方法传入的参数，相当于执行了equals()方法，看下ValueKey的这部分源码。\n1 2 3 4 5 6 7 8 9 // ValueKey @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ValueKey\u0026lt;T\u0026gt; \u0026amp;\u0026amp; other.value == value; } 当ValueKey(2)与ValueKey(3)比较时，很明显2 != 3，因此Widget.canUpdate()返回false，if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget))条件成立，执行了break退出While循环。\n3.3.2、分析第四部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 扫描列表底部 // Scan the bottom of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析1 final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]); final Widget newWidget = newWidgets[newChildrenBottom]; assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); // 分析2 if (oldChild == null || !Widget.canUpdate(oldChild.widget, newWidget)) { break; } // 分析3 oldChildrenBottom -= 1; newChildrenBottom -= 1; } 这个While循环的工作原理是扫描列表底部，也就是从旧Row中第3个子Widget所关联的Element与新Row中第二个子Widget开始往前遍历，判断新旧Widget是否同一个Widget（判断条件是Widget的runtimeType与key），如果不是则break退出该While循环，此时，newChildrenTop与oldChildrenTop恰好就记录了旧Row中子Widget所关联的Element不能够找到所关联的新Row中子Widget时的位置索引。\n否则，当旧Row中子Widget所关联的Element能够找到所关联的新Row中子Widget时，newChildrenTop与oldChildrenTop就会-1。\n3.3.2.1、第一轮循环 在分析第四部分中，此时oldChildrenTop与newChildrenTop均为1，oldChildrenBottom为2，newChildrenBottom为1，满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))进入循环体中。\n分析1：获取oldChild，它是旧Row中第三个Widget所关联的Element。获取newWidget，它是新Row中第二个Widget，也就是旧Row中第三个Widget。\n分析2：执行Widget.canUpdate()，此时oldChild.widget与newWidget所指的都是旧Row中第三个Widget，所以Widget.canUpdate()成立返回true，不会执行break跳出While循环。\n分析3：执行oldChildrenBottom -= 1与newChildrenBottom -= 1，此时oldChildrenTop与newChildrenTop均为1，oldChildrenBottom为1，newChildrenBottom为0。\n3.3.2.2、第二轮循环 在进入下一轮While循环时，不满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))。\n3.3.3、分析第五部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 扫描列表中间的老孩子 // Scan the old children in the middle of the list. final bool haveOldChildren = oldChildrenTop \u0026lt;= oldChildrenBottom; Map\u0026lt;Key, Element\u0026gt;? oldKeyedChildren; if (haveOldChildren) { oldKeyedChildren = \u0026lt;Key, Element\u0026gt;{}; while (oldChildrenTop \u0026lt;= oldChildrenBottom) { final Element? oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]); assert(oldChild == null || oldChild._lifecycleState == _ElementLifecycle.active); if (oldChild != null) { if (oldChild.widget.key != null) { oldKeyedChildren[oldChild.widget.key!] = oldChild; } else { deactivateChild(oldChild); } } oldChildrenTop += 1; } } 3.3.3.1、第一轮循环 在分析第五部分中，此时oldChildrenTop与oldChildrenBottom均为1，所以haveOldChildren为true。\n执行while (oldChildrenTop \u0026lt;= oldChildrenBottom)，此处条件与haveOldChildren的条件相同，所以满足While判断的。\n然后获取oldChild，它是旧Row中第二个Widget所关联的Element。因为Row中所有子Widget都有传入Key，所以满足if (oldChild.widget.key != null)。\n这里是将旧Row中第二个Widget所关联的Element存入到了一个Map里。接着执行oldChildrenTop += 1，此时oldChildrenTop为2。\n3.3.3.2、第二轮循环 在进入下一轮While循环时，不满足while (oldChildrenTop \u0026lt;= oldChildrenBottom)。\n3.3.4、分析第七部分 1 2 3 4 // 我们已经扫描了整个列表 // We\u0026#39;ve scanned the whole list. newChildrenBottom = newWidgets.length - 1; oldChildrenBottom = oldChildren.length - 1; 整个列表的扫描工作完成后，重置newChildrenBottom与oldChildrenBottom，此时oldChildrenBottom为2，newChildrenBottom为1。\n3.3.5、分析第八部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 更新列表底部 // Update the bottom of the list. while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom)) { // 分析1 final Element oldChild = oldChildren[oldChildrenTop]; assert(replaceWithNullIfForgotten(oldChild) != null); assert(oldChild._lifecycleState == _ElementLifecycle.active); final Widget newWidget = newWidgets[newChildrenTop]; assert(Widget.canUpdate(oldChild.widget, newWidget)); // 分析2 final Element newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!; assert(newChild._lifecycleState == _ElementLifecycle.active); assert(oldChild == newChild || oldChild._lifecycleState != _ElementLifecycle.active); // 分析3 newChildren[newChildrenTop] = newChild; previousChild = newChild; newChildrenTop += 1; oldChildrenTop += 1; } 这个While循环的工作原理是从列表底部开始更新，也就是从旧Row中第三个子Widget所关联的Element与新Row中第二个子Widget开始往后遍历，更新Element所持有的旧Widget为新Widget，为什么能这么干呢？这时因为之前扫描列表底部时已经记录了旧Row中子Widget所关联的Element能够找到所关联的新Row中子Widget时的位置索引，该位置索引之后的Element均能更新旧Widget为新Widget。\n当Element更新旧Widget成功时，newChildrenTop与oldChildrenTop就会+1。\n3.3.5.1、第一轮循环 此时oldChildrenTop为2，newChildrenTop为1，oldChildrenBottom为2，newChildrenBottom为1。满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))进入循环体。\n分析1：获取oldChild，它是旧Row中第三个Widget所关联的Element。获取newWidget，它是新Row中第二个Widget，也就是旧Row中第三个Widget。\n分析2：执行Element的updateChild方法，下面是会执行到的updateChild方法的相关源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @protected @pragma(\u0026#39;vm:prefer-inline\u0026#39;) Element? updateChild(Element? child, Widget? newWidget, Object? newSlot) { if (newWidget == null) { if (child != null) { deactivateChild(child); } return null; } final Element newChild; if (child != null) { bool hasSameSuperclass = true; assert(() { final int oldElementClass = Element._debugConcreteSubtype(child); final int newWidgetClass = Widget._debugConcreteSubtype(newWidget); hasSameSuperclass = oldElementClass == newWidgetClass; return true; }()); if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget) { if (child.slot != newSlot) { updateSlotForChild(child, newSlot); } newChild = child; } } return newChild; } 因为比较的两者都是旧Row中第三个子Widget，所以满足if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，最后执行newChild = child把旧Row中第三个子Widget所关联的Element返回。\n分析四：把返回的newChild添加到newChildren中，并且newChild成为了下一个槽位slot所指向的Element，然后执行newChildrenTop += 1与oldChildrenTop += 1，此时oldChildrenTop为3，newChildrenTop为2，oldChildrenBottom为2，newChildrenBottom为1。\n3.3.5.2、第二轮循环 在进入下一轮While循环时不满足while ((oldChildrenTop \u0026lt;= oldChildrenBottom) \u0026amp;\u0026amp; (newChildrenTop \u0026lt;= newChildrenBottom))。\n3.3.6、分析第九部分 1 2 3 4 5 6 7 8 9 // 从旧列表中清除任何剩余的中间节点 // Clean up any of the remaining middle nodes from the old list. if (haveOldChildren \u0026amp;\u0026amp; oldKeyedChildren!.isNotEmpty) { for (final Element oldChild in oldKeyedChildren.values) { if (forgottenChildren == null || !forgottenChildren.contains(oldChild)) { deactivateChild(oldChild); } } } 这里的原理是遍历oldKeyedChildren这个Map，它是第五部分中扫描列表中间的老孩子得出的Map，除了传入GlobalKey的子Widget所关联的Element，其它一律移除，因为新Row中没有子Widget与之关联了。\n这里是把之前存入Map的旧Row中第二个Widget所关联的Element执行deactivateChild方法移除。\n3.3.7、分析第十部分 直接将newChildren返回，那么updateChildren方法就执行完毕了，意味着Row所关联的MultiChildRenderObjectElement也就更新了_children。\n示例3与示例2的不同之处已经讲完，该示例中Row及其所有子Widget更新的核心原理如图所示。\n现在可以回过头来解释示例3中的疑问了：\n1、为什么在使用色块Widget时给它传入一个Key，程序运行效果相比示例2就又变得正常了？ 因为旧Row中子Widget所关联的Element，该Element是持有Widget引用的，可以根据Widget的Key去与新Row中子Widget的Key进行配对，如果Key配对成功，那么就会更新该Element所持有的Widget为新Row中子Widget。如果Key配对失败，并且该Widget没有设置GlobalKey，那么该Widget所关联的Element则会被移除。\n2、为什么点击FloatingActionButton按钮后无日志输出？ 因为Element根据Widget的Key来匹配更新Widget，Widget的引用是一直存在的，走的是if (hasSameSuperclass \u0026amp;\u0026amp; child.widget == newWidget)，所以不会执行child.update(newWidget)，也就不会执行State的build方法，所以无日志输出。\n四、Key的分类 根据作用域的不同，可以将Key分为GlobalKey与LocalKey。LocalKey还可以进一步分为ValueKey、ObjectKey与UniqueKey。\n4.1、GlobalKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /// 在整个应用程序中唯一的key。 /// A key that is unique across the entire app. /// /// Global keys唯一标识elements。Global keys提供对与这些elements关联的其它对象的访问，例如 [BuildContext]。 /// 对于 [StatefulWidget]，global keys还提供对 [State] 的访问。 /// Global keys uniquely identify elements. Global keys provide access to other /// objects that are associated with those elements, such as [BuildContext]. /// For [StatefulWidget]s, global keys also provide access to [State]. /// /// 当具有global keys的Widgets从树中的一个位置移动到树中的另一位置时，它们会重新设置其子树的父级。 /// 为了重新设置其子树的父级，widget必须在其从树中旧位置删除的同一动画帧中到达其在树中的新位置。 /// Widgets that have global keys reparent their subtrees when they are moved /// from one location in the tree to another location in the tree. In order to /// reparent its subtree, a widget must arrive at its new location in the tree /// in the same animation frame in which it was removed from its old location in /// the tree. /// /// 使用global key重新设置 [Element] 的父级相对昂贵，因为此操作将触发对关联的 [State] 及其所有后代的 [State.deactivate] 调用；然后强制重建所有依赖于 [InheritedWidget] 的widgets。 /// Reparenting an [Element] using a global key is relatively expensive, as /// this operation will trigger a call to [State.deactivate] on the associated /// [State] and all of its descendants; then force all widgets that depends /// on an [InheritedWidget] to rebuild. /// /// 如果您不需要上面列出的任何功能，请考虑使用 [Key]、[ValueKey]、[ObjectKey] 或 [UniqueKey]。 /// If you don\u0026#39;t need any of the features listed above, consider using a [Key], /// [ValueKey], [ObjectKey], or [UniqueKey] instead. /// /// 您不能同时在树中包含具有相同global key的两个widgets。尝试这样做将在运行时断言。 /// You cannot simultaneously include two widgets in the tree with the same /// global key. Attempting to do so will assert at runtime. /// /// ## 陷阱 /// ## Pitfalls /// /// 不应在每次构建时重新创建 GlobalKeys。例如，它们通常应该是 [State] 对象拥有的长期对象。 /// GlobalKeys should not be re-created on every build. They should usually be /// long-lived objects owned by a [State] object, for example. /// /// 在每次构建时创建新的GlobalKey将丢弃与旧key关联的子树的状态，并为新key创建一个新的子树。 /// 除了损害性能之外，这还可能导致子树中的widgets出现意外行为。 /// 例如，子树中的 [GestureDetector] 将无法跟踪正在进行的手势，因为它将在每次构建时重新创建。 /// Creating a new GlobalKey on every build will throw away the state of the /// subtree associated with the old key and create a new fresh subtree for the /// new key. Besides harming performance, this can also cause unexpected /// behavior in widgets in the subtree. For example, a [GestureDetector] in the /// subtree will be unable to track ongoing gestures since it will be recreated /// on each build. /// /// 相反，一个好的做法是让 State 对象拥有 GlobalKey，并在 build 方法之外实例化它，例如在 [State.initState] 中。 /// Instead, a good practice is to let a State object own the GlobalKey, and /// instantiate it outside the build method, such as in [State.initState]. @optionalTypeArgs abstract class GlobalKey\u0026lt;T extends State\u0026lt;StatefulWidget\u0026gt;\u0026gt; extends Key { factory GlobalKey({ String? debugLabel }) =\u0026gt; LabeledGlobalKey\u0026lt;T\u0026gt;(debugLabel); const GlobalKey.constructor() : super.empty(); Element? get _currentElement =\u0026gt; WidgetsBinding.instance.buildOwner!._globalKeyRegistry[this]; /// 具有此key的widget在其中构建的build context。 /// The build context in which the widget with this key builds. /// /// 如果树中没有与此global key匹配的widget，则当前上下文为null。 /// The current context is null if there is no widget in the tree that matches /// this global key. BuildContext? get currentContext =\u0026gt; _currentElement; /// 树中当前具有此global key的widget。 /// The widget in the tree that currently has this global key. /// /// 如果树中没有与此global key匹配的widget，则当前widget为空。 /// The current widget is null if there is no widget in the tree that matches /// this global key. Widget? get currentWidget =\u0026gt; _currentElement?.widget; /// 树中当前具有此global key的widget的State /// The [State] for the widget in the tree that currently has this global key. /// /// 如果 (1) 树中没有与此global key匹配的widget，(2) 该widget不是 [StatefulWidget]，或者关联的 [State] 对象不是 `T` 的子类型，则当前state为null。 /// The current state is null if (1) there is no widget in the tree that /// matches this global key, (2) that widget is not a [StatefulWidget], or the /// associated [State] object is not a subtype of `T`. T? get currentState { final Element? element = _currentElement; if (element is StatefulElement) { final StatefulElement statefulElement = element; final State state = statefulElement.state; if (state is T) { return state; } } return null; } } 结合上面GlobalKey的注释以及源码，总结下GlobalKey的特性：\n1、GlobalKey是在整个应用程序中唯一的Key，也就是不能给多个Widget传入同一个GlobalKey实例。\n2、GlobalKey唯一标识Element。GlobalKey提供对与这些Element关联的其它对象的访问，例如currentContext、currentWidget与currentState。\n3、不应在每次构建时重新创建GlobalKey，而是在build方法之外实例化它。\n4、使用GlobalKey重新设置Element的父级相对昂贵，因为此操作将触发对关联的State及其所有后代的State.deactivate调用；然后强制重建所有依赖于InheritedWidget的Widget。\n5、\u0026hellip;\n看下GlobalKey在Flutter源码中的体现过程。\nGlobalKey注册与取消注册 在BuildOwner中有一个Map，用来存放GlobalKey与Element这样的键值对，并且提供了_registerGlobalKey与_unregisterGlobalKey方法对GlobalKey注册与取消注册。\n1 2 3 4 5 6 7 8 9 10 11 12 // BuildOwner final Map\u0026lt;GlobalKey, Element\u0026gt; _globalKeyRegistry = \u0026lt;GlobalKey, Element\u0026gt;{}; void _registerGlobalKey(GlobalKey key, Element element) { _globalKeyRegistry[key] = element; } void _unregisterGlobalKey(GlobalKey key, Element element) { if (_globalKeyRegistry[key] == element) { _globalKeyRegistry.remove(key); } } 那么，它是在哪执行GlobalKey注册与取消注册？\n可以看到，GlobalKey注册是在Element的mount方法中触发的，GlobalKey取消注册是在Element的unmount方法中触发的。\n重新将不活跃的Element合并到树中 在Element的inflateWidget方法中，一共做了3件事情：\n1、执行_retakeInactiveElement方法，通过GlobalKey重新获取不活跃的Element。\n在_retakeInactiveElement方法中，执行了parent.forgetChild，表示从Element的子级列表中删除给定的子级，为该子级在Element树中的其它位置重用做好准备。\n在前面讲Row时，它所关联的Element是MultiChildRenderObjectElement，在MultiChildRenderObjectElement的forgetChild方法中，会把当前不活跃的Element添加进_forgottenChildren中。\n1 2 3 4 5 6 7 @override void forgetChild(Element child) { assert(_children.contains(child)); assert(!_forgottenChildren.contains(child)); _forgottenChildren.add(child); super.forgetChild(child); } 在_retakeInactiveElement方法中，继续执行了parent.deactivateChild，将给定元素移动到非活动元素列表，并将其渲染对象从渲染树中分离。\n2、执行newChild._activateWithParent，让Element从“非活动”生命周期状态转换为“活动”生命周期状态，这里会执行Element的activate方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void _activateWithParent(Element parent, Object? newSlot) { assert(_lifecycleState == _ElementLifecycle.inactive); _parent = parent; _updateDepth(_parent!.depth); _activateRecursively(this); attachRenderObject(newSlot); assert(_lifecycleState == _ElementLifecycle.active); } static void _activateRecursively(Element element) { assert(element._lifecycleState == _ElementLifecycle.inactive); element.activate(); assert(element._lifecycleState == _ElementLifecycle.active); element.visitChildren(_activateRecursively); } 3、执行updateChild，更新Element对Widget的引用关系。\n到此，这个Element就复用完成。\n4.2、LocalKey 1 2 3 4 5 6 7 8 9 10 /// 不是 [GlobalKey] 的key。 /// A key that is not a [GlobalKey]. /// /// Keys在具有相同父级的 [Element] 中必须是唯一的。相比之下，[GlobalKey] 在整个应用程序中必须是唯一的。 /// Keys must be unique amongst the [Element]s with the same parent. By /// contrast, [GlobalKey]s must be unique across the entire app. abstract class LocalKey extends Key { const LocalKey() : super.empty(); } 结合上面LocalKey的注释以及源码，总结下LocalKey的特性：在同一级别的Widget中，LocalKey具有唯一性。\n4.2.1、ValueKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /// 使用特定类型的值来标识自身的key。 /// A key that uses a value of a particular type to identify itself. /// /// 当且仅当它们的值为 [operator==] 时，[ValueKey\u0026lt;T\u0026gt;] 才等于另一个 [ValueKey\u0026lt;T\u0026gt;]。 /// A [ValueKey\u0026lt;T\u0026gt;] is equal to another [ValueKey\u0026lt;T\u0026gt;] if, and only if, their /// values are [operator==]. /// /// 可以对此类进行子类化，以创建与碰巧使用相同值的其它value keys不同的value keys。 /// 如果子类是私有的，这会导致value key类型不能与其它源的keys发生冲突，这可能很有用，例如，如果这些keys被用作与另一个widget提供的keys相同范围内的后备。 /// This class can be subclassed to create value keys that will not be equal to /// other value keys that happen to use the same value. If the subclass is /// private, this results in a value key type that cannot collide with keys from /// other sources, which could be useful, for example, if the keys are being /// used as fallbacks in the same scope as keys supplied from another widget. class ValueKey\u0026lt;T\u0026gt; extends LocalKey { /// Creates a key that delegates its [operator==] to the given value. const ValueKey(this.value); /// The value to which this key delegates its [operator==] final T value; @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ValueKey\u0026lt;T\u0026gt; \u0026amp;\u0026amp; other.value == value; } @override int get hashCode =\u0026gt; Object.hash(runtimeType, value); @override String toString() { final String valueString = T == String ? \u0026#34;\u0026lt;\u0026#39;$value\u0026#39;\u0026gt;\u0026#34; : \u0026#39;\u0026lt;$value\u0026gt;\u0026#39;; // The crazy on the next line is a workaround for // https://github.com/dart-lang/sdk/issues/33297 if (runtimeType == _TypeLiteral\u0026lt;ValueKey\u0026lt;T\u0026gt;\u0026gt;().type) { return \u0026#39;[$valueString]\u0026#39;; } return \u0026#39;[$T $valueString]\u0026#39;; } } 之前讲过，ValueKey的==比较相当于equals()方法。\n4.2.2、ObjectKey 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 一个key，它从用作其值的对象中获取其标识。 /// A key that takes its identity from the object used as its value. /// /// 用于将widget的标识与用于生成该widget的对象的标识联系起来。 /// Used to tie the identity of a widget to the identity of an object used to /// generate that widget. class ObjectKey extends LocalKey { /// Creates a key that uses [identical] on [value] for its [operator==]. const ObjectKey(this.value); /// The object whose identity is used by this key\u0026#39;s [operator==]. final Object? value; @override bool operator ==(Object other) { if (other.runtimeType != runtimeType) { return false; } return other is ObjectKey \u0026amp;\u0026amp; identical(other.value, value); } @override int get hashCode =\u0026gt; Object.hash(runtimeType, identityHashCode(value)); @override String toString() { if (runtimeType == ObjectKey) { return \u0026#39;[${describeIdentity(value)}]\u0026#39;; } return \u0026#39;[${objectRuntimeType(this, \u0026#39;ObjectKey\u0026#39;)} ${describeIdentity(value)}]\u0026#39;; } } 与ValueKey不同，ObjectKey重写了==操作符，内部调用的是identical方法来比较，而identical方法是用来检查两个对象引用是否指向同一个对象，所以ObjectKey的==比较的是引用。\n4.2.3、UniqueKey 1 2 3 4 5 6 7 8 9 10 11 12 13 /// 一个只等于它本身的key。 /// A key that is only equal to itself. /// /// 这不能使用const构造函数创建，因为这意味着所有实例化的keys都是同一个实例，因此不是唯一的。 /// This cannot be created with a const constructor because that implies that /// all instantiated keys would be the same instance and therefore not be unique. class UniqueKey extends LocalKey { UniqueKey(); @override String toString() =\u0026gt; \u0026#39;[#${shortHash(this)}]\u0026#39;; } ","date":"2023-10-27T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bkey/","section":"post","tags":null,"title":"解读Flutter源码之Key"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文解读Flutter源码之StatefulWidget\u0026amp;State的生命周期中，笔者分析了State生命周期的相关方法，但碍于篇幅有限，对于setState方法只是进行了简单描述，还未进行深入分析。\n因此，本文将会深入分析setState方法的源码。\n二、setState方法的特性 在分析setState源码之前，一起再回顾下setState方法的一些特性：\n1、setState方法用于通知框架该对象的内部状态已更改\n2、setState方法提供的回调是同步调用，它不能返回future（也就是不能用async），因为如果是异步调用的话，就会不清楚状态何时实际被设置\n3、通常，建议setState方法仅用于包装对状态的实际更改，而不是与更改相关的任何计算。例如，这里build方法使用的_counter被递增，然后更改被写入磁盘，但只有_counter++被包装在setState方法中。\n1 2 3 4 5 6 7 8 Future\u0026lt;void\u0026gt; _incrementCounter() async { setState(() { _counter++; }); Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package final String dirName = directory.path; await File(\u0026#39;$dirName/counter.txt\u0026#39;).writeAsString(\u0026#39;$_counter\u0026#39;); } 4、在框架调用dispose之后调用setState方法是错误的，可以通过检查mounted属性是否为true来判断调用该方法是否合法。\n三、分析setState方法的源码 setState方法在Flutter中属于用得比较频繁的一个方法，当页面UI状态需要发生改变时，调用setState方法就可以触发页面UI状态的更新，那么setState方法是如何做到的，一起看下它的源码：\n可以看到，在setState方法中，调用了外部传入的回调实例fn，类型为VoidCallback。疑问：为什么要将fn的返回值强转为Object？因为需要在断言中判断fn的返回值类型是否是Future，如果是则抛出异常。\n然后执行了_element的markNeedsBuild方法，这里的_element指的是当前State实例所持有的StatefulElement引用。当然了，StatefulElement与ComponentElement内部都没有markNeedsBuild方法，所以执行的是Element的markNeedsBuild方法。\n先看下markNeedsBuild方法的注释。\n1 2 3 4 5 6 7 8 9 /// 将element标记为脏并将其添加到widgets的全局列表中以在下一帧中重建 /// Marks the element as dirty and adds it to the global list of widgets to /// rebuild in the next frame. /// /// 由于在一帧中两次构建一个element是低效的，应用程序和widgets应该被构造为仅在帧开始之前的事件处理程序期间而不是在构建本身期间将widgets标记为脏。 /// Since it is inefficient to build an element twice in one frame, /// applications and widgets should be structured so as to only mark /// widgets dirty during event handlers before the frame begins, not during /// the build itself. 再看下markNeedsBuild方法的源码。\n在markNeedsBuild方法中，可以注意到有一个成员变量dirty，如果dirty为true则会return返回，之后的逻辑就不走了，先看下成员变量dirty的注释。\n1 2 3 4 5 6 7 8 9 /// 如果element已被标记为需要重建，则返回true。 /// Returns true if the element has been marked as needing rebuilding. /// /// 当element首次创建且调用markNeedsBuild之后，该标志为true。该标志在performRebuild实现中重置为false。 /// The flag is true when the element is first created and after /// [markNeedsBuild] has been called. The flag is reset to false in the /// [performRebuild] implementation. bool get dirty =\u0026gt; _dirty; bool _dirty = true; 从成员变量dirty的注释中可以知道，如果一个element已被标记为需要重建，_dirty就会在markNeedsBuild方法中被标记为true，当执行Element的performRebuild方法时，_dirty会重置为false。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// 导致widget自行更新。 /// Cause the widget to update itself. /// /// 进行适当的检查后由 [rebuild] 调用 /// Called by [rebuild] after the appropriate checks have been made. /// /// 基本实现仅清除dirty标志。 /// The base implementation only clears the [dirty] flag. @protected @mustCallSuper void performRebuild() { _dirty = false; } 我们知道，如果执行到了performRebuild方法，意味着即将执行State的build方法。因此，在执行performRebuild方法之前，连续调用多次setState方法，第二次之后其实都是多余的，因为此时dirty为true，return返回会忽略掉之后的逻辑，只有dirty为false时，调用setState方法才能触发页面UI状态的更新。\nOK，继续看下owner!.scheduleBuildFor(this)这行代码，执行的是BuildOwner的scheduleBuildFor方法，传入this，表示当前需要重建的element引用，那么这里的owner是在哪里创建的呢？\n1 2 3 4 5 /// 管理该element生命周期的对象 /// The object that manages the lifecycle of this element. @override BuildOwner? get owner =\u0026gt; _owner; BuildOwner? _owner; 关于BuildOwner的由来，在之前文章讲runApp分析中有提到，它是在七大binding之一WidgetsBinding的initInstances方法中进行BuildOwner初始化，执行的是BuildOwner构造方法。\n然后在WidgetsBinding的attachRootWidget方法中，将BuildOwner实例作为参数传入了刚创建的RenderObjectToWidgetAdapter实例的attachToRenderTree方法中。\n然后在RenderObjectToWidgetAdapter的attachToRenderTree方法中执行了createElement方法，创建了RenderObjectToWidgetElement实例，接着执行了该Element实例的assignOwner方法，传入了BuildOwner引用。\n因为RenderObjectToWidgetElement没有assignOwner方法，所以执行的是混入的RootElementMixin的assignOwner方法，然后将传入的BuildOwner引用赋值给RootElementMixin的父类Element的成员变量_owner，那么Element就持有了最初创建的BuildOwner引用。\n那么为什么Element的子类可以获取到BuildOwner引用？那是因为在Element的mount方法中，对成员变量_owner进行了重新赋值，实际上就是将最初创建的BuildOwner引用一层一层往下传递给Element的子类了，所以Element的子类可以获取到BuildOwner引用。\nOK，关于BuildOwner的由来已经知晓了，我们回到owner!.scheduleBuildFor(this)这行代码，这里执行了BuildOwner的scheduleBuildFor方法。\n在scheduleBuildFor方法中，涉及了四个变量：Element的成员变量_inDirtyList、BuildOwner的成员变量_dirtyElementsNeedsResorting、BuildOwner的成员变量_scheduledFlushDirtyElements、BuildOwner的成员变量_dirtyElements以及BuildOwner的成员变量onBuildScheduled，下面一一分析这五个变量。\nElement的成员变量_inDirtyList 1 2 3 4 // 这是否在owner._dirtyElements中。这用于知道当element重新激活时我们是否应该将其添加回列表中。 // Whether this is in owner._dirtyElements. This is used to know whether we // should be adding the element back into the list when it\u0026#39;s reactivated. bool _inDirtyList = false; 在scheduleBuildFor方法中，如果该Element已经在_dirtyElements列表中，那么直接return返回，后续的逻辑不再执行；\n在scheduleBuildFor方法中，如果该Element不在_dirtyElements列表中，那么将该Element放入到_dirtyElements列表中，然后将_inDirtyList赋值为true；\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），重新将所有Element的_inDirtyList赋值为false。\nBuildOwner的成员变量_dirtyElementsNeedsResorting 1 2 3 4 5 6 7 8 9 10 11 /// 由于在构建过程中更多elements变脏，_dirtyElements是否需要再次排序 /// Whether [_dirtyElements] need to be sorted again as a result of more /// elements becoming dirty during the build. /// /// 这对于保留Element._sort定义的排序顺序是必要的 /// This is necessary to preserve the sort order defined by [Element._sort]. /// /// 当buildScope未主动重建widget树时，该字段设置为null。 /// This field is set to null when [buildScope] is not actively rebuilding /// the widget tree. bool? _dirtyElementsNeedsResorting; 在scheduleBuildFor方法中，如果该Element已经在_dirtyElements列表中，那么_dirtyElementsNeedsResorting赋值为true，表明_dirtyElements中的Element需要再次排序；\n其它情况_dirtyElementsNeedsResorting为false，也就是不需要再次排序；\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），_dirtyElementsNeedsResorting会赋值为null。\nBuildOwner的成员变量_scheduledFlushDirtyElements _scheduledFlushDirtyElements用来控制是否触发onBuildScheduled回调，相当于控制了是否执行_dirtyElements列表中所有Element的重建。\n在BuildOwner的buildScope方法中，当处理完_dirtyElements列表中所有的Element后（所有Element均完成重建后），_scheduledFlushDirtyElements会赋值为false。\nBuildOwner的成员变量_dirtyElements _dirtyElements列表用来添加需要重建的Element，后续会循环遍历该列表，执行所有Element的rebuild方法进行重建。\n一般情况下，在你的State中点击按钮调用setState方法时，就会把当前State所持有的Element添加进该列表。但是，按钮Widget点击事件后面可能还有它自身的setState，这样就会产生多个需要重建的Element，它们也会被添加进该列表，所以就需要对_dirtyElements进行depth深度排序。\nBuildOwner的成员变量onBuildScheduled 1 2 3 4 /// 当第一个可构建element被标记为脏时，在每个构建过程中调用 /// Called on each build pass when the first buildable element is marked /// dirty. VoidCallback? onBuildScheduled; onBuildScheduled回调的赋值是在WidgetsBinding的initInstances方法中，执行了WidgetsBinding的_handleBuildScheduled方法。\n在WidgetsBinding的_handleBuildScheduled方法中，执行了SchedulerBinding的ensureVisualUpdate方法。\n在SchedulerBinding的ensureVisualUpdate方法中，一开始schedulerPhase的状态为SchedulerPhase.idle，所以会执行scheduleFrame方法安排新帧，从注释可以知道，调用此方法可确保最终调用handleDrawFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// 如果该对象当前未生成帧，则使用 [scheduleFrame] 安排新帧。 /// Schedules a new frame using [scheduleFrame] if this object is not /// currently producing a frame. /// /// 调用此方法可确保最终调用 [handleDrawFrame]，除非它已经在进行中。 /// Calling this method ensures that [handleDrawFrame] will eventually be /// called, unless it\u0026#39;s already in progress. /// /// 如果 [schedulerPhase] 是 [SchedulerPhase.transientCallbacks] 或 [SchedulerPhase.midFrameMicrotasks]（因为在这种情况下已经准备好帧） /// 或 [SchedulerPhase.persistentCallbacks]（因为在这种情况下正在主动渲染帧），则这不起作用）。 /// 如果 [schedulerPhase] 是 [SchedulerPhase.idle]（在帧之间）或 [SchedulerPhase.postFrameCallbacks]（在帧之后），它将调度一个帧。 /// This has no effect if [schedulerPhase] is /// [SchedulerPhase.transientCallbacks] or [SchedulerPhase.midFrameMicrotasks] /// (because a frame is already being prepared in that case), or /// [SchedulerPhase.persistentCallbacks] (because a frame is actively being /// rendered in that case). It will schedule a frame if the [schedulerPhase] /// is [SchedulerPhase.idle] (in between frames) or /// [SchedulerPhase.postFrameCallbacks] (after a frame). void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } 看下SchedulerPhase的几种状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /// SchedulerBinding在SchedulerBinding.handleBeginFrame期间经历的各个阶段。 /// The various phases that a [SchedulerBinding] goes through during /// [SchedulerBinding.handleBeginFrame]. /// /// 这是由SchedulerBinding.schedulerPhase公开的 /// This is exposed by [SchedulerBinding.schedulerPhase]. /// /// 该枚举的值按照与阶段发生的顺序相同的顺序排序，因此可以将它们的相对索引值相互比较 /// The values of this enum are ordered in the same order as the phases occur, /// so their relative index values can be compared to each other. enum SchedulerPhase { /// 没有正在处理的帧。任务（由SchedulerBinding.scheduleTask调度）、微任务（由scheduleMicrotask调度）、 /// Timer回调、事件处理程序（例如，来自用户输入）和其它回调（例如，来自Future、 Stream等）可能正在执行。 /// No frame is being processed. Tasks (scheduled by /// [SchedulerBinding.scheduleTask]), microtasks (scheduled by /// [scheduleMicrotask]), [Timer] callbacks, event handlers (e.g. from user /// input), and other callbacks (e.g. from [Future]s, [Stream]s, and the like) /// may be executing. idle, /// 瞬态回调（由SchedulerBinding.scheduleFrameCallback调度）当前正在执行。 /// The transient callbacks (scheduled by /// [SchedulerBinding.scheduleFrameCallback]) are currently executing. /// /// 通常，这些回调处理将对象更新为新的动画状态 /// Typically, these callbacks handle updating objects to new animation /// states. /// /// See [SchedulerBinding.handleBeginFrame]. transientCallbacks, /// 当前正在执行处理瞬态回调期间安排的微任务。 /// Microtasks scheduled during the processing of transient callbacks are /// current executing. /// /// 例如，这可能包括来自在transientCallbacks阶段解析的future的回调 /// This may include, for instance, callbacks from futures resolved during the /// [transientCallbacks] phase. midFrameMicrotasks, /// 持久回调（由SchedulerBinding.addPersistentFrameCallback调度）当前正在执行 /// The persistent callbacks (scheduled by /// [SchedulerBinding.addPersistentFrameCallback]) are currently executing. /// /// 通常，这是构建/布局/绘制管道。 /// Typically, this is the build/layout/paint pipeline. See /// [WidgetsBinding.drawFrame] and [SchedulerBinding.handleDrawFrame]. persistentCallbacks, /// 帧后回调（由SchedulerBinding.addPostFrameCallback调度）当前正在执行 /// The post-frame callbacks (scheduled by /// [SchedulerBinding.addPostFrameCallback]) are currently executing. /// /// 通常，这些回调处理下一帧的清理和工作安排 /// Typically, these callbacks handle cleanup and scheduling of work for the /// next frame. /// /// See [SchedulerBinding.handleDrawFrame]. postFrameCallbacks, } 继续看下SchedulerBinding的scheduleFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// 如有必要，通过调用dart:ui.PlatformDispatcher.scheduleFrame来安排新帧。 /// If necessary, schedules a new frame by calling /// [dart:ui.PlatformDispatcher.scheduleFrame]. /// /// 调用此函数后，引擎将（最终）调用handleBeginFrame 。 （此调用可能会延迟，例如，如果设备的屏幕关闭，则通常会延迟，直到屏幕打开并且应用程序可见。） /// 在一个帧期间调用此函数会强制调度另一个帧，即使当前帧已尚未完成。 /// After this is called, the engine will (eventually) call /// [handleBeginFrame]. (This call might be delayed, e.g. if the device\u0026#39;s /// screen is turned off it will typically be delayed until the screen is on /// and the application is visible.) Calling this during a frame forces /// another frame to be scheduled, even if the current frame has not yet /// completed. /// /// 当操作系统提供的“Vsync”信号触发时，调度帧就会得到服务。 “Vsync”信号或垂直同步信号在历史上与显示器刷新相关，当时硬件在显示器更新之间物理地垂直移动电子束。 /// 现代硬件的操作在某种程度上更加微妙和复杂，但概念性的“Vsync”刷新信号继续用于指示应用程序何时应更新其渲染 /// Scheduled frames are serviced when triggered by a \u0026#34;Vsync\u0026#34; signal provided /// by the operating system. The \u0026#34;Vsync\u0026#34; signal, or vertical synchronization /// signal, was historically related to the display refresh, at a time when /// hardware physically moved a beam of electrons vertically between updates /// of the display. The operation of contemporary hardware is somewhat more /// subtle and complicated, but the conceptual \u0026#34;Vsync\u0026#34; refresh signal continue /// to be used to indicate when applications should update their rendering. 在SchedulerBinding的scheduleFrame方法中，做了两件事情：\n调用SchedulerBinding的ensureFrameCallbacksRegistered方法 注册了PlatformDispatcher.onBeginFrame与PlatformDispatcher.onDrawFrame两个回调。\n当Vsync信号到来时，onBeginFrame与onDrawFrame都会从Engine层回调，其中onBeginFrame主要用来处理动画相关，onDrawFrame主要用来处理页面构建、布局、绘制相关。\n本文只讲onDrawFrame回调后的逻辑。\n1 2 3 4 5 6 7 8 /// 确保PlatformDispatcher.onBeginFrame和PlatformDispatcher.onDrawFrame的回调已注册。 /// Ensures callbacks for [PlatformDispatcher.onBeginFrame] and /// [PlatformDispatcher.onDrawFrame] are registered. @protected void ensureFrameCallbacksRegistered() { platformDispatcher.onBeginFrame ??= _handleBeginFrame; platformDispatcher.onDrawFrame ??= _handleDrawFrame; } 执行platformDispatcher.scheduleFrame() 1 2 3 4 5 6 7 /// 请求在下一个适当的机会调用onBeginFrame和onDrawFrame回调。 /// Requests that, at the next appropriate opportunity, the [onBeginFrame] and /// [onDrawFrame] callbacks be invoked. void scheduleFrame() =\u0026gt; _scheduleFrame(); @Native\u0026lt;Void Function()\u0026gt;(symbol: \u0026#39;PlatformConfigurationNativeApi::ScheduleFrame\u0026#39;) external static void _scheduleFrame(); 可以看到，platformDispatcher.scheduleFrame() 调用的是_scheduleFrame方法，它已经是底层方法了，这里就不深入底层实现了，不过可以猜测，在Android中应该是调用了Choreographer注册了Vysnc信号监听，然后再回调给Flutter，具体留给你们去验证了。\n等到Engine层处理完成，将会回调Framework层的_drawFrame方法，在_drawFrame方法中执行了PlatformDispatcher的_drawFrame方法。\n1 2 3 4 5 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart @pragma(\u0026#39;vm:entry-point\u0026#39;) void _drawFrame() { PlatformDispatcher.instance._drawFrame(); } 在PlatformDispatcher的_drawFrame方法中，执行了_invoke方法，第一个参数传入的是onDrawFrame回调，这个就是之前讲过的SchedulerBinding的ensureFrameCallbacksRegistered方法中注册的回调。\n1 2 3 4 // Called from the engine, via hooks.dart void _drawFrame() { _invoke(onDrawFrame, _onDrawFrameZone); } 来看下_invoke方法，执行了callback()，也就是调用了onDrawFrame的回调引用，那么就会触发SchedulerBinding的_handleDrawFrame方法。\n1 2 3 4 5 6 7 8 9 10 11 12 // /FlutterSDK/flutter/bin/cache/pkg/sky_engine/lib/ui/hooks.dart /// Invokes [callback] inside the given [zone]. void _invoke(void Function()? callback, Zone zone) { if (callback == null) { return; } if (identical(zone, Zone.current)) { callback(); } else { zone.runGuarded(callback); } } 继续看SchedulerBinding的_handleDrawFrame方法，执行了handleDrawFrame方法。\n先看下handleDrawFrame方法的注释。\n1 2 3 4 5 6 7 8 /// 由引擎调用以产生新的帧 /// Called by the engine to produce a new frame. /// /// 该方法在handleBeginFrame之后立即调用。它调用addPersistentFrameCallback注册的所有回调（通常驱动渲染管道），然后调用addPostFrameCallback注册的回调 /// This method is called immediately after [handleBeginFrame]. It calls all /// the callbacks registered by [addPersistentFrameCallback], which typically /// drive the rendering pipeline, and then calls the callbacks registered by /// [addPostFrameCallback]. 再看下handleDrawFrame方法的源码，它会遍历_persistentCallbacks这个List，然后执行_invokeFrameCallback方法。\n在_invokeFrameCallback方法中，实际上是直接调用callback，也就是_persistentCallbacks中的FrameCallback。\n那么这些FrameCallback是在哪里被添加进_persistentCallbacks这个List？\n实际上是在RendererBinding的initInstances方法中执行了addPersistentFrameCallback方法添加进来，具体实现是_handlePersistentFrameCallback方法。\n在RendererBinding的_handlePersistentFrameCallback方法中，执行了drawFrame方法。\n1 2 3 4 void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); _scheduleMouseTrackerUpdate(); } RendererBinding的drawFrame方法被子类WidgetsBinding实现，在WidgetsBinding的drawFrame方法中，执行了buildOwner!.buildScope(rootElement!);。\n在BuildOwner的buildScope方法中，对_dirtyElements进行了depth深度排序，遍历过程中从depth深度值为最小的Element开始处理，也就是优先处理越接近根布局的Element，然后执行Element的rebuild方法完成Element的重建。\n在Element的rebuild方法中，后续执行了performRebuild方法，这个方法我们太熟悉了，之后的过程就不讲解了，最终会触发build方法的执行，完成相关Widget的重建。\n在WidgetsBinding的drawFrame方法中，执行了buildOwner!.buildScope(rootElement!)之后，就会执行super.drawFrame()，也就是调用父类RendererBinding的drawFrame方法。该方法意味着在重新构建渲染树之后就是真正的渲染开始了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /// 泵送渲染管道以生成帧 /// Pump the rendering pipeline to generate a frame. /// /// 该方法由handleDrawFrame调用，当需要布局和绘制框架时，该方法本身由引擎自动调用。 /// This method is called by [handleDrawFrame], which itself is called /// automatically by the engine when it is time to lay out and paint a frame. /// /// 每个帧由以下阶段组成： /// Each frame consists of the following phases: /// /// 1.动画阶段：在PlatformDispatcher.onBeginFrame中注册的handleBeginFrame方法按注册顺序调用在scheduleFrameCallback中注册的所有瞬态帧回调。 /// 这包括驱动AnimationController对象的所有Ticker实例，这意味着所有活动的Animation对象此时都会勾选。 /// 1. The animation phase: The [handleBeginFrame] method, which is registered /// with [PlatformDispatcher.onBeginFrame], invokes all the transient frame /// callbacks registered with [scheduleFrameCallback], in registration order. /// This includes all the [Ticker] instances that are driving /// [AnimationController] objects, which means all of the active [Animation] /// objects tick at this point. /// /// 2. 微任务：[handleBeginFrame] 返回后，由瞬态帧回调调度的任何微任务都会开始运行。 /// 这通常包括来自完成此帧的 [Ticker] 和 [AnimationController] 的 future 回调。 /// 2. Microtasks: After [handleBeginFrame] returns, any microtasks that got /// scheduled by transient frame callbacks get to run. This typically includes /// callbacks for futures from [Ticker]s and [AnimationController]s that /// completed this frame. /// /// 在 [handleBeginFrame] 之后，调用在 [dart:ui.PlatformDispatcher.onDrawFrame] 中注册的 [handleDrawFrame]， /// 它会调用所有持久帧回调，其中最值得注意的是这个方法 [drawFrame]，其执行过程如下如下： /// After [handleBeginFrame], [handleDrawFrame], which is registered with /// [dart:ui.PlatformDispatcher.onDrawFrame], is called, which invokes all the /// persistent frame callbacks, of which the most notable is this method, /// [drawFrame], which proceeds as follows: /// /// 3. 布局阶段：系统中所有脏的[RenderObject]都被布局 /// 3. The layout phase: All the dirty [RenderObject]s in the system are laid /// out (see [RenderObject.performLayout]). See [RenderObject.markNeedsLayout] /// for further details on marking an object dirty for layout. /// /// 4. 合成位阶段：更新任何脏 [RenderObject] 对象上的合成位。 /// 4. The compositing bits phase: The compositing bits on any dirty /// [RenderObject] objects are updated. See /// [RenderObject.markNeedsCompositingBitsUpdate]. /// /// 5. 绘制阶段：系统中所有脏的[RenderObject]都被重新绘制（参见[RenderObject.paint]）。这会生成[图层]树。 /// 5. The paint phase: All the dirty [RenderObject]s in the system are /// repainted (see [RenderObject.paint]). This generates the [Layer] tree. See /// [RenderObject.markNeedsPaint] for further details on marking an object /// dirty for paint. /// /// 6. 合成阶段：将图层树变成【场景】并发送到GPU。 /// 6. The compositing phase: The layer tree is turned into a [Scene] and /// sent to the GPU. /// /// 7. 语义阶段：系统中所有脏的[RenderObject]都更新了它们的语义。这会生成 [SemanticsNode] 树。 /// 7. The semantics phase: All the dirty [RenderObject]s in the system have /// their semantics updated. This generates the [SemanticsNode] tree. See /// [RenderObject.markNeedsSemanticsUpdate] for further details on marking an /// object dirty for semantics. /// /// For more details on steps 3-7, see [PipelineOwner]. /// /// 8. 最终确定阶段：[drawFrame] 返回后，[handleDrawFrame] 调用帧后回调（在 [addPostFrameCallback] 中注册）。 /// 8. The finalization phase: After [drawFrame] returns, [handleDrawFrame] /// then invokes post-frame callbacks (registered with [addPostFrameCallback]). /// /// 某些绑定（例如，[WidgetsBinding]）会向此列表添加额外的步骤（例如，请参阅[WidgetsBinding.drawFrame]）。 /// Some bindings (for example, the [WidgetsBinding]) add extra steps to this /// list (for example, see [WidgetsBinding.drawFrame]). // // When editing the above, also update widgets/binding.dart\u0026#39;s copy. @protected void drawFrame() { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } ","date":"2023-10-21T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bsetstate/","section":"post","tags":null,"title":"解读Flutter源码之setState"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文解读Flutter源码之runApp中，笔者对于StatefulWidget与StatefulElement源码的分析并未足够深入，而且State相关的分析也并未涉及。\n因此，本文将会深入分析StatefulWidget的源码\u0026amp;State的生命周期。\n二、分析StatefulWidget源码 看一个类的源码，最先入手方向应该是它的注释，因为官方document也是通过代码注释生成的，所以先看下StatefulWidget的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 /// 一个具有可变状态的widget /// A widget that has mutable state. /// /// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。 /// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。 /// State is information that (1) can be read synchronously when the widget is /// built and (2) might change during the lifetime of the widget. It is the /// responsibility of the widget implementer to ensure that the [State] is /// promptly notified when such state changes, using [State.setState]. /// /// 一个stateful widget是“通过构建更具体地描述用户界面的其它widgets的一个星座”来描述用户界面的一部分的一个widget。 /// 构建过程递归地继续，直到用户界面的描述完全具体（例如，完全由 [RenderObjectWidget]s 组成，它描述具体的 [RenderObject]s）。 /// A stateful widget is a widget that describes part of the user interface by /// building a constellation of other widgets that describe the user interface /// more concretely. The building process continues recursively until the /// description of the user interface is fully concrete (e.g., consists /// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s). /// /// 当您描述的用户界面部分可以动态更改时，Stateful widgets非常有用，例如由于具有内部时钟驱动状态，或取决于某些系统状态。 /// 对于仅依赖于对象本身的配置信息和widget在其中填充的 [BuildContext] 的组合，请考虑使用 [StatelessWidget]。 /// Stateful widgets are useful when the part of the user interface you are /// describing can change dynamically, e.g. due to having an internal /// clock-driven state, or depending on some system state. For compositions that /// depend only on the configuration information in the object itself and the /// [BuildContext] in which the widget is inflated, consider using /// [StatelessWidget]. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=AqCMFXEmf3w} /// /// [StatefulWidget] 实例本身是不可变的，并将其可变状态存储在由 [createState] 方法创建的单独 [State] 对象中， /// 或者存储在 [State] 订阅的对象中，例如 [Stream] 或 [ChangeNotifier] 对象，其引用存储在 [StatefulWidget] 本身的final字段中。 /// [StatefulWidget] instances themselves are immutable and store their mutable /// state either in separate [State] objects that are created by the /// [createState] method, or in objects to which that [State] subscribes, for /// example [Stream] or [ChangeNotifier] objects, to which references are stored /// in final fields on the [StatefulWidget] itself. /// /// 每当框架填充 [StatefulWidget] 时，框架都会调用 [createState]，这意味着如果该widget已插入树中的多个位置，则多个 [State] 对象可能与同一个 [StatefulWidget] 关联。 /// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [createState] 来创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。 /// The framework calls [createState] whenever it inflates a /// [StatefulWidget], which means that multiple [State] objects might be /// associated with the same [StatefulWidget] if that widget has been inserted /// into the tree in multiple places. Similarly, if a [StatefulWidget] is /// removed from the tree and later inserted in to the tree again, the framework /// will call [createState] again to create a fresh [State] object, simplifying /// the lifecycle of [State] objects. /// /// 如果 [StatefulWidget] 的创建者使用 [GlobalKey] 作为其 [key]，那么当它从树中的一个位置移动到另一个位置时，[StatefulWidget] 会保留相同的 [State] 对象。 /// 由于具有 [GlobalKey] 的widget最多可在树中的一个位置使用，因此使用 [GlobalKey] 的widget最多具有一个关联element。 /// 当将具有全局键的widget从树中的一个位置移动到另一个位置时，框架利用此属性，将与该widget相关联的（唯一）子树从旧位置移植到新位置（而不是在新位置重新创建子树）。 /// 与 [StatefulWidget] 关联的 [State] 对象与子树的其余部分一起嫁接，这意味着 [State] 对象在新位置重用（而不是重新创建）。 /// 但是，为了符合嫁接的条件，必须将widget插入到从旧位置删除的同一动画帧中的新位置。 /// A [StatefulWidget] keeps the same [State] object when moving from one /// location in the tree to another if its creator used a [GlobalKey] for its /// [key]. Because a widget with a [GlobalKey] can be used in at most one /// location in the tree, a widget that uses a [GlobalKey] has at most one /// associated element. The framework takes advantage of this property when /// moving a widget with a global key from one location in the tree to another /// by grafting the (unique) subtree associated with that widget from the old /// location to the new location (instead of recreating the subtree at the new /// location). The [State] objects associated with [StatefulWidget] are grafted /// along with the rest of the subtree, which means the [State] object is reused /// (instead of being recreated) in the new location. However, in order to be /// eligible for grafting, the widget must be inserted into the new location in /// the same animation frame in which it was removed from the old location. /// /// 性能考虑 /// ## Performance considerations /// /// [StatefulWidget]s 有两个主要类别。 /// There are two primary categories of [StatefulWidget]s. /// /// 第一类是在[State.initState]中分配资源并在[State.dispose]中处理资源，但不依赖于[InheritedWidget]s或调用[State.setState]。 /// 此类widgets通常在应用程序或页面的根部使用，并通过 [ChangeNotifier]、[Stream] 或其它此类对象与子widget进行通信。 /// 遵循这种模式的Stateful widgets相对便宜（就 CPU 和 GPU 周期而言），因为它们构建一次就不再更新。因此，他们可以有一些复杂和深入的构建方法。 /// The first is one which allocates resources in [State.initState] and disposes /// of them in [State.dispose], but which does not depend on [InheritedWidget]s /// or call [State.setState]. Such widgets are commonly used at the root of an /// application or page, and communicate with subwidgets via [ChangeNotifier]s, /// [Stream]s, or other such objects. Stateful widgets following such a pattern /// are relatively cheap (in terms of CPU and GPU cycles), because they are /// built once then never update. They can, therefore, have somewhat complicated /// and deep build methods. /// /// 第二类是使用 [State.setState] 或依赖于 [InheritedWidget]s 的widget。 /// 这些通常会在应用程序的生命周期内重建多次，因此最小化重建此类widget的影响非常重要。 /// （它们也可以使用 [State.initState] 或 [State.didChangeDependency] 并分配资源，但重要的部分是它们重建。） /// The second category is widgets that use [State.setState] or depend on /// [InheritedWidget]s. These will typically rebuild many times during the /// application\u0026#39;s lifetime, and it is therefore important to minimize the impact /// of rebuilding such a widget. (They may also use [State.initState] or /// [State.didChangeDependencies] and allocate resources, but the important part /// is that they rebuild.) /// /// 有几种技术可以用来最小化重建stateful widget的影响： /// There are several techniques one can use to minimize the impact of /// rebuilding a stateful widget: /// /// * 将状态推送到叶子。 /// 例如，如果您的页面有一个滴答作响的时钟，则不要将状态放在页面顶部并在每次时钟滴答时重建整个页面，而是创建一个仅更新自身的专用时钟widget。 /// * Push the state to the leaves. For example, if your page has a ticking /// clock, rather than putting the state at the top of the page and /// rebuilding the entire page each time the clock ticks, create a dedicated /// clock widget that only updates itself. /// /// * 最小化由build方法及其创建的任何widgets传递创建的节点数量。 /// 理想情况下，stateful widget只会创建一个小部件，并且该widget将是一个 [RenderObjectWidget]。 （显然这并不总是实用，但是widget越接近这个理想，它的效率就越高。） /// * Minimize the number of nodes transitively created by the build method and /// any widgets it creates. Ideally, a stateful widget would only create a /// single widget, and that widget would be a [RenderObjectWidget]. /// (Obviously this isn\u0026#39;t always practical, but the closer a widget gets to /// this ideal, the more efficient it will be.) /// /// * 如果子树没有更改，则缓存代表该子树的widget，并在每次可以使用时重新使用它。 /// 为此，请将widget分配给“final”状态变量并在构建方法中重新使用它。 /// 重用widget比创建新的（但配置相同的）widget要高效得多。 /// 另一种缓存策略是将widget的可变部分提取到接受子参数的 [StatefulWidget] 中。 /// * If a subtree does not change, cache the widget that represents that /// subtree and re-use it each time it can be used. To do this, assign /// a widget to a `final` state variable and re-use it in the build method. It /// is massively more efficient for a widget to be re-used than for a new (but /// identically-configured) widget to be created. Another caching strategy /// consists in extracting the mutable part of the widget into a [StatefulWidget] /// which accepts a child parameter. /// /// * 尽可能使用“const” widget。 （这相当于缓存一个widget并重新使用它。） /// * Use `const` widgets where possible. (This is equivalent to caching a /// widget and re-using it.) /// /// * 避免更改任何创建的子树的深度或更改子树中任何widget的类型。 /// 例如，不要返回子控件或包装在[IgnorePointer]中的子控件，而是始终将子控件包装在[IgnorePointer]中并控制[IgnorePointer.ignoring]属性。 /// 这是因为更改子树的深度需要重新构建、布局和绘制整个子树，而仅更改属性将需要对渲染树进行最小可能的更改（例如，在[IgnorePointer]的情况下，根本不需要布局或重新绘制）。 /// * Avoid changing the depth of any created subtrees or changing the type of /// any widgets in the subtree. For example, rather than returning either the /// child or the child wrapped in an [IgnorePointer], always wrap the child /// widget in an [IgnorePointer] and control the [IgnorePointer.ignoring] /// property. This is because changing the depth of the subtree requires /// rebuilding, laying out, and painting the entire subtree, whereas just /// changing the property will require the least possible change to the /// render tree (in the case of [IgnorePointer], for example, no layout or /// repaint is necessary at all). /// /// * 如果由于某种原因必须更改深度，请考虑将子树的公共部分包装在具有 [GlobalKey] 的小部件中，该 [GlobalKey] 在stateful widget的生命周期中保持一致。 /// （如果没有其它widget可以方便地分配key，则 [KeyedSubtree] widget可能对此很有用。） /// * If the depth must be changed for some reason, consider wrapping the /// common parts of the subtrees in widgets that have a [GlobalKey] that /// remains consistent for the life of the stateful widget. (The /// [KeyedSubtree] widget may be useful for this purpose if no other widget /// can conveniently be assigned the key.) /// /// {@macro flutter.flutter.widgets.framework.prefer_const_over_helper} /// /// This video gives more explanations on why `const` constructors are important /// and why a [Widget] is better than a helper method. /// /// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo} /// /// For more details on the mechanics of rebuilding a widget, see /// the discussion at [Element.rebuild]. /// /// {@tool snippet} /// /// This is a skeleton of a stateful widget subclass called `YellowBird`. /// /// In this example, the [State] has no actual state. State is normally /// represented as private member fields. Also, normally widgets have more /// constructor arguments, each of which corresponds to a `final` property. /// /// ```dart /// class YellowBird extends StatefulWidget { /// const YellowBird({ super.key }); /// /// @override /// State\u0026lt;YellowBird\u0026gt; createState() =\u0026gt; _YellowBirdState(); /// } /// /// class _YellowBirdState extends State\u0026lt;YellowBird\u0026gt; { /// @override /// Widget build(BuildContext context) { /// return Container(color: const Color(0xFFFFE306)); /// } /// } /// ``` /// {@end-tool} /// {@tool snippet} /// /// This example shows the more generic widget `Bird` which can be given a /// color and a child, and which has some internal state with a method that /// can be called to mutate it: /// /// ```dart /// class Bird extends StatefulWidget { /// const Bird({ /// super.key, /// this.color = const Color(0xFFFFE306), /// this.child, /// }); /// /// final Color color; /// final Widget? child; /// /// @override /// State\u0026lt;Bird\u0026gt; createState() =\u0026gt; _BirdState(); /// } /// /// class _BirdState extends State\u0026lt;Bird\u0026gt; { /// double _size = 1.0; /// /// void grow() { /// setState(() { _size += 0.1; }); /// } /// /// @override /// Widget build(BuildContext context) { /// return Container( /// color: widget.color, /// transform: Matrix4.diagonal3Values(_size, _size, 1.0), /// child: widget.child, /// ); /// } /// } /// ``` /// {@end-tool} /// /// 按照惯例，widget构造函数仅使用命名参数。同样按照约定，第一个参数是 [key]，最后一个参数是 `child`、`children` 或等效参数。 /// By convention, widget constructors only use named arguments. Also by /// convention, the first argument is [key], and the last argument is `child`, /// `children`, or the equivalent. 可以看到，StatefulWidget的注释还是比较多的，这也恰恰反映了它的一个重要性，毕竟平时用它比较多。在StatefulWidget注释当中，它想尽可能地为API使用者讲明白StatefulWidget是什么，因此这不仅有常规的介绍，而且也有出于性能优化的一个考虑（目前来说，性能优化这块并不是本文的重点），以及最后还贴心地给出了使用示例，下面总结下StatefulWidget的特性：\n1、StatefulWidget实例本身是不可变的，它是将其可变状态存储在由createState方法创建的单独 State对象中。\n2、将StatefulWidget插入到树中的多个位置时，会创建多个单独的State实例；如果 StatefulWidget从树中删除，然后再次插入到树中，框架将再次调用createState来创建一个新的 State对象。\n3、StatefulWidget的实现者在状态更改时可以使用State.setState及时通知State。\n4、如果StatefulWidget的创建者使用GlobalKey作为其key，那么当它从树中的一个位置移动到另一个位置时，StatefulWidget会保留相同的State对象。\n5、\u0026hellip;\n这里给出了StatefulWidget的部分特性，主要是想让大家对StatefulWidget有一个初级认知，至于更多的特性需要从Flutter框架源码中去挖掘，这个任务留给个人自行去探索了。\nOK，我们继续看StatefulWidget的源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 abstract class StatefulWidget extends Widget { const StatefulWidget({ super.key }); /// 创建一个StatefulElement来管理此widget在树中的位置 /// Creates a [StatefulElement] to manage this widget\u0026#39;s location in the tree. /// /// 子类重写此方法的情况并不常见。 /// It is uncommon for subclasses to override this method. @override StatefulElement createElement() =\u0026gt; StatefulElement(this); /// 在树中的给定位置为此widget创建可变状态 /// Creates the mutable state for this widget at a given location in the tree. /// /// 子类应该重写此方法以返回其关联State子类的新创建的实例： /// Subclasses should override this method to return a newly created /// instance of their associated [State] subclass: /// /// ```dart /// @override /// State\u0026lt;SomeWidget\u0026gt; createState() =\u0026gt; _SomeWidgetState(); /// ``` /// /// 框架可以在StatefulWidget的生命周期内多次调用此方法。例如，如果widget被插入树中的多个位置，框架将为每个位置创建一个单独的State对象。 /// 类似地，如果widget从树中删除，然后再次插入到树中，框架将再次调用createState来创建一个新的State对象，从而简化State对象的生命周期 /// The framework can call this method multiple times over the lifetime of /// a [StatefulWidget]. For example, if the widget is inserted into the tree /// in multiple locations, the framework will create a separate [State] object /// for each location. Similarly, if the widget is removed from the tree and /// later inserted into the tree again, the framework will call [createState] /// again to create a fresh [State] object, simplifying the lifecycle of /// [State] objects. @protected @factory State createState(); } 从StatefulWidget的源码可以知道，它继承自抽象类Widget，重写了createElement方法，返回一个StatefulElement实例，并且在Widget的基础上新增了一个createState抽象方法，用于返回一个State实例。\n这两个方法的功能从注释中也可以看的明明白白，关于StatefulWidget的分析先讲到这里。\n三、分析StatefulElement源码 先看下StatefulElement的注释。\n1 2 3 /// 使用 [StatefulWidget] 作为其配置的 [Element]。 /// An [Element] that uses a [StatefulWidget] as its configuration. class StatefulElement extends ComponentElement 可以看到，StatefulElement的注释非常简要，从注释中并不能看出该Element的特性所在，不过可以知道的是StatefulElement继承自ComponentElement，那么来看下ComponentElement的注释。\n1 2 3 4 5 6 7 8 9 10 /// 组成其它[Element]s的一个[Element]. /// An [Element] that composes other [Element]s. /// /// ComponentElement不是直接创建RenderObject ，而是通过创建其它Element来间接创建RenderObject /// Rather than creating a [RenderObject] directly, a [ComponentElement] creates /// [RenderObject]s indirectly by creating other [Element]s. /// /// 与RenderObjectElement对比 /// Contrast with [RenderObjectElement]. abstract class ComponentElement extends Element 可以看到，ComponentElement属于组合型Element，它不是直接创建RenderObject，而是通过创建其它Element来间接创建RenderObject，并且ComponentElement继承自Element，那么来看下Element的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /// 树中特定位置的 [Widget] 实例。 /// An instantiation of a [Widget] at a particular location in the tree. /// /// Widgets描述了如何配置子树，但同一个widget可用于同时配置多个子树，因为widgets是不可变的。 /// [Element]表示使用widget来配置树中的特定位置。 /// 随着时间的推移，与给定Element关联的widget可能会发生变化，例如，如果父widget重建并为此位置创建新的widget。 /// Widgets describe how to configure a subtree but the same widget can be used /// to configure multiple subtrees simultaneously because widgets are immutable. /// An [Element] represents the use of a widget to configure a specific location /// in the tree. Over time, the widget associated with a given element can /// change, for example, if the parent widget rebuilds and creates a new widget /// for this location. /// /// Elements形成一棵树。大多数elements都有一个唯一的子元素，但某些widgets（例如 [RenderObjectElement] 的子类）可以有多个子元素。 /// Elements form a tree. Most elements have a unique child, but some widgets /// (e.g., subclasses of [RenderObjectElement]) can have multiple children. /// /// Elements具有以下生命周期： /// Elements have the following lifecycle: /// /// * 框架通过在将用作element初始配置的widget上调用 [Widget.createElement] 来创建一个element。 /// * The framework creates an element by calling [Widget.createElement] on the /// widget that will be used as the element\u0026#39;s initial configuration. /// /// * 框架调用 [mount] 将新创建的element添加到给定父级中给定槽处的树中。 /// [mount] 方法负责填充任何子widgets，并根据需要调用 [attachRenderObject] 将任何关联的渲染对象附加到渲染树。 /// * The framework calls [mount] to add the newly created element to the tree /// at a given slot in a given parent. The [mount] method is responsible for /// inflating any child widgets and calling [attachRenderObject] as /// necessary to attach any associated render objects to the render tree. /// /// * 此时，该element被认为是“active”并且可能出现在屏幕上。 /// * At this point, the element is considered \u0026#34;active\u0026#34; and might appear on /// screen. /// /// * 在某些时候，父级可能决定更改用于配置此element的widget，例如因为父级使用新状态进行了重建。 /// 发生这种情况时，框架将使用新的widget调用 [update]。 /// 新的widget将始终具有与旧widget相同的 [runtimeType] 和键。 /// 如果父级希望更改树中此位置的widget的 [runtimeType] 或键，则可以通过卸载此element并在此位置填充新widget来实现。 /// * At some point, the parent might decide to change the widget used to /// configure this element, for example because the parent rebuilt with new /// state. When this happens, the framework will call [update] with the new /// widget. The new widget will always have the same [runtimeType] and key as /// old widget. If the parent wishes to change the [runtimeType] or key of /// the widget at this location in the tree, it can do so by unmounting this /// element and inflating the new widget at this location. /// /// * 在某些时候，祖先可能决定从树中删除此element（或中间祖先），祖先通过调用 [deactivateChild] 本身来完成此操作。 /// 停用中间祖先将从渲染树中删除该element的渲染对象，并将该element添加到 [owner] 的非活动element列表中，从而导致框架对此element调用 [deactivate]。 /// * At some point, an ancestor might decide to remove this element (or an /// intermediate ancestor) from the tree, which the ancestor does by calling /// [deactivateChild] on itself. Deactivating the intermediate ancestor will /// remove that element\u0026#39;s render object from the render tree and add this /// element to the [owner]\u0026#39;s list of inactive elements, causing the framework /// to call [deactivate] on this element. /// /// * 此时，该元素被视为“inactive”并且不会出现在屏幕上。 /// element只能保持inactive状态直到当前动画帧结束。 /// 在动画帧结束时，任何仍处于非活动状态的elements都将被卸载。 /// * At this point, the element is considered \u0026#34;inactive\u0026#34; and will not appear /// on screen. An element can remain in the inactive state only until /// the end of the current animation frame. At the end of the animation /// frame, any elements that are still inactive will be unmounted. /// /// * 如果该element被重新合并到树中（例如，因为它或其祖先之一具有可重用的global key）， /// 框架将从 [owner] 的非活动element列表中删除该element，对该element调用 [activate]，并将该element的渲染对象重新附加到渲染树。 /// （此时，该element再次被视为“active”并且可能出现在屏幕上。） /// * If the element gets reincorporated into the tree (e.g., because it or one /// of its ancestors has a global key that is reused), the framework will /// remove the element from the [owner]\u0026#39;s list of inactive elements, call /// [activate] on the element, and reattach the element\u0026#39;s render object to /// the render tree. (At this point, the element is again considered \u0026#34;active\u0026#34; /// and might appear on screen.) /// /// * 如果在当前动画帧结束时该element没有重新合并到树中，框架将对该element调用 [unmount]。 /// * If the element does not get reincorporated into the tree by the end of /// the current animation frame, the framework will call [unmount] on the /// element. /// /// * 此时，该element被视为“defunct”，并且将来不会合并到树中。 /// * At this point, the element is considered \u0026#34;defunct\u0026#34; and will not be /// incorporated into the tree in the future. 可以看到，Element的注释还是挺多的，大部分是描述了它的生命周期。\nOK，结合StatefulElement、ComponentElement以及Element三者的注释，总结一下StatefulElement的特性：\n1、StatefulWidget为StatefulElement提供配置，而StatefulElement则是树中特定位置的StatefulWidget实例。\n2、StatefulElement用来组成其它Element，是一种组合型的Element，StatefulElement不是直接创建RenderObject，而是通过创建其它Element来间接创建RenderObject。\n3、\u0026hellip;\n这里给出了StatefulElement的部分特性，余下的留给个人去探索。OK，继续看下StatefulElement的部分源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StatefulElement extends ComponentElement { /// Creates an element that uses the given widget as its configuration. StatefulElement(StatefulWidget widget) : _state = widget.createState(), super(widget) { assert(() { if (!state._debugTypesAreRight(widget)) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;StatefulWidget.createState must return a subtype of State\u0026lt;${widget.runtimeType}\u0026gt;\u0026#39;), ErrorDescription( \u0026#39;The createState function for ${widget.runtimeType} returned a state \u0026#39; \u0026#39;of type ${state.runtimeType}, which is not a subtype of \u0026#39; \u0026#39;State\u0026lt;${widget.runtimeType}\u0026gt;, violating the contract for createState.\u0026#39;, ), ]); } return true; }()); assert(state._element == null); state._element = this; assert( state._widget == null, \u0026#39;The createState function for $widget returned an old or invalid state \u0026#39; \u0026#39;instance: ${state._widget}, which is not null, violating the contract \u0026#39; \u0026#39;for createState.\u0026#39;, ); state._widget = widget; assert(state._debugLifecycleState == _StateLifecycle.created); } @override Widget build() =\u0026gt; state.build(this); /// The [State] instance associated with this location in the tree. /// /// There is a one-to-one relationship between [State] objects and the /// [StatefulElement] objects that hold them. The [State] objects are created /// by [StatefulElement] in [mount]. State\u0026lt;StatefulWidget\u0026gt; get state =\u0026gt; _state!; State\u0026lt;StatefulWidget\u0026gt;? _state; } 可以看到，在StatefulElement的构造方法中，它做了四件事情。\n执行_state = widget.createState()创建了State实例，并赋值给StatefulElement的成员变量_state，也就是说StatefulElement持有了State实例引用。 执行super(widget)调用父类ComponentElement的构造方法，然后一级一级往上传递this，也就是StatefulWidget本身引用，最后在Element的构造方法中赋值给它的成员变量_widget，说明Element会持有Widget的引用。 执行state._element = this;，将StatefulElement赋值给State的成员变量_element，说明State也持有了StatefulElement引用。 执行state._widget = widget;，将StatefulWidget赋值给State的成员变量_widget，说明State也持有了StatefulWidget引用。 OK，现在应该理清了StatefulWidget、StatefulElement以及State之间的关系。因此，可以得出以下结论：\nStatefulElement持有了State实例引用 StatefulElement持有了StatefulWidget实例引用 State又会反过来持有了StatefulWidget与StatefulElement的引用 StatefulWidget只是负责创建StatefulElement与State实例，并不持有它们 关于State的分析后面会讲到，在此之前，我们看下之前的一个runApp示例，补充之前没给出的StatefulWidget加载的一个执行流程图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void main() { _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MyPage(); } } class MyPage extends StatefulWidget { const MyPage({super.key}); @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return const ColoredBox(color: Colors.pinkAccent); } } StatefulWidget加载的一个执行流程图如下所示。\n四、分析State源码 遇事不决，直接找State的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 /// [StatefulWidget] 的逻辑和内部状态 /// The logic and internal state for a [StatefulWidget]. /// /// 状态是以下信息：(1) 在构建widget时可以同步读取；(2) 在widget的生命周期中可能会发生变化。 /// widget实现者有责任确保在状态更改时使用 [State.setState] 及时通知 [State]。 /// State is information that (1) can be read synchronously when the widget is /// built and (2) might change during the lifetime of the widget. It is the /// responsibility of the widget implementer to ensure that the [State] is /// promptly notified when such state changes, using [State.setState]. /// /// [State] 对象是由框架在填充 [StatefulWidget] 并将其插入到树中时调用 [StatefulWidget.createState] 方法创建的。 /// 因为给定的 [StatefulWidget] 实例可以多次填充（例如，该widget一次在多个位置合并到树中），可能有多个 [State] 对象与给定的 [StatefulWidget] 实例关联。 /// 类似地，如果 [StatefulWidget] 从树中删除，然后再次插入到树中，框架将再次调用 [StatefulWidget.createState] 以创建一个新的 [State] 对象，从而简化 [State] 对象的生命周期。 /// [State] objects are created by the framework by calling the /// [StatefulWidget.createState] method when inflating a [StatefulWidget] to /// insert it into the tree. Because a given [StatefulWidget] instance can be /// inflated multiple times (e.g., the widget is incorporated into the tree in /// multiple places at once), there might be more than one [State] object /// associated with a given [StatefulWidget] instance. Similarly, if a /// [StatefulWidget] is removed from the tree and later inserted in to the tree /// again, the framework will call [StatefulWidget.createState] again to create /// a fresh [State] object, simplifying the lifecycle of [State] objects. /// /// [State] 对象具有以下生命周期： /// [State] objects have the following lifecycle: /// /// * 框架通过调用 [StatefulWidget.createState] 创建一个 [State] 对象。 /// * The framework creates a [State] object by calling /// [StatefulWidget.createState]. /// /// * 新创建的 [State] 对象与 [BuildContext] 关联。 /// 这种关联是永久的：[State] 对象永远不会更改其 [BuildContext]。 /// 但是，[BuildContext] 本身可以与其子树一起在树中移动。此时，[State]对象就被认为是[mounted]。 /// * The newly created [State] object is associated with a [BuildContext]. /// This association is permanent: the [State] object will never change its /// [BuildContext]. However, the [BuildContext] itself can be moved around /// the tree along with its subtree. At this point, the [State] object is /// considered [mounted]. /// /// * 框架调用[initState]。[State]的子类应覆盖 [initState]去执行依赖于[BuildContext]或widget的一次性初始化，当调用[initState]方法时，它们分别作为[context]和[widget]属性可用。 /// * The framework calls [initState]. Subclasses of [State] should override /// [initState] to perform one-time initialization that depends on the /// [BuildContext] or the widget, which are available as the [context] and /// [widget] properties, respectively, when the [initState] method is /// called. /// /// * 框架调用[didChangeDependency]。 /// [State] 的子类应重写 [didChangeDependency] 以执行涉及 [InheritedWidget] 的初始化。 /// 如果调用 [BuildContext.dependOnInheritedWidgetOfExactType]，则如果inherited widgets随后发生更改或者widget在树中移动，则将再次调用 [didChangeDependency] 方法。 /// * The framework calls [didChangeDependencies]. Subclasses of [State] should /// override [didChangeDependencies] to perform initialization involving /// [InheritedWidget]s. If [BuildContext.dependOnInheritedWidgetOfExactType] is /// called, the [didChangeDependencies] method will be called again if the /// inherited widgets subsequently change or if the widget moves in the tree. /// /// * 此时，[State] 对象已完全初始化，框架可能会多次调用其 [build] 方法来获取此子树的用户界面的描述。 /// [State] 对象可以通过调用其 [setState] 方法自发请求重建其子树，这表明它们的某些内部状态已发生变化，可能会影响该子树中的用户界面。 /// * At this point, the [State] object is fully initialized and the framework /// might call its [build] method any number of times to obtain a /// description of the user interface for this subtree. [State] objects can /// spontaneously request to rebuild their subtree by calling their /// [setState] method, which indicates that some of their internal state /// has changed in a way that might impact the user interface in this /// subtree. /// /// * 在此期间，父widget可能会重建并请求更新树中的此位置以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget。 /// 发生这种情况时，框架将更新 [widget] 属性以引用新的widget，然后使用先前的widget作为参数调用 [didUpdateWidget] 方法。 /// [State] 对象应覆盖 [didUpdateWidget] 以响应其关联widget中的更改（例如，启动隐式动画）。 /// 框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。 /// * During this time, a parent widget might rebuild and request that this /// location in the tree update to display a new widget with the same /// [runtimeType] and [Widget.key]. When this happens, the framework will /// update the [widget] property to refer to the new widget and then call the /// [didUpdateWidget] method with the previous widget as an argument. [State] /// objects should override [didUpdateWidget] to respond to changes in their /// associated widget (e.g., to start implicit animations). The framework /// always calls [build] after calling [didUpdateWidget], which means any /// calls to [setState] in [didUpdateWidget] are redundant. (See alse the /// discussion at [Element.rebuild].) /// /// * 在开发过程中，如果发生热重载（无论是通过按“r”从命令行“flutter”工具启动，还是从 IDE 启动），都会调用 [reassemble] 方法。 /// 这提供了重新初始化在 [initState] 方法中准备的任何数据的机会。 /// * During development, if a hot reload occurs (whether initiated from the /// command line `flutter` tool by pressing `r`, or from an IDE), the /// [reassemble] method is called. This provides an opportunity to /// reinitialize any data that was prepared in the [initState] method. /// /// * 如果包含 [State] 对象的子树从树中删除（例如，因为父级使用不同的 [runtimeType] 或 [Widget.key] 构建了一个widget），则框架调用 [deactivate] 方法。 /// 子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。 /// * If the subtree containing the [State] object is removed from the tree /// (e.g., because the parent built a widget with a different [runtimeType] /// or [Widget.key]), the framework calls the [deactivate] method. Subclasses /// should override this method to clean up any links between this object /// and other elements in the tree (e.g. if you have provided an ancestor /// with a pointer to a descendant\u0026#39;s [RenderObject]). /// /// * 此时，框架可能会将该子树重新插入到树的另一部分中。 /// 如果发生这种情况，框架将确保调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。 /// 如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。 /// 因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。 /// * At this point, the framework might reinsert this subtree into another /// part of the tree. If that happens, the framework will ensure that it /// calls [build] to give the [State] object a chance to adapt to its new /// location in the tree. If the framework does reinsert this subtree, it /// will do so before the end of the animation frame in which the subtree was /// removed from the tree. For this reason, [State] objects can defer /// releasing most resources until the framework calls their [dispose] /// method. /// /// * 如果框架在当前动画帧结束时没有重新插入此子树，框架将调用 [dispose]，这表明此 [State] 对象将永远不会再次构建。 /// 子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。 /// * If the framework does not reinsert this subtree by the end of the current /// animation frame, the framework will call [dispose], which indicates that /// this [State] object will never build again. Subclasses should override /// this method to release any resources retained by this object (e.g., /// stop any active animations). /// /// * 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。 /// 此时调用[setState]是错误的。生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。 /// * After the framework calls [dispose], the [State] object is considered /// unmounted and the [mounted] property is false. It is an error to call /// [setState] at this point. This stage of the lifecycle is terminal: there /// is no way to remount a [State] object that has been disposed. 对于State，要关注的重点是它的生命周期，这点从注释中对State生命周期的大量描述也可以看出，这里总结下State生命周期的特性：\n1、框架通过调用StatefulWidget.createState创建一个State对象，新创建的State对象与BuildContext关联。\n2、State的子类可以覆盖initState方法去执行一次性初始化，此时context和widget属性可用。\n3、State的子类可以重写didChangeDependency以执行涉及InheritedWidget的初始化。\n4、State对象完全初始化后，可以通过调用其setState方法自发请求重建其子树。\n5、如果父widget重建并请求更新树中的此位置以显示具有相同runtimeType和Widget.key的新widget，框架将更新widget属性以引用新的widget，然后使用先前的widget作为参数调用didUpdateWidget方法，State的子类可以覆盖didUpdateWidget方法以响应其关联widget中的更改。\n6、在开发过程中，如果发生热重载会调用reassemble方法。\n7、如果包含State对象的子树从树中删除，那么会调用deactivate方法，State的子类可以覆盖deactivate方法做一些清除Element链接的操作。\n8、如果框架在当前动画帧结束时没有重新插入此子树，框架将调用dispose，这表明此State对象将永远不会再次构建。\n9、框架调用dispose后，State对象被视为已卸载，并且mounted属性为false。\n10、\u0026hellip;\n这里给出了State生命周期的部分特性，余下的留给个人去探索。OK，继续看下State生命周期相关方法的源码。\n4.1、initState方法 看下initState方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /// 当该对象插入到树中时调用。 /// Called when this object is inserted into the tree. /// /// 框架将为它创建的每个 [State] 对象调用此方法一次。 /// The framework will call this method exactly once for each [State] object /// it creates. /// /// 重写此方法以执行初始化，该初始化取决于此对象插入树中的位置（即 [context]）或用于配置此对象的widget（即 [widget]）。 /// Override this method to perform initialization that depends on the /// location at which this object was inserted into the tree (i.e., [context]) /// or on the widget used to configure this object (i.e., [widget]). /// /// {@template flutter.widgets.State.initState} /// 如果 [State] 的 [build] 方法依赖于一个本身可以更改状态的对象，例如 [ChangeNotifier] 或 [Stream]，或者可以订阅接收通知的其它对象， /// 那么请务必订阅并在 [initState]、[didUpdateWidget] 和 [dispose] 中正确取消订阅： /// If a [State]\u0026#39;s [build] method depends on an object that can itself /// change state, for example a [ChangeNotifier] or [Stream], or some /// other object to which one can subscribe to receive notifications, then /// be sure to subscribe and unsubscribe properly in [initState], /// [didUpdateWidget], and [dispose]: /// /// * 在[initState]中，订阅该对象。 /// * In [initState], subscribe to the object. /// * 在 [didUpdateWidget] 中，如果更新的小部件配置需要替换对象，则取消订阅旧对象并订阅新对象。 /// * In [didUpdateWidget] unsubscribe from the old object and subscribe /// to the new one if the updated widget configuration requires /// replacing the object. /// * 在[dispose]中，取消订阅该对象。 /// * In [dispose], unsubscribe from the object. /// /// {@endtemplate} /// /// 您不能从此方法中使用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// 但是，在此方法之后将立即调用 [didChangeDependency]，并且可以在此处使用 [BuildContext.dependOnInheritedWidgetOfExactType]。 /// You cannot use [BuildContext.dependOnInheritedWidgetOfExactType] from this /// method. However, [didChangeDependencies] will be called immediately /// following this method, and [BuildContext.dependOnInheritedWidgetOfExactType] can /// be used there. /// /// 该方法的实现应该从调用继承的方法开始，如“super.initState()”。 /// Implementations of this method should start with a call to the inherited /// method, as in `super.initState()`. @protected @mustCallSuper void initState() { // 启用断言时跟踪 [State] 对象的生命周期。 // 该状态表明[State] 对象已创建。此时会调用[State.initState]。 assert(_debugLifecycleState == _StateLifecycle.created); if (kFlutterMemoryAllocationsEnabled) { MemoryAllocations.instance.dispatchObjectCreated( library: _flutterWidgetsLibrary, className: \u0026#39;$State\u0026#39;, object: this, ); } } 关于initState方法的说明都在注释中了，那框架在什么地方触发的initState方法呢？\n调用了ComponentElement的mount方法，在mount方法中又调用了_firstBuild方法。\n_firstBuild方法被子类StatefulElement重写了，并且在该方法中调用了initState方法。\n最后附上initState方法的执行流程图。\n4.2、didChangeDependencies方法 看下didChangeDependencies方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /// 当此 [State] 对象的依赖项发生更改时调用。 /// Called when a dependency of this [State] object changes. /// /// 例如，如果先前对 [build] 的调用引用了后来更改的 [InheritedWidget]，则框架将调用此方法来通知此对象有关更改的信息。 /// For example, if the previous call to [build] referenced an /// [InheritedWidget] that later changed, the framework would call this /// method to notify this object about the change. /// /// 该方法也会在 [initState] 之后立即调用。从此方法调用 [BuildContext.dependOnInheritedWidgetOfExactType] 是安全的。 /// This method is also called immediately after [initState]. It is safe to /// call [BuildContext.dependOnInheritedWidgetOfExactType] from this method. /// /// 子类很少重写此方法，因为框架总是在依赖项更改后调用 [build]。 /// 某些子类确实会重写此方法，因为当它们的依赖项发生变化时，它们需要执行一些昂贵的工作（例如，网络获取），而对于每个构建来说，这些工作都太昂贵了。 /// Subclasses rarely override this method because the framework always /// calls [build] after a dependency changes. Some subclasses do override /// this method because they need to do some expensive work (e.g., network /// fetches) when their dependencies change, and that work would be too /// expensive to do for every build. @protected @mustCallSuper void didChangeDependencies() { } 关于didChangeDependencies方法的说明都在注释中了，那框架在什么地方触发的didChangeDependencies方法呢？\n调用了ComponentElement的mount方法，在mount方法中又调用了_firstBuild方法。\n_firstBuild方法被子类StatefulElement重写了，并且在该方法中调用了initState方法，随后又调用了didChangeDependencies方法，最后执行super._firstBuild()，也就是调用ComponentElement的_firstBuild方法。\n在ComponentElement的_firstBuild方法中，执行了rebuild方法。\n在rebuild方法中又会调用performRebuild方法，该方法被子类StatefulElement和ComponentElement重写了，这里我们看StatefulElement重写的performRebuild方法，可以看到执行了didChangeDependencies方法。\n最后附上didChangeDependencies方法的执行流程图。\n4.3、build方法 看下build方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 /// 描述此widget代表的用户界面部分。 /// Describes the part of the user interface represented by this widget. /// /// 框架在许多不同的情况下调用此方法。例如： /// The framework calls this method in a number of different situations. For /// example: /// /// * 在调用 [initState] 之后 /// * After calling [initState]. /// * 在调用 [didUpdateWidget] 之后 /// * After calling [didUpdateWidget]. /// * 在收到对 [setState] 的调用之后。 /// * After receiving a call to [setState]. /// * 此 [State] 对象的依赖项更改后（例如，先前 [build] 更改引用的 [InheritedWidget]）。 /// * After a dependency of this [State] object changes (e.g., an /// [InheritedWidget] referenced by the previous [build] changes). /// * 调用 [deactivate] 后，然后将 [State] 对象重新插入到树中的另一个位置。 /// * After calling [deactivate] and then reinserting the [State] object into /// the tree at another location. /// /// 该方法可以在每个帧中调用，并且除了构建widget之外不应该有任何副作用。 /// This method can potentially be called in every frame and should not have /// any side effects beyond building a widget. /// /// 框架将此widget下面的子树替换为此方法返回的widget，方法是更新现有子树或删除子树并填充新子树， /// 具体取决于此方法返回的widget是否可以更新现有子树的根，通过调用 [Widget.canUpdate] 确定。 /// The framework replaces the subtree below this widget with the widget /// returned by this method, either by updating the existing subtree or by /// removing the subtree and inflating a new subtree, depending on whether the /// widget returned by this method can update the root of the existing /// subtree, as determined by calling [Widget.canUpdate]. /// /// 通常，实现会返回新创建的widgets星座，这些widgets配置有来自该widget的构造函数、给定的 [BuildContext] 和此 [State] 对象的内部状态的信息。 /// Typically implementations return a newly created constellation of widgets /// that are configured with information from this widget\u0026#39;s constructor, the /// given [BuildContext], and the internal state of this [State] object. /// /// 给定的 [BuildContext] 包含有关在树中构建此小部件的位置的信息。 /// 例如，上下文为树中的该位置提供一组inherited widgets。 /// [BuildContext] 参数始终与此 [State] 对象的 [context] 属性相同，并且在此对象的生命周期内保持不变。 /// 此处冗余地提供了 [BuildContext] 参数，以便此方法与 [WidgetBuilder] 的签名匹配。 /// The given [BuildContext] contains information about the location in the /// tree at which this widget is being built. For example, the context /// provides the set of inherited widgets for this location in the tree. The /// [BuildContext] argument is always the same as the [context] property of /// this [State] object and will remain the same for the lifetime of this /// object. The [BuildContext] argument is provided redundantly here so that /// this method matches the signature for a [WidgetBuilder]. /// /// 设计讨论 /// ## Design discussion /// /// 为什么 [build] 方法在 [State] 上，而不是在 [StatefulWidget] 上？ /// ### Why is the [build] method on [State], and not [StatefulWidget]? /// /// 将 `Widget build(BuildContext context)` 方法放在 [State] 上， /// 而不是将 `Widget build(BuildContext context, State state)` 方法放在 [StatefulWidget] 上， /// 可以为开发人员在子类化 [StatefulWidget] 时提供更大的灵活性。 /// Putting a `Widget build(BuildContext context)` method on [State] rather /// than putting a `Widget build(BuildContext context, State state)` method /// on [StatefulWidget] gives developers more flexibility when subclassing /// [StatefulWidget]. /// /// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。 /// 例如，[AnimatedWidget]是[StatefulWidget]的子类，它引入了一个抽象的`Widget build(BuildContext context)`方法供其子类实现。 /// For example, [AnimatedWidget] is a subclass of [StatefulWidget] that /// introduces an abstract `Widget build(BuildContext context)` method for its /// subclasses to implement. If [StatefulWidget] already had a [build] method /// that took a [State] argument, [AnimatedWidget] would be forced to provide /// its [State] object to subclasses even though its [State] object is an /// internal implementation detail of [AnimatedWidget]. /// /// 从概念上讲，[StatelessWidget] 也可以以类似的方式实现为 [StatefulWidget] 的子类。 /// 如果 [build] 方法位于 [StatefulWidget] 而不是 [State]，那么这将不再可能。 /// Conceptually, [StatelessWidget] could also be implemented as a subclass of /// [StatefulWidget] in a similar manner. If the [build] method were on /// [StatefulWidget] rather than [State], that would not be possible anymore. /// /// 将 [build] 函数放在 [State] 而不是 [StatefulWidget] 上也有助于避免与隐式捕获 `this` 的闭包相关的一类错误。 /// 如果您在 [StatefulWidget] 上的 [build] 函数中定义了一个闭包， /// 则该闭包将隐式捕获“this”，即当前的widget实例，并且在范围内具有该实例的（不可变）字段： /// Putting the [build] function on [State] rather than [StatefulWidget] also /// helps avoid a category of bugs related to closures implicitly capturing /// `this`. If you defined a closure in a [build] function on a /// [StatefulWidget], that closure would implicitly capture `this`, which is /// the current widget instance, and would have the (immutable) fields of that /// instance in scope: /// /// ```dart /// // (this is not valid Flutter code) /// class MyButton extends StatefulWidgetX { /// MyButton({super.key, required this.color}); /// /// final Color color; /// /// @override /// Widget build(BuildContext context, State state) { /// return SpecialWidget( /// handler: () { print(\u0026#39;color: $color\u0026#39;); }, /// ); /// } /// } /// ``` /// /// 例如，假设父级构建“MyButton”时“color”为蓝色，则 print 函数中的“color”指的是蓝色，正如预期的那样。 /// 现在，假设父级用绿色重建“MyButton”。 /// 第一次构建创建的闭包仍然隐式引用原始widget，并且“颜色”仍然打印蓝色， /// 即使widget已更新为绿色；如果该闭包比它的widget寿命更长，它会打印过时的信息。 /// For example, suppose the parent builds `MyButton` with `color` being blue, /// the `$color` in the print function refers to blue, as expected. Now, /// suppose the parent rebuilds `MyButton` with green. The closure created by /// the first build still implicitly refers to the original widget and the /// `$color` still prints blue even through the widget has been updated to /// green; should that closure outlive its widget, it would print outdated /// information. /// /// 相反，使用 [State] 对象上的 [build] 函数，在 [build] 期间创建的闭包隐式捕获 [State] 实例而不是 widget 实例： /// In contrast, with the [build] function on the [State] object, closures /// created during [build] implicitly capture the [State] instance instead of /// the widget instance: /// /// ```dart /// class MyButton extends StatefulWidget { /// const MyButton({super.key, this.color = Colors.teal}); /// /// final Color color; /// // ... /// } /// /// class MyButtonState extends State\u0026lt;MyButton\u0026gt; { /// // ... /// @override /// Widget build(BuildContext context) { /// return SpecialWidget( /// handler: () { print(\u0026#39;color: ${widget.color}\u0026#39;); }, /// ); /// } /// } /// ``` /// /// 现在，当父级用绿色重建“MyButton”时，第一个构建创建的闭包仍然引用 [State] 对象，该对象在重建过程中保留， /// 但框架已更新 [State] 对象的 [widget] 属性以引用新的 `MyButton` 实例，并且 `{widget.color}` 按预期打印绿色。 /// Now when the parent rebuilds `MyButton` with green, the closure created by /// the first build still refers to [State] object, which is preserved across /// rebuilds, but the framework has updated that [State] object\u0026#39;s [widget] /// property to refer to the new `MyButton` instance and `${widget.color}` /// prints green, as expected. /// /// See also: /// /// * [StatefulWidget], which contains the discussion on performance considerations. @protected Widget build(BuildContext context); 关于build方法的说明都在注释中了，那框架在什么地方触发的build方法呢？\n在调用initState方法之后 在调用didUpdateWidget方法之后 在调用setState方法之后。 此State对象的依赖项更改后（例如，先前build更改引用的InheritedWidget）。 调用deactivate后，然后将State对象重新插入到树中的另一个位置。 关于build方法的各个触发条件，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。\n4.4、didUpdateWidget方法 看下didUpdateWidget方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /// 每当widget配置更改时调用。 /// Called whenever the widget configuration changes. /// /// 如果父widget重建并请求树中的此位置更新以显示具有相同 [runtimeType] 和 [Widget.key] 的新widget， /// 框架将更新此 [State] 对象的 [widget] 属性以引用新的widget，然后使用前一个widget作为参数调用此方法。 /// If the parent widget rebuilds and requests that this location in the tree /// update to display a new widget with the same [runtimeType] and /// [Widget.key], the framework will update the [widget] property of this /// [State] object to refer to the new widget and then call this method /// with the previous widget as an argument. /// /// 重写此方法以在 [widget] 更改时做出响应（例如，启动隐式动画）。 /// Override this method to respond when the [widget] changes (e.g., to start /// implicit animations). /// /// 框架总是在调用 [didUpdateWidget] 之后调用 [build]，这意味着 [didUpdateWidget] 中对 [setState] 的任何调用都是多余的。 /// The framework always calls [build] after calling [didUpdateWidget], which /// means any calls to [setState] in [didUpdateWidget] are redundant. /// /// {@macro flutter.widgets.State.initState} /// /// 该方法的实现应该从调用继承的方法开始，如“super.didUpdateWidget(oldWidget)”。 /// Implementations of this method should start with a call to the inherited /// method, as in `super.didUpdateWidget(oldWidget)`. @mustCallSuper @protected void didUpdateWidget(covariant T oldWidget) { } 关于didUpdateWidget方法的说明都在注释中了，那框架在什么地方触发的didUpdateWidget方法呢？\n当Widget通过build方法构建后，就会执行Element的updateChild方法，然后将该Widget的引用作为第二个参数newWidget传入到updateChild方法中。\n然后通过Widget的canUpdate方法判断newWidget是否可用于更新当前将oldWidget作为其配置的Element。\n如果canUpdate方法返回true，就会执行child.update(newWidget)，也就是执行Element的update方法。该方法被子类StatefulElement重写了，所以看下StatefulElement的update方法。\n可以看到，StatefulElement的update方法中执行了State的didUpdateWidget方法，这里就不附上didUpdateWidget方法的执行流程图了。\n4.5、deactivate方法 看下deactivate方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 当该对象从树中删除时调用。 /// Called when this object is removed from the tree. /// /// 每当框架从树中删除此 [State] 对象时，框架都会调用此方法。 /// 在某些情况下，框架会将 [State] 对象重新插入树的另一部分（例如，如果由于使用 [GlobalKey]，包含此 [State] 对象的子树从树中的一个位置嫁接到另一个位置） ）。 /// 如果发生这种情况，框架将调用 [activate] 以使 [State] 对象有机会重新获取它在 [deactivate] 中释放的任何资源。 /// 然后，它还将调用 [build] 以使 [State] 对象有机会适应其在树中的新位置。 /// 如果框架确实重新插入该子树，它将在子树从树中删除的动画帧结束之前执行此操作。 /// 因此，[State] 对象可以推迟释放大部分资源，直到框架调用它们的 [dispose] 方法。 /// The framework calls this method whenever it removes this [State] object /// from the tree. In some cases, the framework will reinsert the [State] /// object into another part of the tree (e.g., if the subtree containing this /// [State] object is grafted from one location in the tree to another due to /// the use of a [GlobalKey]). If that happens, the framework will call /// [activate] to give the [State] object a chance to reacquire any resources /// that it released in [deactivate]. It will then also call [build] to give /// the [State] object a chance to adapt to its new location in the tree. If /// the framework does reinsert this subtree, it will do so before the end of /// the animation frame in which the subtree was removed from the tree. For /// this reason, [State] objects can defer releasing most resources until the /// framework calls their [dispose] method. /// /// 子类应该重写此方法，以清除该对象与树中其它elements之间的任何链接（例如，如果您为祖先提供了指向后代的 [RenderObject] 的指针）。 /// Subclasses should override this method to clean up any links between /// this object and other elements in the tree (e.g. if you have provided an /// ancestor with a pointer to a descendant\u0026#39;s [RenderObject]). /// /// 该方法的实现应该以调用继承的方法结束，如“super.deactivate()”。 /// Implementations of this method should end with a call to the inherited /// method, as in `super.deactivate()`. @protected @mustCallSuper void deactivate() { } 关于deactivate方法的说明都在注释中了，那框架在什么地方触发的deactivate方法呢？\n当Widget通过build方法构建后，就会执行Element的updateChild方法，然后将该Widget的引用作为第二个参数newWidget传入到updateChild方法中。\n这里先解释下红框部分：\n上面红框：表示如果newWidget为null，并且child不为null，那么需要将child删除，因为它不再具有配置。 下面红框：表示如果newWidget、child两者都不为空，并且如果Widget.canUpdate()返回false，表明新的Widget与旧的Widget不相同了，就需要先将老的child从渲染树中去除，重新去挂载新child。 这里多插一嘴，updateChild方法作用就是使用给定的新配置更新给定的child，它是widgets系统的核心，每次我们根据更新的配置添加、更新或删除child时都会调用它。\n这里总结下updateChild方法的执行：\nnewWidget == null newWidget != null child == null 返回null 返回新的Element child != null 旧的child被移除, 返回null 如果可能，更新旧child，返回child或新的Element 在红框部分，都会调用deactivateChild方法，然后在deactivateChild方法中执行owner!._inactiveElements.add(child)。\n在_InactiveElements的add方法中，执行了_deactivateRecursively()。\n在_InactiveElements的_deactivateRecursively()中，执行了element.deactivate()。\nElement的deactivate方法被子类StatefulElement重写了，所以看下StatefulElement的deactivate方法。\n可以看到，StatefulElement的deactivate方法中执行了State的deactivate方法，这里就不附上deactivate方法的执行流程图了。\n4.6、dispose方法 看下dispose方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// 当该对象从树中永久删除时调用。 /// Called when this object is removed from the tree permanently. /// /// 当此 [State] 对象不再构建时，框架将调用此方法。 /// 框架调用 [dispose] 后，[State] 对象被视为已卸载，并且 [mounted] 属性为 false。此时调用[setState]是错误的。 /// 生命周期的这个阶段是终结阶段：无法重新挂载已释放的 [State] 对象。 /// The framework calls this method when this [State] object will never /// build again. After the framework calls [dispose], the [State] object is /// considered unmounted and the [mounted] property is false. It is an error /// to call [setState] at this point. This stage of the lifecycle is terminal: /// there is no way to remount a [State] object that has been disposed. /// /// 子类应该重写此方法以释放该对象保留的任何资源（例如，停止任何活动的动画）。 /// Subclasses should override this method to release any resources retained /// by this object (e.g., stop any active animations). /// /// {@macro flutter.widgets.State.initState} /// /// 该方法的实现应该以调用继承的方法结束，如“super.dispose()”。 /// Implementations of this method should end with a call to the inherited /// method, as in `super.dispose()`. @protected @mustCallSuper void dispose() { assert(_debugLifecycleState == _StateLifecycle.ready); assert(() { _debugLifecycleState = _StateLifecycle.defunct; return true; }()); if (kFlutterMemoryAllocationsEnabled) { MemoryAllocations.instance.dispatchObjectDisposed(object: this); } } 关于dispose方法的说明都在注释中了，那框架在什么地方触发的dispose方法呢？\n在RendererBinding的initInstances方法中，会调用addPersistentFrameCallback方法注册一个持久帧回调。\n在持久帧回调_handlePersistentFrameCallback中调用了RendererBinding的drawFrame方法。\nRendererBinding的drawFrame方法被子类WidgetsBinding重写了，所以看下WidgetsBinding的drawFrame方法。\n在WidgetsBinding的drawFrame方法中执行了BuildOwner的finalizeTree方法。\n在BuildOwner的finalizeTree方法中执行了_InactiveElements的_unmountAll方法。\n在_InactiveElements的_unmountAll方法中执行了_unmount方法。\n在_InactiveElements的_unmount方法中又调用了Element的unmount方法。\nElement的unmount方法被子类StatefulElement重写了，所以看下StatefulElement的unmount方法。\n可以看到，StatefulElement的unmount方法中执行了State的dispose方法，这里就不附上dispose方法的执行流程图了。\n4.7、setState方法 看下setState方法的注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 /// 通知框架该对象的内部状态已更改。 /// Notify the framework that the internal state of this object has changed. /// /// 每当您更改 [State] 对象的内部状态时，请在传递给 [setState] 的函数中进行更改： /// Whenever you change the internal state of a [State] object, make the /// change in a function that you pass to [setState]: /// /// ```dart /// setState(() { _myState = newValue; }); /// ``` /// /// 提供的回调将立即同步调用。它不能返回 future（回调不能是“异步”），因为这样就不清楚状态何时实际被设置。 /// The provided callback is immediately called synchronously. It must not /// return a future (the callback cannot be `async`), since then it would be /// unclear when the state was actually being set. /// /// 调用 [setState] 通知框架此对象的内部状态已更改，可能会影响此子树中的用户界面，这会导致框架为此 [State] 对象安排 [build]。 /// Calling [setState] notifies the framework that the internal state of this /// object has changed in a way that might impact the user interface in this /// subtree, which causes the framework to schedule a [build] for this [State] /// object. /// /// 如果您只是直接更改状态而不调用 [setState]，框架可能不会安排 [build]，并且此子树的用户界面可能不会更新以反映新状态。 /// If you just change the state directly without calling [setState], the /// framework might not schedule a [build] and the user interface for this /// subtree might not be updated to reflect the new state. /// /// 通常，建议 [setState] 方法仅用于包装对状态的实际更改，而不是可能与更改相关的任何计算。 /// 例如，这里将 [build] 函数使用的值递增，然后将更改写入磁盘，但只有递增被包装在 [setState] 中： /// Generally it is recommended that the [setState] method only be used to /// wrap the actual changes to the state, not any computation that might be /// associated with the change. For example, here a value used by the [build] /// function is incremented, and then the change is written to disk, but only /// the increment is wrapped in the [setState]: /// /// ```dart /// Future\u0026lt;void\u0026gt; _incrementCounter() async { /// setState(() { /// _counter++; /// }); /// Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package /// final String dirName = directory.path; /// await File(\u0026#39;$dirName/counter.txt\u0026#39;).writeAsString(\u0026#39;$_counter\u0026#39;); /// } /// ``` /// /// 框架调用[dispose]后调用该方法是错误的。您可以通过检查[mounted]属性是否为true来判断调用该方法是否合法。 /// It is an error to call this method after the framework calls [dispose]. /// You can determine whether it is legal to call this method by checking /// whether the [mounted] property is true. @protected void setState(VoidCallback fn) { assert(() { if (_debugLifecycleState == _StateLifecycle.defunct) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() called after dispose(): $this\u0026#39;), ErrorDescription( \u0026#39;This error happens if you call setState() on a State object for a widget that \u0026#39; \u0026#39;no longer appears in the widget tree (e.g., whose parent widget no longer \u0026#39; \u0026#39;includes the widget in its build). This error can occur when code calls \u0026#39; \u0026#39;setState() from a timer or an animation callback.\u0026#39;, ), ErrorHint( \u0026#39;The preferred solution is \u0026#39; \u0026#39;to cancel the timer or stop listening to the animation in the dispose() \u0026#39; \u0026#39;callback. Another solution is to check the \u0026#34;mounted\u0026#34; property of this \u0026#39; \u0026#39;object before calling setState() to ensure the object is still in the \u0026#39; \u0026#39;tree.\u0026#39;, ), ErrorHint( \u0026#39;This error might indicate a memory leak if setState() is being called \u0026#39; \u0026#39;because another object is retaining a reference to this State object \u0026#39; \u0026#39;after it has been removed from the tree. To avoid memory leaks, \u0026#39; \u0026#39;consider breaking the reference to this object during dispose().\u0026#39;, ), ]); } if (_debugLifecycleState == _StateLifecycle.created \u0026amp;\u0026amp; !mounted) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() called in constructor: $this\u0026#39;), ErrorHint( \u0026#39;This happens when you call setState() on a State object for a widget that \u0026#39; \u0026#34;hasn\u0026#39;t been inserted into the widget tree yet. It is not necessary to call \u0026#34; \u0026#39;setState() in the constructor, since the state is already assumed to be dirty \u0026#39; \u0026#39;when it is initially created.\u0026#39;, ), ]); } return true; }()); final Object? result = fn() as dynamic; assert(() { if (result is Future) { throw FlutterError.fromParts(\u0026lt;DiagnosticsNode\u0026gt;[ ErrorSummary(\u0026#39;setState() callback argument returned a Future.\u0026#39;), ErrorDescription( \u0026#39;The setState() method on $this was called with a closure or method that \u0026#39; \u0026#39;returned a Future. Maybe it is marked as \u0026#34;async\u0026#34;.\u0026#39;, ), ErrorHint( \u0026#39;Instead of performing asynchronous work inside a call to setState(), first \u0026#39; \u0026#39;execute the work (without updating the widget state), and then synchronously \u0026#39; \u0026#39;update the state inside a call to setState().\u0026#39;, ), ]); } // We ignore other types of return values so that you can do things like: // setState(() =\u0026gt; x = 3); return true; }()); _element!.markNeedsBuild(); } 碍于篇幅有限，本文不会去分析setState方法的执行流程，后续可能会出一篇来专门分析setState方法。\n4.8、reassemble方法 看下reassemble方法的注释。\n1 2 3 4 5 6 7 8 9 /// {@macro flutter.widgets.Element.reassemble} /// /// 除了调用此方法之外，还保证在发出重组信号时调用 [build] 方法。因此，大多数widgets不需要在 [reassemble] 方法中执行任何操作。 /// In addition to this method being invoked, it is guaranteed that the /// [build] method will be invoked when a reassemble is signaled. Most /// widgets therefore do not need to do anything in the [reassemble] method. @protected @mustCallSuper void reassemble() { } reassemble方法是专门为开发调试提供的，通过点击AS的Flutter Hot Reload按钮来触发，并且在Release模式下永远不会被调用。所以关于reassemble方法的触发流程，这里就不带大家一一去看源码了，感兴趣的可以自己去探索下。\n至此，State的生命周期方法分析完毕，最后给出State的生命周期流程图。\n五、State生命周期示例 现在要实现的需求：\n1、点击“减一”按钮，由MyChild控制setState进行构建\n2、点击“+”、“添加或移除MyChild控件”按钮，由MyParent控制setState进行构建\n3、MyParent与MyChild中的计数器值要保持一致\n4、不同操作场景下，观察MyChild的生命周期变化\n那么，最终的实现代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), home: const MyParent(title: \u0026#39;State生命周期演示\u0026#39;), ); } } class MyParent extends StatefulWidget { const MyParent({super.key, required this.title}); final String title; @override State\u0026lt;MyParent\u0026gt; createState() =\u0026gt; _MyParentState(); } class _MyParentState extends State\u0026lt;MyParent\u0026gt; { int _counter = 0; bool _isShowCounter = true; void _incrementCounter() { setState(() { _counter++; }); } void _toggleCounter() { setState(() { _isShowCounter = !_isShowCounter; }); } void _counterChanged(int counter) =\u0026gt; _counter = counter; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: Text(widget.title), ), body: _isShowCounter ? MyChild(counter: _counter, counterChanged: _counterChanged) : Container(), floatingActionButton: Column( mainAxisAlignment: MainAxisAlignment.end, children: [ FloatingActionButton( onPressed: _incrementCounter, tooltip: \u0026#39;Increment\u0026#39;, child: const Icon(Icons.add), ), const SizedBox(height: 10), FloatingActionButton( onPressed: _toggleCounter, tooltip: \u0026#39;ToggleCounter\u0026#39;, child: Icon(_isShowCounter ? Icons.toggle_on : Icons.toggle_off), ) ], ), ); } } class MyChild extends StatefulWidget { final int counter; final ValueChanged\u0026lt;int\u0026gt; counterChanged; const MyChild({super.key, required this.counter, required this.counterChanged}); @override State\u0026lt;MyChild\u0026gt; createState() =\u0026gt; _MyChildState(); } class _MyChildState extends State\u0026lt;MyChild\u0026gt; { int _counter = 0; void _decrementCounter() { setState(() { debugPrint(\u0026#39;setState\u0026#39;); _counter--; }); widget.counterChanged(_counter); } @override void initState() { super.initState(); debugPrint(\u0026#39;initState\u0026#39;); } @override void didChangeDependencies() { super.didChangeDependencies(); _counter = widget.counter; debugPrint(\u0026#39;didChangeDependencies\u0026#39;); } @override void didUpdateWidget(covariant MyChild oldWidget) { super.didUpdateWidget(oldWidget); _counter = widget.counter; debugPrint(\u0026#39;didUpdateWidget\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;build\u0026#39;); return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: \u0026lt;Widget\u0026gt;[ const Text( \u0026#39;You have pushed the button this many times:\u0026#39;, ), Text( \u0026#39;$_counter\u0026#39;, style: Theme.of(context).textTheme.headlineMedium, ), ElevatedButton( onPressed: _decrementCounter, child: const Text(\u0026#39;减一\u0026#39;), ), ], ), ); } @override void reassemble() { super.reassemble(); debugPrint(\u0026#39;reassemble\u0026#39;); } @override void deactivate() { super.deactivate(); debugPrint(\u0026#39;deactivate\u0026#39;); } @override void dispose() { super.dispose(); debugPrint(\u0026#39;dispose\u0026#39;); } } 程序运行后，效果如图下所示。\n程序刚运行起来，打印日志为： 1 2 3 I/flutter ( 7658): initState I/flutter ( 7658): didChangeDependencies I/flutter ( 7658): build 点击“减一”按钮，打印日志为： 1 2 I/flutter ( 7658): setState I/flutter ( 7658): build 点击“+”按钮，打印日志为： 1 2 I/flutter ( 7658): didUpdateWidget I/flutter ( 7658): build 点击“Flutter Hot Reload”按钮，打印日志为： 1 2 3 I/flutter ( 7658): reassemble I/flutter ( 7658): didUpdateWidget I/flutter ( 7658): build 点击“添加或移除MyChild控件”按钮，此时状态为移除，那么打印日志为： 1 2 I/flutter ( 7658): deactivate I/flutter ( 7658): dispose 点击“添加或移除MyChild控件”按钮，此时状态为添加，那么打印日志为： 1 2 3 I/flutter ( 7658): initState I/flutter ( 7658): didChangeDependencies I/flutter ( 7658): build ","date":"2023-10-18T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Bstatefulwidgetstate%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","section":"post","tags":null,"title":"解读Flutter源码之StatefulWidget\u0026State的生命周期"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、前言 在上一文Flutter源码之三颗树分类中，我们对Flutter的三颗树Widget、Element、RenderObject进行了简单的分类，知道了Widget可分为RenderObjectWidget一类和非RenderObjectWidget另一类，并且XXXWidget基本上都有与之对应的XXXElement。\n在本文中，将会通过一个小案例以及Debug调试源码的方式深入分析runApp方法的执行过程。\n二、小案例之设计问题 笔者在最初设计小案例时，预期想要的Widget层次结构是下图这样的。\n对应的代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MyPage(); } } class MyPage extends StatefulWidget { const MyPage({super.key}); @override State\u0026lt;MyPage\u0026gt; createState() =\u0026gt; _MyPageState(); } class _MyPageState extends State\u0026lt;MyPage\u0026gt; { @override Widget build(BuildContext context) { return const ColoredBox(color: Colors.pinkAccent); } } 程序运行起来后，可以看到如下效果。\n但是当笔者通过Flutter Inspector查看Widget层次结构时，发现事与愿违，它的结构变为如下所示。\n可以发现，此时的Widget层次结构多出了一个View结构，这无疑会给后面的分析带来不必要的干扰，因此需要看下有无办法去掉View结构部分。\n看了下runApp的源码，发现View结构这一部分是在WidgetsBinding的wrapWithDefaultView方法中被添加进来的。\n再看下wrapWithDefaultView方法的注释： 由runApp用于将提供的rootWidget包装在默认View中。 View决定应用程序渲染到哪个FlutterView中。目前这是来自platformDispatcher的PlatformDispatcher.implicitView 。提供给此方法的rootWidget必须尚未包装在View中。\nOK，这wrapWithDefaultView方法的注释看得一头雾水，没关系，再看下View的红框部分注释。\n翻译：提供的child包装在根据给定view构造的MediaQuery中。 查看了View的部分源码发现的确如此。\n这里的child指我们传入的Widget，view指FlutterView，结合之前的分析，笔者大胆猜测wrapWithDefaultView方法的用意：用View对FlutterView进行一个指定渲染的优化管理，在View中先让MediaQuery初始化，为的是让后续的子Widget能够通过MediaQuery获取相关媒体查询数据。也就是说，如果不想调用wrapWithDefaultView方法，只要保证后续子Widget没用到MediaQuery就OK。\n前面所给出的MyApp代码中是完全没有用到MediaQuery的，所以这点不用担心，我们可以大大方方的不调用wrapWithDefaultView方法，改造后runApp方法如下。\n1 2 3 4 5 6 7 8 9 10 void main() { _runApp(const MyApp()); } void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); binding ..scheduleAttachRootWidget(app) ..scheduleWarmUpFrame(); } 但是这样还不行，因为scheduleAttachRootWidget方法是一个@protected方法，外部调用该方法的话会有警告，所以直接把方法体的代码摘抄出来就好了。\n1 2 3 4 5 6 7 void _runApp(Widget app) { final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized(); Timer.run(() { binding.attachRootWidget(app); }); binding.scheduleWarmUpFrame(); } 再次运行程序，然后通过Flutter Inspector查看Widget层次结构，发现与预期的Widget层次结构一致。\n温馨提示：此处runApp方法的改动是为了在Debug调试源码过程中减少其它Widget的干扰，而在实际项目中不能这样做。\n三、Root分析 OK，现在从程序入口_runApp方法开始分析。该方法接收一个Widget参数，接下来执行WidgetsFlutterBinding的ensureInitialized方法，返回一个WidgetsBinding实例。\n2.1、WidgetsFlutterBinding.ensureInitialized() 1 2 3 4 5 6 7 8 class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding._instance == null) { WidgetsFlutterBinding(); } return WidgetsBinding.instance; } } 由上面源码可知，在ensureInitialized方法中，首先会判断WidgetsBinding._instance == null，如果满足条件，则调用WidgetsFlutterBinding的构造方法进行初始化，最后返回WidgetsBinding.instance实例。\n当然了，第一次调用ensureInitialized方法时WidgetsBinding._instance肯定为null，这里可以打个断点Debug看下。\n此时会有个意外的发现，WidgetsFlutterBinding中根本就没有构造方法，毫无疑问会执行其父类BindingBase的构造方法。\nOK，我们继续跟踪其父类BindingBase的源码。\n发现父类BindingBase构造方法中有一个initInstances方法，这里打个断点Debug调试一下，进入initInstances方法。\n然后进入了WidgetsBinding的initInstances方法，继续Debug下一步，来到super.initInstances()。\n继续Debug进入super.initInstances()，然后进入了RendererBinding的initInstances方法。\n以此类推，当断点Debug调试走到BindingBase的initInstances方法时，它的调用堆栈如下图所示。\n对于出现这样栈帧顺序的方法调用栈，其实并不感到意外，回顾之前WidgetsFlutterBinding的声明处源码。\n1 class WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding 可以发现，WidgetsFlutterBinding混入了GestureBinding、SchedulerBinding、ServicesBinding、PaintingBinding、SemanticsBinding、RendererBinding、WidgetsBinding这七个Binding，并且这些Binding都是BindingBase的子类，每个Binding都重写了父类BindingBase的initInstances方法，也在各自重写的initInstances方法体中调用了super.initInstances()以及执行了实例变量引用的赋值_instance = this。\n因此，initInstances方法的调用顺序为：WidgetsBinding -\u0026gt; RendererBinding -\u0026gt; SemanticsBinding -\u0026gt; PaintingBinding -\u0026gt; ServicesBinding -\u0026gt; SchedulerBinding -\u0026gt; GestureBinding，最后才调用父类BindingBase中的initInstances方法，这点从上图的方法调用栈也可以看出。\n也许你会有疑问：为什么initInstances方法的调用顺序是这样的？\n这其实是Dart语言中with关键字的一个语法特性了，如果一个类with混入的多个类中都有相同的方法（例如上面的initInstances方法），那么当调用该方法时，只会调用距离with关键字最远类中的方法，也就是上面WidgetsBinding中的initInstances方法。\n但是由于WidgetsBinding在initInstances方法中又调用了super.initInstances()，所以才会一级一级地往父类方向调用，直到调用父类BindingBase中的initInstances方法。\n因为调用的是WidgetsFlutterBinding的构造方法来进行初始化，所以ensureInitialized方法实例化的是WidgetsFlutterBinding对象了，只不过把实例引用赋值给了WidgetsBinding，如下图所示。\n2.2、attachRootWidget方法 在WidgetsFlutterBinding.ensureInitialized()实例化WidgetsFlutterBinding后，接下来会继续执行WidgetsBinding的attachRootWidget方法，这个方法接收了一个Widget参数。\n那么attachRootWidget方法做了什么事情？看下它的注释。\n1 2 /// Takes a widget and attaches it to the [rootElement], creating it if /// necessary. 翻译：获取一个Widget并将其附加到rootElement ，并在必要时创建它。 attachRootWidget方法的源码如下图所示。\n由上面源码可知，attachRootWidget方法体中先是执行了RenderObjectToWidgetAdapter构造方法，然后再执行该实例对象的attachToRenderTree方法。\n2.3、RenderObjectToWidgetAdapter构造方法 先打个断点Debug看下RenderObjectToWidgetAdapter构造方法传入的参数。\n可以看到，RenderObjectToWidgetAdapter构造方法传入了3个参数，其中参数child就是我们自己的MyApp；参数container传入了renderView，它的类型为RenderView；最后一个参数debugShortDescription从名字上看是调试用的，这个不用管。\n关于参数container传入了renderView，那么这个renderView是怎么来的呢？\n回顾下之前所讲的那七个混入Binding之一的RendererBinding，其实renderView是在RendererBinding的initInstances方法中初始化的。\nOK，RenderObjectToWidgetAdapter构造方法的参数分析完毕，接下来继续看attachToRenderTree方法。\n2.4、attachToRenderTree方法 先打个断点Debug看下attachToRenderTree方法传入的参数。\n可以看到，attachToRenderTree方法接收2个参数，一个是BuildOwner，另一个是可选的位置参数RenderObjectToWidgetElement。\n关于传入的参数buildOwner，那么这个buildOwner是怎么来的呢？它是在那七个混入Binding之一的WidgetsBinding的initInstances方法中初始化的。\nOK，开始分析attachToRenderTree方法源码，因为element为null，所以重点分析下红框部分。\nowner.lockState()接收一个VoidCallback回调，lockState方法体中只是进行一些断言操作，然后在try-finally中执行callback方法，lockState方法的源码如下。\nlockState方法体中没做什么操作，所以lockState方法回调中先调用了createElement方法，创建Element实例后，再调用Element实例的assignOwner方法，因为assignOwner方法不是主线的重点，所以这部分不做讲解。\n继续看主线的重点：createElement方法，它调用的是RenderObjectToWidgetAdapter这个Widget的createElement方法。\n可以发现，调用了RenderObjectToWidgetElement构造方法，方法参数传入的是this，表示RenderObjectToWidgetAdapter本身。\nRenderObjectToWidgetElement构造方法参数执行super.widget，就会把widget一级一级往上传递，先是执行了 RenderObjectElement的构造方法，最后执行了Element的构造方法。并且在Element的构造方法中，把一路传递过来的this，也就是RenderObjectToWidgetAdapter本身赋值给了Element的成员变量_widget，那么Element就持有了这个Widget。\nOK，owner.lockState()已经分析完成，继续看owner.buildScope()，buildScope方法体的实现与前面的lockState方法较为相似，也只是进行一些断言判断，最后在try-finally中执行callback方法。\nbuildScope方法体中没做什么操作，所以在buildScope方法回调中就会执行element的mount方法，也就是RenderObjectToWidgetElement的mount方法。\n分析下RenderObjectToWidgetElement的mount方法，这里分两步走，一步是执行super.mount，也就是执行父类的mount方法；另一步是执行_rebuild方法，这个后面会讲。\n看下第一步，也就是执行父类的mount方法，它会一级一级往上执行，先是执行RenderObjectElement的mount方法，最后执行Element的mount方法。\n可以看到，在Element的mount方法中主要是对一些属性进行赋值操作，如_parent等。当Element的mount方法执行完成后就会出栈，然后回来执行RenderObjectElement的mount方法。\n在RenderObjectElement的mount方法中会执行widget的createRenderObject方法，想必该Widget是谁应该知道吧，它就是之前在构造方法中将参数一级一级往上传递的this，也就是RenderObjectToWidgetAdapter，它是RootWidget，如果不确定，可以Debug断点调试看下。\n继续执行RenderObjectToWidgetAdapter的 createRenderObject方法，会返回一个container，也就是之前讲的RenderView。\n然后将createRenderObject方法返回值赋值给RenderObjectElement的成员变量_renderObject，于是得出一个结论：RenderObjectElement会持有一个RenderObject实例。\n接着，继续执行RenderObjectElement中的attachRenderObject方法。\n在RenderObjectElement中的attachRenderObject方法中，它一共做了三件事情。\n1、执行_findAncestorRenderObjectElement方法，沿着父类往上查找最远处RenderObjectElement类型的Element，并且赋值给 _ancestorRenderObjectElement；其中_parent是在Element的mount方法中赋值，一开始_parent为null，所以_findAncestorRenderObjectElement方法返回为null，相当于该方法没执行。\n2、执行上一步返回的_ancestorRenderObjectElement的insertRenderObjectChild方法将renderObject插入渲染树中； 但是由于_ancestorRenderObjectElement为null，所以insertRenderObjectChild方法并没有触发。\n3、执行_findAncestorParentDataElement方法，沿着父类往上查找最近处ParentDataElement类型的Element，但是由于_parent为null，所以该方法执行了个寂寞。\n因此，整体上RenderObjectElement中的attachRenderObject方法相当于没执行到。\nOK，RenderObjectElement的mount方法分析完了，此时会继续出栈，然后继续执行RenderObjectToWidgetElement的mount方法中super.mount()之后的逻辑。\n也就是执行RenderObjectToWidgetElement的_rebuild方法，在 _rebuild方法中，执行了updateChild方法，参数一_child为null，参数二就是我们自己的MyApp，参数三为Object。\n继续执行Element的updateChild方法，因为此时child为null，所以会执行红框部分，也就是执行inflateWidget方法。\n继续执行Element的inflateWidget方法，之前已经知道传入的newWidget为MyApp，看下它的源码。\n在Element中的inflateWidget方法中，它一共做了3件事情。\n1、校验key是否为GlobalKey，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。\n2、执行newWidget的createElement方法，也就是执行MyApp的createElement方法，返回一个Element实例。\n3、执行上一步返回Element实例的mount方法。\n看到这里，相信你会觉得createElement、mount方法似曾相识，因为之前分析过了。\n总结下Root分析的执行流程，如下图所示。\n四、StatelessWidget分析 接着Root分析，继续执行MyApp的createElement方法，因为MyApp的类型是StatelessWidget，所以执行了StatelessWidget的createElement方法。\n然后创建了StatelessElement实例，并将this传入StatelessElement的构造方法中，this也就是MyApp本身，而StatelessElement构造方法的参数执行了super.widget，会一级一级地向父类传递this，先是执行了ComponentElement的构造方法，最后再执行Element的构造方法，将传递的this赋值给Element的成员变量_widget。\n这种子类Element向父类一级一级传递this的行为我们之前讲过的，也是似曾相识了。\n接着Root分析，继续执行Element的mount方法。因为StatelessElement没有mount方法，所以执行的是ComponentElement的mount方法。\n可以看到，先是执行了super.mount，也就是执行Element的mount方法，这个之前看过，只是一些成员变量的赋值操作。\n然后执行了_firstBuild方法，在该方法中又执行了Element的rebuild方法。\n在Element的rebuild方法中，try-finally处执行了performRebuild方法，然后又回到了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，做了两件事情。\n1、执行build方法。这里执行了StatelessElement的build方法。\n这里的widget就是我们自己的MyApp，所以执行了MyApp的build方法，创建了MyPage实例。\n2、执行了Element的updateChild方法，看到该方法是否又似曾相识，OK，继续分析。\n因为此时child为null，所以会执行红框部分，也就是执行inflateWidget方法。\n继续执行Element的inflateWidget方法，之前已经知道传入的newWidget为MyPage，看下它的源码。\n在Element中的inflateWidget方法中，它一共做了三件事情，这个前面讲过。\n1、校验key是否为GlobalKey，如果是就会做相应逻辑，因为不是此次主线重点，所以不做讲解。\n2、执行newWidget的createElement方法，也就是执行MyPage的createElement方法，返回一个Element实例。\n3、执行上一步返回Element实例的mount方法。\n看到这里，相信你会觉得再熟悉不过，因为之前多次分析过createElement、mount方法了。\n五、StatefulWidget分析 接着StatelessWidget分析，继续执行MyPage的createElement方法，因为MyPage的类型是StatefulWidget，所以执行了StatefulWidget的createElement方法。\n然后创建了StatefulElement实例，并将this传入StatefulElement的构造方法中，this也就是MyPage本身。\n在StatefulElement的构造方法中，执行了widget.createState()，widget就是我们的MyPage，也就是执行了MyPage的createState方法。\n将创建好的_MyPageState实例赋值给StatefulElement的成员变量_state，也就是说StatefulElement持有了State实例。\n与此同时，StatefulElement构造方法中还执行了super(widget)，会一级一级地向父类传递this，先是执行了ComponentElement的构造方法，最后再执行Element的构造方法，将传递的this赋值给Element的成员变量_widget。\n这种子类Element向父类一级一级传递this的行为我们之前讲过的，也是老相识了。\n接着StatelessWidget分析，继续执行Element的mount方法。因为StatefulElement没有mount方法，所以执行的是ComponentElement的mount方法。\n可以看到，先是执行了super.mount，也就是执行Element的mount方法，这个之前看过，只是一些成员变量的赋值操作。\n然后执行了_firstBuild方法，在该方法中又执行了Element的rebuild方法。\n在Element的rebuild方法中，try-finally处执行了performRebuild方法，然后又回到了ComponentElement的performRebuild方法。\n在ComponentElement的performRebuild方法中，做了两件事情。\n1、执行build方法。这里执行了StatefulElement的build方法。\n这里执行了state.build()，也就是执行了_MyPageState的build方法，创建了ColoredBox实例。\n2、执行了Element的updateChild方法，该方法是老朋友了。\n再后面就是ColoredBox的分析，因为ColoredBox最终父类的类型与根布局RenderObjectToWidgetAdapter的类型都是RenderObjectWidget，因此分析都是差不多的，后面就留给你们发挥了。\n当然了，runApp方法的分析肯定不止上面这些内容，后续有机会再补上。\n","date":"2023-10-14T11:28:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBflutter%E6%BA%90%E7%A0%81%E4%B9%8Brunapp/","section":"post","tags":null,"title":"解读Flutter源码之runApp"},{"categories":["Flutter"],"contents":" 注：本文代码基于Flutter SDK 3.13.5\n一、Widget的分类 作为一个初学者，我们知道在Flutter中万物皆Widget，这恰恰说明了Widget在Flutter中的一个重要性，那么以Android开发者的角度来看，Flutter中的Widget是否等同于Android中的View呢？或者说Widget能否像Android中的UI控件一样分为ViewGroup、View两种形式呢？比如说，将需要传入child参数的Widget可认为ViewGroup，如Container、Center等，将不需要传入child参数的Widget可认为View，如Text、Icon等等，如此分类是否合理呢？\nOK，带着疑问，我们先来看下Widget的部分注释。\n1 2 3 4 5 /// Describes the configuration for an [Element]. /// /// Widgets are the central class hierarchy in the Flutter framework. A widget /// is an immutable description of part of a user interface. Widgets can be /// inflated into elements, which manage the underlying render tree. 翻译：Widget描述一个Element的配置。Widget是Flutter框架中的中心类层次结构。一个widget是用户界面一部分的不可变描述。Widget可以创建出Element，这些Element管理底层渲染树。\n其中“be inflated into”在谷歌翻译中会被翻译为“膨胀为”，但是我认为应该翻译为“创建出”比较合理，因为在Widget源码中有一个抽象的createElement方法，就是用来创建并返回Element对象的。\n1 2 3 4 5 6 7 8 9 10 11 12 /// Widget的部分源码 abstract class Widget extends DiagnosticableTree { const Widget({ this.key }); final Key? key; @protected @factory Element createElement(); } 现在，我们知道了Widget在Flutter中扮演着一个UI配置的角色，它是不可变的，Widget本身既非视图，也不会直接绘制任何内容。从这一维度上讲，Widget不完全等同于Android中的View，所以将Widget像Android中的UI控件一样分为ViewGroup、View两种形式我认为并不合理。\n那么Widget该如何分类呢？我们可以先查看Widget的所有直接子类，比对直接子类之间的区别来进行分类。\n选中Widget-》点击AS菜单栏Navigate中的Type Hierarchy选项，就可以输出Widget的继承关系层次结构（使用快捷键呼出也可以，我这里的默认快捷键是F4）。\n经过仔细比对Widget直接子类之间的区别，将Widget分类后如下图所示。\n如上图所示，根据有无RenderObject大致可以将Widget分为RenderObjectWidget一类和非RenderObjectWidget另一类。\nRenderObjectWidget一类 那么RenderObjectWidget是什么？看下它的部分注释说明。\n1 2 3 /// RenderObjectWidgets provide the configuration for [RenderObjectElement]s, /// which wrap [RenderObject]s, which provide the actual rendering of the /// application. 翻译：RenderObjectWidget为RenderObjectElement提供配置，RenderObjectElement包装了RenderObject，RenderObject提供应用程序的实际渲染。\n到这里已经初步知道这三颗树在Flutter中的作用了，Widget为Element提供配置，Element管理着RenderObject，实际渲染的是RenderObject。\n再来看下RenderObjectWidget源码。\n由上图可知，RenderObjectWidget抽象类主要包含4个方法：createElement、createRenderObject、updateRenderObject、didUnmountRenderObject，其中createElement和createRenderObject为抽象方法，需要子类去实现，也就是说， RenderObjectWidget不仅要创建Element，也要创建RenderObject。\n下面以同样的方式查看RenderObjectWidget继承关系层次结构，又可以将RenderObjectWidget一类分为以下几类。\nWidget 说明 SingleChildRenderObjectWidget 为SingleChildRenderObjectElement提供配置，只能传入单个Child的Widget MultiChildRenderObjectWidget 为MultiChildRenderObjectElement提供配置，可以传入多个Child的Widget LeafRenderObjectWidget 为LeafRenderObjectElement提供配置，没有Child的Widget RenderObjectToWidgetAdapter 从RenderObject到Element树的桥梁 非RenderObjectWidget另一类 非RenderObjectWidget又可以按有无State分为StatefulWidget、StatelessWidget和ProxyWidget等等，我们只重点看下StatefulWidget和StatelessWidget。\n首先看下StatefulWidget的部分注释。\n1 /// A widget that has mutable state. 翻译：Widget具有可变状态。\n在StatefulWidget中主要有createElement和createState方法，其中createElement方法返回了一个StatefulElement，而createState方法则为一个抽象方法，就是我们经常实现的一个方法。\n为什么说StatefulWidget是可变的？这是因为State信息在Widget的生命周期中可能会发生变化。Widget实现者可以确保在状态更改时使用State.setState及时通知State。\n至于StatelessWidget，看下它的部分注释。\n1 /// A widget that does not require mutable state. 翻译：不需要可变状态的Widget。\nStatelessWidget主要有createElement和build方法，其中createElement方法返回了一个StatelessElement，而build方法则为一个抽象方法，就是我们经常实现的一个方法。\n二、 Element的分类 通过对上面Widget分类的了解，我们可以看出它主要是为了给Element提供配置和创建Element而生的。并且细心点就可以发现，对于上述提到的XXXWidget基本上都有对应的XXXElement，如下：\n1 2 3 4 5 6 7 StatelessWidget -\u0026gt; StatelessElement StatefulWidget -\u0026gt; StatefulElement InheritedWidget -\u0026gt; InheritedElement LeafRenderObjectWidget -\u0026gt; LeafRenderObjectElement SingleChildRenderObjectWidget -\u0026gt; SingleChildRenderObjectElement MultiChildRenderObjectWidget -\u0026gt; MultiChildRenderObjectElement ... 那么，Element到底是什么？首先看下Element的部分注释。\n1 /// An instantiation of a [Widget] at a particular location in the tree. 翻译：树中特定位置的Widget实例。\n通过查看Element的部分源码我们可以发现，Element中不仅持有了Widget、还持有了RenderObject，从这一角度来讲，Element是Widget与RenderObject之间沟通的桥梁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Element的部分源码 abstract class Element extends DiagnosticableTree implements BuildContext { Element(Widget widget) : assert(widget != null), widget = widget; @override Widget get widget =\u0026gt; _widget!; Widget? _widget; RenderObject? get renderObject { RenderObject? result; void visit(Element element) { assert(result == null); if (element._lifecycleState == _ElementLifecycle.defunct) { return; } else if (element is RenderObjectElement) { result = element.renderObject; } else { element.visitChildren(visit); } } visit(this); return result; } } 下面以同样的方式查看Element继承关系层次结构，可以发现每个XXXElement基本上是通过继承ComponentElement或RenderObjectElement来间接继承Element，Element分类如下图所示。\n三、RenderObject的分类 通过前面的了解，我们知道RenderObject用来渲染的，那么RenderObject是什么呢？看下它的部分注释。\n1 2 3 4 /// An object in the render tree. /// /// The [RenderObject] class hierarchy is the core of the rendering /// library\u0026#39;s reason for being. 翻译：渲染树中的对象。RenderObject类层次结构是渲染库存在的核心。\n下面以同样的方式查看RenderObject继承关系层次结构，又可以将RenderObject分为以下几类。\nRenderObject 说明 RenderObjectWithChildMixin 用于渲染只有一个子对象的泛型mixin ContainerRenderObjectMixin 用于渲染具有多个子对象的泛型mixin RenderView 渲染树的根节点 RenderBox 二维笛卡尔坐标系中的渲染对象 RenderSliver 在视口中实现滚动效果的渲染对象的基类 RelayoutWhenSystemFontsChangeMixin RenderObject的Mixin每当系统字体更改时都会调用systemFontsDidChange ","date":"2023-10-10T14:47:31+08:00","permalink":"https://anddevmk.cn/post/flutter%E6%BA%90%E7%A0%81%E4%B9%8B%E4%B8%89%E9%A2%97%E6%A0%91%E5%88%86%E7%B1%BB/","section":"post","tags":null,"title":"Flutter源码之三颗树分类"},{"categories":["Java"],"contents":" 注：本文代码基于JDK 17\n一、概述 动态代理，一个听起来很高深的名词，其实并非如此，在日常的开发中，你或多或少都有遇到过，比如你调用第三方SDK的方法时，该方法的具体实现或许就是使用了动态代理，这个本文后面会讲到。\n不管是在Java开发还是Android开发中，动态代理的应用场景都非常广泛，因此我们需要学习它，并且了解它的运行原理，这也是本文接下来要做的事情。\n二、什么是代理？ 代理在我们的日常生活中很常见，比如说：\n恶略天气出去吃饭麻烦，可以点外卖\n爷爷不会使用手机充话费，找孙女帮忙充\n在这两个例子中，外卖骑手、孙女这两个角色都是帮我们干活的，他们做着我们不能做或不想做的事情。\n因此，代理其实就是当前对象不能做或不想做的事情，委托给别的对象做。\n三、静态代理的使用 还是以上面的“孙女帮爷爷充话费”为例进行说明，现有一个行为接口Action，包含了一个充话费的方法recharge。\n1 2 3 4 5 6 7 8 9 10 /** * 行为接口 */ public interface Action { /** * 充话费 */ void recharge(); } 因为爷爷需要充话费，所以Grandfather类实现了Action接口。\n1 2 3 4 5 6 7 8 9 10 /** * 爷爷 */ public final class Grandfather implements Action { @Override public void recharge() { System.out.println(\u0026#34;recharge\u0026#34;); } } 但是，爷爷并不会使用手机充话费，于是他找了孙女请求帮忙充话费，那么Granddaughter类也要实现Action接口，然后把两者的充话费行为关联起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 孙女 */ public final class Granddaughter implements Action { private final Action action; public Granddaughter(Action action) { this.action = action; } @Override public void recharge() { System.out.println(\u0026#34;before recharge\u0026#34;); if (action != null) action.recharge(); System.out.println(\u0026#34;after recharge\u0026#34;); } } 最终的main方法如下：\n1 2 3 4 5 6 7 8 public class Client { public static void main(String[] args) { Grandfather grandfather = new Grandfather(); Granddaughter granddaughter = new Granddaughter(grandfather); granddaughter.recharge(); } } 由上面代码可知，Grandfather和Granddaughter两个类都实现了相同的接口Action，实际对象是Grandfather，代理对象是Granddaughter。\nGranddaughter内部有一个action的成员变量，指向实际对象，在构造方法中被初始化，对于方法recharge方法的调用，它转发给了实际对象，接着在调用前后输出了一些跟踪调试信息，这也是代理对原方法进行增强的一种体现，上面代码输出如下：\n1 2 3 before recharge recharge after recharge 因此，代理背后一般至少有一个实际对象，代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。\n在代码中创建了一个代理类Granddaughter，它的代码是在写程序时固定的，所以称为静态代理。\n虽然静态代理实现简单，且不侵入原代码，但是当场景复杂一些的时候，静态代理的缺点也会暴露出来。\n1、当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有2种方式：\n只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类 2、当接口增加、删除、修改方法的时候，目标对象与代理类都要同时修改，十分不易维护。\n那么，这要如何改进呢？\n当然是让代理类动态的生成，这也是接下来要说的动态代理。\n四、动态代理的使用 在静态代理中，代理类是直接定义在代码中的，而在动态代理中，代理类是动态生成的，那么就有一个疑问了，要如何去实现动态代理呢？\n在JDK中，提供了java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler这两个类来实现动态代理。动态代理的使用有2个步骤：\n创建一个类去实现InvocationHandler接口，并且实现该接口的invoke方法。\n使用Proxy类的newProxyInstance方法去创建代理类的实例对象。\n接下来，我们按照上面的步骤一一实现动态代理，首先创建一个类ActionInvocationHandler，让它去实现InvocationHandler接口，并且实现该接口的invoke方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Action接口调用处理器 */ public class ActionInvocationHandler implements InvocationHandler { private final Object realObj; // 实际对象 public ActionInvocationHandler(Object realObj) { this.realObj = realObj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;before recharge\u0026#34;); Object result = method.invoke(realObj, args); System.out.println(\u0026#34;after recharge\u0026#34;); return result; } } ActionInvocationHandler类实现了InvocationHandler接口，它的构造方法接受一个Object类型的参数realObj，realObj表示被代理的实际对象，接着在invoke方法中处理所有的接口调用，它有3个参数：\nproxy：表示代理对象本身，注意了，它不是被代理的实际对象，这个参数一般用处不大；\nmethod：表示代理方法的method对象；\nargs：表示代理方法的参数；\n上面调用了method的invoke方法，传递了实际对象realObj作为参数，达到了调用实际对象对应方法的目的，在调用任何方法前后，我们输出了跟踪调试语句。需要注意的是，不能将proxy作为参数传递给method的invoke方法，比如：\n1 Object result = method.invoke(proxy, args); 上面的语句会造成死循环，因为proxy表示当前代理对象，这又会调用到ActionInvocationHandler的invoke方法。\n然后使用Proxy类的newProxyInstance方法去创建代理类的实例对象，调用代理类的实例对象的方法，代码如下：\n1 2 3 4 5 6 7 8 9 public class Client { public static void main(String[] args) { Grandfather grandfather = new Grandfather(); Action action = (Action) Proxy.newProxyInstance(Action.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Action.class}, new ActionInvocationHandler(grandfather)); action.recharge(); } } 和静态代理相比，代码看起来复杂不少，但是Action接口和Grandfather的定义不变，程序的输出也没变，只是代理对象Granddaughter的创建方式变了，它使用Proxy类的静态方法newProxyInstance来创建代理对象，该方法的声明如下：\n1 2 3 public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) newProxyInstance方法有3个参数：\nloader：代理类的类加载器；\ninterfaces：代理类要实现的接口列表，它是一个数组，元素的类型只能是接口，不能是普通的类；\nh：h的类型为InvocationHandler，它是一个接口，只定义了一个方法invoke，对代理接口所有方法的调用都会转给该方法。\nnewProxyInstance方法的返回值类型为Object，可以强制转换为interfaces数组中的某个接口类型。这里我们强制转换为了Action类型，需要注意的是，它不能强制转换为某个类类型。\n如果上面动态代理的代码令你感到疑惑，那么接下来让我们一起去深入源码，慢慢解开你心中的疑惑。\n五、动态代理的原理 我们先看下Proxy类的newProxyInstance方法，因为它返回的是代理类的实例对象，那么代理类的实例对象是怎么被构造出来的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) { Objects.requireNonNull(h); // 如果没有调用setSecurityManager方法设置SecurityManager，那么getSecurityManager方法返回为null，因此，默认情况下caller即为null，否则返回调用此方法的方法的调用者的类 @SuppressWarnings(\u0026#34;removal\u0026#34;) final Class\u0026lt;?\u0026gt; caller = System.getSecurityManager() == null ? null : Reflection.getCallerClass(); /* * Look up or generate the designated proxy class and its constructor. */ // 分析1 Constructor\u0026lt;?\u0026gt; cons = getProxyConstructor(caller, loader, interfaces); // 分析2 return newProxyInstance(caller, cons, h); } 分析1：调用getProxyConstructor方法创建代理类的构造方法所对应的构造器对象cons，\n其中方法的参数传入了类加载器loader和数组interfaces；\n分析2：调用newProxyInstance方法创建代理类的实例对象并返回，其中方法的参数传入了构造器对象cons和InvocationHandler类型的变量h。\nOK，首先看getProxyConstructor方法的实现，它是怎么创建的构造器对象cons？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private static Constructor\u0026lt;?\u0026gt; getProxyConstructor(Class\u0026lt;?\u0026gt; caller, ClassLoader loader, Class\u0026lt;?\u0026gt;... interfaces) { // optimization for single interface // 代理接口数组中只有单个接口 if (interfaces.length == 1) { Class\u0026lt;?\u0026gt; intf = interfaces[0]; // 默认情况下，caller为null，不满足此处if if (caller != null) { // 检查创建代理类所需的权限 checkProxyAccess(caller, loader, intf); } return proxyCache.sub(intf).computeIfAbsent( loader, (ld, clv) -\u0026gt; new ProxyBuilder(ld, clv.key()).build() ); } else { // 代理接口数组中存在多个接口 // interfaces cloned final Class\u0026lt;?\u0026gt;[] intfsArray = interfaces.clone(); // 默认情况下，caller为null，不满足此处if if (caller != null) { // 检查创建代理类所需的权限 checkProxyAccess(caller, loader, intfsArray); } final List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; intfs = Arrays.asList(intfsArray); return proxyCache.sub(intfs).computeIfAbsent( loader, (ld, clv) -\u0026gt; new ProxyBuilder(ld, clv.key()).build() ); } } 通过上面代码可知，根据数组interfaces的长度来分情况处理，但是不管怎样，最终都是调用了proxyCache变量的复杂调用链进行相关操作，那么proxyCache是什么玩意？\n1 2 3 4 5 6 7 8 public class Proxy implements java.io.Serializable { /** * a cache of proxy constructors with * {@link Constructor#setAccessible(boolean) accessible} flag already set */ private static final ClassLoaderValue\u0026lt;Constructor\u0026lt;?\u0026gt;\u0026gt; proxyCache = new ClassLoaderValue\u0026lt;\u0026gt;(); } 由代码注释可知，proxyCache是已设置accessible标志的代理构造函数的缓存，并且它是ClassLoaderValue类型。跟踪ClassLoaderValue类发现它继承自抽象类AbstractClassLoaderValue，当调用ClassLoaderValue的sub方法时，因为ClassLoaderValue没有sub方法，所以实际上是调用了抽象类AbstractClassLoaderValue的sub方法，这个sub方法创建了Sub对象，而Sub类又是AbstractClassLoaderValue的内部类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public abstract class AbstractClassLoaderValue\u0026lt;CLV extends AbstractClassLoaderValue\u0026lt;CLV, V\u0026gt;, V\u0026gt; { public \u0026lt;K\u0026gt; Sub\u0026lt;K\u0026gt; sub(K key) { return new Sub\u0026lt;\u0026gt;(key); } public final class Sub\u0026lt;K\u0026gt; extends AbstractClassLoaderValue\u0026lt;Sub\u0026lt;K\u0026gt;, V\u0026gt; { private final K key; Sub(K key) { this.key = key; } } } 根据proxyCache变量的复杂调用链，下一步就是调用Sub类的computeIfAbsent方法了，但是Sub类没有computeIfAbsent方法，那么调用的就是父类AbstractClassLoaderValue的computeIfAbsent方法了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public abstract class AbstractClassLoaderValue\u0026lt;CLV extends AbstractClassLoaderValue\u0026lt;CLV, V\u0026gt;, V\u0026gt; { public V computeIfAbsent(ClassLoader cl, BiFunction\u0026lt; ? super ClassLoader, ? super CLV, ? extends V \u0026gt; mappingFunction) throws IllegalStateException { ConcurrentHashMap\u0026lt;CLV, Object\u0026gt; map = map(cl); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) CLV clv = (CLV) this; Memoizer\u0026lt;CLV, V\u0026gt; mv = null; while (true) { Object val = (mv == null) ? map.get(clv) : map.putIfAbsent(clv, mv); if (val == null) { if (mv == null) { // create Memoizer lazily when 1st needed and restart loop mv = new Memoizer\u0026lt;\u0026gt;(cl, clv, mappingFunction); continue; } // mv != null, therefore sv == null was a result of successful // putIfAbsent try { // trigger Memoizer to compute the value V v = mv.get(); // attempt to replace our Memoizer with the value map.replace(clv, mv, v); // return computed value return v; } catch (Throwable t) { // our Memoizer has thrown, attempt to remove it map.remove(clv, mv); // propagate exception because it\u0026#39;s from our Memoizer throw t; } } else { try { return extractValue(val); } catch (Memoizer.RecursiveInvocationException e) { // propagate recursive attempts to calculate the same // value as being calculated at the moment throw e; } catch (Throwable t) { // don\u0026#39;t propagate exceptions thrown from foreign Memoizer - // pretend that there was no entry and retry // (foreign computeIfAbsent invocation will try to remove it anyway) } } // TODO: // Thread.onSpinLoop(); // when available } } } computeIfAbsent方法当中用到了ConcurrentHashMap，这里可以知道应该是支持多线程并发的，computeIfAbsent方法的功能可以解读为：返回与此ClassLoaderValue和给定ClassLoader关联的值，如果不存在，则通过调用给定的mappingFunction来计算该值，将其关联并返回它。\n很明显，map中没有缓存时，创建构造器的核心逻辑落在了在ProxyBuilder类上，继续跟踪ProxyBuilder类，发现它是Proxy的内部类，先看它的成员变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Proxy implements java.io.Serializable { private static final class ProxyBuilder { // 分析1 private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess(); // 分析2：所有代理类名称的前缀 // prefix for all proxy class names private static final String proxyClassNamePrefix = \u0026#34;$Proxy\u0026#34;; // 分析3：用于生成唯一代理类名称的下一个数字 // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); // 分析4：已定义代理类的反向缓存，也就是已经生成代理类的纪录为true // a reverse cache of defined proxy classes private static final ClassLoaderValue\u0026lt;Boolean\u0026gt; reverseProxyCache = new ClassLoaderValue\u0026lt;\u0026gt;(); } } 分析1：创建了JavaLangAccess实例，它是通过SharedSecrets的getJavaLangAccess方法来获取，我寻思既然有getXXX方法，那么也应该有setXXX方法，经过一番搜索，发现JavaLangAccess的setJavaLangAccess方法是在System类的setJavaLangAccess方法中被调用，而System类的setJavaLangAccess方法将通过虚拟机VM来调用。\n1 2 3 4 5 6 7 8 9 10 11 12 private static void setJavaLangAccess() { // Allow privileged classes outside of java.lang SharedSecrets.setJavaLangAccess(new JavaLangAccess() { // 埋下伏笔 public Class\u0026lt;?\u0026gt; defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) { return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source); } // ... }); } 继续跟踪ProxyBuilder类的构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ProxyBuilder(ClassLoader loader, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces) { // 分析2：如果模块系统未初始化，那么代理是不支持的 if (!VM.isModuleSystemInited()) { throw new InternalError(\u0026#34;Proxy is not supported until \u0026#34; + \u0026#34;module system is fully initialized\u0026#34;); } // 分析3：代理接口数量最多只能65535个 if (interfaces.size() \u0026gt; 65535) { throw new IllegalArgumentException(\u0026#34;interface limit exceeded: \u0026#34; + interfaces.size()); } // 分析4：返回代理接口的所有公共非静态方法签名引用的所有类型(返回值类型、共享参数类型，共享异常类型) Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; refTypes = referencedTypes(loader, interfaces); // 分析5：验证给定的代理接口和给定的引用类型对定义加载器可见 // IAE if violates any restrictions specified in newProxyInstance validateProxyInterfaces(loader, interfaces, refTypes); this.interfaces = interfaces; // 分析6：返回生成的代理类所属的模块，有如下规则： // 1、如果任何代理接口是包私有的，则代理类位于包私有接口的同一模块中 // 2、如果所有代理接口都是公共的并且位于导出包中，则代理类位于无条件导出包中的动态模块中 // 3、如果所有代理接口都是公共的，并且至少有一个位于非导出包中，则该代理类位于非导出包中的动态模块中 this.module = mapToModule(loader, interfaces, refTypes); assert getLoader(module) == loader; } // 分析1：如果是单个代理接口的情况，其实也是把接口转换为List，然后调用另一个构造方法 ProxyBuilder(ClassLoader loader, Class\u0026lt;?\u0026gt; intf) { this(loader, Collections.singletonList(intf)); } 由上面代码可知，代理类的生成有着许多限制规则，主要是Java 9引入了模块管理的概念，继续跟踪ProxyBuilder类的build方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 生成一个代理类并返回其代理构造函数，并已设置可访问标志 Constructor\u0026lt;?\u0026gt; build() { // 分析1：定义代理类的Class对象 Class\u0026lt;?\u0026gt; proxyClass = defineProxyClass(module, interfaces); assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Prox final Constructor\u0026lt;?\u0026gt; cons; try { // 分析2：返回代理类的构造器 cons = proxyClass.getConstructor(constructorParams); } catch (NoSuchMethodException e) { throw new InternalError(e.toString(), e); } AccessController.doPrivileged(new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { cons.setAccessible(true); return null; } }); return cons; } 很明显，代理类的生成过程都在defineProxyClass方法当中，继续跟踪。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 private static Class\u0026lt;?\u0026gt; defineProxyClass(Module m, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces) { // 分析1：定义代理类所在的包路径 String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; boolean nonExported = false; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ // 分析2：记录非公共代理接口的包，以便代理类将定义在同一个包中。验证所有非公共代理接口是否位于同一个包中。 for (Class\u0026lt;?\u0026gt; intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { accessFlags = Modifier.FINAL; // non-public, final String pkg = intf.getPackageName(); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( \u0026#34;non-public interfaces from different packages\u0026#34;); } } else { if (!intf.getModule().isExported(intf.getPackageName())) { // module-private types nonExported = true; } } } // 分析3：所有代理接口都是公共和导出的 if (proxyPkg == null) { // all proxy interfaces are public and exported if (!m.isNamed()) throw new InternalError(\u0026#34;ununamed module: \u0026#34; + m); // 如果代理接口所在包名在模块中是不可导出的，那么代理接口包名定义为com.sun.proxy.模块名，否则定义为模块名 proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \u0026#34;.\u0026#34; + m.getName() : m.getName(); } else if (proxyPkg.isEmpty() \u0026amp;\u0026amp; m.isNamed()) { throw new IllegalArgumentException( \u0026#34;Unnamed package cannot be added to \u0026#34; + m); } if (m.isNamed()) { if (!m.getDescriptor().packages().contains(proxyPkg)) { throw new InternalError(proxyPkg + \u0026#34; not exist in \u0026#34; + m.getName()); } } /* * Choose a name for the proxy class to generate. */ // 分析4：选择要生成的代理类的名称 // 计数器+1 long num = nextUniqueNumber.getAndIncrement(); // 如果包名为\u0026#34;\u0026#34;，代理类名字 $Proxy + 计数器数字，否则 包名.$Proxy + 计数器数字 String proxyName = proxyPkg.isEmpty() ? proxyClassNamePrefix + num : proxyPkg + \u0026#34;.\u0026#34; + proxyClassNamePrefix + num; ClassLoader loader = getLoader(m); trace(proxyName, m, loader, interfaces); /* * Generate the specified proxy class. */ // 分析5：生成指定的代理类 // 动态生成代理类字节数组 byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags); try { // 通过代理类字节数组定义代理类Class对象，对于了前面说的System的setJavaLangAccess方法的实现 Class\u0026lt;?\u0026gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile, null, \u0026#34;__dynamic_proxy__\u0026#34;); // 缓存代理类已经生成过的标记true reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE); return pc; } catch (ClassFormatError e) { /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); } } 继续跟踪ProxyGenerator的generateProxyClass方法，看看是如何生成代理类字节数组的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 给定名称和代理接口列表生成代理类 static byte[] generateProxyClass(ClassLoader loader, final String name, List\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; interfaces, int accessFlags) { // 分析1 ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags); final byte[] classFile = gen.generateClassFile(); // 分析2 if (saveGeneratedFiles) { java.security.AccessController.doPrivileged( new java.security.PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { try { int i = name.lastIndexOf(\u0026#39;.\u0026#39;); Path path; if (i \u0026gt; 0) { Path dir = Path.of(dotToSlash(name.substring(0, i))); Files.createDirectories(dir); path = dir.resolve(name.substring(i + 1) + \u0026#34;.class\u0026#34;); } else { path = Path.of(name + \u0026#34;.class\u0026#34;); } Files.write(path, classFile); return null; } catch (IOException e) { throw new InternalError( \u0026#34;I/O exception saving generated file: \u0026#34; + e); } } }); } return classFile; } 分析1：调用了ProxyGenerator的generateClassFile方法来生成代理类的字节数组，跟踪看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 生成代理类的类文件。该方法驱动类文件生成过程 private byte[] generateClassFile() { // 确定代理类的基础信息（类修饰符、类名、父类、实现的接口等等） visit(V14, accessFlags, dotToSlash(className), null, JLR_PROXY, typeNames(interfaces)); /* * Add proxy methods for the hashCode, equals, * and toString methods of java.lang.Object. This is done before * the methods from the proxy interfaces so that the methods from * java.lang.Object take precedence over duplicate methods in the * proxy interfaces. */ // 分析1：将所有方法封装成ProxyMethod对象 // 为java.lang.Object的hashCode、equals和toString方法添加代理方法。这是在代理接口中的方法之前完成的，以便 java.lang.Object 中的方法优先于代理接口中的重复方法。 addProxyMethod(hashCodeMethod); addProxyMethod(equalsMethod); addProxyMethod(toStringMethod); /* * Accumulate all of the methods from the proxy interfaces. */ // 遍历所有代理接口中的所有方法，并生成ProxyMethod对象 for (Class\u0026lt;?\u0026gt; intf : interfaces) { for (Method m : intf.getMethods()) { if (!Modifier.isStatic(m.getModifiers())) { addProxyMethod(m, intf); } } } /* * For each set of proxy methods with the same signature, * verify that the methods\u0026#39; return types are compatible. */ // 对于具有相同签名的每组代理方法，验证方法的返回类型是否兼容 for (List\u0026lt;ProxyMethod\u0026gt; sigmethods : proxyMethods.values()) { checkReturnTypes(sigmethods); } // 分析2：开始生成代理类的构造，方法，成员变量等等 // 生成代理类的构造方法 generateConstructor(); // 遍历ProxyMethod列表 for (List\u0026lt;ProxyMethod\u0026gt; sigmethods : proxyMethods.values()) { for (ProxyMethod pm : sigmethods) { // add static field for the Method object // 为Method对象添加静态字段 visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName, LJLR_METHOD, null, null); // Generate code for proxy method // 生成代理方法的代码 pm.generateMethod(this, className); } } // 生成代理类的静态代码块 generateStaticInitializer(); generateLookupAccessor(); // 第一步：计算 ClassFile 结构的大小（以字节为单位）。 magic 字段使用 4 个字节，10 个强制字段（minor_version、major_version、constant_pool_count、access_flags、this_class、super_class、interfaces_count、fields_count、methods_count 和 attribute_count）每个使用 2 个字节，每个接口也使用 2 个字节。 // 第二步：分配一个正确大小的 ByteVector并用 ClassFile 内容填充它。 // 也就是写入魔数、次版本号、主版本号、常量池等等。 // 第三步：转换为二进制数组输出 return toByteArray(); } 分析2：saveGeneratedFiles是用于保存生成的代理类文件的调试标志，如下所示：\n1 2 3 4 private static final boolean saveGeneratedFiles = java.security.AccessController.doPrivileged( new GetBooleanAction( \u0026#34;jdk.proxy.ProxyGenerator.saveGeneratedFiles\u0026#34;)); AccessController的doPrivileged方法需要传入PrivilegedAction接口，而PrivilegedAction接口中有一个run方法，run方法的返回值即为saveGeneratedFiles，又因为GetBooleanAction实现了PrivilegedAction接口，所以只需跟踪GetBooleanAction的run方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class GetBooleanAction implements java.security.PrivilegedAction\u0026lt;Boolean\u0026gt; { private String theProp; /** * Constructor that takes the name of the system property whose boolean * value needs to be determined. * * @param theProp the name of the system property. */ public GetBooleanAction(String theProp) { this.theProp = theProp; } public Boolean run() { return Boolean.getBoolean(theProp); } } 继续跟踪Boolean的getBoolean方法。\n1 2 3 4 5 6 7 8 public static boolean getBoolean(String name) { boolean result = false; try { result = parseBoolean(System.getProperty(name)); } catch (IllegalArgumentException | NullPointerException e) { } return result; } 很显然，调用了System类的getProperty方法，然后转换为boolean值返回，name其实就是\njdk.proxy.ProxyGenerator.saveGeneratedFiles，那么我们只需要在Proxy类的newProxyInstance方法之前，通过System类的setProperty方法设置该值为true即可保存代理类文件。\n1 2 3 4 5 6 7 8 9 10 public class Client { public static void main(String[] args) { System.setProperty(\u0026#34;jdk.proxy.ProxyGenerator.saveGeneratedFiles\u0026#34;, \u0026#34;true\u0026#34;); Grandfather grandfather = new Grandfather(); Action action = (Action) Proxy.newProxyInstance(Action.class.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{Action.class}, new ActionInvocationHandler(grandfather)); action.recharge(); } } 运行过后，会在如下位置生成代理类，这也是接口都是public修饰时的情况。\n本例中生成的代理类如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public final class $Proxy0 extends Proxy implements Action { private static final Method m0; private static final Method m1; private static final Method m2; private static final Method m3; public $Proxy0(InvocationHandler var1) { super(var1); } public final int hashCode() { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final boolean equals(Object var1) { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final String toString() { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void recharge() { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m0 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;); m1 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m2 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;); m3 = Class.forName(\u0026#34;com.pengmj.proxy.Action\u0026#34;).getMethod(\u0026#34;recharge\u0026#34;); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup var0) throws IllegalAccessException { if (var0.lookupClass() == Proxy.class \u0026amp;\u0026amp; var0.hasFullPrivilegeAccess()) { return MethodHandles.lookup(); } else { throw new IllegalAccessException(var0.toString()); } } } 由上面代码可知：\n1、代理类$Proxy0继承自Proxy类，并实现了我们自己定义的Action接口；\n有一个疑问：问什么JDK动态代理只能基于接口进行代理？\n因为它已经继承了Proxy类了，而Java不支持多继承。\n2、代理类使用了final修饰，说明代理类无法被继承；\n3、接口中所有被代理的方法以及Object类的hashCode、equals、toString方法在static静态代码块中通过反射建立了method对象；\n4、当调用接口中所有被代理的方法以及Object类的hashCode、equals、toString方法时，都会转交给InvocationHandler的invoke方法；\n我们回到之前流程，当创建了代理类的构造器之后，就会调用newProxyInstance方法，继续跟踪看看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private static Object newProxyInstance(Class\u0026lt;?\u0026gt; caller, // null if no SecurityManager Constructor\u0026lt;?\u0026gt; cons, InvocationHandler h) { /* * Invoke its constructor with the designated invocation handler. */ try { if (caller != null) { checkNewProxyPermission(caller, cons.getDeclaringClass()); } return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException | InstantiationException e) { throw new InternalError(e.toString(), e); } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else { throw new InternalError(t.toString(), t); } } } 很明显了，通过构造器直接newInstance创建代理类实例对象，构造方法传入的参数为h。至此，JDK动态代理的原理就讲解完成了。\n六、动态代理在Android上的运用 在Android上，动态代理也隐隐约约地存在着，比如网络请求框架Retrofit，它的create方法就使用了动态代理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { validateServiceInterface(service); return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {service}, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args); } }); } ","date":"2023-08-11T22:39:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBjdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","section":"post","tags":null,"title":"解读JDK动态代理"},{"categories":["Kotlin"],"contents":" 注：本文代码基于Kotlin 1.9.0\n前言 一般而言，Kotlin的协程实现分为两个层次：\n基础设施层：标准库的协程API，主要对协程提供了概念和语义上最基本的支持，API所在包名的前缀为kotlin.coroutines.*。基于此，本文主要内容就是解读Kotlin协程启动源码。\n业务框架层：协程的上层框架支持，API所在包名的前缀为kotlinx.coroutines.*。\n整体上，将通过Kotlin协程的基础设施创建的协程称为简单协程，将基于简单协程实现的各种业务层进行封装之后得到的协程称为复合协程。\n一、协程的创建 在Kotlin当中创建一个简单协程不是什么难事，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) 标准库中提供了一个createCoroutine方法，我们可以通过它来创建协程，不过这个协程并不会立即执行，我们先来看看它的声明:\n1 2 3 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; 这里解释下上面的声明：\n1、suspend ()-\u0026gt;T是createCoroutine方法的Receiver，Receiver是一个被suspend关键字修饰的挂起函数，这也是协程的执行体，我们不妨称它为协程体。这里补充一条Kotlin基础知识：Kotlin扩展的本质就是定义了一个函数，当程序用对象调用扩展方法时，Kotlin在编译过程中会执行静态解析，将调用扩展函数的调用者作为函数的第一个参数传入，也就是说，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，对于本文后面的内容来说，这是一个伏笔，叫它伏笔1吧；\n2、参数completion会在协程执行完成后调用，实际上就是协程的完成回调；\n3、返回值是一个Continuation对象，由于现在协程仅仅被创建出来，因此需要通过这个值在之后触发协程的启动。\n二、协程的启动 调用continuation的resume方法之后，协程体会立即开始执行，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 此时要抛出本文要重点解决的问题：为什么调用continuation.resume(Unit)就会触发协程体的执行呢？\n如果按一般思路去理解，上面代码返回的变量continuation就是问题的突破口，只要找出continuation变量的真身，就能定位到resume方法的具体实现，从而找出触发协程体执行的所在。\nOK，一步步来，我们先看suspend方法的源码：\n1 public inline fun \u0026lt;R\u0026gt; suspend(noinline block: suspend () -\u0026gt; R): suspend () -\u0026gt; R = block suspend方法比较简单，把传入的挂起函数原封不动地返回，但是要注意：suspend方法是一个内联方法，而参数block是非内联的，意味着block在编译后会生成一个函数对象（匿名内部类），这里是埋下伏笔2。\ncreateCoroutine方法的声明我们前面讲过了，现在完整看下createCoroutine方法的源码：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 由源码可知，这里调用了2个参数的构造方法创建了SafeContinuation对象，其中第1个参数先不管，后面会讲到，第2个参数为COROUTINE_SUSPENDED。知道了continuation变量的实例对象是SafeContinuation，也就是说可以推测下，调用continuation变量的resume方法实际上是调用了SafeContinuation的resume方法，继续跟踪SafeContinuation的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal expect class SafeContinuation\u0026lt;in T\u0026gt; : Continuation\u0026lt;T\u0026gt; { internal constructor(delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any?) @PublishedApi internal constructor(delegate: Continuation\u0026lt;T\u0026gt;) @PublishedApi internal fun getOrThrow(): Any? override val context: CoroutineContext override fun resumeWith(result: Result\u0026lt;T\u0026gt;): Unit } public interface Continuation\u0026lt;in T\u0026gt; { public val context: CoroutineContext public fun resumeWith(result: Result\u0026lt;T\u0026gt;) } 通过观察SafeContinuation的源码，可以得到3个结论：\n1、SafeContinuation类是expect关键字修饰，意味着它是一个跨平台类，也就是说不同平台该类有不同的实现。这里先说明，后面我们只看Kotlin平台下的具体实现；\n2、SafeContinuation类实现了接口Continuation；\n3、SafeContinuation类中并没有resume方法，然而我们先前推测过，调用continuation的resume方法实际上是调用了SafeContinuation的resume方法，很显然这是错的。\n看到这里或许已经一头雾水了，但是先不要着急哈，继续寻找突破口，先看下continuation变量的resume方法的源码：\n1 2 public inline fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.resume(value: T): Unit = resumeWith(Result.success(value)) 由源码可知，resume方法是接口Continuation的一个扩展方法，其内部调用了Continuation的resumeWith方法，结合前面说的，SafeContinuation实现了接口Continuation，那么最终调用的就是SafeContinuation的resumeWith方法了。\n但是SafeContinuation是一个跨平台类，要先找到它的具体实现，在Kotlin平台上的具体实现位置为：\nSafeContinuation具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 internal actual class SafeContinuation\u0026lt;in T\u0026gt; internal actual constructor( private val delegate: Continuation\u0026lt;T\u0026gt;, initialResult: Any? ) : Continuation\u0026lt;T\u0026gt;, CoroutineStackFrame { @PublishedApi internal actual constructor(delegate: Continuation\u0026lt;T\u0026gt;) : this(delegate, UNDECIDED) public actual override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { while (true) { // lock-free loop val cur = this.result // atomic read when { cur === UNDECIDED -\u0026gt; if (RESULT.compareAndSet(this, UNDECIDED, result.value)) return cur === COROUTINE_SUSPENDED -\u0026gt; if (RESULT.compareAndSet(this, COROUTINE_SUSPENDED, RESUMED)) { delegate.resumeWith(result) return } else -\u0026gt; throw IllegalStateException(\u0026#34;Already resumed\u0026#34;) } } } } 先前讲过，创建SafeContinuation对象时传入的第2个参数为COROUTINE_SUSPENDED，那么可以知道，SafeContinuation的resumeWith方法执行后实际上调用的是delegate变量的resumeWith方法，于是乎，现在可以从找continuation变量的真身转为找delegate变量的真身了，因为SafeContinuation只是个包装马甲，真正做事情的是delegate变量，那么delegate变量又是什么了？\nSafeContinuation对象被创建是通过调用2个参数的构造方法，其中delegate变量是第1个参数待传入，我们可以回去跟踪下SafeContinuation被创建时的源码：\n1 2 3 4 5 6 7 8 9 10 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) public expect fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; public expect fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; 由源码可知，delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() 而且发现createCoroutineUnintercepted方法和intercepted方法都是跨平台方法，要先找到它们的具体实现，在Kotlin平台上的具体实现位置为：\ncreateCoroutineUnintercepted方法和intercepted方法的具体实现代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) // ① return if (this is BaseContinuationImpl) create(probeCompletion) // ② else createCoroutineFromSuspendFunction(probeCompletion) { // ③ (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } private inline fun \u0026lt;T\u0026gt; createCoroutineFromSuspendFunction( completion: Continuation\u0026lt;T\u0026gt;, crossinline block: (Continuation\u0026lt;T\u0026gt;) -\u0026gt; Any? ): Continuation\u0026lt;Unit\u0026gt; { val context = completion.context // label == 0 when coroutine is not started yet (initially) or label == 1 when it was return if (context === EmptyCoroutineContext) object : RestrictedContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } else object : ContinuationImpl(completion as Continuation\u0026lt;Any?\u0026gt;, context) { private var label = 0 override fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? = when (label) { 0 -\u0026gt; { label = 1 result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith block(this) // run the block, may return or suspend } 1 -\u0026gt; { label = 2 result.getOrThrow() // this is the result if the block had suspended } else -\u0026gt; error(\u0026#34;This coroutine had already completed\u0026#34;) } } } public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this // ④ 这里解释下上面的标号地方：\n标号①、probeCoroutineCreated方法如下：\n1 2 3 internal fun \u0026lt;T\u0026gt; probeCoroutineCreated(completion: Continuation\u0026lt;T\u0026gt;): Continuation\u0026lt;T\u0026gt; { return completion } 代码很简单，就是把传入的completion原封不动的返回。\n标号②、如果suspend () -\u0026gt; T是BaseContinuationImpl的子类，那么调用BaseContinuationImpl类的create方法，并返回Continuation\u0026lt;Unit\u0026gt;，该方法如下：\n1 2 3 4 5 6 7 8 internal abstract class BaseContinuationImpl( public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public open fun create(completion: Continuation\u0026lt;*\u0026gt;): Continuation\u0026lt;Unit\u0026gt; { throw UnsupportedOperationException(\u0026#34;create(Continuation) has not been overridden\u0026#34;) } } BaseContinuationImpl类的create方法默认没有实现，估计是其子类实现了。\n标号③、如果suspend () -\u0026gt; T不是BaseContinuationImpl的子类，那么调用createCoroutineFromSuspendFunction方法，并返回Continuation\u0026lt;Unit\u0026gt;，其方法闭包中会将suspend () -\u0026gt; T强制转换为Function1接口，并调用Function1接口的invoke方法。\n解释下createCoroutineFromSuspendFunction方法的实现：\ncreateCoroutineFromSuspendFunction方法内部会先判断context变量是否为EmptyCoroutineContext对象，如果是的话则返回RestrictedContinuationImpl对象，否则就返回ContinuationImpl对象。\n标号④、将调用Continuation接口扩展方法intercepted的调用者强制转换为ContinuationImpl对象，如果转换成功，则调用ContinuationImpl的intercepted方法，否则返回调用者本身。\nOK，上面分析那么多，发现有2个名字比较显眼：ContinuationImpl和BaseContinuationImpl，可以认为它们和delegate的构建肯定有关系，到这里就不往下看源码了，因为看不懂了，啊哈哈～。\n既然按一般思路去跟踪源码无法定位到问题，那么只能反编译源码了，去看看编译器是否在编译后添加了“魔法”，回顾下先前协程启动的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 val continuation = suspend { val x: Int = 88 123 + x }.createCoroutine(object : Continuation\u0026lt;Int\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;Int\u0026gt;) { println(\u0026#34;$result\u0026#34;) } }) continuation.resume(Unit) 运行过上面代码后，点击IDEA的Tools-\u0026gt;Kotlin-\u0026gt;Show Kotlin ByteCode来查看字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 // ================com/pengmj/kotlincoroutine/SampleKt.class ================= // class version 52.0 (52) // access flags 0x31 public final class com/pengmj/kotlincoroutine/SampleKt { // access flags 0x19 public final static main()V L0 LINENUMBER 6 L0 L1 LINENUMBER 9 L1 L2 LINENUMBER 6 L2 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ACONST_NULL INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V CHECKCAST kotlin/jvm/functions/Function1 ASTORE 1 L3 ALOAD 1 L4 LINENUMBER 9 L4 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 DUP INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.\u0026lt;init\u0026gt; ()V CHECKCAST kotlin/coroutines/Continuation INVOKESTATIC kotlin/coroutines/ContinuationKt.createCoroutine (Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; L5 LINENUMBER 6 L5 ASTORE 0 L6 LINENUMBER 17 L6 ALOAD 0 ASTORE 1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; ASTORE 2 L7 ALOAD 1 GETSTATIC kotlin/Result.Companion : Lkotlin/Result$Companion; POP ALOAD 2 INVOKESTATIC kotlin/Result.constructor-impl (Ljava/lang/Object;)Ljava/lang/Object; L8 INVOKEINTERFACE kotlin/coroutines/Continuation.resumeWith (Ljava/lang/Object;)V (itf) L9 LINENUMBER 18 L9 RETURN L10 LOCALVARIABLE continuation Lkotlin/coroutines/Continuation; L6 L10 0 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x1009 public static synthetic main([Ljava/lang/String;)V INVOKESTATIC com/pengmj/kotlincoroutine/SampleKt.main ()V RETURN MAXSTACK = 0 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=2, d1={\u0026#34;\\u0000\\u0008\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001\\u00a8\\u0006\\u0002\u0026#34;}, d2={\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.class ================= // class version 52.0 (52) // access flags 0x30 // signature Lkotlin/coroutines/jvm/internal/SuspendLambda;Lkotlin/jvm/functions/Function1\u0026lt;Lkotlin/coroutines/Continuation\u0026lt;-Ljava/lang/Integer;\u0026gt;;Ljava/lang/Object;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin.coroutines.jvm.internal.SuspendLambda implements kotlin.jvm.functions.Function1\u0026lt;kotlin.coroutines.Continuation\u0026lt;? super java.lang.Integer\u0026gt;, java.lang.Object\u0026gt; final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { // access flags 0x11 public final invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object; @Lorg/jetbrains/annotations/Nullable;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 INVOKESTATIC kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED ()Ljava/lang/Object; L0 LINENUMBER 6 L0 ASTORE 3 ALOAD 0 GETFIELD com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.label : I TABLESWITCH 0: L1 default: L2 L1 ALOAD 1 INVOKESTATIC kotlin/ResultKt.throwOnFailure (Ljava/lang/Object;)V L3 LINENUMBER 7 L3 BIPUSH 88 ISTORE 2 L4 LINENUMBER 8 L4 BIPUSH 123 ILOAD 2 IADD INVOKESTATIC kotlin/coroutines/jvm/internal/Boxing.boxInt (I)Ljava/lang/Integer; L5 ARETURN L2 LINENUMBER 6 L2 NEW java/lang/IllegalStateException DUP LDC \u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34; INVOKESPECIAL java/lang/IllegalStateException.\u0026lt;init\u0026gt; (Ljava/lang/String;)V ATHROW LOCALVARIABLE x I L4 L5 2 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$1; L3 L2 0 LOCALVARIABLE $result Ljava/lang/Object; L3 L2 1 MAXSTACK = 3 MAXLOCALS = 4 @Lkotlin/coroutines/jvm/internal/DebugMetadata;(f=\u0026#34;sample.kt\u0026#34;, l={}, i={}, s={}, n={}, m=\u0026#34;invokeSuspend\u0026#34;, c=\u0026#34;com.pengmj.kotlincoroutine.SampleKt$main$continuation$1\u0026#34;) // access flags 0x0 \u0026lt;init\u0026gt;(Lkotlin/coroutines/Continuation;)V ALOAD 0 ICONST_1 ALOAD 1 INVOKESPECIAL kotlin/coroutines/jvm/internal/SuspendLambda.\u0026lt;init\u0026gt; (ILkotlin/coroutines/Continuation;)V RETURN MAXSTACK = 3 MAXLOCALS = 2 // access flags 0x0 I label // access flags 0x11 // signature (Lkotlin/coroutines/Continuation\u0026lt;*\u0026gt;;)Lkotlin/coroutines/Continuation\u0026lt;Lkotlin/Unit;\u0026gt;; // declaration: kotlin.coroutines.Continuation\u0026lt;kotlin.Unit\u0026gt; create(kotlin.coroutines.Continuation\u0026lt;?\u0026gt;) public final create(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; @Lorg/jetbrains/annotations/NotNull;() // invisible // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 ALOAD 1 LDC \u0026#34;completion\u0026#34; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullParameter (Ljava/lang/Object;Ljava/lang/String;)V NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 DUP ALOAD 1 INVOKESPECIAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.\u0026lt;init\u0026gt; (Lkotlin/coroutines/Continuation;)V ASTORE 2 ALOAD 2 ARETURN L1 LOCALVARIABLE this Lkotlin/coroutines/jvm/internal/BaseContinuationImpl; L0 L1 0 LOCALVARIABLE completion Lkotlin/coroutines/Continuation; L0 L1 1 MAXSTACK = 3 MAXLOCALS = 3 // access flags 0x11 public final invoke(Ljava/lang/Object;)Ljava/lang/Object; ALOAD 0 ALOAD 1 CHECKCAST kotlin/coroutines/Continuation INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.create (Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation; CHECKCAST com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 GETSTATIC kotlin/Unit.INSTANCE : Lkotlin/Unit; INVOKEVIRTUAL com/pengmj/kotlincoroutine/SampleKt$main$continuation$1.invokeSuspend (Ljava/lang/Object;)Ljava/lang/Object; ARETURN MAXSTACK = 2 MAXLOCALS = 2 @Lkotlin/Metadata;(mv={1, 9, 0}, k=3, d1={\u0026#34;\\u0000\\n\\n\\u0000\\n\\u0002\\u0010\\u0008\\n\\u0002\\u0008\\u0002\\u0010\\u0000\\u001a\\u00020\\u0001H\\u008a@\\u00a2\\u0006\\u0004\\u0008\\u0002\\u0010\\u0003\u0026#34;}, d2={\u0026#34;\u0026lt;anonymous\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;invoke\u0026#34;, \u0026#34;(Ljava/lang/Object;)Ljava/lang/Object;\u0026#34;}) OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x18 final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 null null // compiled from: sample.kt } // ================com/pengmj/kotlincoroutine/SampleKt$main$continuation$2.class ================= // class version 52.0 (52) // access flags 0x31 // signature Ljava/lang/Object;Lkotlin/coroutines/Continuation\u0026lt;Ljava/lang/Integer;\u0026gt;; // declaration: com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin.coroutines.Continuation\u0026lt;java.lang.Integer\u0026gt; public final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 implements kotlin/coroutines/Continuation { OUTERCLASS com/pengmj/kotlincoroutine/SampleKt main ()V // access flags 0x1 public getContext()Lkotlin/coroutines/CoroutineContext; @Lorg/jetbrains/annotations/NotNull;() // invisible L0 LINENUMBER 11 L0 GETSTATIC kotlin/coroutines/EmptyCoroutineContext.INSTANCE : Lkotlin/coroutines/EmptyCoroutineContext; CHECKCAST kotlin/coroutines/CoroutineContext ARETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x1 public resumeWith(Ljava/lang/Object;)V // annotable parameter count: 1 (visible) // annotable parameter count: 1 (invisible) @Lorg/jetbrains/annotations/NotNull;() // invisible, parameter 0 L0 LINENUMBER 14 L0 ALOAD 1 INVOKESTATIC kotlin/Result.toString-impl (Ljava/lang/Object;)Ljava/lang/String; ASTORE 2 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L2 L3 LINENUMBER 15 L3 RETURN L4 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L4 0 LOCALVARIABLE result Ljava/lang/Object; L0 L4 1 MAXSTACK = 2 MAXLOCALS = 3 // access flags 0x0 \u0026lt;init\u0026gt;()V L0 LINENUMBER 9 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this Lcom/pengmj/kotlincoroutine/SampleKt$main$continuation$2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 @Lkotlin/Metadata;(mv={1, 9, 0}, k=1, d1={\u0026#34;\\u0000%\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\u0008\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0003\\n\\u0002\\u0010\\u0002\\n\\u0000\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0008\\u0002*\\u0001\\u0000\\u0008\\n\\u0018\\u00002\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\u0001J\\u001e\\u0010\\u0007\\u001a\\u00020\\u00082\\u000c\\u0010\\u0009\\u001a\\u0008\\u0012\\u0004\\u0012\\u00020\\u00020\\nH\\u0016\\u00f8\\u0001\\u0000\\u00a2\\u0006\\u0002\\u0010\\u000bR\\u0014\\u0010\\u0003\\u001a\\u00020\\u00048VX\\u0096\\u0004\\u00a2\\u0006\\u0006\\u001a\\u0004\\u0008\\u0005\\u0010\\u0006\\u0082\\u0002\\u0004\\n\\u0002\\u0008\\u0019\\u00a8\\u0006\\u000c\u0026#34;}, d2={\u0026#34;com/pengmj/kotlincoroutine/SampleKt$main$continuation$2\u0026#34;, \u0026#34;Lkotlin/coroutines/Continuation;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;context\u0026#34;, \u0026#34;Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;getContext\u0026#34;, \u0026#34;()Lkotlin/coroutines/CoroutineContext;\u0026#34;, \u0026#34;resumeWith\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;result\u0026#34;, \u0026#34;Lkotlin/Result;\u0026#34;, \u0026#34;(Ljava/lang/Object;)V\u0026#34;, \u0026#34;Kotlin\u0026#34;}) // access flags 0x19 public final static INNERCLASS com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 null null // compiled from: sample.kt } // ================META-INF/Kotlin.kotlin_module ================= \u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0000\u0000 \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000 \u0026amp; \u001acom.pengmj.kotlincoroutine\u0012\u0008SampleKt\u0026#34;\u0000*\u0000 在上面一大片字节码中，我们着重看这几行：\n1 2 3 4 5 6 7 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 NEW com/pengmj/kotlincoroutine/SampleKt$main$continuation$2 final class com/pengmj/kotlincoroutine/SampleKt$main$continuation$1 extends kotlin/coroutines/jvm/internal/SuspendLambda implements kotlin/jvm/functions/Function1 { } 由上面字节码可知：\n编译器帮我们创建了2个匿名内部类SampleKt$main$continuation$1和SampleKt$main$continuation$2，它们的类名是\u0026lt;FileName\u0026gt;Kt$\u0026lt;FunctionName\u0026gt;$continuation$1这样的形式，其中\u0026lt;FileName\u0026gt;和\u0026lt;FunctionName\u0026gt;指代的是代码所在的文件名和函数名。\n这里会有个疑问：这些匿名内部类是哪来的？\n第一个匿名内部类SampleKt$main$continuation$1，它就是我们的协程体，那个用以创建协程的suspend方法传入的Lambda表达式，即suspend ()-\u0026gt;R，也对应了前面说过的埋下伏笔2；\n并且SampleKt$main$continuation$1继承了抽象类SuspendLambda，还实现了Function1接口，继续追踪SuspendLambda时，发现它间接实现了Continuation接口，与先前提到的ContinuationImpl、BaseContinuationImpl存在继承关系，如下图所示：\n第二个匿名内部类SampleKt$main$continuation$2，从它的字节码中可以看出它有getContext方法、resumeWith方法以及无参构造方法，可以猜到它就是createCoroutine方法传入的对象表达式，学过Kotlin基础的应该明白，对象表达式其实是增强版的匿名内部类。\n到目前为止还看不出什么，还需要把字节码再转译一下，点击Kotlin ByteCode面板上的Decompile按钮，转译后的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } }); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { // ① @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } // $FF: synthetic method public static void main(String[] var0) { main(); } } 这里解释下上面的标号地方：\n标号①、调用了ContinuationKt的createCoroutine方法，第一个参数传入var1变量，而var1变量的类型是Function1，对应的Koltin实际代码为：\n1 2 3 4 public fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutine( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; = SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED) 前面提过埋下伏笔1，suspend ()-\u0026gt;T会作为createCoroutine方法的第一个参数传入，此时可以推断出，这里的var1就是第一个匿名内部类SampleKt$main$continuation$1的实例；createCoroutine方法第二个参数则是completion回调，也是前面说的第二个匿名内部类SampleKt$main$continuation$2。\n标号②、还记得前面说的createCoroutineUnintercepted方法和intercepted方法的具体实现吗？\n1 2 3 4 5 6 7 8 9 10 11 public actual fun \u0026lt;T\u0026gt; (suspend () -\u0026gt; T).createCoroutineUnintercepted( completion: Continuation\u0026lt;T\u0026gt; ): Continuation\u0026lt;Unit\u0026gt; { val probeCompletion = probeCoroutineCreated(completion) return if (this is BaseContinuationImpl) create(probeCompletion) // ① else createCoroutineFromSuspendFunction(probeCompletion) { (this as Function1\u0026lt;Continuation\u0026lt;T\u0026gt;, Any?\u0026gt;).invoke(it) } } 因为SampleKt$main$continuation$1是BaseContinuationImpl的子类，所以会执行上面①处的create方法，此处调用的是BaseContinuationImpl类的create方法，但是BaseContinuationImpl类中没有具体实现create方法，所以由子类SampleKt$main$continuation$1来实现，如下代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { @NotNull public final Continuation create(@NotNull Continuation completion) { // ② Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new \u0026lt;anonymous constructor\u0026gt;(completion); return var2; } }); } 发现在create方法中又创建了一个匿名内部类对象var2，类型为Function1，那么可以知道createCoroutineUnintercepted方法返回的就是新的SampleKt$main$continuation$1对象。\n有一个疑问：var2和外部new Function1创建的匿名内部类对象var1有什么区别和关联呢？\n先声明下，从Kotlin代码反编译而来的Java代码可能会出现不符合Java代码执行逻辑的情况。外部创建的匿名内部类对象var1主要是用来帮助启动协程，因此completion传入为null；而create方法中创建的匿名内部类对象var2主要是用来管理协程的状态。\n如果你看到本文的后续内容后，可能会回过头来问，为什么var2可以调用var1中的invokeSuspend方法，它们不是两个不同的对象吗？\n是的，没错，它们的确是两个不同的对象，但是因为反编译后的源码不一定能准确的表达完整Java代码执行逻辑，这里我再手动转译一下，应该就能看明白了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public final class SampleKt { final class SampleKt$main$continuation$1 extends SuspendLambda implements Function1 { public SampleKt$main$continuation$1(Continuation completion){ super(completion) } int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } @NotNull public final Continuation create(@NotNull Continuation completion) { Intrinsics.checkNotNullParameter(completion, \u0026#34;completion\u0026#34;); Function1 var2 = new SampleKt$main$continuation$1(completion); return var2; } public final Object invoke(Object var1) { return ((\u0026lt;undefinedtype\u0026gt;)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE); } } public static final void main() { SampleKt$main$continuation$1 var1 = new SampleKt$main$continuation$1(null); Continuation continuation = ContinuationKt.createCoroutine(var1, (Continuation)(new Continuation() { @NotNull public CoroutineContext getContext() { return (CoroutineContext)EmptyCoroutineContext.INSTANCE; } public void resumeWith(@NotNull Object result) { String var2 = Result.toString-impl(result); System.out.println(var2); } })); Unit var2 = Unit.INSTANCE; Result.Companion var10001 = Result.Companion; continuation.resumeWith(Result.constructor-impl(var2)); } } 还记得我们最初的那个任务吗？就是找到delegate变量的真身，我们已经知道delegate变量就是这么长的一串东西：\n1 createCoroutineUnintercepted(completion).intercepted() createCoroutineUnintercepted方法已经分析了，返回的就是新的SampleKt$main$continuation$1对象，那么继续看intercepted方法：\n1 2 public actual fun \u0026lt;T\u0026gt; Continuation\u0026lt;T\u0026gt;.intercepted(): Continuation\u0026lt;T\u0026gt; = (this as? ContinuationImpl)?.intercepted() ?: this 很明显，SampleKt$main$continuation$1也是ContinuationImpl的子类，因而这里调用了ContinuationImpl的intercepted方法：\n1 2 3 4 5 6 7 8 9 10 internal abstract class ContinuationImpl( completion: Continuation\u0026lt;Any?\u0026gt;?, private val _context: CoroutineContext? ) : BaseContinuationImpl(completion) { public fun intercepted(): Continuation\u0026lt;Any?\u0026gt; = intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this) .also { intercepted = it } } 上面代码说明如果设置了协程的拦截器，那么就从上下文中去找，如果上下文中也没有，则用自身SampleKt$main$continuation$1，最后赋值。很显然，本例是没有设置协程的拦截器，那么intercepted方法返回的就是SampleKt$main$continuation$1，所以delegate变量的真身就是SampleKt$main$continuation$1。\n接下来看看delegate变量调用了resumeWith方法的流程，因为SampleKt$main$continuation$1中没有resumeWith方法，再根据继承关系，我们看BaseContinuationImpl类的resumeWith方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal abstract class BaseContinuationImpl( // This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet // it has a public getter (since even untrusted code is allowed to inspect its call stack). public val completion: Continuation\u0026lt;Any?\u0026gt;? ) : Continuation\u0026lt;Any?\u0026gt;, CoroutineStackFrame, Serializable { public final override fun resumeWith(result: Result\u0026lt;Any?\u0026gt;) { // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume var current = this var param = result while (true) { // Invoke \u0026#34;resume\u0026#34; debug probe on every resumed continuation, so that a debugging library infrastructure // can precisely track what part of suspended callstack was already resumed probeCoroutineResumed(current) with(current) { val completion = completion!! // fail fast when trying to resume continuation without completion val outcome: Result\u0026lt;Any?\u0026gt; = try { val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) } catch (exception: Throwable) { Result.failure(exception) } releaseIntercepted() // this state machine instance is terminating if (completion is BaseContinuationImpl) { // unrolling recursion via loop current = completion param = outcome } else { // top-level completion reached -- invoke and return completion.resumeWith(outcome) return } } } } protected abstract fun invokeSuspend(result: Result\u0026lt;Any?\u0026gt;): Any? } 上面代码的重点是调用了invokeSuspend方法，这是个抽象方法，由子类SampleKt$main$continuation$1实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Metadata( mv = {1, 9, 0}, k = 2, d1 = {\u0026#34;\\u0000\\b\\n\\u0000\\n\\u0002\\u0010\\u0002\\n\\u0000\\u001a\\u0006\\u0010\\u0000\\u001a\\u00020\\u0001¨\\u0006\\u0002\u0026#34;}, d2 = {\u0026#34;main\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Kotlin\u0026#34;} ) public final class SampleKt { public static final void main() { Function1 var1 = (Function1)(new Function1((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object var1) { Object var3 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) { case 0: ResultKt.throwOnFailure(var1); int x = 88; return Boxing.boxInt(123 + x); default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } } } } 这里invokeSuspend方法通过状态机来执行协程体中的逻辑，最终返回处理结果Boxing.boxInt(123 + x)，很显然，invokeSuspend方法其实就是suspend {}闭包中的处理逻辑。\n回到BaseContinuationImpl类的resumeWith方法，看下这2行代码：\n1 2 val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return 如果invokeSuspend方法返回值是挂起状态COROUTINE_SUSPENDED，则resumeWith方法直接退出，否则就通过调用completion.resumeWith(outcome)传递给外部。\n至此，协程启动流程就讲解完成了。\n","date":"2023-07-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/%E8%A7%A3%E8%AF%BBkotlin%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81/","section":"post","tags":null,"title":"解读Kotlin协程启动源码"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 事件分发机制是View体系中一个非常重要的核心知识点，也是难点，不少Android开发者搞了几年的Android，或许也还没完全弄明白它的原理。\n另外，在Android开发过程中难免会碰到滑动冲突的场景，而解决滑动冲突的理论基础就是事件分发机制，因此掌握事件分发机制十分必要。\n接下来，本文会先从实践的角度总结出结论，然后从源码的角度去看事件分发的过程，最后利用前面所学知识去演示如何解决开发中常见的滑动冲突。\n二、从实践的角度总结出结论 2.1、实践前的理论知识 事件分发主要涉及3个方法，代码如下：\n1 2 3 4 5 6 7 8 // Activity、ViewGroup、View都有提供该方法，该方法的作用：事件的分发 public boolean dispatchTouchEvent(MotionEvent event) // 仅ViewGroup提供该方法，该方法的作用：事件的拦截 public boolean onInterceptTouchEvent(MotionEvent ev) // Activity、View都有提供该方法，该方法的作用：事件的处理 public boolean onTouchEvent(MotionEvent event) 这3个方法有2个共同点，第一个共同点就是都有一个入参MotionEvent，它表示当用户触摸屏幕时所进行的每一次交互（每一次交互指的是手指在UI控件上从按下、滑动再到抬起的过程），都会产生一次同一序列的触摸事件，这些触摸事件被封装进了MotionEvent类里，通过以下方法可以获取触摸事件的类型，代码如下：\n1 val action = ev?.action 在事件分发过程中，常用的触摸事件类型有以下4种：\nACTION_DOWN：表示手指按下的事件。\nACTION_MOVE：表示手指移动的事件。\nACTION_UP：表示手指抬起的事件。\nACTION_CANCEL：表示当前触摸事件已终止。\n第二个共同点是都需要返回boolean类型的返回值，关于返回值的作用是什么后面会讲到。\n那么，事件分发中这3个方法之间有什么关系呢？\n它们之间的关系可以用以下伪代码来表示：\n1 2 3 4 5 6 7 8 9 public boolean dispatchTouchEvent(MotionEvent ev) { boolean result = false; if (onInterceptTouchEvent(ev)) { result = onTouchEvent(ev); } else { result = child.dispatchTouchEvent(ev); } return result; } 通过伪代码，先大致了解下触摸事件的传递规则：对于一个根ViewGroup来说，触摸事件产生后，首先会传递给它，这时它的dispatchTouchEvent方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。\n2.2、实践开始 开始前，我们先编写一个UI界面，本文之后的讲解都是基于该UI界面的层次结构，UI界面运行后的效果如下：\n从运行效果图可以知道，该UI界面内部嵌套了一个紫色的MyViewGroup2控件、一个绿色的MyViewGroup1控件以及一个黑色的MyView控件，布局文件代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup2 android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;@color/purple_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyViewGroup1 android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.pengmj.androideventdispatch.MyView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;@color/black\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup1\u0026gt; \u0026lt;/com.pengmj.androideventdispatch.MyViewGroup2\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 其中MyViewGroup2控件和MyViewGroup1控件的实现是一样的，都是继承自ConstraintLayout，以MyViewGroup2为例，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyViewGroup2 : ConstraintLayout { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 而MyView继承自View，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MyView : View { constructor(context: Context?) : super(context) constructor( context: Context?, attrs: AttributeSet? ) : super(context, attrs) constructor( context: Context?, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) } 最后，MainActivity的代码如下：\n1 2 3 4 5 6 7 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } 之前介绍事件分发的相关方法时，代码注释里有描述过，在Activity、ViewGroup、View中都有dispatchTouchEvent方法，在Activity、View中都有onTouchEvent方法，对于ViewGroup而言，则多了一个onInterceptTouchEvent方法。\n因此，本文先讲解不包含onInterceptTouchEvent方法时的事件分发过程，然后再讲解包含onInterceptTouchEvent方法时的事件分发过程。\n2.2.1、ACTION_DOWN的事件分发过程（不包含onInterceptTouchEvent方法的情况） 既然先讨论的是不包含onInterceptTouchEvent方法的情况，那么只需将MainActivity、MyViewGroup2、MyViewGroup1、MyView都重写dispatchTouchEvent方法和onTouchEvent方法，为了验证在这种情况下的ACTION_DOWN事件分发过程，都打上日志进行观察，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return super.onTouchEvent(event) } 为什么要加上if (LOG_ACTION_DOWN)判断条件呢？这是一个开关，用于日志过滤，方便观察。本文所有源码将在文末贴出。\n2.2.1.1、在dispatchTouchEvent方法中拦截ACTION_DOWN事件 在dispatchTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道dispatchTouchEvent方法需要返回boolean类型的返回值，它的返回值有3种情况：\n情况一：返回super.dispatchTouchEvent dispatchTouchEvent方法默认返回super.dispatchTouchEvent，表示不拦截任何事件，它是View体系中默认的事件分发过程。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n情况二：返回true 在dispatchTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.dispatchTouchEvent(ev) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true之后，ACTION_DOWN事件就会直接停止传递，后面的子控件都不会接收到这个事件。\n情况三：返回false 和之前返回true的情况一样，这里返回false的情况也有两种方式拦截ACTION_DOWN事件，并且两种情况下的表现对于ACTION_DOWN事件来说是没区别的，最终打印结果是一样的，所以这里演示的是仅拦截ACTION_DOWN事件。\n在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return false } } return super.dispatchTouchEvent(ev) } 运行起来后，点击MyView控件时，日志打印如下：\n1 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup2的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyViewGroup1的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回false 修改MyView的dispatchTouchEvent方法的代码为同上述MainActivity。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回false拦截事件之后，事件并不会直接停止传递，而是向父控件的onTouchEvent方法回传。\n2.2.1.2、在onTouchEvent方法中拦截ACTION_DOWN事件 在onTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和View体系中默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面的结论也是针对情况二来讲。\n在onTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论在哪个控件的onTouchEvent方法中拦截ACTION_DOWN事件并返回true，事件都会直接停止传递，后面的父控件都不会接收到这个事件。\n2.2.2、ACTION_DOWN的事件分发过程（包含onInterceptTouchEvent方法的情况） 在onInterceptTouchEvent方法中拦截ACTION_DOWN事件之前，我们需要知道onInterceptTouchEvent方法需要返回boolean类型的返回值，它有3种情况：\n情况一：返回super.onInterceptTouchEvent\n情况二：返回true\n情况三：返回false\n其中，情况一和情况三都表示不拦截ACTION_DOWN事件，所以它们的事件分发过程和默认的事件分发过程是一毛一样的，所以这里只分析情况二，下面结论也是针对情况二来讲。\n在onInterceptTouchEvent方法中拦截ACTION_DOWN事件有两种方式：一是仅拦截ACTION_DOWN事件；二是拦截所有事件，这样也就包括了ACTION_DOWN事件。\n仅拦截ACTION_DOWN事件的代码如下：\n1 2 3 4 5 6 7 8 9 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 拦截所有事件的代码如下：\n1 2 3 4 5 6 7 8 override fun onInterceptTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } } return true } 两种拦截ACTION_DOWN事件的方式有什么区别呢？\n对于ACTION_DOWN事件来说没区别，最终打印结果是一样的，所以本文接下来采用仅拦截ACTION_DOWN事件的方式。\n在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onInterceptTouchEvent方法为上面所说的仅拦截ACTION_DOWN事件的代码。\n运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n若在ViewGroup的onInterceptTouchEvent方法中拦截ACTION_DOWN事件，只会改变ACTION_DOWN事件的正常流向，事件会直接流向自己的onTouchEvent方法中，并不会截断事件。\n2.2.3、多个方法拦截的情况 一般我们在拦截事件时，都是共同使用onInterceptTouchEvent方法和onTouchEvent方法的，通过在onInterceptTouchEvent方法中返回true，将ACTION_DOWN消息流向自己的onTouchEvent方法中，然后在该onTouchEvent方法中返回true拦截事件。\n下面以MyViewGroup1为例，在MyViewGroup1的onInterceptTouchEvent方法中拦截ACTION_DOWN事件并返回true，在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true。\n修改MyViewGroup1的onInterceptTouchEvent方法和onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true; } } return super.onTouchEvent(event) } 运行起来后，点击MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN ACTION_DOWN事件分发过程如下图所示：\n2.2.4、ACTION_MOVE和ACTION_UP的事件分发过程 ACTION_MOVE和ACTION_UP事件的分发过程与之前所讲的ACTION_DOWN事件并不是完全一样的，为了对比两者，我会用黑色箭头表示ACTION_DOWN的事件分发过程，用红色箭头合并表示ACTION_MOVE和ACTION_UP的事件分发过程，为什么两者都用红色箭头表示呢？这是因为ACTION_MOVE和ACTION_UP的事件流向是完全相同的，后面都以ACTION_MOVE事件来讲解。\n2.2.4.1、ACTION_MOVE默认的事件分发过程 ACTION_MOVE默认的事件分发过程，和之前所讲的ACTION_DOWN事件默认的事件分发过程是一样的，也就是所有的事件分发方法都不做拦截处理。\n修改MainActivity、MyView的dispatchTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 修改MyViewGroup2、MyViewGroup1的dispatchTouchEvent方法、onInterceptTouchEvent方法、onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_INTERCEPT_TOUCH_EVENT \u0026amp;\u0026amp; LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onInterceptTouchEvent(ev) } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(event) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.2、在dispatchTouchEvent方法中拦截ACTION_MOVE事件 按照之前在dispatchTouchEvent方法中拦截ACTION_DOWN事件的写法，同样地，在dispatchTouchEvent方法中拦截ACTION_MOVE事件，比如说修改MyViewGroup2的dispatchTouchEvent方法，你可能会写下如下代码：\n1 2 3 4 5 6 7 8 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } } return super.dispatchTouchEvent(ev) 然而代码运行后，发现并不能如愿地看到想要的ACTION_MOVE日志，也就是说代码没有起作用，这是因为ACTION_MOVE事件根本就不会流到MyViewGroup2的dispatchTouchEvent方法中，前面讲过，默认情况下，ACTION_MOVE事件的流向是从MainActivity的dispatchTouchEvent方法直接到MainActivity的onTouchEvent方法。\n那如何让ACTION_MOVE事件继续往子控件流向呢？\n解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。其中前一种方式与后两种方式对于ACTION_MOVE事件的流向，它们的表现形式是不一样的；后两种方式对于ACTION_MOVE事件来说没区别，最终打印结果是一样的，所以本文后面会介绍第一种方式和第三种方式。\n2.2.4.2.1、仅拦截ACTION_DOWN事件 在MainActivity的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.dispatchTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。\n2.2.4.2.2、拦截所有事件 在MainActivity的dispatchTouchEvent方法中拦截所有事件并返回true 修改MainActivity的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的dispatchTouchEvent方法中拦截所有事件并返回true 修改MyView的dispatchTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n在dispatchTouchEvent方法中返回true拦截事件之后，ACTION_MOVE事件的流向与ACTION_DOWN事件的完全相同，事件会直接停止传递，后面的子控件都不会接收到这个事件。\n2.2.4.3、在onTouchEvent方法中拦截ACTION_MOVE事件 和在dispatchTouchEvent方法中拦截ACTION_MOVE事件相似，对于希望在onTouchEvent方法中拦截ACTION_MOVE事件，解决办法有3种：仅拦截ACTION_DOWN事件、同时拦截ACTION_DOWN事件和ACTION_MOVE事件、拦截所有事件。又因为这里只有仅拦截ACTION_DOWN事件和拦截所有事件的表现是不一样的，所以本文只会演示这2种。\n2.2.4.3.1、仅拦截ACTION_DOWN事件 在MainActivity的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun onTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { if (LOG_ACTION_DOWN) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) return true } MotionEvent.ACTION_MOVE -\u0026gt; { if (LOG_ACTION_MOVE) Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return super.onTouchEvent(ev) } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截ACTION_DOWN事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n此处结论同2.2.4.2.1小节。\n2.2.4.3.2、拦截所有事件 在MainActivity的onTouchEvent方法中拦截所有事件并返回true 修改MainActivity的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MainActivity: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup2的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup2的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyViewGroup1的onTouchEvent方法中拦截所有事件并返回true 修改MyViewGroup1的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n在MyView的onTouchEvent方法中拦截所有事件并返回true 修改MyView的onTouchEvent方法为同上面MainActivity代码。\n运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyView: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyView: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n通过对日志的观察，不难看出规律，可以得出结论：\n无论ACTION_DOWN消息的流向是怎样的，只要最终流到onTouchEvent函数中就行。假设控件A最终在onTouchEvent函数中消费了ACTION_DOWN消息，那么ACTION_MOVE消息的流向就是先流到控件A的dispatchTouchEvent函数中，最终直接流到控件A的onTouchEvent函数中，进而消息停止传递。\n2.2.4.4、多个方法拦截的情况 注：下面演示都是拦截所有事件\n2.2.4.4.1、组合dispatchTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyView的dispatchTouchEvent方法中返回false，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyView的dispatchTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;dispatchTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return false } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.2、组合onInterceptTouchEvent方法和onTouchEvent方法拦截ACTION_MOVE事件 在MyViewGroup1的onInterceptTouchEvent方法中返回true，而在MyViewGroup2的onTouchEvent方法中返回true拦截ACTION_MOVE事件。\n修改MyViewGroup1的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 修改MyViewGroup2的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onTouchEvent -\u0026gt; ACTION_MOVE ACTION_MOVE事件分发过程如下图所示：\n2.2.4.4.3、一种特殊情况 在MyViewGroup2的onInterceptTouchEvent方法中拦截ACTION_MOVE事件返回true，而在MyView的onTouchEvent方法中返回true*。\n修改MyViewGroup2的onInterceptTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) return true } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return super.onInterceptTouchEvent(ev) } 修改MyView的onTouchEvent方法为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_DOWN\u0026#34;) } MotionEvent.ACTION_MOVE -\u0026gt; { Log.e(TAG, \u0026#34;onTouchEvent -\u0026gt; ACTION_MOVE\u0026#34;) } MotionEvent.ACTION_CANCEL -\u0026gt; { Log.e(TAG, \u0026#34;onInterceptTouchEvent -\u0026gt; ACTION_CANCEL\u0026#34;) } } return true } 运行起来后，触摸MyView控件时，日志打印如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_DOWN E/MyView: dispatchTouchEvent -\u0026gt; ACTION_DOWN E/MyView: onTouchEvent -\u0026gt; ACTION_DOWN E/MainActivity: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: dispatchTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup2: onInterceptTouchEvent -\u0026gt; ACTION_MOVE E/MyViewGroup1: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyViewGroup1: onInterceptTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: dispatchTouchEvent -\u0026gt; ACTION_CANCEL E/MyView: onTouchEvent -\u0026gt; ACTION_CANCEL ACTION_MOVE事件分发过程如下图所示：\n本来ACTION_MOVE事件依然会从MainActivity的dispatchTouchEvent方法流向子控件，但是在到达MyViewGroup2的onInterceptTouchEvent方法时，ACTION_MOVE事件被拦截了。到这里，这次的ACTION_MOVE事件就没有了，变成了ACTION_CANCEL事件继续向子控件传递，一直传递到ACTION_MOVE事件原本要传递的位置，通知所有被截断的子控件，它们的事件取消了，后面没有事件再传递过来。\n三、从源码的角度去看事件分发的过程 3.1、Activity的事件分发过程 当用户触摸屏幕的时候，触摸事件就会传递给当前的Activity，由Activity的dispatchTouchEvent方法进行事件分发，所以先从该方法进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // android.app.Activity public boolean dispatchTouchEvent(MotionEvent ev) { // 分析1 if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } // 分析2 if (getWindow().superDispatchTouchEvent(ev)) { return true; } // 分析3 return onTouchEvent(ev); } 分析1：这里是个if条件判断，如果触摸事件的类型是ACTION_DOWN，那么调用onUserInteraction方法，onUserInteraction方法的解释如下：\n1 2 3 4 5 6 7 // android.app.Activity // 当用户与屏幕交互（例如触摸、键盘输入或轨迹球滚动）时，系统会调用该方法 // 此回调和onUserLeaveHint方法旨在帮助Activity智能管理状态栏通知；具体来说，用于帮助Activity确定取消通知的适当时间 // 所有对Activity的onUserLeaveHint回调的调用都将伴随对onUserInteraction调用。这确保Activity将被告知相关的用户活动，例如下拉通知窗格并触摸那里的项目 public void onUserInteraction() { } 分析2：这里有也是个if条件判断，它调用了getWindow的superDispatchTouchEvent方法，一旦if条件为true成立，那么直接return true，整个dispatchTouchEvent方法便会执行完毕，后面的onTouchEvent方法不会被触发。\n继续看getWindow方法，代码如下：\n1 2 3 4 5 // android.app.Activity public Window getWindow() { return mWindow; } getWindow方法返回的是一个mWindow，而mWindow的初始化在Activity的attach方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // android.app.Activity final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); // ... } 可以看到，mWindow是一个PhoneWindow对象，也就是说之前if条件中getWindow的superDispatchTouchEvent方法实际上是调用了PhoneWindow对象的superDispatchTouchEvent方法，那么继续看PhoneWindow对象的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 // com.android.internal.policy.PhoneWindow @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } PhoneWindow对象的superDispatchTouchEvent方法又转接给了mDecor的superDispatchTouchEvent方法，而mDecor是一个DecorView对象，它是窗口的顶层视图，包含窗口装饰，DecorView初始化的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // com.android.internal.policy.PhoneWindow @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the // decor, when theme attributes and the like are crysta // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } // ... } private void installDecor() { mForceDecorInstall = false; if (mDecor == null) { mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted \u0026amp;\u0026amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } else { mDecor.setWindow(this); } // ... } protected DecorView generateDecor(int featureId) { // System process doesn\u0026#39;t have application context and in that case we need to directly // the context we have. Otherwise we want the application context, so we don\u0026#39;t cling to // activity. // ... return new DecorView(context, featureId, this, getAttributes()); } DecorView是在installDecor方法中被初始化的，此处代码和Activity的setContentView方法的源码相关联，只是这里的分析不是本文的重点，所以不会展开讲解。\nOK，回到之前流程，那么调用的是DecorView的superDispatchTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 // com.android.internal.policy.DecorView public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks { public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } } DecorView继承自FrameLayout，FrameLayout继承自ViewGroup，而FrameLayout没有重写dispatchTouchEvent方法，那么super.dispatchTouchEvent调用的就是ViewGroup的dispatchTouchEvent方法了。\n至此，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup。\n分析3：如果getWindow的superDispatchTouchEvent方法返回false，那么if条件判断不成立，就会继续执行Activity的onTouchEvent方法。\n继续看Activity的onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 // android.app.Activity public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; } 这里调用了mWindow的shouldCloseOnTouch方法，我们知道，mWindow的实现类是PhoneWindow，所以shouldCloseOnTouch方法的具体实现应该就在PhoneWindow对象里，可惜PhoneWindow中并没有实现该方法，所以只能找Window对象本身了，果然Window类下有shouldCloseOnTouch方法的实现，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 // android.view.Window @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023) public boolean shouldCloseOnTouch(Context context, MotionEvent event) { final boolean isOutside = event.getAction() == MotionEvent.ACTION_UP \u0026amp;\u0026amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside \u0026amp;\u0026amp; peekDecorView() != null \u0026amp;\u0026amp; isOutside) { return true; } return false; } isOutside表示触摸位置是否在DecorView的外部，它的判断逻辑为：如果触摸事件为ACTION_UP事件并且触摸事件的坐标x，y超出了DecorView边界时，则认为触摸位置在DecorView的外部；如果触摸事件为ACTION_OUTSIDE，那么也认为触摸位置在DecorView的外部。\n然后来到if条件的判断了，第一个条件是一个mCloseOnTouchOutside布尔值，它表示点击DecorView外部时是否可以关闭。如果将Activity设置成Dialog样式的时候，可以通过setCloseOnTouchOutside方法设置mCloseOnTouchOutside布尔值为true；第二个条件是一个peekDecorView方法，它返回的是mDecor对象，也就是判断mDecor对象是否为null；第三个条件就是我们的isOutside值了。\n如果同时满足上面所说的3个条件，那么整个shouldCloseOnTouch方法就会返回true，否则返回false。但是一般情况下很少将Activity设置为Dialog样式，所以也就用不到setCloseOnTouchOutside方法，所以mCloseOnTouchOutside的值false，那么if条件判断为false，整个shouldCloseOnTouch方法返回false，所以最终onTouchEvent方法也是返回false。\n3.2、ViewGroup的事件分发过程 上面分析了Activity的事件分发过程，可以知道，getWindow的superDispatchTouchEvent方法让触摸事件的分发从Activity流转到了ViewGroup，那么继续看ViewGroup的dispatchTouchEvent方法，因为ViewGroup的dispatchTouchEvent方法很长，所以我们先分析前面一部分代码，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... // 分析1 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // 分析2 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // 分析3 // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 分析3.1 final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // 分析3.1.1 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { // 分析3.1.2 intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. // 分析3.2 intercepted = true; } // ... } // ... return handled; } 分析1：handled布尔值用来标记事件分发的处理结果，并最终作为dispatchTouchEvent方法的返回值；onFilterTouchEventForSecurity方法是做一个安全性检查，默认返回true；但是在我们执行敏感控件的点击事件时，有可能会被恶意软件在此之上加上一个不可接受事件的窗口，骗取我们的点击，那么解决办法是调用View的setFilterTouchesWhenObscured方法设置true，它会往View的setFlags方法中添加FILTER_TOUCHES_WHEN_OBSCURED，表示当视图的窗口被另一个可见窗口遮挡时框架丢弃触摸事件，这时onFilterTouchEventForSecurity方法就会返回false，从而dispatchTouchEvent方法返回false。\n分析2：if判断如果触摸事件的类型为ACTION_DOWN，表示新的ACTION_DOWN事件来了，也就是同一序列的触摸事件的起点，所以需要调用cancelAndClearTouchTargets方法来取消并清除所有触摸目标，以及调用resetTouchState方法来重置所有触摸状态以准备新的循环。这两方法里面的重点是清空mFirstTouchTarget，重置FLAG_DISALLOW_INTERCEPT标记，这里cancelAndClearTouchTargets方法和resetTouchState方法的源码就不列出来了，可自行查阅。\n分析3：intercepted布尔值用来表示是否拦截事件；接下来是一个if判断，条件一是触摸事件的类型为ACTION_DOWN，条件二是mFirstTouchTarget != null。mFirstTouchTarget和后面的代码逻辑有关，它的作用就是当ViewGroup不拦截事件并将事件交由子元素处理时，mFirstTouchTarget会被赋值并指向子元素，这时mFirstTouchTarget != null成立。\n如果if判断为true 接下来，如果触摸事件的类型为ACTION_DOWN，或者mFirstTouchTarget != null时，就会进入分析3.1，布尔值disallowIntercept用来表示不允许父View拦截事件，它和FLAG_DISALLOW_INTERCEPT这个标志位有关，并且该标志位的位运算可以通过requestDisallowInterceptTouchEvent方法设置，从而改变disallowIntercept的值。\n默认情况下，也就是没设置FLAG_DISALLOW_INTERCEPT标志位时，disallowIntercept的值为false，此时就会进入分析3.1.1，接着调用onInterceptTouchEvent方法拦截事件，如果onInterceptTouchEvent方法返回true，表示ViewGroup会拦截当前事件，那么intercepted被赋值为true，反之赋值为false。来看下onInterceptTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // android.view.ViewGroup public boolean onInterceptTouchEvent(MotionEvent ev) { if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } onInterceptTouchEvent方法比较简单，if条件第一个判断触摸事件是否来自鼠标设备；第二个判断触摸事件的类型是否是ACTION_DOWN；第三个检查是否按下了鼠标按键；第四个判断触摸位置是否在滚动条上。在大多数情况下if条件不会成立，也就是可以认为默认情况下onInterceptTouchEvent方法返回false。\n如果通过requestDisallowInterceptTouchEvent方法设置FLAG_DISALLOW_INTERCEPT标志位，此时disallowIntercept为true，那么就不满足if(!disallowIntercept)条件了，所以不会再调用onInterceptTouchEvent方法，而是走的else逻辑，从而进入分析3.1.2，将intercepted赋值为false。\n注意：FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件。\n为什么？\n因为前面说过，ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。因此，子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN事件的处理。\n如果if判断为false 如果ViewGroup拦截事件，那么子View就无法获得事件，当ACTION_MOVE和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN ||mFirstTouchTarget ! = null)这个条件为false，将导致ViewGroup的onInterceptTouchEvent不会再被调用，然后走的是else逻辑，也就是进入分析3.2，将intercepted赋值为true。\n到这里，我们已经知道，intercepted的值如果为true，表示ViewGroup要拦截事件，反之不拦截，接下来，继续看ViewGroup的不拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE; final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0 \u0026amp;\u0026amp; !isMouseEvent; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex); final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } } } 如果不是ACTION_CANCEL事件或者ViewGroup不拦截事件时，倒叙遍历子View，然后调用dispatchTransformedTouchEvent方法进行分发事件，注意该方法第三个参数child，此时child不为null，继续看dispatchTransformedTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // android.view.ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; } 前面说过，此时child不为null，那么就会调用child的dispatchTouchEvent方法进行事件的分发，如果child的dispatchTouchEvent方法返回true，那么if(dispatchTransformedTouchEvent)条件成立，就会执行后面的addTouchTarget方法，给mFirstTouchTarget赋值，addTouchTarget方法代码如下：\n1 2 3 4 5 6 7 8 // android.view.ViewGroup private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } 从上面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。那么如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素（如果还有下一个子元素的话）。\n接下来，继续看ViewGroup拦截事件的逻辑，剩余的dispatchTouchEvent方法代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // android.view.ViewGroup @Override public boolean dispatchTouchEvent(MotionEvent ev) { boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { // ... // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { } } return handled; } 如果遍历所有的子元素后事件都没有被合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。在这两种情况下，ViewGroup会自己处理点击事件。注意dispatchTransformedTouchEvent方法的第三个参数child，此时child为null，从前面的分析可以知道，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View的dispatchTouchEvent方法，即点击事件开始交由View来处理。\n3.3、View的事件分发过程 上面分析了ViewGroup的事件分发过程，可以知道，ViewGroup拦截事件后，让触摸事件的分发从ViewGroup流转到了View，那么继续看View的dispatchTouchEvent方法，这里省略了一些不重要的代码，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean dispatchTouchEvent(MotionEvent event) { boolean result = false; if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } return result; } 可以看到View的dispatchTouchEvent方法处理比较简单，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，如果没有设置mOnTouchListener监听器，或者onTouch方法返回false时，那么就会调用View的onTouchEvent方法，继续看onTouchEvent方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // android.view.View public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED \u0026amp;\u0026amp; (mPrivateFlags4 \u0026amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn\u0026#39;t respond to them. return clickable; } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } return false; } 从上面代码可以知道，View处于不可用时依然会消耗事件。如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法。好了，继续看onTouchEvent对事件的处理，剩余代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // android.view.View public boolean onTouchEvent(MotionEvent event) { if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } } mIgnoreNextUpEvent = false; break; } return true; } return false; } 只要View满足clickable，当ACTION_UP事件发生时，最终会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // android.view.View public boolean performClick() { // We still need to call this method to handle the cases where p // externally, instead of through performClickInternal() notifyAutofillManagerOnClick(); final boolean result; final ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; } 至此，事件分发机制的源码就分析完成了。\n四、解决开发中常见的滑动冲突 经过前面理论知识的准备，下面就要进入解决开发中常见的滑动冲突的实战环节。\n4.1、常见的滑动冲突场景\u0026amp;处理思路 当内外两层View都可以滑动的时候，就会产生滑动冲突，常见的滑动冲突场景如下图所示：\n场景一：外部滑动方向和内部滑动方向不一致 此种场景可以根据当前滑动方向是横向还是纵向来判断事件到底该交给谁来处理。\n那滑动方向怎么判断呢？\n在滑动过程中会有两个点的坐标，通过两个点的坐标就可以计算手指的移动距离，如图所示：\n手指移动后横向距离变化为dx，纵向距离变化为dy，如果dx＞dy，那么此次滑动就算作横向滑动；相反，则认为此次滑动是纵向滑动。\n场景二：外部滑动方向和内部滑动方向不致 当内外两层都在同一个方向可以滑动的时候，显然存在逻辑问题。因为当手指开始滑动的时候，系统无法知道用户到底是想让哪一层滑动，所以当手指滑动的时候就会出现问题，要么只有一层能滑动，要么就是内外两层都滑动得很卡顿。\n这种得根据业务需求，通过下面的拦截与禁止拦截的方法，决定在什么情况下滑动哪个View。\n场景三：上面两种情况的嵌套 上面图中没放出来，是场景一和场景二都存在的情况，也就是它们之间互相嵌套，或者多层嵌套，然而不管多么复杂，解决思路都是一毛一样的，按照上面提的解决思路一层一层处理即可。\n4.2、解决滑动冲突的办法 4.2.1、外部拦截法 所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。\n外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { if(父控件需要当前点击事件){ intercepted = true }else{ intercepted = false } } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } 解释下上面代码，在onInterceptTouchEvent方法中，首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；\n其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false；\n最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onClick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。\n4.2.2、内部拦截法 内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，这种方法的伪代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { if(自己需要当前点击事件){ parent.requestDisallowInterceptTouchEvent(true) }else{ parent.requestDisallowInterceptTouchEvent(false) } } } return super.dispatchTouchEvent(event) } 解释下上面代码，我留意到一些文章中会写到在子控件的ACTION_DOWN消息中使用getParent().requestDisallowInterceptTouchEvent(true)；，这是无效的，因为如果父控件拦截了ACTION_DOWN消息，则这里写的函数根本不会执行。\n4.3、滑动冲突实战 先上布局文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.core.widget.NestedScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.appcompat.widget.AppCompatEditText android:id=\u0026#34;@+id/edit_text\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;@dimen/edit_text_height\u0026#34; android:text=\u0026#34;@string/edit_text_content\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;1000dp\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; android:gravity=\u0026#34;center\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/edit_text\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/androidx.core.widget.NestedScrollView\u0026gt; \u0026lt;/layout\u0026gt; 上面是一个EditText，但是这个EditText的内容超出了显示区域，所以它的内容是可以上下滑动的，下面是一个View，高度给得非常大，用来支撑外部的NestedScrollView足够可以滑动，因为NestedScrollView也可以上下滑动，由于双方都可以上下滑动，导致冲突了，运行效果图如下：\n可以看到，在没有处理滑动冲突，在EditText向上滑动时，依然是整体NestedScrollView在滑动，这属于常见的滑动冲突场景里的情况二了，OK，下面就来解决冲突。\n用外部拦截法解决滑动冲突问题 使用外部拦截法来解决滑动冲突问题的话，需要重写NestedScrollView，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class MyNestedScrollView : NestedScrollView { constructor(context: Context) : super(context) { doInit(context) } constructor( context: Context, attrs: AttributeSet? ) : super(context, attrs) { doInit(context) } constructor( context: Context, attrs: AttributeSet?, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) { doInit(context) } private var editTextHeight: Int = 0 private fun doInit(context: Context) { editTextHeight = context.resources.getDimensionPixelSize(R.dimen.edit_text_height) } private var downY: Int = 0 override fun onInterceptTouchEvent(ev: MotionEvent): Boolean { var intercepted = super.onInterceptTouchEvent(ev) when (ev.action) { MotionEvent.ACTION_DOWN -\u0026gt; { downY = ev.y.toInt() intercepted = false } MotionEvent.ACTION_MOVE -\u0026gt; { intercepted = downY \u0026gt; editTextHeight } MotionEvent.ACTION_UP -\u0026gt; { intercepted = false } } return intercepted } } 解释下上面代码，因为EditText的高度是固定的，在这个高度之前触摸的位置都是EditText的内容区域，此时让NestedScrollView不要拦截事件，在这个内容区域值之外的位置，让NestedScrollView拦截事件。\n可以看到，在使用外部拦截法时，需要提前知道不拦截消息的区域，这样才能做好消息处理，所以也只有在子控件的位置和大小是固定的并且能获取到的情况下，外部拦截法才是有用的。\n将自定义的MyNestedScrollView替换布局文件里的NestedScrollView即可，运行后效果如下：\n用内部拦截法解决滑动冲突问题 使用内部拦截法来解决滑动冲突问题的话，需要重写EditText，它的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyEditText : AppCompatEditText { constructor(context: Context) : super(context) constructor( context: Context, attrs: AttributeSet ) : super(context, attrs) constructor( context: Context, attrs: AttributeSet, defStyleAttr: Int ) : super(context, attrs, defStyleAttr) override fun dispatchTouchEvent(event: MotionEvent): Boolean { when (event.action) { MotionEvent.ACTION_MOVE -\u0026gt; { parent.requestDisallowInterceptTouchEvent(true) } } return super.dispatchTouchEvent(event) } } 因为在ACTION_MOVE消息到来时，EditText需要自己处理消息，所以这里并没有内部拦截法中判断是否需要该事件的if（自己需要这类点击事件）代码。\n将自定义的MyEditText替换布局文件里的EditText即可，运行后效果同用外部拦截法解决滑动冲突。\n本文源码地址： AndroidEventDispatch\n","date":"2023-06-23T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","section":"post","tags":null,"title":"Android事件分发机制"},{"categories":["Android"],"contents":" 注：本文代码基于Android Sv2\n一、概述 XML文件在Android中是一种非常常见的文件格式，例如你的主页面布局文件activity_main.xml、Android清单文件AndroidManifest.xml、XXX.xml的res资源文件等等，然而我们在日常开发中往往会忽略XML文件本身，因为AS太过智能化，根据AS智能提示很容易就能写出想要的XML文件，但是我们真的有了解过XML文件吗？还有为什么要去了解XML文件？阅读本文后，你应该可以找到问题的答案。\n因此，本文会把关注点放到XML文件本身，学习它的基础语法，然后循序渐进地讲解Android中怎么解析XML数据，这对之后在Framework层遇到XML解析流程时非常有帮助，比如Activity的setContentView源码里，它是如何将我们写的layout布局文件解析出来的。\n二、XML简单介绍 2.1、什么是XML？ XML的全称为Extensible Markup Language，翻译过来是可扩展标记语言，它是标准通用标记语言的子集，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。\n2.2、XML的基本语法 2.2.1、必须有声明语句 XML声明是XML文档的第一句，代码如下：\n1 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; 2.2.2、XML文档有且只有一个根元素 良好格式的XML文档必须有一个根元素，就是紧接着声明后面建立的第一个元素，其他元素都是这个根元素的子元素，根元素完全包括文档中其他所有的元素，根元素的起始标记要放在所有其他元素的起始标记之前；根元素的结束标记要放在所有其他元素的结束标记之后，代码如下：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 在上面代码中，root称为根元素。\n2.2.3、XML标签对大小写敏感 在XML文档中，大小写是有区别的，例如下面代码中“a”和“A”是不同的标记。注意在写元素时，前后标记的大小写要保持一致。最好养成一种习惯，或者全部大写，或者全部小写，或者大写第一个字母，这样可以减少因为大小写不匹配而产生的文档错误。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;a\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;A\u0026gt;\u0026lt;/A\u0026gt; \u0026lt;/root\u0026gt; 2.2.4、属性值必须加引号 XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误。\n如下代码为错误演示：\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;element id=999\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 如下代码为正确演示：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;element id=\u0026#34;999\u0026#34;\u0026gt;\u0026lt;/element\u0026gt; \u0026lt;/root\u0026gt; 2.2.5、所有的标记必须有相应的结束标记 在XML中，所有标记必须成对出现，有一个开始标记，就必须有一个结束标记，否则将被视为错误。\n2.2.6、实体引用 在XML中，一些字符拥有特殊的意义，如果你把字符\u0026quot;\u0026lt;\u0026ldquo;放在XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;!--IDE报错--\u0026gt; \u0026lt;count\u0026gt;num \u0026lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 为了避免这个错误，需要用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符。\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;root\u0026gt; \u0026lt;count\u0026gt;num \u0026amp;lt; 1000\u0026lt;/count\u0026gt; \u0026lt;/root\u0026gt; 在XML中，有5个预定义的实体引用。\n2.2.7、命名空间 在XML中，因为元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。\n这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的table元素，就会发生命名冲突，XML解析器无法确定如何处理这类冲突。\n如果以Java的思维来描述，可以认为是在同一个包下，创建了两个类名都为Table的类，那么在使用时就会不知道要用的是哪个了。\n因此，需要用XML命名空间来解决该冲突问题。XML命名空间属性被放置于元素的开始标签之中，其语法为：\n1 xmlns:namespace-prefix=\u0026#34;namespaceURI\u0026#34; 当XML命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;root\u0026gt; \u0026lt;s:table xmlns:s=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 命名空间也可以在XML根元素中声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;root xmlns:s=\u0026#34;https://www.student.com/\u0026#34; xmlns:p=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;s:table\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Tony\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202323\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;s:tr\u0026gt; \u0026lt;s:td\u0026gt;Jerry\u0026lt;/s:td\u0026gt; \u0026lt;s:td\u0026gt;202324\u0026lt;/s:td\u0026gt; \u0026lt;/s:tr\u0026gt; \u0026lt;/s:table\u0026gt; \u0026lt;p:table\u0026gt; \u0026lt;p:name\u0026gt;Tony\u0026lt;/p:name\u0026gt; \u0026lt;p:weight\u0026gt;65\u0026lt;/p:weight\u0026gt; \u0026lt;p:height\u0026gt;175\u0026lt;/p:height\u0026gt; \u0026lt;/p:table\u0026gt; \u0026lt;/root\u0026gt; 为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作，其语法为：\n1 xmlns=\u0026#34;namespaceURI\u0026#34; 这个XML文档在表格中记载着学生信息。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;table xmlns=\u0026#34;https://www.student.com/\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Tony\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202323\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Jerry\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;202324\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 这个XML文档记载着个人信息。\n1 2 3 4 5 \u0026lt;table xmlns=\u0026#34;https://www.person.com/\u0026#34;\u0026gt; \u0026lt;name\u0026gt;Tony\u0026lt;/name\u0026gt; \u0026lt;weight\u0026gt;65\u0026lt;/weight\u0026gt; \u0026lt;height\u0026gt;175\u0026lt;/height\u0026gt; \u0026lt;/table\u0026gt; 三、Android解析XML数据 3.1、选择XML解释器 Android提供了三种类型的XML解析器，它们是DOM、SAX和XmlPullParser，但是官方建议使用XmlPullParser，这是一种在Android上解析XML的高效且可维护的方式，Android有此接口的两个实现如下：\nKXmlParser，使用XmlPullParserFactory.newPullParser() ExpatPullParser，使用Xml.newPullParser() 上面两种任一选择都可以，在本文的示例中使用的是ExpatPullParser和Xml.newPullParser()。\n3.1.1、XmlPullParser接口 这里仅列举XmlPullParser接口和后面示例有联系的变量和方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 public interface XmlPullParser { // ***************next()报告的事件类型*************** // 表明解析器位于文档的最开头，尚未读取任何内容，这种事件类型只能通过在第一次调用next()、nextToken或nextTag()之前调用getEventType()来观察 int START_DOCUMENT = 0; // xml文档的逻辑结束，当到达输入文档的末尾时，从getEventType()、next()和nextToken()返回 int END_DOCUMENT = 1; // 读取开始标记时从getEventType()、next()、nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得（如果命名空间已启用） int START_TAG = 2; // 读取结束标记时从getEventType()、next()或nextToken()返回。开始标记的名称可从getName()获得，其命名空间和前缀可从getNamespace()和getPrefix()获得 int END_TAG = 3; // 已读取字符数据并将通过调用getText()获得 int TEXT = 4; // 该数组可用于将事件类型整型常量（如START_TAG或TEXT）转换为字符串。例如，TYPES[START_TAG]的值是字符串“START_TAG”。该数组仅用于诊断输出。依赖数组的内容可能是危险的，因为恶意应用程序可能会更改数组，尽管它是最终的，但由于Java语言的限制 String [] TYPES = { \u0026#34;START_DOCUMENT\u0026#34;, \u0026#34;END_DOCUMENT\u0026#34;, \u0026#34;START_TAG\u0026#34;, \u0026#34;END_TAG\u0026#34;, \u0026#34;TEXT\u0026#34;, \u0026#34;CDSECT\u0026#34;, \u0026#34;ENTITY_REF\u0026#34;, \u0026#34;IGNORABLE_WHITESPACE\u0026#34;, \u0026#34;PROCESSING_INSTRUCTION\u0026#34;, \u0026#34;COMMENT\u0026#34;, \u0026#34;DOCDECL\u0026#34; }; // ***************命名空间相关特性*************** // 这个特性决定了解析器是否处理命名空间。对于所有功能，默认值为false // 注意：该值在解析期间不能更改，必须在解析前设置 String FEATURE_PROCESS_NAMESPACES = \u0026#34;http://xmlpull.org/v1/doc/features.html#process-namespaces\u0026#34;; // 使用此调用来更改解析器的一般行为，例如命名空间处理或文档类型声明处理。必须在第一次调用next或nextToken之前调用此方法。否则，将抛出异常 void setFeature(String name, boolean state) throws XmlPullParserException; // 将解析器的输入源设置为给定的阅读器并重置解析器。事件类型设置为初始值 START_DOCUMENT。将读取器设置为null只会停止解析并重置解析器状态，从而允许解析器释放解析缓冲区等内部资源 void setInput(Reader in) throws XmlPullParserException; // 设置解析器将要处理的输入流。此调用重置解析器状态并将事件类型设置为初始值START_DOCUMENT // 注意：如果传递了输入编码字符串，则必须使用它。否则，如果inputEncoding为null，解析器应该尝试确定遵循XML 1.0规范的输入编码（见下文） void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException; // ***************TEXT相关方法*************** // 检查当前TEXT事件是否只包含空白字符。对于IGNORABLE_WHITESPACE，这始终为真。对于TEXT和CDSECT，当当前事件文本至少包含一个非空白字符时返回false。对于任何其他事件类型，都会抛出异常 boolean isWhitespace() throws XmlPullParserException; // 以String形式返回当前事件的文本内容。返回值取决于当前事件类型，例如对于TEXT事件，它是元素内容（这是使用next()时的典型情况） String getText (); // ***************START_TAG END_TAG共享方法*************** // 对于START_TAG或END_TAG事件，启用命名空间时返回当前元素的（本地）名称。当命名空间处理被禁用时，原始名称被返回。对于ENTITY_REF事件，返回实体名称。如果当前事件不是START_TAG、END_TAG或ENTITY_REF，则返回null String getName(); // ***************START_TAG属性检索方法*************** // 返回由命名空间URI和命名空间localName标识的属性值。如果命名空间被禁用，命名空间必须为空。如果当前事件类型不是START_TAG，则将抛出IndexOutOfBoundsException String getAttributeValue(String namespace, String name); // ***************实际解析方法*************** // 返回当前事件的类型（START_TAG、END_TAG、TEXT等） int getEventType() throws XmlPullParserException; // 获取下一个解析事件 - 元素内容将被合并，并且必须为整个元素内容只返回一个TEXT事件（将忽略注释和处理指令，并且必须扩展实体引用，或者如果实体引用无法扩展则必须抛出异常）。如果元素内容为空（内容为“”），则不会报告TEXT事件 int next() throws XmlPullParserException, IOException; // ***************使XML解析更容易的实用方法*************** // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配。null将匹配任何名称空间和任何名称。如果测试未通过，则抛出异常。异常文本表示解析器位置、预期事件和不符合要求的当前事件 void require(int type, String namespace, String name) throws XmlPullParserException, IOException; // 如果是START_TAG或END_TAG，则调用next()并返回事件，否则抛出异常。如果有的话，它将跳过实际标记之前的空白TEXT int nextTag() throws XmlPullParserException, IOException; } 接下来，只讲解一下重点的方法。\n3.1.1.1、next方法 从上面的注释可以知道，next方法用于获取下一个解析事件，但是它有一些现象需要知道下。\n现象一：如果元素内容为空，则不会报告TEXT事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // kotlin原始字符串 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) var eventType = parser.eventType while (eventType != XmlPullParser.END_DOCUMENT) { Log.e(\u0026#34;MinKin\u0026#34;, \u0026#34;eventType: ${XmlPullParser.TYPES[eventType]}; name: ${parser.name}; text: ${parser.text}\u0026#34;) eventType = parser.next() } 打印结果如下：\n1 2 3 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: END_TAG; name: school; text: null 从打印结果来看，school元素内容为空时，的确没有触发TEXT事件。\n不知到你们是否留意到，为什么也没有触发END_DOCUMENT事件？\n其实是有触发的，只是不满足条件没法打印出来。因为While循环的判断条件为eventType != XmlPullParser.END_DOCUMENT，当eventType == XmlPullParser.END_DOCUMENT时，此时早已退出循环了，所以没有打印出来。\n特性二：如果实体引用无法扩展则必须抛出异常。 将上面代码中的xml变量替换为如下代码：\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 此时因为school标签之间多了\u0026rdquo;\u0026lt;\u0026quot;，运行时会触发XmlPullParserException这样的一个崩溃。把字符\u0026quot;\u0026lt;\u0026ldquo;放在 XML元素中，会发生错误，这是因为解析器会把它当作新元素的开始，为了避免这个错误，用实体引用来代替\u0026rdquo;\u0026lt;\u0026ldquo;字符，这也是我们之前讲过的。\n1 2 3 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 修改为实体引用后，打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: \u0026lt; E/MinKin: eventType: END_TAG; name: school; text: null 特性三：标签之间不是黏连一起的，比如之间有空格，或者出现了换行，或者存在子标签的情况下，都会报告TEXT事件。 将上面代码中的xml变量替换为如下代码：\n1 2 3 4 // 标签之间有空格 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 1 2 3 4 5 // 标签之间出现了换行 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里school标签之间多打印了一次TEXT事件。如果是存在子标签的情况下，代码如下：\n1 2 3 4 5 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt; \u0026lt;count\u0026gt;1000\u0026lt;/count\u0026gt; \u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() 打印结果如下：\n1 2 3 4 5 6 7 8 9 E/MinKin: eventType: START_DOCUMENT; name: null; text: null E/MinKin: eventType: START_TAG; name: school; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: START_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: 1000 E/MinKin: eventType: END_TAG; name: count; text: null E/MinKin: eventType: TEXT; name: null; text: E/MinKin: eventType: END_TAG; name: school; text: null 明显可以看到，这里count标签前后多打印了两次TEXT事件。\n3.1.1.2、nextTag方法 如果当前事件不是START_TAG或END_TAG，会抛出XmlPullParserException异常，例如下面代码就会崩溃。\n1 2 3 4 5 6 7 8 9 10 11 val xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;school\u0026gt;清华大学\u0026lt;/school\u0026gt; \u0026#34;\u0026#34;\u0026#34;.trimIndent() val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(StringReader(xml)) parser.next() parser.nextTag() 分析原因：初始时，当前事件为START_DOCUMENT，调用parser的next方法后，事件变为START_TAG，然后再调用parser的nextTag方法时，它的事件状态应该不满足START_TAG或END_TAG，从而抛出了异常。\n为什么不满足？nextTag方法本质源码为：\n1 2 3 4 5 6 7 8 int eventType = next(); if(eventType == TEXT \u0026amp;\u0026amp; isWhitespace()) { // skip whitespace eventType = next(); } if (eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG) { throw new XmlPullParserException(\u0026#34;expected start or end tag\u0026#34;, this, null); } return eventType; 可以看到，会优先调用next方法，此时当前事件为TEXT，接着会去判断eventType == TEXT \u0026amp;\u0026amp; isWhitespace()，但是isWhitespace方法是不满足的，因为school标签中存在元素内容“清华大学”，所以isWhitespace方法返回false，也就无法进入if条件去进一步调用next，事件停留在TEXT，满足了后面的eventType != START_TAG \u0026amp;\u0026amp; eventType != END_TAG，从而抛出了异常。\n注意：next方法和nextTag方法需要在合理的地方使用，使用不当就会抛出异常。\n3.2、分析animal 创建一个animal.xml文件，解析animal的第一步是确定感兴趣的字段，解析器会提取这些字段的数据，并忽略其余字段。本案例会演示如何忽略cat标签，仅提取需要的字段。\n要解析的XML内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;animal xmlns=\u0026#34;https://www.baidu.com/\u0026#34;\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Rufus\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;labrador\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=labrador\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;拉布拉多猎犬（英文名：Labrador retriever）是起源于加拿大的纽芬兰岛，最早被训练在冰冷的海上将渔网收回和担任搬运工作的一种猎犬。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;dog\u0026gt; \u0026lt;name\u0026gt;Marty\u0026lt;/name\u0026gt; \u0026lt;breed\u0026gt;whippet\u0026lt;/breed\u0026gt; \u0026lt;link href=\u0026#34;https://www.baidu.com/s?wd=whippet\u0026#34; rel=\u0026#34;alternate\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;profile type=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;![CDATA[ \u0026lt;p style=\u0026#34;color: #34495e;\u0026#34;\u0026gt;小灵狗是一种赛狗，性温顺。和蔼。\u0026lt;/p\u0026gt; ]]\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/dog\u0026gt; \u0026lt;cat\u0026gt; \u0026lt;name\u0026gt;大黄\u0026lt;/name\u0026gt; \u0026lt;/cat\u0026gt; \u0026lt;/animal\u0026gt; 习惯性，animal标签包含了命名空间xmlns，profile标签的元素内容标记为HTML，所以要把HTML内容当成整体的纯文本去提取，这里给HTML内容包裹一层\u0026lt;![CDATA[ HTML内容 ]]，否则HTML中的标签会被XML当成元素去解析。\n3.3、实例化XML解释器 解析animal的下一步就是实例化解析器和启动解析的过程，此代码段会初始化一个解析器，使其不处理命名空间并将提供的InputStream用作输入，它通过调用nextTag方法开始解析过程，并调用readAnimal方法，该方法将提取并处理应用感兴趣的数据，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class AnimalXMLParser { // 不使用命名空间 private val ns: String? = null @Throws(XmlPullParserException::class, IOException::class) fun parse(inputStream: InputStream): List\u0026lt;Dog\u0026gt; { inputStream.use { val parser = Xml.newPullParser() // 解析器不处理命名空间 parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false) parser.setInput(it, null) parser.nextTag() return readAnimal(parser) } } // ... } 3.4、读取animal readAnimal方法执行处理animal的实际工作，它会查找标记为“dog”的元素作为以递归方式处理animal的起点，如果某个标签不是dog标签，则会跳过它，以递归方式处理完整个animal后，readAnimal方法将返回结果集List，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Throws(XmlPullParserException::class, IOException::class) private fun readAnimal(parser: XmlPullParser): List\u0026lt;Dog\u0026gt; { val dogs = mutableListOf\u0026lt;Dog\u0026gt;() // 测试当前事件是否属于给定类型以及命名空间和名称是否匹配 parser.require(XmlPullParser.START_TAG, ns, \u0026#34;animal\u0026#34;) while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } if (parser.name == \u0026#34;dog\u0026#34;) { dogs.add(readDog(parser)) } else { skip(parser) } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;animal\u0026#34;) return dogs } 其中Dog类为：\n1 2 3 4 5 6 data class Dog( val name: String?, val breed: String?, val link: String?, val profile: String? ) 3.5、解析XML 解析XML animal的步骤如下：\n按照分析animal中所述，确定希望包含在应用中的标签。此示例提取了dog标签及其嵌套标签name、breed、link和profile的数据。\n创建以下方法：\n要包含的每个标签的“read”方法，例如readDog方法。解析器会从输入流中读取标签。当遇到此示例中名为name、breed、link和profile的标签时，它会调用该标签的相应方法。否则，它会跳过该标签。 为每个不同类型的标签提取数据并推动解析器解析下一个标签的方法。在此示例中，相关方法如下所示： 对于name、breed和profile标签，解析器会调用 readText方法。此方法通过调用parser的getText方法提取这些标签的数据。 对于link标签，解析器首先会确定链接是否为其感兴趣的类型，再提取该链接的数据。然后使用parser的getAttributeValue方法提取该链接的值。 对于dog标签，解析器会调用readDog方法。此方法会解析条目的嵌套标签，并返回包含数据成员name、breed、link和profile的Dog对象。 一种递归的辅助skip方法。 以下代码段展示了解析器如何解析name、breed、link和profile。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @Throws(XmlPullParserException::class, IOException::class) private fun readDog(parser: XmlPullParser): Dog { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;dog\u0026#34;) var name: String? = null var breed: String? = null var link: String? = null var profile: String? = null while (parser.next() != XmlPullParser.END_TAG) { if (parser.eventType != XmlPullParser.START_TAG) { continue } when (parser.name) { \u0026#34;name\u0026#34; -\u0026gt; name = readName(parser) \u0026#34;breed\u0026#34; -\u0026gt; breed = readBreed(parser) \u0026#34;link\u0026#34; -\u0026gt; link = readLink(parser) \u0026#34;profile\u0026#34; -\u0026gt; profile = readProfile(parser) else -\u0026gt; skip(parser) } } return Dog(name, breed, link, profile) } @Throws(XmlPullParserException::class, IOException::class) private fun readProfile(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;profile\u0026#34;) val profile = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;profile\u0026#34;) return profile } @Throws(XmlPullParserException::class, IOException::class) private fun readLink(parser: XmlPullParser): String { var link = \u0026#34;\u0026#34; parser.require(XmlPullParser.START_TAG, ns, \u0026#34;link\u0026#34;) val tag = parser.name val relType = parser.getAttributeValue(null, \u0026#34;rel\u0026#34;) if (tag == \u0026#34;link\u0026#34;) { if (relType == \u0026#34;alternate\u0026#34;) { link = parser.getAttributeValue(null, \u0026#34;href\u0026#34;) parser.nextTag() } } parser.require(XmlPullParser.END_TAG, ns, \u0026#34;link\u0026#34;) return link } @Throws(XmlPullParserException::class, IOException::class) private fun readBreed(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;breed\u0026#34;) val breed = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;breed\u0026#34;) return breed } @Throws(XmlPullParserException::class, IOException::class) private fun readName(parser: XmlPullParser): String { parser.require(XmlPullParser.START_TAG, ns, \u0026#34;name\u0026#34;) val name = readText(parser) parser.require(XmlPullParser.END_TAG, ns, \u0026#34;name\u0026#34;) return name } @Throws(XmlPullParserException::class, IOException::class) private fun readText(parser: XmlPullParser): String { var result = \u0026#34;\u0026#34; if (parser.next() == XmlPullParser.TEXT) { result = parser.text parser.nextTag() } return result } 3.6、跳过不感兴趣的标签 解析器需要跳过不感兴趣的标签，下面是解析器的skip方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Throws(XmlPullParserException::class, IOException::class) private fun skip(parser: XmlPullParser) { if (parser.eventType != XmlPullParser.START_TAG) { throw IllegalStateException() } var depth = 1 while (depth != 0) { when (parser.next()) { XmlPullParser.END_TAG -\u0026gt; depth-- XmlPullParser.START_TAG -\u0026gt; depth++ } } } 其工作原理如下：\n如果当前事件不是START_TAG，则会抛出异常。 它会使用START_TAG以及直到匹配的END_TAG（含）的所有事件。 为确保其在遇到正确的END_TAG时停止，而非在遇到原始 START_TAG之后的首个标签时停止，它会不断追踪嵌套深度。 因此，如果当前元素具有嵌套元素，在解析器使用了原始START_TAG及其匹配的END_TAG之间的所有事件之前，depth的值不会为0。例如，看看解析器如何跳过拥有name这个嵌套元素的 cat元素：\n第一次经历while循环时，解析器在\u0026lt;cat\u0026gt;之后遇到的下一个标签是\u0026lt;name\u0026gt;的START_TAG。depth的值递增到2。 第二次经历while循环时，解析器遇到的下一个标签是 END_TAG，也就是\u0026lt;/name\u0026gt;。depth的值递减为1。 第三次，也就是最后一次经历while循环时，解析器遇到的下一个标签是END_TAG，也就是。depth的值递减为0，这表明该方法已成功跳过\u0026lt;cat\u0026gt;元素。 3.7、使用XML数据 第一步：把animal.xml文件放到Assets目录下。\n第二步：本文使用Databinding，所以需要在app的build.gradle中添加依赖：\n1 2 3 4 5 android { dataBinding { enabled = true } } 第三步：改造activity_main.xml布局，这里只有一个点击按钮，给按钮绑定点击事件，点击按钮时触发XML的解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;presenter\u0026#34; type=\u0026#34;com.pengmj.androidparsexml.Presenter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:onClick=\u0026#34;@{(view)-\u0026gt;presenter.onParseXML(view)}\u0026#34; android:text=\u0026#34;解析XML\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 第四步：实现点击事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Presenter { companion object { private val tag: String = Presenter::class.java.simpleName } fun onParseXML(view: View) { val inputStream = view.context.assets.open(\u0026#34;animal.xml\u0026#34;) val list = AnimalXMLParser().parse(inputStream) Log.e(tag, list.toString()) } } 第五步：在MainActivity中将Databinding绑定UI层，设置页面点击事件对象。\n1 2 3 4 5 6 7 8 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding = DataBindingUtil.setContentView\u0026lt;ActivityMainBinding\u0026gt;(this, R.layout.activity_main) binding.presenter = Presenter() } } 本文源码地址： AndroidParseXML\n","date":"2023-05-07T14:41:31+08:00","permalink":"https://anddevmk.cn/post/android%E8%A7%A3%E6%9E%90xml%E6%95%B0%E6%8D%AE/","section":"post","tags":null,"title":"Android解析XML数据"},{"categories":["Java"],"contents":"一、概述 假设你对ArrayDeque的源码一无所知，那么仅凭ArrayDeque名字来看的话，大概可以猜到它的实现和Array数组有关。\nArrayDeque是Java Collections Framework的一个成员，它的底层是基于定长数组实现的一个双端队列，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据，并且维护了双端队列头部元素的索引head和尾部元素的索引tail，使得它成为了一个逻辑上的循环数组，所谓循环是指元素到数组尾之后可以接着从数组头开始。\n我们知道，数组非尾部的插入和删除效率是比较低的，然而，这在ArrayDeque上的表现却是效率高，这是怎么实现的呢？\n接下来，本文会叙述ArrayDeque是如何维护这样一个循环数组，它的扩容机制是怎么实现的，这些都是ArrayDeque的核心所在；除此之外，本文还会叙述ArrayDeque的基本操作是怎样实现的，以及其它的细节。\n好了，让我们一起逐步揭开它的神秘面纱。\n二、ArrayDeque源码解读 2.1、继承关系 从UML类图中可以看到，ArrayDeque直接或间接实现了Iterable、Collection、Deque、Queue、Cloneable、Serializable这6个接口；ArrayDeque继承了AbstractCollection这个抽象类。\nArrayDeque和LinkedList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，比如说Deque接口、Queue接口的解读，本文不再次叙述，想去了解的话，可参考之前的Java集合系列：一文解读LinkedList源码「JDK11」一文。\n2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 // 存储双端队列元素的数组。所有不包含双端队列元素的数组单元格始终为空。该数组始终至少有一个空槽（在尾部）。 transient Object[] elements; // 双端队列头部元素的索引（这是将被 remove() 或 pop() 删除的元素）；或者任意数字 0 \u0026lt;= head \u0026lt; elements.length 等于 tail 如果双端队列为空。 transient int head; // 将下一个元素添加到双端队列尾部的索引（通过 addLast(E)、add(E) 或 push(E)）； elements[tail] 始终为空。 transient int tail; // 要分配的数组的最大大小。一些 VM 在数组中保留一些标题字。尝试分配更大的数组可能会导致 OutOfMemoryError: Requested array size exceeds VM limit private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从成员变量head、tail的注释可以知道，数组的长度、头部元素、尾部元素都和这两个变量有关，那么当数组初始化后，这样的数组表现形式有4种情况：\n头部元素的索引head == 尾部元素的索引tail，那么数组为空，也就是数组内部没有元素，如下图所示： 头部元素的索引head \u0026lt; 尾部元素的索引tail，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到tail-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail == 0，那么头部元素为elements[head]，尾部元素为elements[elements.length-1]，元素索引从head到elements.length-1，如下图所示： 头部元素的索引head \u0026gt; 尾部元素的索引tail \u0026amp;\u0026amp; 尾部元素的索引tail != 0，那么头部元素为elements[head]，尾部元素为elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1，如下图所示： 2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 构造一个空数组双端队列，其初始容量足以容纳16个元素 public ArrayDeque() { elements = new Object[16]; } // 构造一个空数组双端队列，其初始容量足以容纳指定数量的元素 public ArrayDeque(int numElements) { elements = new Object[(numElements \u0026lt; 1) ? 1 : (numElements == Integer.MAX_VALUE) ? Integer.MAX_VALUE : numElements + 1]; } // 构造一个包含指定集合元素的双端队列，按照集合迭代器返回元素的顺序。（集合的迭代器返回的第一个元素成为第一个元素，或双端队列的前面。） public ArrayDeque(Collection\u0026lt;? extends E\u0026gt; c) { this(c.size()); copyElements(c); } // 将集合c的元素循环添加到队尾 private void copyElements(Collection\u0026lt;? extends E\u0026gt; c) { c.forEach(this::addLast); } 我们看下第二个构造方法，需要传入一个numElements，这里有3种情况确定数组大小：\n如果numElements \u0026lt; 1，那么数组大小为1；\n如果numElements == Integer.MAX_VALUE，那么数组大小为Integer.MAX_VALUE；\n如果numElements \u0026gt;= 1 \u0026amp;\u0026amp; numElements \u0026lt; Integer.MAX_VALUE，那么数组大小为numElements + 1;\n第三种情况：为什么要numElements + 1呢？\n因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置。\n2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // ***********尾部插入*********** // 在此双端队列的末尾插入指定的元素 public boolean add(E e) { addLast(e); return true; } // 在此双端队列的末尾插入指定的元素 public void addLast(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 上面说了，tail索引对应的位置是一个空位，所以这里用来存放元素e es[tail] = e; // 计算tail的新索引位置，赋值给tail变量；如果(tail+1) \u0026gt;= es.length，那么tail = 0，否则就是tail+1 // 判断是否head == tail，如果是则表示数组存满了，需要进行扩容 if (head == (tail = inc(tail, es.length))) // 执行扩容 grow(1); } static final int inc(int i, int modulus) { if (++i \u0026gt;= modulus) i = 0; return i; } // 在此双端队列的末尾插入指定的元素 public boolean offer(E e) { return offerLast(e); } // 在此双端队列的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 将指定集合中的所有元素添加到此双端队列的末尾，就像对每个元素调用addLast一样，按照集合的迭代器返回它们的顺序。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // s：原数组的元素个数 // needed：所需的最低额外容量 final int s, needed; // needed = 原数组的元素个数 + 集合c的长度 + 1（tail索引占位）- 原数组长度 // 如果needed\u0026gt;0，说明数组元素个数 + 集合c的长度 + 1（tail索引占位) \u0026gt; 原数组长度，也就是原数组容量不够装集合c了，需要扩容 if ((needed = (s = size()) + c.size() + 1 - elements.length) \u0026gt; 0) // 执行扩容 grow(needed); // 扩容完成后，将集合c的元素循环添加到队尾 copyElements(c); // 如果此双端队列发生了更改，那么返回true return size() \u0026gt; s; } // ***********头部插入*********** // 在此双端队列的前面插入指定的元素 public void addFirst(E e) { if (e == null) throw new NullPointerException(); final Object[] es = elements; // 计算head的新索引位置，赋值给head变量；如果(head-1) \u0026lt; 0，那么head = es.length-1，否则就是head-1 es[head = dec(head, es.length)] = e; // 判断是否head==tail，如果是则表示数组存满了，需要进行扩容 if (head == tail) // 执行扩容 grow(1); } static final int dec(int i, int modulus) { if (--i \u0026lt; 0) i = modulus - 1; return i; } // 在此双端队列的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素压入此双端队列所代表的堆栈。换句话说，将元素插入到这个双端队列的前面 public void push(E e) { addFirst(e); } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // ***********尾部删除*********** public E removeLast() { E e = pollLast(); if (e == null) throw new NoSuchElementException(); return e; } public E pollLast() { final Object[] es; // 记录tail的新索引位置 final int t; // 计算tail的新索引位置，赋值给临时变量t；如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出t索引对应的元素 E e = elementAt(es = elements, t = dec(tail, es.length)); if (e != null) // 将t赋值给tail，然后将tail索引位置的元素置为null es[tail = t] = null; return e; } // ***********头部删除*********** // 检索并删除由此双端队列表示的队列的头部。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E remove() { return removeFirst(); } // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。 public E poll() { return pollFirst(); } public E removeFirst() { E e = pollFirst(); if (e == null) throw new NoSuchElementException(); return e; } public E pollFirst() { final Object[] es; // 记录head索引位置 final int h; // 在数组中取出head索引对应的元素 E e = elementAt(es = elements, h = head); if (e != null) { // 将head索引位置的元素置为null es[h] = null; // 计算head的新索引位置，赋值给head；如果(head+1) \u0026gt;= es.length，那么head = 0，否则就是head+1 head = inc(h, es.length); } // 返回head索引对应的元素 return e; } // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。 public E pop() { return removeFirst(); } 2.4.3、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // ***********头部检索*********** // 检索但不删除由此双端队列表示的队列的头部。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。 public E element() { return getFirst(); } // 检索但不删除由此双端队列表示的队列的头部，或者如果此双端队列为空则返回null 。 public E peek() { return peekFirst(); } public E getFirst() { // 在数组中取出head索引对应的元素 E e = elementAt(elements, head); if (e == null) throw new NoSuchElementException(); // 返回head索引对应的元素 return e; } // 返回数组索引 i 处的元素。这是对泛型的轻微滥用，被 javac 所接受 static final \u0026lt;E\u0026gt; E elementAt(Object[] es, int i) { return (E) es[i]; } public E peekFirst() { // 在数组中取出head索引对应的元素 return elementAt(elements, head); } // ***********尾部检索*********** public E getLast() { final Object[] es = elements; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 E e = elementAt(es, dec(tail, es.length)); if (e == null) throw new NoSuchElementException(); return e; } public E peekLast() { final Object[] es; // 计算tail的新索引位置，如果(tail-1) \u0026lt; 0，那么tail = es.length-1，否则就是tail-1 // 在数组中取出tail新索引对应的元素 return elementAt(es = elements, dec(tail, es.length)); } 2.4.4、扩容机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将此双端队列的容量至少增加给定的数量 // need：所需的最低额外容量 private void grow(int needed) { // overflow-conscious code // 获取旧容量大小 final int oldCapacity = elements.length; // 记录新容量大小 int newCapacity; // Double capacity if small; else grow by 50% // jump：可译为跳跃，是基于旧容量计算的一个值，姑且叫跳跃容量 // 如果oldCapacity \u0026lt; 64，那么jump = oldCapacity + 2，为什么这里是+2？+1不行吗？因为+2有两个含义，一个是给tail占位使用，另一个就是给新元素插入使用 // 如果oldCapacity \u0026gt;= 64，那么jump = oldCapacity \u0026gt;\u0026gt; 1，右移一位表示除2，相当于oldCapacity/2 int jump = (oldCapacity \u0026lt; 64) ? (oldCapacity + 2) : (oldCapacity \u0026gt;\u0026gt; 1); // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 如果（跳跃容量 + 旧容量）\u0026gt; MAX_ARRAY_SIZE，说明超过数组长度允许最大值了 // // newCapacity的值有两个情况： // 如果oldCapacity \u0026lt; 64，那newCapacity为oldCapacity * 2 + 2 // 如果oldCapacity \u0026gt;= 64，那newCapacity为oldCapacity * 1.5 if (jump \u0026lt; needed || (newCapacity = (oldCapacity + jump)) - MAX_ARRAY_SIZE \u0026gt; 0) // 出现上面说的两种情况时，需要重新调整新容量大小 newCapacity = newCapacity(needed, jump); // 将原数组的元素全部拷贝到新数组中去 final Object[] es = elements = Arrays.copyOf(elements, newCapacity); // Exceptionally, here tail == head needs to be disambiguated // 此时数组只是扩大了，但是tail==head，即依然指向同一位置，为避免歧义，需要调整head和tail的位置 if (tail \u0026lt; head || (tail == head \u0026amp;\u0026amp; es[head] != null)) { // wrap around; slide first leg forward to end of array // 计算扩容后数组的剩余空间 int newSpace = newCapacity - oldCapacity; // 将旧数据复制到新位置 System.arraycopy(es, head, es, head + newSpace, oldCapacity - head); // 将旧位置的旧数据全部清空，head成为新位置⾸元素的位置 for (int i = head, to = (head += newSpace); i \u0026lt; to; i++) es[i] = null; } } // 边缘条件的容量计算，尤其是溢出 private int newCapacity(int needed, int jump) { final int oldCapacity = elements.length, minCapacity; // 边界处理：判断旧容量 + 所需的最低额外容量是否超过数组长度允许最大值 if ((minCapacity = oldCapacity + needed) - MAX_ARRAY_SIZE \u0026gt; 0) { if (minCapacity \u0026lt; 0) throw new IllegalStateException(\u0026#34;Sorry, deque too big\u0026#34;); return Integer.MAX_VALUE; } // 如果跳跃容量 \u0026lt; 所需的最低额外容量，说明是计划赶不上变换，比如说调用构造方法时传入numElements为1，然后调用addAll方法，一次性添加一个很大的集合进来，就有可能出现这种情况 // 返回minCapacity = oldCapacity + needed if (needed \u0026gt; jump) return minCapacity; // 如果最小容量minCapacity没有超过数组长度允许最大值，并且need \u0026lt;= jump // 边界处理：判断旧容量+跳跃容量是否超过数组长度允许最大值 return (oldCapacity + jump - MAX_ARRAY_SIZE \u0026lt; 0) ? oldCapacity + jump : MAX_ARRAY_SIZE; } 下面通过一个小例子去演示扩容机制的执行流程，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 初始时，数组⻓度是5，真实索引是0-4，head = tail = 0 ArrayDeque\u0026lt;Integer\u0026gt; arrayDeque = new ArrayDeque\u0026lt;\u0026gt;(4); // 执行完，head = 0, tail = 1；此时数组为：[1, null, null, null, null] arrayDeque.addLast(1); // 执行完，head = 4，tail = 1；此时数组为：[1, null, null, null, 2] arrayDeque.addFirst(2); // 执行完，head = 3，tail = 1；此时数组为：[1, null, null, 3, 2] arrayDeque.addFirst(3); // 执行完，head = 2，tail = 1；此时数组为：[1, null, 4, 3, 2] arrayDeque.addFirst(4); // 执行完，head = tail = 1，触发扩容；此时数组为：[1, 5, 4, 3, 2]，扩容容量为5*2+2 // 然后将旧数据复制到新位置，此时数组为：[1, 5, 4, 3, 2, null, null, null, 5, 4, 3, 2] // 接着清掉旧数据，这时head = 8，tail = 1；此时数组为：[1, null, null, null, null, null, null, null, 5, 4, 3, 2] arrayDeque.addFirst(5); // 执行完，head = 8, tail = 2；此时数组为：[1, 6, null, null, null, null, null, null, 5, 4, 3 ,2] arrayDeque.addLast(6); 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 返回此双端队列中的元素数 public int size() { // i = tail，j = head，modulus = elements.length // 那么i -= j为i = i-j，代入后是tail = tail - head，然后判断计算后的tail是否 \u0026lt; 0 // 如果 \u0026lt; 0，说明是head \u0026gt; tail的情况，对应于前面讲成员变量提到的数组情况3或4，这种情况下， tail会再次计算，tail = tail + elements.length，这样计算就可以求出数组的元素个数，不明白可以对照图来看 // 如果 \u0026gt;= 0，说明是head \u0026lt;= tail的情况，对应于前面讲成员变量提到的数组情况1或2，这种情况下，直接把tail返回即可，因为if条件判断时已经计算过了，这样计算就可以求出数组的元素个数，不明白可以对照图来看 return sub(tail, head, elements.length); } static final int sub(int i, int j, int modulus) { if ((i -= j) \u0026lt; 0) i += modulus; return i; } // 如果此双端队列包含指定元素，则返回true 。更正式地说，当且仅当此双端队列包含至少一个满足o.equals(e)的元素e时才返回true public boolean contains(Object o) { if (o != null) { final Object[] es = elements; // to = (i \u0026lt;= end) ? end : es.length; 代入为：to = （head \u0026lt;= tail）? tail : es.length; // 这里要判断head \u0026lt;= tail，如果是true，那么to==end，即to为tail，说明内层for循环只需要遍历区间[head,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false // 如果head \u0026gt; tail，如果为true，那么to = es.length，说明内层for循环要遍历区间[head,es.length)中是否存在和o元素相同的元素，如果存在，返回true // 否则，内存for循环执行完成，外层for循环此时执行 i = 0, to = end； // 接着内存for循环继续要遍历区间[0,tail)中是否存在和o元素相同的元素，如果存在，返回true，否则break结束外层循环，返回false for (int i = head, end = tail, to = (i \u0026lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i \u0026lt; to; i++) if (o.equals(es[i])) return true; if (to == end) break; } } return false; } 三、总结 在ArrayDeque的源码中，并没有与并发相关的代码，所以说ArrayDeque是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。\nArrayDeque没有索引位置的概念，不能根据索引位置进行操作，所以没有更改操作，如set方法。\n另外，ArrayDeque禁止添加空元素。最关键一点是：ArrayDeque用作堆栈时很可能比Stack快，用作队列时比LinkedList快。\n","date":"2023-04-24T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraydeque%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayDeque源码「JDK11」"},{"categories":["Java"],"contents":"一、概述 LinkedList是Java Collections Framework的一个成员，然后底层是基于双向链表来实现的。对于LinkedList来说，可能平常开发用的频率并没有ArrayList多，这并不是我们不去学习LinkedList原理的理由。我们知道，ArrayList的特点是随机访问效率很高，但是非尾部的插入和删除性能就比较低，因为要挪动元素位置。LinkedList和ArrayList一样实现了List接口，因为两者底层的实现不一样，造就了它的特点与ArrayList几乎正好相反。\n接下来，本文会叙述LinkedList是如何维护这样一个双向链表的，基本操作是怎样实现的，以及其它的细节。\n二、LinkedList源码解读 2.1、继承关系 从UML类图中可以看到，LinkedList直接或间接实现了Iterable、Collection、List、Deque、Queue、Cloneable、Serializable这7个接口；LinkedList直接或间接继承了AbstractSequentialList、AbstractList、AbstractCollection这3个抽象类。\n可能细心的同学会发现，为什么AbstractList实现了List接口，LinkedList还要去再实现一次List接口？\n关于这一点，在之前的Java集合系列：一文解读ArrayList源码「JDK11」一文中已有解答，除此之外，LinkedList和ArrayList在继承关系上是比较相似的，所以针对相同继承关系内容的叙述，本文不再次叙述，想去了解的话，可点击上文链接去了解。\n2.1.1、Queue接口 Queue接口是一个队列接口，它对Collection接口进行了扩展。所谓队列，就类似于日常生活中的各种排队，特点就是先进先出，在尾部添加元素，从头部删除元素，它的接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Queue\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此队列，则在成功时返回true并在当前没有可用空间时抛出IllegalStateException boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，当使用容量受限的队列时，此方法通常优于add，后者可能仅通过抛出异常来插入元素失败 boolean offer(E e); // 检索并删除此队列的头部。此方法与poll()的不同之处仅在于，如果此队列为空，它会抛出异常 E remove(); // 检索并删除此队列的头部，如果此队列为空，则返回null E poll(); // 检索但不删除此队列的头部。此方法与peek不同之处仅在于，如果此队列为空，它会抛出异常 E element(); // 检索但不删除此队列的头部，如果此队列为空，则返回null E peek(); } Queue队列提供了插入、删除和检查操作。这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（null或false ，具体取决于操作），如下图所示：\n注意：Queue队列实现通常不允许插入null元素，尽管某些实现（例如 LinkedList）不禁止插入null。即使在允许它的实现中，也不应将null插入到Queue队列中，因为null也被poll方法用作特殊的返回值，以指示队列不包含任何元素。\n实践一下，我们把LinkedList当作Queue队列来使用，如下代码：\n1 2 3 4 5 6 7 Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(\u0026#34;Jerry\u0026#34;); queue.offer(\u0026#34;Tom\u0026#34;); queue.offer(\u0026#34;May\u0026#34;); while (queue.peek() != null) { System.out.println(queue.poll()); } 2.1.2、Deque接口 Deque接口对Queue接口进行了扩展，Deque是“double ended queue”的缩写，它定义了访问双端队列两端元素的方法，接口定义为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public interface Deque\u0026lt;E\u0026gt; extends Queue\u0026lt;E\u0026gt; { // 如果可以在不违反容量限制的情况下立即将指定的元素插入此双端队列的前面，如果当前没有可用空间则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerFirst void addFirst(E e); // 如果可以在不违反容量限制的情况下立即插入指定的元素，则在此双端队列的末尾插入指定的元素，如果当前没有可用空间，则抛出IllegalStateException 。使用容量受限的双端队列时，通常最好使用方法offerLast。此方法等效于add void addLast(E e); // 将指定的元素插入此双端队列的前面，除非它违反容量限制。当使用容量受限的双端队列时，此方法通常优于addFirst方法，后者仅通过抛出异常才能插入元素失败。 boolean offerFirst(E e); // 除非违反容量限制，否则在此双端队列的末尾插入指定的元素。当使用容量受限的双端队列时，此方法通常优于addLast方法，后者仅通过抛出异常才能插入元素失败 boolean offerLast(E e); // 检索并删除此双端队列的第一个元素。此方法与pollFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeFirst(); // 检索并删除此双端队列的最后一个元素。此方法与pollLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E removeLast(); // 检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回null E pollFirst(); // 检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回null E pollLast(); // 检索但不删除此双端队列的第一个元素。此方法与peekFirst不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getFirst(); // 检索但不删除此双端队列的最后一个元素。此方法与peekLast不同之处仅在于，如果此双端队列为空，它会抛出异常。 E getLast(); // 检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回null E peekFirst(); // 检索但不删除此双端队列的最后一个元素，如果此双端队列为空则返回null E peekLast(); // *** Queue methods *** // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true并在当前没有可用空间时抛出IllegalStateException .使用容量受限的双端队列时，通常最好使用offer 。此方法等效于addLast boolean add(E e); // 如果可以在不违反容量限制的情况下立即将指定元素插入此双端队列表示的队列（换句话说，在此双端队列的尾部），成功时返回true ，如果当前没有可用空间则返回false 。当使用容量受限的双端队列时，此方法通常优于add方法，后者仅通过抛出异常才能插入元素失败。此方法等效于offerLast boolean offer(E e); // 检索并删除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与poll()的不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于removeFirst() E remove(); // 检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回null 。此方法等效于pollFirst() E poll(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素）。此方法与peek不同之处仅在于，如果此双端队列为空，它会抛出异常。此方法等效于getFirst() E element(); // 检索但不删除由此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回null 。此方法等效于peekFirst() E peek(); // *** Stack methods *** // 如果可以在不违反容量限制的情况下立即将元素推入此双端队列表示的堆栈（换句话说，在此双端队列的头部），如果当前没有可用空间则抛出IllegalStateException void push(E e); // 从此双端队列表示的堆栈中弹出一个元素。换句话说，删除并返回此双端队列的第一个元素。此方法等效于removeFirst() E pop(); } Deque接口提供了插入、删除和检查的方法，这些方法中的每一个都以两种形式存在：一种在操作失败时抛出异常，另一种返回一个特殊值（ null或false ，具体取决于操作），如下图所示：\n当双端队列用作队列时，会产生FIFO（先进先出）行为。元素在双端队列的末尾添加，并从开头删除。从Queue接口继承的方法与Deque接口方法完全等价，如下图所示：\n除此之外，双端队列也可以用作LIFO（后进先出）堆栈。应优先使用此接口而不是使用Stack类。当双端队列用作堆栈时，元素从双端队列的开头被压入和弹出。Stack方法等同于Deque方法，如下图所示：\n实践一下，我们把LinkedList当作Deque堆栈来使用，如下代码：\n1 2 3 4 5 6 7 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); deque.push(\u0026#34;Jerry\u0026#34;); deque.push(\u0026#34;Tom\u0026#34;); deque.push(\u0026#34;May\u0026#34;); while (deque.peek() != null) { System.out.println(deque.pop()); } 注意：当双端队列用作队列或堆栈时，peek方法同样有效；在任何一种情况下，元素都是从双端队列的开头提取的。\n虽然并未严格要求Deque队列实现禁止插入空元素，但强烈建议它们这样做。强烈建议任何确实允许null元素的Deque实现的用户不要利用插入null的能力。之所以如此，是因为null被各种方法用作特殊的返回值，以指示双端队列为空。\nDeque接口除了上面介绍的核心方法外，它还有一个迭代器方法，可以从后往前遍历，如下代码：\n1 2 3 4 5 Deque\u0026lt;String\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(Arrays.asList(new String[]{\u0026#34;Jerry\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;May\u0026#34;})); Iterator\u0026lt;String\u0026gt; iterator = deque.descendingIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2.2、成员变量 1 2 3 4 5 6 7 8 // LinkedList的大小（它包含的元素数） transient int size = 0; // 指向第一个节点的指针 transient Node\u0026lt;E\u0026gt; first; // 指向最后一个节点的指针 transient Node\u0026lt;E\u0026gt; last; LinkedList的成员变量不多，我们重点看下内部类Node节点的实现，如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static class Node\u0026lt;E\u0026gt; { // 存储元素 E item; // 后继节点 Node\u0026lt;E\u0026gt; next; // 前驱节点 Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 从上面Node节点的构造函数来看，Node节点的结构如下图所示：\nLinkedList就是由一个个的Node节点双向连接而成，如下图所示：\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 // 构造一个空列表 public LinkedList() { } // 构造一个包含指定集合元素的列表，按照集合迭代器返回元素的顺序 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c) { this(); // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 addAll(c); } 2.4、核心方法 2.4.1、插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // ***********尾部插入*********** // 将指定的元素附加到此列表的末尾 public boolean add(E e) { linkLast(e); return true; } // 将指定的元素附加到此列表的末尾 public void addLast(E e) { linkLast(e); } // 添加指定元素作为此列表的尾部（最后一个元素） public boolean offer(E e) { return add(e); } // 在此列表的末尾插入指定的元素 public boolean offerLast(E e) { addLast(e); return true; } // 按照指定集合的​​迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { return addAll(size, c); } // ***********头部插入*********** // 在此列表的开头插入指定的元素 public void addFirst(E e) { linkFirst(e); } // 在此列表的前面插入指定的元素 public boolean offerFirst(E e) { addFirst(e); return true; } // 将一个元素推入此列表表示的堆栈中。换句话说，将元素插入此列表的前面 public void push(E e) { addFirst(e); } // ***********中间插入*********** // 在此列表中的指定位置插入指定元素。将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一） public void add(int index, E element) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 如果插入的索引位置为size，那说明是尾部插入 if (index == size) // 执行尾部插入 linkLast(element); else // 先找到当前链表上指定index位置的node节点，然后再插入新节点 linkBefore(element, node(index)); } // ***********插入核心实现*********** // 链接e作为最后一个元素 void linkLast(E e) { // 获取当前链表的last节点 final Node\u0026lt;E\u0026gt; l = last; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 让新节点成为last节点 last = newNode; // 如果last节点为null，说明这是第一次插入新节点，所以新节点也是first节点 if (l == null) first = newNode; else // 否则新节点是last节点的下一个节点 l.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 链接e作为第一个元素 private void linkFirst(E e) { // 获取当前链表的first节点 final Node\u0026lt;E\u0026gt; f = first; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 让新节点成为last节点 first = newNode; // 如果first节点为null，说明这是第一次插入新节点，所以新节点也是last节点 if (f == null) last = newNode; else // 否则新节点是first节点的上一个节点 f.prev = newNode; // 更新size：元素个数+1 size++; modCount++; } // 返回指定元素索引处的（非空）节点。 Node\u0026lt;E\u0026gt; node(int index) { // assert isElementIndex(index); // size \u0026gt;\u0026gt; 1 == size/2 // 如果index \u0026lt; size/2，那么就从first节点开始往后遍历查找 if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) x = x.next; return x; } else { // 如果index \u0026gt;= size/2，那么就从last节点开始往前遍历查找 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) x = x.prev; return x; } } // 在非空节点 succ 之前插入元素 e void linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; // 获取当前链表的succ节点的前一个节点pred final Node\u0026lt;E\u0026gt; pred = succ.prev; // 创建一个新节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); // 让新节点成为succ节点的前一个节点 succ.prev = newNode; // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 更新size：元素个数+1 size++; modCount++; } // 将指定集合中的所有元素插入此列表，从指定位置开始。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）。新元素将按照指定集合的​​迭代器返回的顺序出现在列表中。 public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { // 判断参数是否是迭代器或添加操作的有效位置的索引 checkPositionIndex(index); // 将集合c的元素按集合c的顺序转换为数组返回 Object[] a = c.toArray(); // 如果数组长度为0，那么返回false int numNew = a.length; if (numNew == 0) return false; // 定义当前链表index索引对应的succ节点，以及succ节点的前节点pred Node\u0026lt;E\u0026gt; pred, succ; // 如果index == size，说明是尾部插入 if (index == size) { // size位置的节点为null succ = null; // pred节点为插入位置的前节点last pred = last; } else { // 否则是中间插入，那么先找到当前链表上指定index位置的node节点，然后再插入新节点 succ = node(index); // pred为succ的前节点 pred = succ.prev; } // 遍历数组，让数组转换为链表 for (Object o : a) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) o; // 创建一个新节点 Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, null); // 如果pred节点为null，说明这是插入到头节点位置，所以新节点也是first节点 if (pred == null) first = newNode; else // 否则新节点是pred节点的下一个节点 pred.next = newNode; // 每一轮循环结束，新节点就是pred节点 pred = newNode; } // 如果succ节点为null，说明是尾部插入，此时插入已经完成，那么pred节点为数组的最后一个节点，所以理所应当成为last节点 if (succ == null) { last = pred; } else { // 如果succ节点不为null，说明是中间插入，此时插入已经完成，那么数组的最后一个节点指向插入位置节点succ pred.next = succ; // 数组的最后一个节点pred，理所应当成为插入位置节点succ的上一个节点 succ.prev = pred; } // 更新size：元素个数+数组长度 size += numNew; modCount++; return true; } 2.4.2、删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 // ***********尾部删除*********** // 从此列表中移除并返回最后一个元素 public E removeLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 检索并删除此列表的最后一个元素，如果此列表为空，则返回null public E pollLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : unlinkLast(l); } // ***********头部删除*********** // 检索并删除此列表的头部（第一个元素） public E remove() { return removeFirst(); } // 检索并删除此列表的头部（第一个元素） public E poll() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表中移除并返回第一个元素。 public E removeFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 检索并删除此列表的第一个元素，如果此列表为空，则返回null public E pollFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : unlinkFirst(f); } // 从此列表表示的堆栈中弹出一个元素。换句话说，删除并返回此列表的第一个元素 public E pop() { return removeFirst(); } // ***********中间删除*********** // 移除此列表中指定位置的元素。将任何后续元素向左移动（从其索引中减去一个）。返回从列表中删除的元素。 public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } // ***********删除核心实现*********** // 取消链接非空的第一个节点f private E unlinkFirst(Node\u0026lt;E\u0026gt; f) { // assert f == first \u0026amp;\u0026amp; f != null; // 获取node节点的元素element final E element = f.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = f.next; // 将node节点持有的元素item置为null f.item = null; // 将node节点持有的后继节点指针置为null f.next = null; // help GC // node节点的下一个节点成为first节点 first = next; // 如果next节点为null，说明最后一个节点也被删除了，那么last节点置为null if (next == null) last = null; else // 否则node节点置为null next.prev = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空的最后一个节点l private E unlinkLast(Node\u0026lt;E\u0026gt; l) { // assert l == last \u0026amp;\u0026amp; l != null; // 获取node节点的元素element final E element = l.item; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = l.prev; // 将node节点持有的元素item置为null l.item = null; // 将node节点持有的前躯节点指针置为null l.prev = null; // help GC // node节点的上一个节点成为last节点 last = prev; // 如果prev节点为null，说明最后一个节点也被删除了，那么first节点置为null if (prev == null) first = null; else // 否则node节点置为null prev.next = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 取消链接非空节点x E unlink(Node\u0026lt;E\u0026gt; x) { // assert x != null; // 获取node节点的元素element final E element = x.item; // 获取node节点的后继节点 final Node\u0026lt;E\u0026gt; next = x.next; // 获取node节点的前驱节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 如果prev节点为null，说明是头部删除，那么next节点成为first节点 if (prev == null) { first = next; } else { // 如果prev节点不为null，说明是中间删除，那么next节点成为前驱节点prev的下一个节点 prev.next = next; // node节点的前驱节点指针置为null x.prev = null; } // 如果next节点为null，说明是尾部删除，那么prev节点成为last节点 if (next == null) { last = prev; } else { // 如果prev节点不为null，说明是中间删除，那么prev节点成为后继节点next的上一个节点 next.prev = prev; // node节点的后继节点指针置为null x.next = null; } // 将node节点持有的元素item置为null x.item = null; // 更新size：元素个数-1 size--; modCount++; return element; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果此列表不包含该元素，则它保持不变。更正式地说，删除具有最低索引i元素 public boolean remove(Object o) { // 如果要删除的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后执行删除 if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果要删除的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后执行删除 for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } 2.4.3、更改 1 2 3 4 5 6 7 8 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { checkElementIndex(index); Node\u0026lt;E\u0026gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; } 2.4.4、检索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ***********头部检索*********** // 检索但不删除此列表的头部（第一个元素） public E element() { return getFirst(); } // 检索但不删除此列表的头部（第一个元素） public E peek() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // 返回此列表中的第一个元素 public E getFirst() { final Node\u0026lt;E\u0026gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 检索但不删除此列表的第一个元素，如果此列表为空，则返回null public E peekFirst() { final Node\u0026lt;E\u0026gt; f = first; return (f == null) ? null : f.item; } // ***********尾部检索*********** // 返回此列表中的最后一个元素 public E getLast() { final Node\u0026lt;E\u0026gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 检索但不删除此列表的最后一个元素，如果此列表为空，则返回null public E peekLast() { final Node\u0026lt;E\u0026gt; l = last; return (l == null) ? null : l.item; } // ***********中间检索*********** // 返回此列表中指定位置的元素 public E get(int index) { checkElementIndex(index); return node(index).item; } 2.5、其它方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 返回此列表中指定元素第一次出现的索引，如果此列表不包含该元素，则返回 -1，更正式地说，返回具有最低索引i元素 public int indexOf(Object o) { int index = 0; // 如果要查找的元素为null，那么就从first节点开始往后遍历，直到找到第一个为null的元素，然后返回index if (o == null) { for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { // 如果要查找的元素不为null，那么就从first节点开始往后遍历，直到找到第一个和o相同的元素，然后返回index for (Node\u0026lt;E\u0026gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; } 三、总结 在LinkedList的源码中，并没有与并发相关的代码，所以说LinkedList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new LinkedList(...)); 另外，LinkedList要根据实际的业务场景来使用，比如说，如果列表长度未知，添加、删除操作比较多，尤其经常从两端进行操作，而按照索引位置访问相对比较少，使用LinkedList会有更好的性能。\n","date":"2023-04-19T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBlinkedlist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读LinkedList源码「JDK11」"},{"categories":null,"contents":" 此博客主要用来对日常的开发等相关的内容进行记录，如果需要转载请表明出处。\n","date":"2023-04-16T20:53:15+08:00","permalink":"https://anddevmk.cn/about/","section":"","tags":null,"title":"关于"},{"categories":["Java"],"contents":"一、概述 ArrayList是经常用到的一个容器，它是Java Collections Framework的一个成员，然后底层是基于定长数组来实现的，如果数组存放满了，就会通过扩容机制重新生成一个更大的数组来存放数据。\n因此，扩容机制是ArrayList的核心所在，这一点是务必要掌握的；除此之外，本文还会叙述ArrayList的基本操作是怎样实现的，以及其它的细节。\n二、ArrayList源码解读 2.1、继承关系 从UML类图中可以看到，ArrayList直接或间接实现了Iterable、Collection、List、RandomAccess、Cloneable、Serializable这6个接口；ArrayList直接或间接继承了AbstractList、AbstractCollection这2个抽象类。\n疑问来了：为什么AbstractList实现了List接口，ArrayList还要去再实现一次List接口，是吃饱了撑着吗？\n带着疑问，我立马去网上冲浪一波，然后发现了3个对此的解释。\n观点1：如果ArrayList没去实现List接口，会导致class的getInterfaces方法返回不同的结果，这么做是为了方便基于List接口的动态代理。\n观点2：这可能是为了增加继承结构的可追踪性。当浏览Javadoc或类似的东西时，就不必遍历整个继承树，它不会有任何不良影响，并且可以帮助理解代码。\n观点3：ArrayList的作者Josh Bloch曾经认为ArrayList再实现一次List接口是有一些价值的，但后来发现这是个错误。\n以上3个观点均出自stackoverflow的一个帖子，我们了解下就好了，深究意义不大，具体原因还得是作者自己才知道。\n2.1.1、Iterable接口 2.1.1.1、概述 Iterable表示可迭代的，它有个iterator方法，需要返回Iterator对象，Iterator是一个接口，表示为迭代器。Iterable接口的定义如下：\n1 2 3 4 5 6 public interface Iterable\u0026lt;T\u0026gt; { Iterator\u0026lt;T\u0026gt; iterator(); // .....省略 } 那么实现Iterable接口有什么作用呢？先说结论：只要对象实现了Iterable接口，就可以使用for-each语法，编译器会转换为调用Iterable和Iterator接口的方法。\n我们平常用for-each语法遍历list时，你可能会写下如下代码：\n1 2 3 4 5 6 7 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(3); list.add(1); list.add(2); list.add(3); for (Integer value : list) { System.out.println(\u0026#34;value: \u0026#34; + value); } 这种for-each语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：\n1 2 3 4 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.next()); } 除了Iterable接口的iterator方法外，List接口也有一个listIterator方法，需要返回ListIterator对象，ListIterator是一个接口，它对Iterator接口做了扩展。比如，可以从末尾往前遍历，如下代码：\n1 2 3 4 ListIterator\u0026lt;Integer\u0026gt; iterator = list.listIterator(list.size()); while (iterator.hasPrevious()){ System.out.println(\u0026#34;value: \u0026#34; + iterator.previous()); } 2.1.1.2、fail-fast机制 那些年，年少时所犯下的错误，想起自己刚入门Java时，曾经写过如下代码：\n1 2 3 4 5 for (Integer value : list) { if (value \u0026lt; 3) { list.remove(value); } } 当年的直觉告诉你，这么写不存在问题，但是运行却会报并发修改的错误：\n1 Exception in thread \u0026#34;main\u0026#34; java.util.ConcurrentModificationException 显然，这里是没有并发的代码，我们去看看ConcurrentModificationException的注释描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 当不允许进行此类修改时，已检测到对象的并发修改的方法可能会抛出此异常。 * This exception may be thrown by methods that have detected concurrent * modification of an object when such modification is not permissible. * \u0026lt;p\u0026gt; * 例如，通常不允许一个线程在另一个线程迭代集合时修改集合。 * For example, it is not generally permissible for one thread to modify a Collection * while another thread is iterating over it. * 通常，在这些情况下迭代的结果是不确定的。 * In general, the results of the iteration are undefined under these circumstances. * 如果检测到此行为，某些 Iterator 实现（包括 JRE 提供的所有通用集合实现）可能会选择抛出此异常。 * Some Iterator implementations (including those of all the general purpose collection implementations * provided by the JRE) may choose to throw this exception if this behavior is * detected. * 执行此操作的迭代器被称为fail-fast迭代器，因为它们快速而干净地失败，而不是冒着在未来不确定的时间出现任意的、不确定的行为的风险。 * Iterators that do this are known as \u0026lt;i\u0026gt;fail-fast\u0026lt;/i\u0026gt; iterators, * as they fail quickly and cleanly, rather that risking arbitrary, * non-deterministic behavior at an undetermined time in the future. * \u0026lt;p\u0026gt; * 请注意，此异常并不总是表示对象已被不同的线程并发修改。 * Note that this exception does not always indicate that an object has * been concurrently modified by a \u0026lt;i\u0026gt;different\u0026lt;/i\u0026gt; thread. * 如果单个线程发出一系列违反对象契约的方法调用，则该对象可能会抛出此异常。 * If a single thread issues a sequence of method invocations that violates the * contract of an object, the object may throw this exception. * 例如，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。 * For example, if a thread modifies a collection directly while it is * iterating over the collection with a fail-fast iterator, the iterator * will throw this exception. * 请注意，不能保证fail-fast行为，因为一般来说，在存在非同步并发修改的情况下不可能做出任何硬性保证。 * \u0026lt;p\u0026gt;Note that fail-fast behavior cannot be guaranteed as it is, generally * speaking, impossible to make any hard guarantees in the presence of * unsynchronized concurrent modification. * ail-fast操作会尽最大努力抛出ConcurrentModificationException。 * Fail-fast operations throw {@code ConcurrentModificationException} on a best-effort basis. * 因此，编写依赖于此异常的正确性的程序是错误的： ConcurrentModificationException应该仅用于检测错误。 * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: \u0026lt;i\u0026gt;{@code ConcurrentModificationException} * should be used only to detect bugs.\u0026lt;/i\u0026gt; * * @author Josh Bloch * @see Collection * @see Iterator * @see Spliterator * @see ListIterator * @see Vector * @see LinkedList * @see HashSet * @see Hashtable * @see TreeMap * @see AbstractList * @since 1.2 */ 上面的注释说的很明显了，如果线程在使用fail-fast迭代器迭代集合时直接修改集合，则迭代器将抛出此异常。\n那么如何避免异常呢？可以使用迭代器的remove方法，如下所示：\n1 2 3 4 5 6 Iterator\u0026lt;Integer\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { if (iterator.next() \u0026lt; 3) { iterator.remove(); } } 它自己的remove方法为何又可以使用呢？我们需要看下迭代器的原理了。\n2.1.1.3、迭代器的原理 我们先来看下ArrayList中iterator方法的实现，代码如下：\n1 2 3 4 5 6 7 public class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } } iterator方法实现很简单，直接new一个Itr对象返回，Itr是ArrayList的一个成员内部类，实现了Iterator接口，它的代码量并不多，所以直接贴出来了，看注释应该就能明白。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // index of next element to return 下一个要返回的元素位置 int lastRet = -1; // index of last element returned; -1 if no such 最后一个返回的索引位置，如果没有，为-1 int expectedModCount = modCount; // 期望的修改次数，初始化为外部类当前的修改次数modCount // prevent creating a synthetic constructor Itr() {} public boolean hasNext() { return cursor != size; // cursor与数组元素数量的比较 } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public E next() { // 校验是否发生了结构性变化 checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); // 更新cursor的值，每次+1 cursor = i + 1; // 更新lastRet值，返回对应的元素 return (E) elementData[lastRet = i]; } public void remove() { // 注意：lastRet \u0026lt; 0时会抛出异常，所以调用remove()之前需要先调用next()去更新lastRet的值 if (lastRet \u0026lt; 0) throw new IllegalStateException(); // 校验是否发生了结构性变化 checkForComodification(); try { // 执行ArrayList的remove方法，modCount++ ArrayList.this.remove(lastRet); // 更新cursor的值，remove后元素数量少了一个，相当于cursor=cursor-1 cursor = lastRet; // 重置lastRet lastRet = -1; // 更新expectedModCount expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } // 校验是否发生了结构性变化，所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 迭代器源码中next方法，remove方法都会调用checkForComodification方法进行校验是否发生了结构性变化，由此可见，迭代器的内部维护了索引位置相关的数据，要求在迭代过程中，不能发生结构性变化，否则这些索引位置功能就会失效。\n2.1.2、RandomAccess接口 RandomAccess内部是没有任何代码的接口，它属于标记接口，其定义如下：\n1 2 public interface RandomAccess { } 实现了RandomAccess接口的类表示支持快速随机访问，用在一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现，比如Collections类的binarySearch方法，会根据List是否实现了RandomAccess接口而采用不同的实现，代码如下：\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } 2.2、成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 默认初始容量 private static final int DEFAULT_CAPACITY = 10; // 用于空实例的共享空数组实例 private static final Object[] EMPTY_ELEMENTDATA = {}; // 用于默认大小的空实例的共享空数组实例。注意：要将它与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少 // 可以理解为标记调空参数构造方法 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 存储ArrayList元素的数组缓冲区。ArrayList的容量就是这个数组缓冲区的长度。添加第一个元素时，任何具有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空 ArrayList 都将扩展为 DEFAULT_CAPACITY。 transient Object[] elementData; // ArrayList的大小（它包含的元素数） private int size; // 要分配的数组的最大大小（除非必要） private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表，使得正在进行的迭代可能会产生不正确的结果。 protected transient int modCount = 0; 疑问来了：我们知道了ArrayList实现了Serializable接口，但是elementData为何要用transient修饰，这不表示elementData不能被序列化？\n其实玄机在于ArrayList中的两个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 将ArrayList实例的状态保存到流中（即序列化它）。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } // 从流中重构ArrayList实例（即反序列化） private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); Object[] elements = new Object[size]; // Read in all elements in the proper order. for (int i = 0; i \u0026lt; size; i++) { elements[i] = s.readObject(); } elementData = elements; } else if (size == 0) { elementData = EMPTY_ELEMENTDATA; } else { throw new java.io.InvalidObjectException(\u0026#34;Invalid size: \u0026#34; + size); } } ArrayList在序列化的时候会调用writeObject方法，直接将size和element写入ObjectOutputStream；反序列化时调用readObject方法，从ObjectInputStream获取size和element，再恢复到elementData。\nelementData是存储ArrayList元素的数组缓冲区，通常扩容后都会预留一些空间，也就是说有部分空间实际没有存储元素，序列化时只序列化实际存储的那些元素，而不是整个数组，从而可以节省空间和时间。\n疑问来了：为什么MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8而不是Integer.MAX_VALUE？\n因为存储了Array的头部信息，所以这里需要减去8。\n2.3、构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 空参构造方法 public ArrayList() { // 由于没有指定初始容量，所以赋值一个空实例的共享空数组实例，可以理解为标记调空参数构造方法 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 指定了初始容量的构造方法 public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { // 创建指定大小的Object数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } public ArrayList(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 elementData = c.toArray(); if ((size = elementData.length) != 0) { // 重复调用Arrays.copyOf()是为了防止c.toArray()不返回Object[] // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. // 这里单纯就是元素个数为0后，赋值一个空实例的共享空数组实例 this.elementData = EMPTY_ELEMENTDATA; } } 2.4、核心方法 2.4.1、add方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 将指定的元素附加到此列表的末尾 public boolean add(E e) { // 此列表在结构上被修改的次数 modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { // 数组容量满了，执行扩容机制 if (s == elementData.length) // 得到一个扩容后的新数组 elementData = grow(); // size位置插入元素 elementData[s] = e; // 更新size大小：原元素个数大小+1 size = s + 1; } // 在此列表中的指定位置插入指定元素 public void add(int index, E element) { // 校验index的范围 rangeCheckForAdd(index); modCount++; // 当前元素个数大小 final int s; Object[] elementData; // 数组容量满了，执行扩容机制 if ((s = size) == (elementData = this.elementData).length) // 得到一个扩容后的新数组 elementData = grow(); // 将当前位于该位置的元素（如果有）和任何后续元素向右移动（将其索引加一）。 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 移动后，index位置空余出来，即可将element插入到index位置 elementData[index] = element; // 更新size大小：原元素个数大小+1 size = s + 1; } // 将指定集合中的所有元素追加到此列表的末尾 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { // c.toArray()底层实际调用的也是Arrays.copyOf()，根据集合c的长度创建一个Object[]新数组，把数据拷贝到新数组上 Object[] a = c.toArray(); modCount++; int numNew = a.length; if (numNew == 0) return false; Object[] elementData; final int s; // 原数组的剩余容量不够插入数组的大小时，就进行扩容 if (numNew \u0026gt; (elementData = this.elementData).length - (s = size)) // 得到一个扩容后的新数组 elementData = grow(s + numNew); // 将插入数组的元素拷贝到扩容数组上 System.arraycopy(a, 0, elementData, s, numNew); // 更新size大小：原元素个数大小+插入数组的长度 size = s + numNew; return true; } 关于add方法，如果是末尾插入，那么平均时间复杂度为O(1)；如果是非末尾插入，因为需要移动元素，那么平均时间复杂度为O(n)。因此，我们应该尽量避免在大数据量中调用add带索引参数的方法。\n2.4.2、grow方法（扩容机制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private Object[] grow() { return grow(size + 1); } // 增加容量以确保它至少可以容纳最小容量参数指定的元素数 private Object[] grow(int minCapacity) { // minCapacity = size + 1 // 先计算新容量大小，再根据新容量大小创建一个Object[]新数组，把数据拷贝到新数组上 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } // 返回至少与给定最小容量一样大的容量。如果足够，返回增加 50% 的当前容量。除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。 private int newCapacity(int minCapacity) { // overflow-conscious code // 旧容量 = 原数组的长度 int oldCapacity = elementData.length; // 新容量 = 旧容量 + 旧容量右移一位（相当于除于2） int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt;= 0) { // 如果是调用了无参数构造方法，没有指定初始容量时 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 默认初始容量就为10 return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // 其它情况一律size + 1 return minCapacity; } // 如果还没达到最大容量，那就是新容量大小，否则返回一个返回一个巨大的容量 return (newCapacity - MAX_ARRAY_SIZE \u0026lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); // size+1 \u0026gt; MAX_ARRAY_SIZE时，那么返回一个巨大的容量Integer.MAX_VALUE，否则MAX_ARRAY_SIZE return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 2.4.3、remove方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 移除此列表中指定位置的元素 public E remove(int index) { // 校验index的范围 Objects.checkIndex(index, size); final Object[] es = elementData; // 取出要移除的元素 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E oldValue = (E) es[index]; // 删除元素 fastRemove(es, index); // 返回要移除的元素 return oldValue; } // 跳过边界检查并且不返回删除的值的私有删除方法 private void fastRemove(Object[] es, int i) { modCount++; final int newSize; // 如果删除的元素索引位置非最后一个元素位置，那么将当前位于该位置的元素（如果有）和任何后续元素向左移动（将其索引减一）。 if ((newSize = size - 1) \u0026gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); // 移动原size-1位置多余了，需要置null es[size = newSize] = null; } // 从此列表中移除第一次出现的指定元素（如果存在）。如果列表不包含该元素，则它不变。 public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; // 使用了java label语法 found: { // 如果传入null，那么遍历去查看是否存在null的元素，找到就跳出循环 if (o == null) { for (; i \u0026lt; size; i++) if (es[i] == null) break found; } else { // 如果传入不为null，那么遍历去查看是否存在相同的元素，找到就跳出循环 for (; i \u0026lt; size; i++) if (o.equals(es[i])) break found; } // 上面两个条件下都找不到要查找的元素，则返回false return false; } // 找到要删除的元素后执行删除 fastRemove(es, i); return true; } 2.4.4、set方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 用指定元素替换此列表中指定位置的元素 public E set(int index, E element) { // 校验index的范围 Objects.checkIndex(index, size); // 获取索引位置对应的元素 E oldValue = elementData(index); // 设置索引位置对应的元素 elementData[index] = element; // 返回要修改的元素 return oldValue; } // 返回索引位置对应的元素 E elementData(int index) { return (E) elementData[index]; } 2.4.5、get方法 1 2 3 4 5 6 7 // 返回此列表中指定位置的元素 public E get(int index) { // 校验index的范围 Objects.checkIndex(index, size); // 返回索引位置对应的元素 return elementData(index); } 2.5、其它方法 2.5.1、ensureCapacity方法 1 2 3 4 5 6 7 8 9 10 11 12 // 如有必要，增加此ArrayList实例的容量，以确保它至少可以容纳最小容量参数指定的元素数。 // 也就是说，这个方法的使用场景是如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数 public void ensureCapacity(int minCapacity) { // 最小容量不得低于原数组的长度，同时原数组不是第一次调用空参数构造方法和第一次扩容 if (minCapacity \u0026gt; elementData.length \u0026amp;\u0026amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA \u0026amp;\u0026amp; minCapacity \u0026lt;= DEFAULT_CAPACITY)) { modCount++; // 进行扩容 grow(minCapacity); } } 2.5.2、trimToSize方法 1 2 3 4 5 6 7 8 9 10 11 12 // 将此ArrayList实例的容量修剪为列表的当前大小。应用程序可以使用此操作来最小化ArrayList实例的存储 public void trimToSize() { modCount++; // 数组容量没装满元素 if (size \u0026lt; elementData.length) { // 如果元素个数为0，那么赋值一个空实例的共享空数组实例 elementData = (size == 0) ? EMPTY_ELEMENTDATA // 否则拷贝元素到新数组上，新数组的大小就是元素个数的数量 : Arrays.copyOf(elementData, size); } } 三、总结 在ArrayList的源码中，并没有与并发相关的代码，所以说ArrayList是非线程安全类，在并发环境下多个线程同时操作，会引发不可预知的错误。应该使用Collections.synchronizedList方法包装列表，最好在创建时完成，如下代码：\n1 List list = Collections.synchronizedList(new ArrayList(...)); 另外，ArrayList是经常用到的一个容器，要根据实际的业务场景来使用，比如说，当添加、删除数据不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会有更好的性能。\n","date":"2023-04-16T14:41:31+08:00","permalink":"https://anddevmk.cn/post/java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97%E4%B8%80%E6%96%87%E8%A7%A3%E8%AF%BBarraylist%E6%BA%90%E7%A0%81jdk11/","section":"post","tags":null,"title":"Java集合系列：一文解读ArrayList源码「JDK11」"}]